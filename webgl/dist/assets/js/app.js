/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/modelViewer/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/assets-loader/src/browser-has-blob.js":
/*!************************************************************!*\
  !*** ./node_modules/assets-loader/src/browser-has-blob.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = (function() {
    try {
        return !!new Blob();
    } catch (e) {
        return false;
    }
}());


/***/ }),

/***/ "./node_modules/assets-loader/src/emitter.js":
/*!***************************************************!*\
  !*** ./node_modules/assets-loader/src/emitter.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventEmitter = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js").EventEmitter;

function Emitter() {
    EventEmitter.call(this);
    this.setMaxListeners(20);
}

Emitter.prototype = Object.create(EventEmitter.prototype);
Emitter.prototype.constructor = Emitter;

Emitter.prototype.off = function(type, listener) {
    if (listener) {
        return this.removeListener(type, listener);
    }
    if (type) {
        return this.removeAllListeners(type);
    }
    return this.removeAllListeners();
};

module.exports = Emitter;


/***/ }),

/***/ "./node_modules/assets-loader/src/group.js":
/*!*************************************************!*\
  !*** ./node_modules/assets-loader/src/group.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(/*! ./emitter.js */ "./node_modules/assets-loader/src/emitter.js");
var createLoader = __webpack_require__(/*! ./loader */ "./node_modules/assets-loader/src/loader.js");
var autoId = 0;

module.exports = function createGroup(config) {
    var group;
    var map = {};
    var assets = [];
    var queue = [];
    var numLoaded = 0;
    var numTotal = 0;
    var loaders = {};

    var add = function(options) {
        // console.debug('add', options);
        if (Array.isArray(options)) {
            options.forEach(add);
            return group;
        }
        var isGroup = !!options.assets && Array.isArray(options.assets);
        // console.debug('isGroup', isGroup);
        var loader;
        if (isGroup) {
            loader = createGroup(configure(options, config));
        } else {
            loader = createLoader(configure(options, config));
        }
        loader.once('destroy', destroyHandler);
        queue.push(loader);
        loaders[loader.id] = loader;
        return group;
    };

    var get = function(id) {
        if (!arguments.length) {
            return assets;
        }
        if (map[id]) {
            return map[id];
        }
        return loaders[id];
    };

    var find = function(id) {
        if (get(id)) {
            return get(id);
        }
        var found = null;
        Object.keys(loaders).some(function(key) {
            found = loaders[key].find && loaders[key].find(id);
            return !!found;
        });
        return found;
    };

    var getExtension = function(url) {
        return url && url.split('?')[0].split('.').pop().toLowerCase();
    };

    var configure = function(options, defaults) {
        if (typeof options === 'string') {
            var url = options;
            options = {
                url: url
            };
        }

        if (options.isTouchLocked === undefined) {
            options.isTouchLocked = defaults.isTouchLocked;
        }

        if (options.blob === undefined) {
            options.blob = defaults.blob;
        }

        if (options.basePath === undefined) {
            options.basePath = defaults.basePath;
        }

        options.id = options.id || options.url || String(++autoId);
        options.type = options.type || getExtension(options.url);
        options.crossOrigin = options.crossOrigin || defaults.crossOrigin;
        options.webAudioContext = options.webAudioContext || defaults.webAudioContext;
        options.log = defaults.log;

        return options;
    };

    var start = function() {
        numTotal = queue.length;

        queue.forEach(function(loader) {
            loader
                .on('progress', progressHandler)
                .once('complete', completeHandler)
                .once('error', errorHandler)
                .start();
        });

        queue = [];

        return group;
    };

    var progressHandler = function(progress) {
        var loaded = numLoaded + progress;
        group.emit('progress', loaded / numTotal);
    };

    var completeHandler = function(asset, id, type) {
        if (Array.isArray(asset)) {
            asset = { id: id, file: asset, type: type };
        }
        numLoaded++;
        group.emit('progress', numLoaded / numTotal);
        map[asset.id] = asset.file;
        assets.push(asset);
        group.emit('childcomplete', asset);
        checkComplete();
    };

    var errorHandler = function(err) {
        numTotal--;
        if (group.listeners('error').length) {
            group.emit('error', err);
        } else {
            console.error(err);
        }
        checkComplete();
    };

    var destroyHandler = function(id) {
        loaders[id] = null;
        delete loaders[id];

        map[id] = null;
        delete map[id];

        assets.some(function(asset, i) {
            if (asset.id === id) {
                assets.splice(i, 1);
                return true;
            }
        });
    };

    var checkComplete = function() {
        if (numLoaded >= numTotal) {
            group.emit('complete', assets, map, config.id, 'group');
        }
    };

    var destroy = function() {
        while (queue.length) {
            queue.pop().destroy();
        }
        group.off('error');
        group.off('progress');
        group.off('complete');
        assets = [];
        map = {};
        config.webAudioContext = null;
        numTotal = 0;
        numLoaded = 0;

        Object.keys(loaders).forEach(function(key) {
            loaders[key].destroy();
        });
        loaders = {};

        group.emit('destroy', group.id);

        return group;
    };

    // emits: progress, error, complete, destroy

    group = Object.create(Emitter.prototype, {
        _events: {
            value: {}
        },
        id: {
            get: function() {
                return config.id;
            }
        },
        add: {
            value: add
        },
        start: {
            value: start
        },
        get: {
            value: get
        },
        find: {
            value: find
        },
        getLoader: {
            value: function(id) {
                return loaders[id];
            }
        },
        loaded: {
            get: function() {
                return numLoaded >= numTotal;
            }
        },
        file: {
            get: function() {
                return assets;
            }
        },
        destroy: {
            value: destroy
        }
    });

    config = configure(config || {}, {
        basePath: '',
        blob: false,
        touchLocked: false,
        crossOrigin: null,
        webAudioContext: null,
        log: false
    });

    if (Array.isArray(config.assets)) {
        add(config.assets);
    }

    return group;
};


/***/ }),

/***/ "./node_modules/assets-loader/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/assets-loader/src/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assetsLoader = __webpack_require__(/*! ./group */ "./node_modules/assets-loader/src/group.js");
assetsLoader.stats = __webpack_require__(/*! ./stats */ "./node_modules/assets-loader/src/stats.js");

module.exports = assetsLoader;


/***/ }),

/***/ "./node_modules/assets-loader/src/loader.js":
/*!**************************************************!*\
  !*** ./node_modules/assets-loader/src/loader.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(/*! ./emitter.js */ "./node_modules/assets-loader/src/emitter.js");
var browserHasBlob = __webpack_require__(/*! ./browser-has-blob.js */ "./node_modules/assets-loader/src/browser-has-blob.js");
var stats = __webpack_require__(/*! ./stats */ "./node_modules/assets-loader/src/stats.js");

module.exports = function(options) {
    var id = options.id;
    var basePath = options.basePath || '';
    var url = options.url;
    var type = options.type;
    var crossOrigin = options.crossOrigin;
    var isTouchLocked = options.isTouchLocked;
    var blob = options.blob && browserHasBlob;
    var webAudioContext = options.webAudioContext;
    var log = options.log;

    var loader;
    var loadHandler;
    var request;
    var startTime;
    var timeout;
    var file;

    var start = function() {
        startTime = Date.now();

        switch (type) {
            case 'json':
                loadJSON();
                break;
            case 'jpg':
            case 'png':
            case 'gif':
            case 'webp':
            case 'svg':
                loadImage();
                break;
            case 'mp3':
            case 'ogg':
            case 'opus':
            case 'wav':
            case 'm4a':
                loadAudio();
                break;
            case 'ogv':
            case 'mp4':
            case 'webm':
            case 'hls':
                loadVideo();
                break;
            case 'bin':
            case 'binary':
                loadXHR('arraybuffer');
                break;
            case 'txt':
            case 'text':
                loadXHR('text');
                break;
            default:
                throw 'AssetsLoader ERROR: Unknown type for file with URL: ' + basePath + url + ' (' + type + ')';
        }
    };

    var dispatchComplete = function(data) {
        if (!data) {
            return;
        }
        file = {id: id, file: data, type: type};
        loader.emit('progress', 1);
        loader.emit('complete', file, id, type);
        removeListeners();
    };

    var loadXHR = function(responseType, customLoadHandler) {
        loadHandler = customLoadHandler || completeHandler;

        request = new XMLHttpRequest();
        request.open('GET', basePath + url, true);
        request.responseType = responseType;
        request.addEventListener('progress', progressHandler);
        request.addEventListener('load', loadHandler);
        request.addEventListener('error', errorHandler);
        request.send();
    };

    var progressHandler = function(event) {
        if (event.lengthComputable) {
            loader.emit('progress', event.loaded / event.total);
        }
    };

    var completeHandler = function() {
        if (success()) {
            dispatchComplete(request.response);
        }
    };

    var success = function() {
        // console.log('success', url, request.status);
        if (request && request.status < 400) {
            stats.update(request, startTime, url, log);
            return true;
        }
        errorHandler(request && request.statusText);
        return false;
    };

    // json

    var loadJSON = function() {
        loadXHR('json', function() {
            if (success()) {
                var data = request.response;
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }
                dispatchComplete(data);
            }
        });
    };

    // image

    var loadImage = function() {
        if (blob) {
            loadImageBlob();
        } else {
            loadImageElement();
        }
    };

    var loadImageElement = function() {
        request = new Image();
        if (crossOrigin) {
            request.crossOrigin = 'anonymous';
        }
        request.addEventListener('error', errorHandler, false);
        request.addEventListener('load', elementLoadHandler, false);
        request.src = basePath + url;
    };

    var elementLoadHandler = function(event) {
        window.clearTimeout(timeout);
        if (!event && (request.error || !request.readyState)) {
            errorHandler();
            return;
        }
        dispatchComplete(request);
    };

    var loadImageBlob = function() {
        loadXHR('blob', function() {
            if (success()) {
                request = new Image();
                request.addEventListener('error', errorHandler, false);
                request.addEventListener('load', imageBlobHandler, false);
                request.src = window.URL.createObjectURL(request.response);
            }
        });
    };

    var imageBlobHandler = function() {
        window.URL.revokeObjectURL(request.src);
        dispatchComplete(request);
    };

    // audio

    var loadAudio = function() {
        if (webAudioContext) {
            loadAudioBuffer();
        } else {
            loadMediaElement('audio');
        }
    };

    // video

    var loadVideo = function() {
        if (blob) {
            loadXHR('blob');
        } else {
            loadMediaElement('video');
        }
    };

    // audio buffer

    var loadAudioBuffer = function() {
        loadXHR('arraybuffer', function() {
            if (success()) {
                webAudioContext.decodeAudioData(
                    request.response,
                    function(buffer) {
                        request = null;
                        dispatchComplete(buffer);
                    },
                    function(e) {
                        errorHandler(e);
                    }
                );
            }
        });
    };

    // media element

    var loadMediaElement = function(tagName) {
        request = document.createElement(tagName);

        if (!isTouchLocked) {
            // timeout because sometimes canplaythrough doesn't fire
            window.clearTimeout(timeout);
            timeout = window.setTimeout(elementLoadHandler, 2000);
            request.addEventListener('canplaythrough', elementLoadHandler, false);
        }

        request.addEventListener('error', errorHandler, false);
        request.preload = 'auto';
        request.src = basePath + url;
        request.load();

        if (isTouchLocked) {
            dispatchComplete(request);
        }
    };

    // error

    var errorHandler = function(err) {
        // console.log('errorHandler', url, err);
        window.clearTimeout(timeout);

        var message = err;

        if (request && request.tagName && request.error) {
            var ERROR_STATE = ['', 'ABORTED', 'NETWORK', 'DECODE', 'SRC_NOT_SUPPORTED'];
            message = 'MediaError: ' + ERROR_STATE[request.error.code] + ' ' + request.src;
        } else if (request && request.statusText) {
            message = request.statusText;
        } else if (err && err.message) {
            message = err.message;
        } else if (err && err.type) {
            message = err.type;
        }

        loader.emit('error', 'Error loading "' + basePath + url + '" ' + message);

        destroy();
    };

    // clean up

    var removeListeners = function() {
        loader.off('error');
        loader.off('progress');
        loader.off('complete');

        if (request) {
            request.removeEventListener('progress', progressHandler);
            request.removeEventListener('load', loadHandler);
            request.removeEventListener('error', errorHandler);
            request.removeEventListener('load', elementLoadHandler);
            request.removeEventListener('canplaythrough', elementLoadHandler);
            request.removeEventListener('load', imageBlobHandler);
        }
    };

    var destroy = function() {
        removeListeners();

        if (request && request.abort && request.readyState < 4) {
            request.abort();
        }

        request = null;
        webAudioContext = null;
        file = null;

        window.clearTimeout(timeout);

        loader.emit('destroy', id);
    };

    // emits: progress, error, complete

    loader = Object.create(Emitter.prototype, {
        _events: {
            value: {}
        },
        id: {
            value: options.id
        },
        start: {
            value: start
        },
        loaded: {
            get: function() {
                return !!file;
            }
        },
        file: {
            get: function() {
                return file;
            }
        },
        destroy: {
            value: destroy
        }
    });

    return loader;
};


/***/ }),

/***/ "./node_modules/assets-loader/src/stats.js":
/*!*************************************************!*\
  !*** ./node_modules/assets-loader/src/stats.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
    mbs: 0,
    secs: 0,
    update: function(request, startTime, url, log) {
        var length;
        var headers = request.getAllResponseHeaders();
        if (headers) {
            var match = headers.match(/content-length: (\d+)/i);
            if (match && match.length) {
                length = match[1];
            }
        }
        // var length = request.getResponseHeader('Content-Length');
        if (length) {
            length = parseInt(length, 10);
            var mbs = length / 1024 / 1024;
            var secs = (Date.now() - startTime) / 1000;
            this.secs += secs;
            this.mbs += mbs;
            if (log) {
                this.log(url, mbs, secs);
            }
        } else if(log) {
            console.warn.call(console, 'Can\'t get Content-Length:', url);
        }
    },
    log: function(url, mbs, secs) {
        if (url) {
            var file = 'File loaded: ' +
                url.substr(url.lastIndexOf('/') + 1) +
                ' size:' + mbs.toFixed(2) + 'mb' +
                ' time:' + secs.toFixed(2) + 's' +
                ' speed:' + (mbs / secs).toFixed(2) + 'mbps';

            console.log.call(console, file);
        }
        var total = 'Total loaded: ' + this.mbs.toFixed(2) + 'mb' +
            ' time:' + this.secs.toFixed(2) + 's' +
            ' speed:' + this.getMbps().toFixed(2) + 'mbps';
        console.log.call(console, total);
    },
    getMbps: function() {
        return this.mbs / this.secs;
    }
};


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/scss/global.scss":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/scss/global.scss ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, "html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n  position: fixed;\n  background-color: #000000;\n  /* Old browsers */\n  /* Permalink - use to edit and share this gradient: http://colorzilla.com/gradient-editor/#6d6d6d+0,000000+100 */ }\n\nhtml {\n  -webkit-text-size-adjust: none;\n  -moz-text-size-adjust: none;\n  text-size-adjust: none; }\n\nh1, h2, h3, h4, text, p {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-webkit-font-smoothing: antialiased;\n  font-family: 'Open Sans', sans-serif; }\n\n.Main-Canvas {\n  user-select: none;\n  opacity: 1;\n  transition: opacity .5s ease-out .25s; }\n  .isLoading .Main-Canvas {\n    opacity: 0; }\n\n.editor-points {\n  position: absolute;\n  padding: 50px 0 0 20px;\n  left: 0;\n  z-index: 1000;\n  color: white; }\n  .editor-points div {\n    position: relative;\n    background: black;\n    height: 20px;\n    cursor: pointer;\n    margin-bottom: 2px;\n    padding: 2px;\n    min-width: 100px;\n    justify-content: space-between;\n    display: flex; }\n    .editor-points div p {\n      margin: 0;\n      margin-right: 10px;\n      max-width: 180px;\n      white-space: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis; }\n    .editor-points div p.delete {\n      color: red;\n      font-weight: bold;\n      position: absolute;\n      right: 0;\n      top: 50%;\n      margin-top: -10px; }\n\n.markers {\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 10;\n  width: 100%;\n  height: 100%;\n  color: white; }\n\n.markers p {\n  position: absolute;\n  top: 0;\n  left: 0;\n  font-family: 'ITCAvantGardeStd-Demi';\n  cursor: pointer; }\n\n.markers p:hover {\n  color: #009ADD; }\n\n.container {\n  width: 100%;\n  height: 100%;\n  position: fixed;\n  top: 0;\n  left: 0;\n  display: flex;\n  justify-content: center;\n  align-items: center; }\n\n.camera-spots nav {\n  color: black;\n  position: absolute;\n  bottom: 20px;\n  left: 20px;\n  display: flex;\n  width: 100%; }\n  .camera-spots nav p {\n    position: relative;\n    margin: 0;\n    width: auto;\n    margin: 0 30px; }\n\n.Message {\n  pointer-events: none;\n  position: absolute;\n  z-index: 999;\n  width: 100%;\n  top: calc(50% - 50px);\n  text-align: center;\n  letter-spacing: 11px;\n  color: white;\n  opacity: 0;\n  transition: opacity .5s ease-out, letter-spacing .5s ease-out; }\n  .isLoading .Message {\n    letter-spacing: 10px;\n    opacity: 1; }\n\n.Loading-Bar {\n  pointer-events: none;\n  position: absolute;\n  z-index: 998;\n  width: 0%;\n  height: 1px;\n  top: 50%;\n  background: rgba(255, 255, 255, 0.5);\n  opacity: 0;\n  transition: width .5s ease-out, opacity .5s ease-out; }\n  .isLoading .Loading-Bar {\n    opacity: 1; }\n\n.env {\n  position: fixed;\n  width: 100%;\n  z-index: 9999;\n  color: white;\n  top: 100px;\n  font-size: 24px;\n  padding: 20px; }\n", ""]);



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/scss/modelViewer.scss":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/scss/modelViewer.scss ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".camera-spots {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 10;\n  width: 100%;\n  height: 100%;\n  color: black; }\n\n.camera-spots p:hover {\n  color: #009ADD; }\n\n.camera-spots .annotation {\n  width: 30%;\n  position: absolute;\n  top: 30%;\n  max-width: 250px;\n  padding: 10px 5px;\n  background-color: rgba(0, 0, 0, 0.6);\n  border-radius: 10px; }\n  .camera-spots .annotation p {\n    color: white;\n    margin: auto;\n    margin-bottom: 10px;\n    padding: 0;\n    font-size: 14px;\n    width: 95%; }\n  .camera-spots .annotation .image-spot {\n    width: 95%;\n    display: block;\n    margin: auto;\n    background-color: green;\n    min-height: 100px; }\n  .camera-spots .annotation .close {\n    position: absolute;\n    right: 8px;\n    top: 8px;\n    width: 20px;\n    height: 20px;\n    background-color: red; }\n\n.camera-spots p.spot {\n  position: absolute;\n  width: 200px;\n  margin-top: -10px;\n  margin-left: -100px;\n  text-align: center;\n  top: 0;\n  left: 0;\n  font-family: 'ITCAvantGardeStd-Demi';\n  cursor: pointer; }\n", ""]);



/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return '@media ' + item[2] + '{' + content + '}';
      } else {
        return content;
      }
    }).join('');
  }; // import a list of modules into the list


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (i = 0; i < modules.length; i++) {
      var item = modules[i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || '';
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
  return '/*# ' + data + ' */';
}

/***/ }),

/***/ "./node_modules/fast-url-parser/src/urlparser.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-url-parser/src/urlparser.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
Copyright (c) 2014 Petka Antonov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
function Url() {
    //For more efficient internal representation and laziness.
    //The non-underscore versions of these properties are accessor functions
    //defined on the prototype.
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;

    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;

    this._prependSlash = false;
}

var querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

Url.queryString = querystring;

Url.prototype.parse =
function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (typeof str !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " +
            typeof str);
    }
    var start = 0;
    var end = str.length - 1;

    //Trim leading and trailing ws
    while (str.charCodeAt(start) <= 0x20 /*' '*/) start++;
    while (str.charCodeAt(end) <= 0x20 /*' '*/) end--;

    start = this._parseProtocol(str, start, end);

    //Javascript doesn't have host
    if (this._protocol !== "javascript") {
        start = this._parseHost(str, start, end, hostDenotesSlash);
        var proto = this._protocol;
        if (!this.hostname &&
            (this.slashes || (proto && !slashProtocols[proto]))) {
            this.hostname = this.host = "";
        }
    }

    if (start <= end) {
        var ch = str.charCodeAt(start);

        if (ch === 0x2F /*'/'*/ || ch === 0x5C /*'\'*/) {
            this._parsePath(str, start, end, disableAutoEscapeChars);
        }
        else if (ch === 0x3F /*'?'*/) {
            this._parseQuery(str, start, end, disableAutoEscapeChars);
        }
        else if (ch === 0x23 /*'#'*/) {
          this._parseHash(str, start, end, disableAutoEscapeChars);
        }
        else if (this._protocol !== "javascript") {
            this._parsePath(str, start, end, disableAutoEscapeChars);
        }
        else { //For javascript the pathname is just the rest of it
            this.pathname = str.slice(start, end + 1 );
        }

    }

    if (!this.pathname && this.hostname &&
        this._slashProtocols[this._protocol]) {
        this.pathname = "/";
    }

    if (parseQueryString) {
        var search = this.search;
        if (search == null) {
            search = this.search = "";
        }
        if (search.charCodeAt(0) === 0x3F /*'?'*/) {
            search = search.slice(1);
        }
        //This calls a setter function, there is no .query data property
        this.query = Url.queryString.parse(search);
    }
};

Url.prototype.resolve = function Url$resolve(relative) {
    return this.resolveObject(Url.parse(relative, false, true)).format();
};

Url.prototype.format = function Url$format() {
    var auth = this.auth || "";

    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
    }

    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";

    //Cache the result of the getter function
    var q = this.query;
    if (q && typeof q === "object") {
        query = Url.queryString.stringify(q);
    }

    if (!search) {
        search = query ? "?" + query : "";
    }

    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 0x3A /*':'*/)
        protocol += ":";

    if (this.host) {
        host = auth + this.host;
    }
    else if (hostname) {
        var ip6 = hostname.indexOf(":") > -1;
        if (ip6) hostname = "[" + hostname + "]";
        host = auth + hostname + (port ? ":" + port : "");
    }

    var slashes = this.slashes ||
        ((!protocol ||
        slashProtocols[protocol]) && host !== false);


    if (protocol) scheme = protocol + (slashes ? "//" : "");
    else if (slashes) scheme = "//";

    if (slashes && pathname && pathname.charCodeAt(0) !== 0x2F /*'/'*/) {
        pathname = "/" + pathname;
    }
    if (search && search.charCodeAt(0) !== 0x3F /*'?'*/)
        search = "?" + search;
    if (hash && hash.charCodeAt(0) !== 0x23 /*'#'*/)
        hash = "#" + hash;

    pathname = escapePathName(pathname);
    search = escapeSearch(search);

    return scheme + (host === false ? "" : host) + pathname + search + hash;
};

Url.prototype.resolveObject = function Url$resolveObject(relative) {
    if (typeof relative === "string")
        relative = Url.parse(relative, false, true);

    var result = this._clone();

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there"s nothing left to do here.
    if (!relative.href) {
        result._href = "";
        return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative._protocol) {
        relative._copyPropsTo(result, true);

        if (slashProtocols[result._protocol] &&
            result.hostname && !result.pathname) {
            result.pathname = "/";
        }
        result._href = "";
        return result;
    }

    if (relative._protocol && relative._protocol !== result._protocol) {
        // if it"s a known url protocol, then changing
        // the protocol does weird things
        // first, if it"s not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that"s known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashProtocols[relative._protocol]) {
            relative._copyPropsTo(result, false);
            result._href = "";
            return result;
        }

        result._protocol = relative._protocol;
        if (!relative.host && relative._protocol !== "javascript") {
            var relPath = (relative.pathname || "").split("/");
            while (relPath.length && !(relative.host = relPath.shift()));
            if (!relative.host) relative.host = "";
            if (!relative.hostname) relative.hostname = "";
            if (relPath[0] !== "") relPath.unshift("");
            if (relPath.length < 2) relPath.unshift("");
            result.pathname = relPath.join("/");
        } else {
            result.pathname = relative.pathname;
        }

        result.search = relative.search;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result._port = relative._port;
        result.slashes = result.slashes || relative.slashes;
        result._href = "";
        return result;
    }

    var isSourceAbs =
        (result.pathname && result.pathname.charCodeAt(0) === 0x2F /*'/'*/);
    var isRelAbs = (
            relative.host ||
            (relative.pathname &&
            relative.pathname.charCodeAt(0) === 0x2F /*'/'*/)
        );
    var mustEndAbs = (isRelAbs || isSourceAbs ||
                        (result.host && relative.pathname));

    var removeAllDots = mustEndAbs;

    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative.pathname && relative.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
        result.hostname = "";
        result._port = -1;
        if (result.host) {
            if (srcPath[0] === "") srcPath[0] = result.host;
            else srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative._protocol) {
            relative.hostname = "";
            relative._port = -1;
            if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
            }
            relative.host = "";
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }

    if (isRelAbs) {
        // it"s absolute.
        result.host = relative.host ?
            relative.host : result.host;
        result.hostname = relative.hostname ?
            relative.hostname : result.hostname;
        result.search = relative.search;
        srcPath = relPath;
        // fall through to the dot-handling below.
    } else if (relPath.length) {
        // it"s relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
    } else if (relative.search) {
        // just pull out the search.
        // like href="?foo".
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especialy happens in cases like
            //url.resolveObject("mailto:local1@domain1", "local2@domain2")
            var authInHost = result.host && result.host.indexOf("@") > 0 ?
                result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        result.search = relative.search;
        result._href = "";
        return result;
    }

    if (!srcPath.length) {
        // no path at all.  easy.
        // we"ve already handled the other stuff above.
        result.pathname = null;
        result._href = "";
        return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (
        (result.host || relative.host) && (last === "." || last === "..") ||
        last === "");

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
            srcPath.splice(i, 1);
        } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
            srcPath.unshift("..");
        }
    }

    if (mustEndAbs && srcPath[0] !== "" &&
        (!srcPath[0] || srcPath[0].charCodeAt(0) !== 0x2F /*'/'*/)) {
        srcPath.unshift("");
    }

    if (hasTrailingSlash && (srcPath.join("/").substr(-1) !== "/")) {
        srcPath.push("");
    }

    var isAbsolute = srcPath[0] === "" ||
        (srcPath[0] && srcPath[0].charCodeAt(0) === 0x2F /*'/'*/);

    // put the host back
    if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" :
            srcPath.length ? srcPath.shift() : "";
        //occationaly the auth can get stuck only in host
        //this especialy happens in cases like
        //url.resolveObject("mailto:local1@domain1", "local2@domain2")
        var authInHost = result.host && result.host.indexOf("@") > 0 ?
            result.host.split("@") : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
        }
    }

    mustEndAbs = mustEndAbs || (result.host && srcPath.length);

    if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
    }

    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
};

var punycode = __webpack_require__(/*! punycode */ "./node_modules/punycode/punycode.js");
Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    // IDNA Support: Returns a punycoded representation of "domain".
    // It only converts parts of the domain name that
    // have non-ASCII characters, i.e. it doesn't matter if
    // you call it with a domain that already is ASCII-only.
    return punycode.toASCII(hostname);
};

var escapePathName = Url.prototype._escapePathName =
function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 0x23 /*'#'*/, 0x3F /*'?'*/)) {
        return pathname;
    }
    //Avoid closure creation to keep this inlinable
    return _escapePath(pathname);
};

var escapeSearch = Url.prototype._escapeSearch =
function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 0x23 /*'#'*/, -1)) return search;
    //Avoid closure creation to keep this inlinable
    return _escapeSearch(search);
};

Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x3A /*':'*/) {
            var protocol = str.slice(start, i);
            if (doLowerCase) protocol = protocol.toLowerCase();
            this._protocol = protocol;
            return i + 1;
        }
        else if (protocolCharacters[ch] === 1) {
            if (ch < 0x61 /*'a'*/)
                doLowerCase = true;
        }
        else {
            return start;
        }

    }
    return start;
};

Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
    var auth = str.slice(start, end + 1);
    if (decode) {
        auth = decodeURIComponent(auth);
    }
    this.auth = auth;
};

Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    //Internal format is integer for more efficient parsing
    //and for efficient trimming of leading zeros
    var port = 0;
    //Distinguish between :0 and : (no port number at all)
    var hadChars = false;
    var validPort = true;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/) {
            port = (10 * port) + (ch - 0x30 /*'0'*/);
            hadChars = true;
        }
        else {
            validPort = false;
            if (ch === 0x5C/*'\'*/ || ch === 0x2F/*'/'*/) {
                validPort = true;
            }
            break;
        }

    }
    if ((port === 0 && !hadChars) || !validPort) {
        if (!validPort) {
            this._port = -2;
        }
        return 0;
    }

    this._port = port;
    return i - start;
};

Url.prototype._parseHost =
function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    var first = str.charCodeAt(start);
    var second = str.charCodeAt(start + 1);
    if ((first === 0x2F /*'/'*/ || first === 0x5C /*'\'*/) &&
        (second === 0x2F /*'/'*/ || second === 0x5C /*'\'*/)) {
        this.slashes = true;

        //The string starts with //
        if (start === 0) {
            //The string is just "//"
            if (end < 2) return start;
            //If slashes do not denote host and there is no auth,
            //there is no host when the string starts with //
            var hasAuth =
                containsCharacter(str, 0x40 /*'@'*/, 2, hostEndingCharacters);
            if (!hasAuth && !slashesDenoteHost) {
                this.slashes = null;
                return start;
            }
        }
        //There is a host that starts after the //
        start += 2;
    }
    //If there is no slashes, there is no hostname if
    //1. there was no protocol at all
    else if (!this._protocol ||
        //2. there was a protocol that requires slashes
        //e.g. in 'http:asd' 'asd' is not a hostname
        slashProtocols[this._protocol]
    ) {
        return start;
    }

    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;

    var j = -1;

    //Find the last occurrence of an @-sign until hostending character is met
    //also mark if decoding is needed for the auth portion
    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x40 /*'@'*/) {
            j = i;
        }
        //This check is very, very cheap. Unneeded decodeURIComponent is very
        //very expensive
        else if (ch === 0x25 /*'%'*/) {
            authNeedsDecoding = true;
        }
        else if (hostEndingCharacters[ch] === 1) {
            break;
        }
    }

    //@-sign was found at index j, everything to the left from it
    //is auth part
    if (j > -1) {
        this._parseAuth(str, start, j - 1, authNeedsDecoding);
        //hostname starts after the last @-sign
        start = hostNameStart = j + 1;
    }

    //Host name is starting with a [
    if (str.charCodeAt(start) === 0x5B /*'['*/) {
        for (var i = start + 1; i <= end; ++i) {
            var ch = str.charCodeAt(i);

            //Assume valid IP6 is between the brackets
            if (ch === 0x5D /*']'*/) {
                if (str.charCodeAt(i + 1) === 0x3A /*':'*/) {
                    portLength = this._parsePort(str, i + 2, end) + 1;
                }
                var hostname = str.slice(start + 1, i).toLowerCase();
                this.hostname = hostname;
                this.host = this._port > 0 ?
                    "[" + hostname + "]:" + this._port :
                    "[" + hostname + "]";
                this.pathname = "/";
                return i + portLength + 1;
            }
        }
        //Empty hostname, [ starts a path
        return start;
    }

    for (var i = start; i <= end; ++i) {
        if (charsAfterDot > 62) {
            this.hostname = this.host = str.slice(start, i);
            return i;
        }
        var ch = str.charCodeAt(i);

        if (ch === 0x3A /*':'*/) {
            portLength = this._parsePort(str, i + 1, end) + 1;
            hostNameEnd = i - 1;
            break;
        }
        else if (ch < 0x61 /*'a'*/) {
            if (ch === 0x2E /*'.'*/) {
                //Node.js ignores this error
                /*
                if (lastCh === DOT || lastCh === -1) {
                    this.hostname = this.host = "";
                    return start;
                }
                */
                charsAfterDot = -1;
            }
            else if (0x41 /*'A'*/ <= ch && ch <= 0x5A /*'Z'*/) {
                doLowerCase = true;
            }
            //Valid characters other than ASCII letters -, _, +, 0-9
            else if (!(ch === 0x2D /*'-'*/ ||
                       ch === 0x5F /*'_'*/ ||
                       ch === 0x2B /*'+'*/ ||
                       (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/))
                ) {
                if (hostEndingCharacters[ch] === 0 &&
                    this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
        }
        else if (ch >= 0x7B /*'{'*/) {
            if (ch <= 0x7E /*'~'*/) {
                if (this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
            idna = true;
        }
        lastCh = ch;
        charsAfterDot++;
    }

    //Node.js ignores this error
    /*
    if (lastCh === DOT) {
        hostNameEnd--;
    }
    */

    if (hostNameEnd + 1 !== start &&
        hostNameEnd - hostNameStart <= 256) {
        var hostname = str.slice(hostNameStart, hostNameEnd + 1);
        if (doLowerCase) hostname = hostname.toLowerCase();
        if (idna) hostname = this._hostIdna(hostname);
        this.hostname = hostname;
        this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }

    return hostNameEnd + 1 + portLength;

};

Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
        input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
};

Url.prototype._clone = function Url$_clone() {
    var ret = new Url();
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
};

Url.prototype._getComponentEscaped =
function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
    var cur = start;
    var i = start;
    var ret = "";
    var autoEscapeMap = isAfterQuery ?
        this._afterQueryAutoEscapeMap : this._autoEscapeMap;
    for (; i <= end; ++i) {
        var ch = str.charCodeAt(i);
        var escaped = autoEscapeMap[ch];

        if (escaped !== "" && escaped !== undefined) {
            if (cur < i) ret += str.slice(cur, i);
            ret += escaped;
            cur = i + 1;
        }
    }
    if (cur < i + 1) ret += str.slice(cur, i);
    return ret;
};

Url.prototype._parsePath =
function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
    var pathStart = start;
    var pathEnd = end;
    var escape = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    var prePath = this._port === -2 ? "/:" : "";

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);
        if (ch === 0x23 /*'#'*/) {
          this._parseHash(str, i, end, disableAutoEscapeChars);
            pathEnd = i - 1;
            break;
        }
        else if (ch === 0x3F /*'?'*/) {
            this._parseQuery(str, i, end, disableAutoEscapeChars);
            pathEnd = i - 1;
            break;
        }
        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
            escape = true;
        }
    }

    if (pathStart > pathEnd) {
        this.pathname = prePath === "" ? "/" : prePath;
        return;
    }

    var path;
    if (escape) {
        path = this._getComponentEscaped(str, pathStart, pathEnd, false);
    }
    else {
        path = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = prePath === ""
        ? (this._prependSlash ? "/" + path : path)
        : prePath + path;
};

Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
    var queryStart = start;
    var queryEnd = end;
    var escape = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x23 /*'#'*/) {
            this._parseHash(str, i, end, disableAutoEscapeChars);
            queryEnd = i - 1;
            break;
        }
        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
            escape = true;
        }
    }

    if (queryStart > queryEnd) {
        this.search = "";
        return;
    }

    var query;
    if (escape) {
        query = this._getComponentEscaped(str, queryStart, queryEnd, true);
    }
    else {
        query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
};

Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
    if (start > end) {
        this.hash = "";
        return;
    }

    this.hash = disableAutoEscapeChars ?
        str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
};

Object.defineProperty(Url.prototype, "port", {
    get: function() {
        if (this._port >= 0) {
            return ("" + this._port);
        }
        return null;
    },
    set: function(v) {
        if (v == null) {
            this._port = -1;
        }
        else {
            this._port = parseInt(v, 10);
        }
    }
});

Object.defineProperty(Url.prototype, "query", {
    get: function() {
        var query = this._query;
        if (query != null) {
            return query;
        }
        var search = this.search;

        if (search) {
            if (search.charCodeAt(0) === 0x3F /*'?'*/) {
                search = search.slice(1);
            }
            if (search !== "") {
                this._query = search;
                return search;
            }
        }
        return search;
    },
    set: function(v) {
        this._query = v;
    }
});

Object.defineProperty(Url.prototype, "path", {
    get: function() {
        var p = this.pathname || "";
        var s = this.search || "";
        if (p || s) {
            return p + s;
        }
        return (p == null && s) ? ("/" + s) : null;
    },
    set: function() {}
});

Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
        var proto = this._protocol;
        return proto ? proto + ":" : proto;
    },
    set: function(v) {
        if (typeof v === "string") {
            var end = v.length - 1;
            if (v.charCodeAt(end) === 0x3A /*':'*/) {
                this._protocol = v.slice(0, end);
            }
            else {
                this._protocol = v;
            }
        }
        else if (v == null) {
            this._protocol = null;
        }
    }
});

Object.defineProperty(Url.prototype, "href", {
    get: function() {
        var href = this._href;
        if (!href) {
            href = this._href = this.format();
        }
        return href;
    },
    set: function(v) {
        this._href = v;
    }
});

Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (str instanceof Url) return str;
    var ret = new Url();
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
    return ret;
};

Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
        obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
    }
    return obj.format();
};

Url.resolve = function Url$Resolve(source, relative) {
    return Url.parse(source, false, true).resolve(relative);
};

Url.resolveObject = function Url$ResolveObject(source, relative) {
    if (!source) return relative;
    return Url.parse(source, false, true).resolveObject(relative);
};

function _escapePath(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
    });
}

function _escapeSearch(search) {
    return search.replace(/#/g, function(match) {
        return encodeURIComponent(match);
    });
}

//Search `char1` (integer code for a character) in `string`
//starting from `fromIndex` and ending at `string.length - 1`
//or when a stop character is found
function containsCharacter(string, char1, fromIndex, stopCharacterTable) {
    var len = string.length;
    for (var i = fromIndex; i < len; ++i) {
        var ch = string.charCodeAt(i);

        if (ch === char1) {
            return true;
        }
        else if (stopCharacterTable[ch] === 1) {
            return false;
        }
    }
    return false;
}

//See if `char1` or `char2` (integer codes for characters)
//is contained in `string`
function containsCharacter2(string, char1, char2) {
    for (var i = 0, len = string.length; i < len; ++i) {
        var ch = string.charCodeAt(i);
        if (ch === char1 || ch === char2) return true;
    }
    return false;
}

//Makes an array of 128 uint8's which represent boolean values.
//Spec is an array of ascii code points or ascii code point ranges
//ranges are expressed as [start, end]

//Create a table with the characters 0x30-0x39 (decimals '0' - '9') and
//0x7A (lowercaseletter 'z') as `true`:
//
//var a = makeAsciiTable([[0x30, 0x39], 0x7A]);
//a[0x30]; //1
//a[0x15]; //0
//a[0x35]; //1
function makeAsciiTable(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item){
        if (typeof item === "number") {
            ret[item] = 1;
        }
        else {
            var start = item[0];
            var end = item[1];
            for (var j = start; j <= end; ++j) {
                ret[j] = 1;
            }
        }
    });

    return ret;
}


var autoEscape = ["<", ">", "\"", "`", " ", "\r", "\n",
    "\t", "{", "}", "|", "\\", "^", "`", "'"];

var autoEscapeMap = new Array(128);



for (var i = 0, len = autoEscapeMap.length; i < len; ++i) {
    autoEscapeMap[i] = "";
}

for (var i = 0, len = autoEscape.length; i < len; ++i) {
    var c = autoEscape[i];
    var esc = encodeURIComponent(c);
    if (esc === c) {
        esc = escape(c);
    }
    autoEscapeMap[c.charCodeAt(0)] = esc;
}
var afterQueryAutoEscapeMap = autoEscapeMap.slice();
autoEscapeMap[0x5C /*'\'*/] = "/";

var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,

    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
};

//Optimize back from normalized object caused by non-identifier keys
function f(){}
f.prototype = slashProtocols;

Url.prototype._protocolCharacters = makeAsciiTable([
    [0x61 /*'a'*/, 0x7A /*'z'*/],
    [0x41 /*'A'*/, 0x5A /*'Z'*/],
    0x2E /*'.'*/, 0x2B /*'+'*/, 0x2D /*'-'*/
]);

Url.prototype._hostEndingCharacters = makeAsciiTable([
    0x23 /*'#'*/, 0x3F /*'?'*/, 0x2F /*'/'*/, 0x5C /*'\'*/
]);

Url.prototype._autoEscapeCharacters = makeAsciiTable(
    autoEscape.map(function(v) {
        return v.charCodeAt(0);
    })
);

//If these characters end a host name, the path will not be prepended a /
Url.prototype._noPrependSlashHostEnders = makeAsciiTable(
    [
        "<", ">", "'", "`", " ", "\r",
        "\n", "\t", "{", "}", "|",
        "^", "`", "\"", "%", ";"
    ].map(function(v) {
        return v.charCodeAt(0);
    })
);

Url.prototype._autoEscapeMap = autoEscapeMap;
Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;

module.exports = Url;

Url.replace = function Url$Replace() {
    __webpack_require__.c.url = {
        exports: Url
    };
};


/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "./node_modules/gl-matrix/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/index.js ***!
  \*********************************************/
/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ "./node_modules/gl-matrix/esm/mat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return _mat2_js__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ "./node_modules/gl-matrix/esm/mat2d.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return _mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return _mat3_js__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return _mat4_js__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return _quat_js__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ "./node_modules/gl-matrix/esm/quat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat2", function() { return _quat2_js__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ "./node_modules/gl-matrix/esm/vec2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return _vec2_js__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return _vec3_js__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return _vec4_js__WEBPACK_IMPORTED_MODULE_9__; });












/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDU", function() { return LDU; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2d.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2d.js ***!
  \*********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat3.js ***!
  \********************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat.js ***!
  \********************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, getAngle, multiply, rotateX, rotateY, rotateZ, calculateW, exp, ln, pow, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngle", function() { return getAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ln", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat2.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat2.js ***!
  \*********************************************/
/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationValues", function() { return fromRotationTranslationValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReal", function() { return getReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDual", function() { return getDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setReal", function() { return setReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDual", function() { return setDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatAppend", function() { return rotateByQuatAppend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatPrepend", function() { return rotateByQuatPrepend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAroundAxis", function() { return rotateAroundAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");



/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getRotation"](outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getTranslation"](t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateX"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateY"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateZ"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__["dot"];
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__["length"];
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__["squaredLength"];
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec2.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec4.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/glslify/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/glslify/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}


/***/ }),

/***/ "./node_modules/gsap/CSSPlugin.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/CSSPlugin.js ***!
  \****************************************/
/*! exports provided: CSSPlugin, default, _getBBox, _createElement, checkPrefix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return CSSPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CSSPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getBBox", function() { return _getBBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_createElement", function() { return _createElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPrefix", function() { return _checkPropPrefix; });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/*!
 * CSSPlugin 3.2.6
 * https://greensock.com
 *
 * Copyright 2008-2020, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(?:left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists()) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _checkPropPrefix(_transformOriginProp);
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if (toPercent && (_transformProps[property] || ~property.indexOf("adius"))) {
    //transforms and borderRadius are relative to the size of the element itself!
    return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(curValue / (isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty]) * amount);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_ticker"].time) {
    return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";

    if (horizontal && toPercent) {
      cache = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getCache"])(parent);
      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_ticker"].time;
      cache.width = parent[measureProperty];
    }
  }

  return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;

  if (!_pluginInitted) {
    _initCore();
  }

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getProperty"])(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    }
  }

  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_renderComplexString"]),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      relative,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];

  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_colorStringFilter"])(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


  start = a[0];
  end = a[1];
  startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"]) || [];
  endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"]) || [];

  if (endValues.length) {
    while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"].exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;

        if (relative) {
          endValue = endValue.substr(2);
        }

        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"].lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: relative ? relative * endNum : endNum - startNum,
          m: color && color < 4 ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_relExp"].test(end)) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numExp"]).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"]);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getCache"])(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      addedToDOM = 1; //flag

      nextSibling = target.nextSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);

    if (temp) {
      style.display = temp;
    } else {
      _removeProperty(target, "display");
    }

    if (addedToDOM) {
      if (nextSibling) {
        parent.insertBefore(target, nextSibling);
      } else if (parent) {
        parent.appendChild(target);
      } else {
        _docElement.removeChild(target);
      }
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["GSCache"](target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    t1 = !cache.uncache && target.getAttribute("data-svg-origin");

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.cos(skewX * _DEG2RAD));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(Math.sqrt(a * a + b * b + c * c));
      scaleY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      matrix = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      matrix && target.setAttribute("transform", matrix);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  cache.x = ((cache.xPercent = x && Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0) ? 0 : x) + px;
  cache.y = ((cache.yPercent = y && Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0) ? 0 : y) + px;
  cache.z = z + px;
  cache.scaleX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(scaleX);
  cache.scaleY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(scaleY);
  cache.rotation = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotation) + deg;
  cache.rotationX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotationX) + deg;
  cache.rotationY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(start);
  return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a11);
    a21 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a21);
    a12 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a12);
    a22 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(tx + xPercent / 100 * temp.width);
    ty = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);

  if (forceCSS) {
    //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
    target.style[_transformProp] = temp;
  }
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {
  var cap = 360,
      isString = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_isString"])(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = relative ? endNum * relative : endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var style = _tempDivStyler.style,
      startCache = target._gsap,
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;
  style.cssText = getComputedStyle(target).cssText + ";position:absolute;display:block;"; //%-based translations will fail unless we set the width/height to match the original target (and padding/borders can affect it)

  style[_transformProp] = transforms;

  _doc.body.appendChild(_tempDivStyler);

  endCache = _parseTransform(_tempDivStyler, 1);

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(startValue);
      endUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, startCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _doc.body.removeChild(_tempDivStyler);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});

var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority;

    if (!_pluginInitted) {
      _initCore();
    }

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_plugins"][p] && Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_checkPlugin"])(p, vars, tween, index, target, targets)) {
        //plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_replaceRandom"])(endValue);
      }

      if (specialProp) {
        if (specialProp(this, target, p, endValue, tween)) {
          hasPriority = 1;
        }
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        this.add(style, "setProperty", getComputedStyle(target).getPropertyValue(p) + "", endValue + "", index, targets, 0, 0, p);
      } else {
        startValue = _get(target, p);
        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;

        if (relative) {
          endValue = endValue.substr(2);
        }

        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];

            if (~p.indexOf(",")) {
              p = p.split(",")[0];
            }
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform || _parseTransform(target); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, cache, "scaleY", cache.scaleY, relative ? relative * endNum : endNum - cache.scaleY);
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              if (endUnit !== cache.zOrigin) {
                _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
              }

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, endValue, relative);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = (endValue + "").substr((endNum + "").length) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[p] : startUnit);

          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, p, startValue, endUnit);
          }

          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, endUnit === "px" && vars.autoRound !== false && !isTransformRelated ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit) {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, target[p], endValue, index, targets);
          } else {
            Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_missingPlugin"])(p, endValue);

            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, endValue);
        }

        props.push(p);
      }
    }

    if (hasPriority) {
      Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_sortPropTweensByPriority"])(this);
    }
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_isUndefined"])(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getSetter"])(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].utils.checkPrefix = _checkPropPrefix;

(function (positionAndScale, rotation, others, aliases) {
  var all = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(rotation, function (name) {
    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[name] = "px";
});

_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].registerPlugin(CSSPlugin);


/***/ }),

/***/ "./node_modules/gsap/gsap-core.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/gsap-core.js ***!
  \****************************************/
/*! exports provided: GSCache, Animation, Timeline, Tween, PropTween, gsap, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ, TweenMax, TweenLite, TimelineMax, TimelineLite, default, wrap, wrapYoyo, distribute, random, snap, normalize, getUnit, clamp, splitColor, toArray, mapRange, pipe, unitize, interpolate, shuffle, _getProperty, _numExp, _numWithUnitExp, _isString, _isUndefined, _renderComplexString, _relExp, _setDefaults, _removeLinkedListItem, _forEachName, _sortPropTweensByPriority, _colorStringFilter, _replaceRandom, _checkPlugin, _plugins, _ticker, _config, _roundModifier, _round, _missingPlugin, _getSetter, _getCache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GSCache", function() { return GSCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return Animation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timeline", function() { return Timeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tween", function() { return Tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropTween", function() { return PropTween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gsap", function() { return gsap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return Power0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return Power1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return Power2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return Power3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return Power4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return Linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quad", function() { return Quad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubic", function() { return Cubic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quart", function() { return Quart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quint", function() { return Quint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Strong", function() { return Strong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Elastic", function() { return Elastic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Back", function() { return Back; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return SteppedEase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return Bounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sine", function() { return Sine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Expo", function() { return Expo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circ", function() { return Circ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenMax", function() { return Tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return Tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return Timeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return Timeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return gsap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return wrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapYoyo", function() { return wrapYoyo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distribute", function() { return distribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "snap", function() { return snap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUnit", function() { return getUnit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitColor", function() { return splitColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapRange", function() { return mapRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return pipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unitize", function() { return unitize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return interpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getProperty", function() { return _getProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_numExp", function() { return _numExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_numWithUnitExp", function() { return _numWithUnitExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isString", function() { return _isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isUndefined", function() { return _isUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_renderComplexString", function() { return _renderComplexString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_relExp", function() { return _relExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_setDefaults", function() { return _setDefaults; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_removeLinkedListItem", function() { return _removeLinkedListItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_forEachName", function() { return _forEachName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_sortPropTweensByPriority", function() { return _sortPropTweensByPriority; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_colorStringFilter", function() { return _colorStringFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_replaceRandom", function() { return _replaceRandom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_checkPlugin", function() { return _checkPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_plugins", function() { return _plugins; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ticker", function() { return _ticker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_config", function() { return _config; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_roundModifier", function() { return _roundModifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_round", function() { return _round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_missingPlugin", function() { return _missingPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getSetter", function() { return _getSetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getCache", function() { return _getCache; });
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/*!
 * GSAP 3.2.6
 * https://greensock.com
 *
 * @license Copyright 2008-2020, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_parenthesesExp = /\(([^()]+)\)/i,
    //finds the string between parentheses.
_relExp = /[+-]=-?[\.\d]+/,
    _delimitedValueExp = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;

  if (!_isObject(target) && !_isFunction(target)) {
    targets = [targets];
  }

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property) {
  var currentValue = target[property];
  return _isFunction(currentValue) ? target[property]() : _isUndefined(currentValue) && target.getAttribute(property) || currentValue;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _parseVars = function _parseVars(params, type, parent) {
  //reads the arguments passed to one of the key methods and figures out if the user is defining things with the OLD/legacy syntax where the duration is the 2nd parameter, and then it adjusts things accordingly and spits back the corrected vars object (with the duration added if necessary, as well as runBackwards or startAt or immediateRender). type 0 = to()/staggerTo(), 1 = from()/staggerFrom(), 2 = fromTo()/staggerFromTo()
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars;

  if (isLegacy) {
    vars.duration = params[1];
  }

  vars.parent = parent;

  if (type) {
    irVars = vars;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);

    if (type < 2) {
      vars.runBackwards = 1;
    } else {
      vars.startAt = params[varsIndex - 1]; // "from" vars
    }
  }

  return vars;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];

    if (tween && tween._lazy) {
      tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0;
    }
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  if (_lazyTweens.length) {
    _lazyRender();
  }

  animation.render(time, suppressEvents, force);

  if (_lazyTweens.length) {
    //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
    _lazyRender();
  }
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    if (!(p in obj)) {
      obj[p] = defaults[p];
    }
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(obj, defaults) {
  for (var p in defaults) {
    if (!(p in obj) && p !== "duration" && p !== "ease") {
      obj[p] = defaults[p];
    }
  }
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p];
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    if (!(p in excluding)) {
      copy[p] = obj[p];
    }
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  if (child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren)) {
    child.parent.remove(child);
  }

  child._act = 0;
},
    _uncache = function _uncache(animation) {
  var a = animation;

  while (a) {
    a._dirty = 1;
    a = a.parent;
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  return (tTime /= cycleDuration) && ~~tTime === tTime ? ~~tTime - 1 : ~~tTime;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _round(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || child._initted && !child._dur) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _round(position + child._delay);
  child._end = _round(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  timeline._recent = child;
  skipChecks || _postAddChecks(timeline, child);
  return timeline;
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween._zTime < 0 ? 0 : 1,
      ratio = totalTime < 0 ? 0 : 1,
      repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    //in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    prevIteration = _animationCycle(tween._tTime, repeatDelay);

    if (iteration !== prevIteration) {
      prevRatio = 1 - ratio;

      if (tween.vars.repeatRefresh && tween._initted) {
        tween.invalidate();
      }
    }
  }

  if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
    //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
    return;
  }

  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    tween.ratio = ratio;

    if (tween._from) {
      ratio = 1 - ratio;
    }

    tween._time = 0;
    tween._tTime = tTime;
    suppressEvents || _callback(tween, "onStart");
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    if (!ratio && tween._startAt && !tween._onUpdate && tween._start) {
      //if the tween is positioned at the VERY beginning (_start 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
      tween._startAt.render(totalTime, true, force);
    }

    tween._onUpdate && (suppressEvents || _callback(tween, "onUpdate"));

    if (tTime && tween._repeat && !suppressEvents && tween.parent) {
      _callback(tween, "onRepeat");
    }

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      tween.ratio && _removeFromParent(tween, 1);

      if (!suppressEvents) {
        _callback(tween, tween.ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (!child._dur && child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (!child._dur && child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache) {
  var repeat = animation._repeat,
      dur = _round(duration) || 0;
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e12 : _round(dur * (repeat + 1) + animation._rDelay * repeat);

  if (animation._time > dur) {
    animation._time = dur;
    animation._tTime = Math.min(animation._tTime, animation._tDur);
  }

  !skipUncache && _uncache(animation.parent);
  animation.parent && _setEnd(animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    i = position.charAt(0);

    if (i === "<" || i === ">") {
      return (i === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0);
    }

    i = position.indexOf("=");

    if (i < 0) {
      if (!(position in labels)) {
        labels[position] = clippedDuration;
      }

      return labels[position];
    }

    offset = +(position.charAt(i - 1) + position.substr(i + 1));
    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1)) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value) {
  return (value + "").substr((parseFloat(value) + "").length);
},
    clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, leaveStrings) {
  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call(_doc.querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = ~~(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);

        if (d > max) {
          max = d;
        }

        if (d < min) {
          min = d;
        }
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _round(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()

  return function (raw) {
    return ~~(Math.round(parseFloat(raw) / v) * v * p) / p + (_isNumber(raw) ? 0 : getUnit(raw));
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && ~~(Math.round((min + Math.random() * (max - min)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + (value - inMin) / inRange * outRange;
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      params,
      scope;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  return params ? callback.apply(scope, params) : callback.call(scope);
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  if (animation.progress() < 1) {
    _callback(animation, "onInterrupt");
  }

  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  if (config.register) {
    config.register(gsap, Plugin, PropTween);
  }
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    _hue = function _hue(h, m1, m2) {
  h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length === 4) {
        //for shorthand like #9F0
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b;
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;

        if (a.length > 3) {
          a[3] *= 1; //cast as number
        }

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch;

    if (elapsed > _lagThreshold) {
      _startTime += elapsed - _adjustedLag;
    }

    _lastUpdate += elapsed;
    _self.time = (_lastUpdate - _startTime) / 1000;
    overlap = _self.time - _nextTime;

    if (overlap > 0 || manual) {
      _self.frame++;
      _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
      dispatch = 1;
    }

    if (!manual) {
      //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
      _id = _req(_tick);
    }

    if (dispatch) {
      _listeners.forEach(function (l) {
        return l(_self.time, elapsed, _self.frame, v);
      });
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _raf = _win.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1 / (_fps || 240);
      _nextTime = _self.time + _gap;
    },
    add: function add(callback) {
      _listeners.indexOf(callback) < 0 && _listeners.push(callback);

      _wake();
    },
    remove: function remove(callback) {
      var i;
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1);
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _parenthesesExp.exec(name)[1].split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // potential future feature - allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos. Not sure it's worth the kb.
// _propagateYoyoEase = (timeline, isYoyo) => {
// 	let child = timeline._first, ease;
// 	while (child) {
// 		if (child instanceof Timeline) {
// 			_propagateYoyoEase(child, isYoyo);
// 		} else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
// 			if (child.timeline) {
// 				_propagateYoyoEase(child.timeline, isYoyo);
// 			} else {
// 				ease = child._ease;
// 				child._ease = child._yEase;
// 				child._yEase = ease;
// 				child._yoyo = isYoyo;
// 			}
// 		}
// 		child = child._next;
// 	}
// },
_parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation =
/*#__PURE__*/
function () {
  function Animation(vars, time) {
    var parent = vars.parent || _globalTimeline;
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat || 0) {
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1);

    this.data = vars.data;
    _tickerActive || _ticker.wake();
    parent && _addToTimeline(parent, this, time || time === 0 ? time : parent._time, 1);
    vars.reversed && this.reverse();
    vars.paused && this.paused(true);
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this.parent || this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      // if (!parent._dp && parent._time === parent._dur) { // if a root timeline completes...and then a while later one of its children resumes, we must shoot the playhead forward to where it should be raw-wise, otherwise the child will jump to the end. Down side: this assumes it's using the _ticker.time as a reference.
      // 	parent._time = _ticker.time - parent._start;
      // }
      this._start = _round(parent._time - (this._ts > 0 ? _totalTime / this._ts : ((this._dirty ? this.totalDuration() : this._tDur) - _totalTime) / -this._ts));

      _setEnd(this);

      if (!parent._dirty) {
        //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
        _uncache(parent);
      } //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.


      while (parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum) {
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause

      _lazySafeRender(this, _totalTime, suppressEvents);
    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % this._dur || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  };

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    return _recacheAncestors(this.totalTime(_clamp(0, this._tDur, tTime), true));
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && (this._tTime -= _tinyNum) && Math.abs(this._zTime) !== _tinyNum); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detatched parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  } // globalTime(rawTime) {
  // 	let animation = this,
  // 		time = arguments.length ? rawTime : animation.rawTime();
  // 	while (animation) {
  // 		time = animation._start + time / (animation._ts || 1);
  // 		animation = animation.parent;
  // 	}
  // 	return time;
  // }
  ;

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      this._rDelay = value;
      return _onUpdateTotalDuration(this);
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    if (from != null) {
      this.seek(from, suppressEvents);
    }

    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    if (from != null) {
      this.seek(from || this.totalDuration(), suppressEvents);
    }

    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    if (atTime != null) {
      this.seek(atTime, suppressEvents);
    }

    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      if (!!value !== this.reversed()) {
        this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.
      }

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive(hasStarted) {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && (this._initted || !hasStarted) && parent.isActive(hasStarted) && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;

        if (params) {
          vars[type + "Params"] = params;
        }

        if (type === "onUpdate") {
          this._onUpdate = callback;
        }
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline =
/*#__PURE__*/
function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, time) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars, time) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _this.parent && _postAddChecks(_this.parent, _assertThisInitialized(_this));
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    new Tween(targets, _parseVars(arguments, 0, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));
    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    new Tween(targets, _parseVars(arguments, 1, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));
    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    new Tween(targets, _parseVars(arguments, 2, this), _parsePosition(this, _isNumber(fromVars) ? arguments[4] : position));
    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), _parsePosition(this, position));
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = this !== _globalTimeline && totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        if (!dur) {
          prevTime = this._zTime;
        }

        if (totalTime || !suppressEvents) {
          //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.
          this._zTime = totalTime;
        }
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;
        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (time > dur || tDur === tTime) {
          time = dur;
        }

        iteration = ~~(tTime / cycleDuration);

        if (iteration && iteration === tTime / cycleDuration) {
          time = dur;
          iteration--;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);

          if (iteration < prevIteration) {
            rewinding = !rewinding;
          }

          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime, suppressEvents, !dur)._lock = 0;

          if (!suppressEvents && this.parent) {
            _callback(this, "onRepeat");
          }

          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime !== this._time || prevPaused !== !this._ts) {
            return this;
          }

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur + 0.0001 : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.
          //_propagateYoyoEase(this, isYoyo);

        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _round(prevTime), _round(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      if (this._onUpdate && !suppressEvents) {
        _callback(this, "onUpdate", true);
      }

      if (tTime === tDur && tDur >= this.totalDuration() || !tTime && this._ts < 0) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        (totalTime || !dur) && (totalTime && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime)) {
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    if (!_isNumber(position)) {
      position = _parsePosition(this, position);
    }

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return _uncache(this);
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          if (tweens) {
            a.push(child);
          }
        } else {
          if (timelines) {
            a.push(child);
          }

          if (nested) {
            a.push.apply(a, child.getChildren(true, tweens, timelines));
          }
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this.parent && !this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _round(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (!onlyActive || child.isActive(onlyActive === "started"))) {
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  };

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        tween = Tween.to(tl, _setDefaults(vars, {
      ease: "none",
      lazy: false,
      time: endTime,
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();
        var duration = vars.duration || Math.abs((endTime - tl._time) / tl.timeScale());

        if (tween._dur !== duration) {
          _setDuration(tween, duration).render(tween._time, true, true);
        }

        if (_onStart) {
          //in case the user had an onStart in the vars - we don't want to overwrite it.
          _onStart.apply(tween, onStartParams || []);
        }
      }
    }));

    return tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._time = this._tTime = 0;

    if (includeLabels) {
      this.labels = {};
    }

    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        end,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        if (child._dirty) {
          child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.
        }

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e20);
          prevStart = 0;
        }

        end = _setEnd(child);

        if (end > max && child._ts) {
          max = end;
        }

        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : Math.min(_bigNum, max), 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        if (!child) {
          _ticker.sleep();
        }
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
  if (_isFunction(end)) {
    end = end(index || 0, target, targets);
  }

  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      end = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);
    }
  }

  if (parsedStart !== end) {
    if (!isNaN(parsedStart + end)) {
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);

      if (funcParam) {
        pt.fp = funcParam;
      }

      if (modifier) {
        pt.modifier(modifier, this, target);
      }

      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  if (_isFunction(vars)) {
    vars = _parseFuncOrString(vars, tween, index, target, targets);
  }

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto",
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars;

  if (tl && (!keyframes || !ease)) {
    ease = "none";
  }

  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  if (!tl) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    if (prevStartAt) {
      prevStartAt.render(-1, true).kill();
    }

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      if (immediateRender) {
        if (time > 0) {
          !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
        } else if (dur) {
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (prevStartAt) {
        !autoRevert && (tween._startAt = 0);
      } else {
        if (time) {
          //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
          immediateRender = false;
        }

        _removeFromParent(tween._startAt = Tween.set(targets, _merge(_copyExcluding(vars, _reservedProps), {
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

        })));

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    cleanVars = _copyExcluding(vars, _reservedProps);
    tween._pt = 0;
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};

      if (_lazyLookup[gsData.id]) {
        _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      }

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        if (plugin.priority) {
          hasPriority = 1;
        }
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            if (plugin.priority) {
              hasPriority = 1;
            }
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      if (tween._op && tween._op[i]) {
        tween.kill(target, tween._op[i]);
      }

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, "started"); //Also make sure the overwriting doesn't overwrite THIS tween!!!


        _overwritingTween = 0;
      }

      if (tween._pt && lazy) {
        _lazyLookup[gsData.id] = 1;
      }
    }

    if (hasPriority) {
      _sortPropTweensByPriority(tween);
    }

    if (tween._onInit) {
      //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
      tween._onInit(tween);
    }
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  tween._onUpdate = onUpdate;
  tween._initted = 1;
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
    _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused").split(",");
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween =
/*#__PURE__*/
function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, time, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      time.duration = vars;
      vars = time;
      time = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars), time) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        parent = _this3.parent,
        parsedTargets = (_isArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = _assertThisInitialized(_this3);

      if (keyframes) {
        _setDefaults(tl.vars.defaults, {
          ease: "none"
        });

        keyframes.forEach(function (frame) {
          return tl.to(parsedTargets, frame, ">");
        });
      } else {
        l = parsedTargets.length;
        staggerFunc = stagger ? distribute(stagger) : _emptyFunc;

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              if (!staggerVarsToMerge) {
                staggerVarsToMerge = {};
              }

              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = {};

          for (p in vars) {
            if (_staggerPropsToSkip.indexOf(p) < 0) {
              copy[p] = vars[p];
            }
          }

          copy.stagger = 0;

          if (staggerVarsToMerge) {
            _merge(copy, staggerVarsToMerge);
          }

          if (vars.yoyoEase && !vars.repeat) {
            //so that propagation works properly when a ancestor timeline yoyos
            copy.yoyoEase = vars.yoyoEase;
          }

          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));
        }

        duration = delay = 0;
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    parent && _postAddChecks(parent, _assertThisInitialized(_this3));

    if (immediateRender || !duration && !keyframes && _this3._start === parent._time && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay)); //in case delay is negative

    }

    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || this._startAt && this._zTime < 0 !== totalTime < 0) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;
        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (time > dur || tDur === tTime) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          time = dur;
        }

        iteration = ~~(tTime / cycleDuration);

        if (iteration && iteration === tTime / cycleDuration) {
          time = dur;
          iteration--;
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          return this;
        }

        if (iteration !== prevIteration) {
          //timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
          //repeatRefresh functionality
          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(cycleDuration * iteration, true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, time, force, suppressEvents)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        if (totalTime < 0 && this._startAt) {
          this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        }

        _callback(this, "onUpdate");
      }

      if (this._repeat) if (iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent) {
        _callback(this, "onRepeat");
      }

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        if (totalTime < 0 && this._startAt && !this._onUpdate) {
          this._startAt.render(totalTime, true, force);
        }

        (totalTime || !dur) && (totalTime && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && !(tTime < tDur && this.timeScale() > 0)) {
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate();
    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = 0;

      if (this.parent) {
        return _interrupt(this);
      }
    }

    if (this.timeline) {
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true);
      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    if (this._initted && !this._pt && firstPT) {
      //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
      _interrupt(this);
    }

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return new Tween(targets, _parseVars(arguments, 1));
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return new Tween(targets, _parseVars(arguments, 2));
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property) {
      pt.modifier(modifier, tween, target);
    }

    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween =
/*#__PURE__*/
function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    if (_isString(target)) {
      //in case selector text or an array is passed in
      target = toArray(target)[0];
    }

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    if (unit === "native") {
      unit = "";
    }

    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, property);

    return Plugin ? setter : function (value) {
      return setter(target, property, unit ? value + unit : value, cache, 1);
    };
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    if (value && value.ease) {
      value.ease = _parseEase(value.ease, _defaults.ease);
    }

    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref) {
    var name = _ref.name,
        effect = _ref.effect,
        plugins = _ref.plugins,
        defaults = _ref.defaults,
        extendTimeline = _ref.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    for (var p in vars) {
      this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p); //this.add(target, "setAttribute", (target.getAttribute((p in target.dataset ? (p = "data-" + p) : p)) || 0) + "", vars[p], index, targets, 0, 0, p);

      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.2.6";
_coreReady = 1;

if (_windowExists()) {
  _wake();
}

var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;

 //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.



/***/ }),

/***/ "./node_modules/gsap/index.js":
/*!************************************!*\
  !*** ./node_modules/gsap/index.js ***!
  \************************************/
/*! exports provided: gsap, default, CSSPlugin, TweenMax, TweenLite, TimelineMax, TimelineLite, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gsap", function() { return gsapWithCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return gsapWithCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenMax", function() { return TweenMaxWithCSS; });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TimelineMax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TimelineLite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power0"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Linear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quad", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubic", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Cubic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quart", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quart"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quint", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quint"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Strong", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Strong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Elastic", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Elastic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Back", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Back"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["SteppedEase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Bounce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sine", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Sine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Expo", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Expo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Circ", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Circ"]; });

/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./node_modules/gsap/CSSPlugin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["CSSPlugin"]; });



var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["CSSPlugin"]) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"],
    // to protect from tree shaking
TweenMaxWithCSS = gsapWithCSS.core.Tween;


/***/ }),

/***/ "./node_modules/hex-rgb/index.js":
/*!***************************************!*\
  !*** ./node_modules/hex-rgb/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const hexCharacters = 'a-f\\d';
const match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;
const match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;
const nonHexChars = new RegExp(`[^#${hexCharacters}]`, 'gi');
const validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, 'i');

module.exports = (hex, options = {}) => {
	if (typeof hex !== 'string' || nonHexChars.test(hex) || !validHexSize.test(hex)) {
		throw new TypeError('Expected a valid hex string');
	}

	hex = hex.replace(/^#/, '');
	let alpha = 1;

	if (hex.length === 8) {
		alpha = parseInt(hex.slice(6, 8), 16) / 255;
		hex = hex.slice(0, 6);
	}

	if (hex.length === 4) {
		alpha = parseInt(hex.slice(3, 4).repeat(2), 16) / 255;
		hex = hex.slice(0, 3);
	}

	if (hex.length === 3) {
		hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
	}

	const num = parseInt(hex, 16);
	const red = num >> 16;
	const green = (num >> 8) & 255;
	const blue = num & 255;

	return options.format === 'array' ?
		[red, green, blue, alpha] :
		{red, green, blue, alpha};
};


/***/ }),

/***/ "./node_modules/mini-signals/lib/mini-signals.js":
/*!*******************************************************!*\
  !*** ./node_modules/mini-signals/lib/mini-signals.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var MiniSignalBinding = (function () {
  function MiniSignalBinding(fn, once, thisArg) {
    if (once === undefined) once = false;

    _classCallCheck(this, MiniSignalBinding);

    this._fn = fn;
    this._once = once;
    this._thisArg = thisArg;
    this._next = this._prev = this._owner = null;
  }

  _createClass(MiniSignalBinding, [{
    key: 'detach',
    value: function detach() {
      if (this._owner === null) return false;
      this._owner.detach(this);
      return true;
    }
  }]);

  return MiniSignalBinding;
})();

function _addMiniSignalBinding(self, node) {
  if (!self._head) {
    self._head = node;
    self._tail = node;
  } else {
    self._tail._next = node;
    node._prev = self._tail;
    self._tail = node;
  }

  node._owner = self;

  return node;
}

var MiniSignal = (function () {
  function MiniSignal() {
    _classCallCheck(this, MiniSignal);

    this._head = this._tail = undefined;
  }

  _createClass(MiniSignal, [{
    key: 'handlers',
    value: function handlers() {
      var exists = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      var node = this._head;

      if (exists) return !!node;

      var ee = [];

      while (node) {
        ee.push(node);
        node = node._next;
      }

      return ee;
    }
  }, {
    key: 'has',
    value: function has(node) {
      if (!(node instanceof MiniSignalBinding)) {
        throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.');
      }

      return node._owner === this;
    }
  }, {
    key: 'dispatch',
    value: function dispatch() {
      var node = this._head;

      if (!node) return false;

      while (node) {
        if (node._once) this.detach(node);
        node._fn.apply(node._thisArg, arguments);
        node = node._next;
      }

      return true;
    }
  }, {
    key: 'add',
    value: function add(fn) {
      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      if (typeof fn !== 'function') {
        throw new Error('MiniSignal#add(): First arg must be a Function.');
      }
      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));
    }
  }, {
    key: 'once',
    value: function once(fn) {
      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      if (typeof fn !== 'function') {
        throw new Error('MiniSignal#once(): First arg must be a Function.');
      }
      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));
    }
  }, {
    key: 'detach',
    value: function detach(node) {
      if (!(node instanceof MiniSignalBinding)) {
        throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.');
      }
      if (node._owner !== this) return this;

      if (node._prev) node._prev._next = node._next;
      if (node._next) node._next._prev = node._prev;

      if (node === this._head) {
        this._head = node._next;
        if (node._next === null) {
          this._tail = null;
        }
      } else if (node === this._tail) {
        this._tail = node._prev;
        this._tail._next = null;
      }

      node._owner = null;
      return this;
    }
  }, {
    key: 'detachAll',
    value: function detachAll() {
      var node = this._head;
      if (!node) return this;

      this._head = this._tail = null;

      while (node) {
        node._owner = null;
        node = node._next;
      }
      return this;
    }
  }]);

  return MiniSignal;
})();

MiniSignal.MiniSignalBinding = MiniSignalBinding;

exports['default'] = MiniSignal;
module.exports = exports['default'];


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/events/events.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/events/events.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "./node_modules/parse-dds/index.js":
/*!*****************************************!*\
  !*** ./node_modules/parse-dds/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// All values and structures referenced from:
// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
//
// DX10 Cubemap support based on
// https://github.com/dariomanesku/cmft/issues/7#issuecomment-69516844
// https://msdn.microsoft.com/en-us/library/windows/desktop/bb943983(v=vs.85).aspx
// https://github.com/playcanvas/engine/blob/master/src/resources/resources_texture.js

var DDS_MAGIC = 0x20534444
var DDSD_MIPMAPCOUNT = 0x20000
var DDPF_FOURCC = 0x4

var FOURCC_DXT1 = fourCCToInt32('DXT1')
var FOURCC_DXT3 = fourCCToInt32('DXT3')
var FOURCC_DXT5 = fourCCToInt32('DXT5')
var FOURCC_DX10 = fourCCToInt32('DX10')
var FOURCC_FP32F = 116 // DXGI_FORMAT_R32G32B32A32_FLOAT

var DDSCAPS2_CUBEMAP = 0x200
var D3D10_RESOURCE_DIMENSION_TEXTURE2D = 3
var DXGI_FORMAT_R32G32B32A32_FLOAT = 2

// The header length in 32 bit ints
var headerLengthInt = 31

// Offsets into the header array
var off_magic = 0
var off_size = 1
var off_flags = 2
var off_height = 3
var off_width = 4
var off_mipmapCount = 7
var off_pfFlags = 20
var off_pfFourCC = 21
var off_caps2 = 28

module.exports = parseHeaders

function parseHeaders (arrayBuffer) {
  var header = new Int32Array(arrayBuffer, 0, headerLengthInt)

  if (header[off_magic] !== DDS_MAGIC) {
    throw new Error('Invalid magic number in DDS header')
  }

  if (!header[off_pfFlags] & DDPF_FOURCC) {
    throw new Error('Unsupported format, must contain a FourCC code')
  }

  var blockBytes
  var format
  var fourCC = header[off_pfFourCC]
  switch (fourCC) {
    case FOURCC_DXT1:
      blockBytes = 8
      format = 'dxt1'
      break
    case FOURCC_DXT3:
      blockBytes = 16
      format = 'dxt3'
      break
    case FOURCC_DXT5:
      blockBytes = 16
      format = 'dxt5'
      break
    case FOURCC_FP32F:
      format = 'rgba32f'
      break
    case FOURCC_DX10:
      var dx10Header = new Uint32Array(arrayBuffer.slice(128, 128 + 20))
      format = dx10Header[0]
      var resourceDimension = dx10Header[1]
      var miscFlag = dx10Header[2]
      var arraySize = dx10Header[3]
      var miscFlags2 = dx10Header[4]

      if (resourceDimension === D3D10_RESOURCE_DIMENSION_TEXTURE2D && format === DXGI_FORMAT_R32G32B32A32_FLOAT) {
        format = 'rgba32f'
      } else {
        throw new Error('Unsupported DX10 texture format ' + format)
      }
      break
    default:
      throw new Error('Unsupported FourCC code: ' + int32ToFourCC(fourCC))
  }

  var flags = header[off_flags]
  var mipmapCount = 1

  if (flags & DDSD_MIPMAPCOUNT) {
    mipmapCount = Math.max(1, header[off_mipmapCount])
  }

  var cubemap = false
  var caps2 = header[off_caps2]
  if (caps2 & DDSCAPS2_CUBEMAP) {
    cubemap = true
  }

  var width = header[off_width]
  var height = header[off_height]
  var dataOffset = header[off_size] + 4
  var texWidth = width
  var texHeight = height
  var images = []
  var dataLength

  if (fourCC === FOURCC_DX10) {
    dataOffset += 20
  }

  if (cubemap) {
    for (var f = 0; f < 6; f++) {
      if (format !== 'rgba32f') {
        throw new Error('Only RGBA32f cubemaps are supported')
      }
      var bpp = 4 * 32 / 8

      width = texWidth
      height = texHeight

      // cubemap should have all mipmap levels defined
      // Math.log2(width) + 1
      var requiredMipLevels = Math.log(width) / Math.log(2) + 1

      for (var i = 0; i < requiredMipLevels; i++) {
        dataLength = width * height * bpp
        images.push({
          offset: dataOffset,
          length: dataLength,
          shape: [ width, height ]
        })
        // Reuse data from the previous level if we are beyond mipmapCount
        // This is hack for CMFT not publishing full mipmap chain https://github.com/dariomanesku/cmft/issues/10
        if (i < mipmapCount) {
          dataOffset += dataLength
        }
        width = Math.floor(width / 2)
        height = Math.floor(height / 2)
      }
    }
  } else {
    for (var i = 0; i < mipmapCount; i++) {
      dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes

      images.push({
        offset: dataOffset,
        length: dataLength,
        shape: [ width, height ]
      })
      dataOffset += dataLength
      width = Math.floor(width / 2)
      height = Math.floor(height / 2)
    }
  }

  return {
    shape: [ texWidth, texHeight ],
    images: images,
    format: format,
    flags: flags,
    cubemap: cubemap
  }
}

function fourCCToInt32 (value) {
  return value.charCodeAt(0) +
    (value.charCodeAt(1) << 8) +
    (value.charCodeAt(2) << 16) +
    (value.charCodeAt(3) << 24)
}

function int32ToFourCC (value) {
  return String.fromCharCode(
    value & 0xff,
    (value >> 8) & 0xff,
    (value >> 16) & 0xff,
    (value >> 24) & 0xff
  )
}


/***/ }),

/***/ "./node_modules/punycode/punycode.js":
/*!*******************************************!*\
  !*** ./node_modules/punycode/punycode.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "./node_modules/querystringparser/js/querystringparser.js":
/*!****************************************************************!*\
  !*** ./node_modules/querystringparser/js/querystringparser.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var QueryStringSerializer = __webpack_require__(/*! ./querystringserializer.js */ "./node_modules/querystringparser/js/querystringserializer.js");
module.exports = QueryStringParser;

var rplus = /\+/g;
var rint = /^[0-9]+$/;
var isArray = Array.isArray;
var haveProp = {}.hasOwnProperty;

function QueryStringParser() {
    this.containsSparse = false;
    this.cacheKey = "";
    this.cacheVal = null;
}

QueryStringParser.maxLength = 32768;
QueryStringParser.maxDepth = 4;
QueryStringParser.maxKeys = 256;

QueryStringParser.parse = function QueryStringParser$Parse(str) {
    if (typeof str === "string") {
        var maxLength = QueryStringParser.maxLength;
        if (str.length > maxLength) {
            throw new RangeError(
                "str is too large (" +
                "QueryStringParser.maxLength=" + maxLength + ")"
            );
        }
        var parser = new QueryStringParser();
        return parser.parseString(str, false);
    }
    else if (str !== null && typeof str === "object") {
        var parser = new QueryStringParser();
        return parser.parseObject(str);
    }
    return {};
};

QueryStringParser.stringify =
function QueryStringParser$Stringify(value) {
    var serializer = new QueryStringSerializer();
    return serializer.serialize(value);
};

QueryStringParser.prototype.decode =
function QueryStringParser$decode(str, shouldDecode, containsPlus) {
    if (shouldDecode === false) return str;
    if (containsPlus === true) str = str.replace(rplus, " ");
    try {
        return decodeURIComponent(str);
    }
    catch (e) {
        return str;
    }
};

QueryStringParser.prototype.maybeArrayIndex =
function QueryStringParser$maybeArrayIndex(str, arrayLength) {
    var len = str.length;
    if (len === 0) {
        return arrayLength;
    }
    var ch = str.charCodeAt(0);

    if (ch === 48) {
        return len > 1 ? -1 : 0;
    }
    else if (48 <= ch && ch <= 57) {
        if (len === 1) {
            return ch - 48;
        }
        else if (rint.test(str)) {
            var v = parseInt(str, 10);
            if (0 < v && v <= 1073741822) {
                return v;
            }
        }
    }
    return -1;
};

QueryStringParser.prototype.getSlot =
function QueryStringParser$getSlot(dictionary, prevKey, curKey) {
    var slot;
    if (!(haveProp.call(dictionary, prevKey))) {
        var index = this.maybeArrayIndex(curKey, 0);
        if (index > -1) {
            slot = [];
        }
        else {
            slot = {};
        }
        dictionary[prevKey] = slot;
    }
    else {
        slot = dictionary[prevKey];
    }
    return slot;
};

QueryStringParser.prototype.placeNestedValue =
function QueryStringParser$placeNestedValue
(dictionary, key, value, i, prevKey, curKey) {
    var slot = this.getSlot(dictionary, prevKey, curKey);
    var index = -1;

    if (isArray(slot)) {
        index = this.maybeArrayIndex(curKey, slot.length);
    }

    var len = key.length;
    var depth = 2;
    var maxDepth = QueryStringParser.maxDepth;
    var start = -1;
    for (; i < len; ++i) {
        var ch = key.charCodeAt(i);
        if (ch === 91) {
            start = i + 1;
        }
        else if (ch === 93 &&
                start > -1) {
            prevKey = curKey;
            curKey = start === i ? "" : key.substring(start, i);
            start = -1;
            depth++;
            if (depth > maxDepth) {
                throw new RangeError("Nesting depth of keys is too large " +
                    "(QueryStringParser.maxDepth="+maxDepth+")" );
            }
            slot = this.getSlot(slot, prevKey, curKey);

            index = isArray(slot)
                ? this.maybeArrayIndex(curKey, slot.length)
                : -1;
        }
    }

    if(index > -1) {
        if (value !== "") {
            if (index === slot.length) {
                slot.push(value);
            }
            else {
                this.containsSparse = true;
                slot[index] = value;
            }
        }
    }
    else {
        this.insert(slot, curKey, value);
    }
};

QueryStringParser.prototype.insert =
function QueryStringParser$insert(dictionary, key, value) {
    var ret = null;
    if (haveProp.call(dictionary, key)) {
        var prev = dictionary[key];
        if( isArray(prev) ) {
            prev.push(value);
            ret = prev;
        }
        else {
            ret = [prev, value];
            dictionary[key] = ret;
        }
    }
    else {
        dictionary[key] = value;
    }
    return ret;
};

QueryStringParser.prototype.push =
function QueryStringParser$push(dictionary, key, value) {
    var ret = null;
    if (haveProp.call(dictionary, key)) {
        var prev = dictionary[key];
        prev.push(value);
        ret = prev;
    }
    else {
        ret = [value];
        dictionary[key] = ret;
    }
    return ret;
};

QueryStringParser.prototype.maybePlaceNestedValue =
function QueryStringParser$maybePlaceNestedValue(dictionary, key, value) {
    var len = key.length;
    if (key.charCodeAt(len - 1) !== 93) {
        this.placeValue(dictionary, key, value, false);
        return;
    }
    var start = -1;

    var i = 0;
    var curKey;
    var prevKey;

    for (; i < len; ++i) {
        var ch = key.charCodeAt(i);

        if (ch === 91) {
            start = i + 1;
            prevKey = key.slice(0, i);
        }
        else if (ch === 93) {
            if (start < 0) {
                this.placeValue(dictionary, key, value, false);
                return;
            }
            curKey = start === i ? "" : key.slice(start, i);
            i++;
            break;
        }
    }

    if (curKey === void 0) {
        this.placeValue(dictionary, key, value, false);
        return;
    }

    if (curKey === "" && value !== "" && i === len) {
        if (key === this.cacheKey) {
            this.cacheVal.push(value);
        }
        else {
            this.cacheKey = key;
            this.cacheVal = this.push(dictionary, prevKey, value);
        }
    }
    else {
        this.placeNestedValue(dictionary, key, value, i, prevKey, curKey);
    }
};

QueryStringParser.prototype.placeValue =
function QueryStringParser$placeValue(dictionary, key, value, possiblyNested) {
    if (possiblyNested === true) {
        this.maybePlaceNestedValue(dictionary, key, value);
        return;
    }
    if (key === this.cacheKey) {
        this.cacheVal.push(value);
        return;
    }
    var cache = this.insert(dictionary, key, value);
    if (cache !== null) {
        this.cacheKey = key;
        this.cacheVal = cache;
    }
};

QueryStringParser.prototype.compact =
function QueryStringParser$compact(obj) {
    if (isArray(obj)) {
        var ret = [];
        var keys = Object.keys(obj);
        for( var i = 0, len = keys.length; i < len; ++i ) {
            ret.push(obj[keys[i]]);
        }
        return ret;
    }
    else if (typeof obj === "object") {
        var keys = Object.keys(obj);
        for( var i = 0, len = keys.length; i < len; ++i ) {
            var key = keys[i];
            obj[key] = this.compact(obj[key]);
        }
    }
    else {
        return obj;
    }
};

QueryStringParser.prototype.parseObject =
function QueryStringParser$parseObject(obj) {
    var keys = Object.keys(obj);
    var len = keys.length;
    if (len === 0) {
        return {};
    }
    len--;
    var ret = "";
    var key;
    for( var i = 0; i < len; ++i ) {
        key = keys[i];
        ret += key + "=" + obj[key] + "&";
    }
    key = keys[i];
    ret += key + "=" + obj[key];
    return this.parseString(ret, true);
};

QueryStringParser.prototype.parseString =
function QueryStringParser$parseString(str, noDecode) {
    var maxKeys = QueryStringParser.maxKeys;
    var keys = 0;
    var decodeKey = false;
    var decodeValue = false;
    var possiblyNested = false;
    var len = str.length;
    var i = 0;
    var dictionary = {};
    var keyStart = 0;
    var keyEnd = 0;
    var valueStart = 0;
    var valueEnd = 0;
    var left = 0;
    var lastIndex = len - 1;
    var containsPlus = false;


    for (; i < len; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 91) {
            left++;
        }
        else if (left > 0 && ch === 93) {
            possiblyNested = true;
            left--;
        }
        else if (left === 0 && ch === 61) {
            var j = i + 1;

            keyEnd = i - 1;
            valueEnd = valueStart = j;
            var key = str.slice(keyStart, keyEnd + 1);
            key = this.decode(key, decodeKey, containsPlus);
            decodeKey = false;

            for (; j < len; ++j) {
                ch = str.charCodeAt(j);
                if ((ch === 43 || ch === 37) && !noDecode) {
                    if (ch === 43) containsPlus = true;
                    decodeValue = true;
                }
                if (ch === 38 || j === lastIndex) {
                    valueEnd = j;
                    i = j;

                    if (ch === 38) {
                        valueEnd--;
                    }

                    var value = str.slice(valueStart, valueEnd + 1);
                    value = this.decode(value, decodeValue, containsPlus);

                    this.placeValue(dictionary, key, value, possiblyNested);

                    containsPlus = decodeValue = false;
                    possiblyNested = false;

                    keyStart = j + 1;
                    keys++;
                    if (keys > maxKeys) {
                        throw new RangeError("Amount of keys is too large " +
                            "(QueryStringParser.maxKeys=" + maxKeys + ")");
                    }
                    break;
                }
            }
        }
        else if ((ch === 43 || ch === 37) && !noDecode) {
            if (ch === 43) containsPlus = true;
            decodeKey = true;
        }
    }
    if (keyStart !== len) {
        var value = "";
        var key = str.slice(keyStart, len);
        key = this.decode(key, decodeKey, containsPlus);
        this.placeValue(dictionary, key, value, possiblyNested);
    }


    if (this.containsSparse) {
        this.compact(dictionary);
    }

    return dictionary;
};


/***/ }),

/***/ "./node_modules/querystringparser/js/querystringserializer.js":
/*!********************************************************************!*\
  !*** ./node_modules/querystringparser/js/querystringserializer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

module.exports = QueryStringSerializer;
var enc = encodeURIComponent;
var ARRAY = [];
var isArray = Array.isArray;
var getProto = Object.getPrototypeOf;
var oProto = getProto({});

function isObject(obj) {
    if (isArray(obj)) {
        return true;
    }
    if (obj === null || typeof obj !== "object") {
        return false;
    }
    var proto = getProto(obj);

    return proto === oProto || proto === null;
}

function QueryStringSerializer() {

}

QueryStringSerializer.prototype.serialize =
function QueryStringSerializer$serialize(obj) {
    if (obj === null ||
        typeof obj !== "object") {
        throw new TypeError("the obj to stringify must be an object");
    }
    var keys = Object.keys(obj);
    var len = keys.length;
    var array = ARRAY;
    var stack = [];
    var ret = [];
    var cur = obj;
    var keyPrefix = "";

    for (var i = 0; i < len; ++i) {
        var key = keys === array ? i : keys[i];
        var value = cur[key];
        if (isObject(value)) {
            stack.push(keyPrefix, cur, keys, len, i);

            if (keyPrefix === "") {
                keyPrefix = key;
            }
            else {
                keyPrefix = keyPrefix + "[" + enc(key) + "]";
            }

            if (isArray(value)) {
                keys = array;
                len = value.length;
            }
            else {
                keys = Object.keys(value);
                len = keys.length;
            }
            i = -1;
            cur = value;
        }
        else {
            if (typeof value !== "string") {
                value = "" + value;
            }

            var serializedKey = keyPrefix === ""
                                ? enc(key)
                                : keyPrefix + "[" + enc(key) + "]";
            ret.push(serializedKey + "=" + enc(value));
        }

        if(i === len - 1 && stack.length > 0) {
            i = stack.pop();
            len = stack.pop();
            keys = stack.pop();
            cur = stack.pop();
            keyPrefix = stack.pop();
        }
    }

    return ret.join("&");
};


/***/ }),

/***/ "./node_modules/scheduling/src/scheduler.js":
/*!**************************************************!*\
  !*** ./node_modules/scheduling/src/scheduler.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Scheduler.js
const FRAMERATE = 60;

class Scheduler {

	constructor() {
		this._delayTasks = [];
		this._nextTasks = [];
		this._deferTasks = [];
		this._highTasks = [];
		this._usurpTask = [];
		this._enterframeTasks = [];
		this._idTable = 0;

		this._startTime = new Date().getTime();

		this._deltaTime = 0;
		this._internalTime = 0;
		this._isPaused = false;


		this._loop();
	}


	//  PUBLIC METHODS

	addEF(func, params) {
		params = params || [];
		const id = this._idTable;
		this._enterframeTasks[id] = { func, params };
		this._idTable ++;
		return id;
	}

	removeEF(id) {
		if (this._enterframeTasks[id] !== undefined) {
			this._enterframeTasks[id] = null;
		}
		return -1;
	}

	delay(func, params, delay) {
		const time = new Date().getTime();
		const t = { func, params, delay, time };
		this._delayTasks.push(t);
	}

	defer(func, params) {
		const t = { func, params };
		this._deferTasks.push(t);
	}

	next(func, params) {
		const t = { func, params };
		this._nextTasks.push(t);
	}

	usurp(func, params) {
		const t = { func, params };
		this._usurpTask.push(t);
	}


	pause() {
		this._isPaused = true;
	}


	advance() {
		this._internalTime += 1 / FRAMERATE;
	}


	resume() {
		this._isPaused = false;
	}

	//  PRIVATE METHODS

	_process() {
		let i = 0;
		let task;
		let interval;
		let current;
		for (i = 0; i < this._enterframeTasks.length; i++) {
			task = this._enterframeTasks[i];
			if (task !== null && task !== undefined) {
				task.func(task.params);
			}
		}

		while (this._highTasks.length > 0) {
			task = this._highTasks.pop();
			task.func(task.params);
		}


		let startTime = new Date().getTime();
		let _startTime = this._deltaTime;
		this._deltaTime = (startTime - this._startTime)/1000;

		for (i = 0; i < this._delayTasks.length; i++) {
			task = this._delayTasks[i];
			if (startTime - task.time > task.delay) {
				task.func(task.params);
				this._delayTasks.splice(i, 1);
			}
		}

		startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;
		interval = 1000 / FRAMERATE;
		while (this._deferTasks.length > 0) {
			task = this._deferTasks.shift();
			current = new Date().getTime();
			if (current - startTime < interval) {
				task.func(task.params);
			} else {
				this._deferTasks.unshift(task);
				break;
			}
		}


		startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;
		interval = 1000 / FRAMERATE;
		while (this._usurpTask.length > 0) {
			task = this._usurpTask.shift();
			current = new Date().getTime();
			if (current - startTime < interval) {
				task.func(task.params);
			}
		}

		this._highTasks = this._highTasks.concat(this._nextTasks);
		this._nextTasks = [];
		this._usurpTask = [];

		if(!this._isPaused) {
			this._internalTime += this._deltaTime - _startTime;
		}
	}


	_loop() {
		this._process();
		window.requestAnimationFrame(() => this._loop());
	}

	get intervalTime() {
		return this._internalTime;
	}

	get deltaTime() {
		return this._deltaTime;
	}
}

const scheduler = new Scheduler();

/* harmony default export */ __webpack_exports__["default"] = (scheduler);


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/js/Assets.js":
/*!**************************!*\
  !*** ./src/js/Assets.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
// Assets.js

const Assets = {};
let _assets = [];
let assets;
let textures = [];

const getAsset = function (id) {
  return assets.find(a => a.id === id).file;
};

const getExtension = function (mFile) {
  const ary = mFile.split('.');
  return ary[ary.length - 1];
};

Assets.init = function (mAssets, assetsToLoad) {
  assets = mAssets;
  let hdrCubemaps = {};
  _assets = assetsToLoad.map(o => {
    const ext = getExtension(o.url);
    const file = getAsset(o.id);
    let texture;

    switch (ext) {
      case 'jpg':
      case 'png':
        texture = new alfrid__WEBPACK_IMPORTED_MODULE_0__["GLTexture"](file);
        textures.push(texture);
        return {
          id: o.id,
          file: texture
        };
        break;

      case 'hdr':
        let cubemapName = o.id.split('_')[0];
        texture = alfrid__WEBPACK_IMPORTED_MODULE_0__["default"].HDRLoader.parse(file);
        const oAsset = {
          id: o.id,
          file: texture
        };

        if (!hdrCubemaps[cubemapName]) {
          hdrCubemaps[cubemapName] = [];
        }

        hdrCubemaps[cubemapName].push(oAsset);
        return oAsset;
        break;

      case 'dds':
        texture = alfrid__WEBPACK_IMPORTED_MODULE_0__["GLCubeTexture"].parseDDS(file);
        return {
          id: o.id,
          file: texture
        };
        break;

      case 'obj':
        const mesh = alfrid__WEBPACK_IMPORTED_MODULE_0__["ObjLoader"].parse(file);
        return {
          id: o.id,
          file: mesh
        };
        break;

      default:
        console.log('error with extension', ext);
    }
  });

  for (let s in hdrCubemaps) {
    if (hdrCubemaps[s].length == 6) {
      console.log('Generate Cubemap :', s);
      const ary = [Assets.get(`${s}_posx`), Assets.get(`${s}_negx`), Assets.get(`${s}_posy`), Assets.get(`${s}_negy`), Assets.get(`${s}_posz`), Assets.get(`${s}_negz`)];
      const texture = new alfrid__WEBPACK_IMPORTED_MODULE_0__["default"].GLCubeTexture(ary);

      _assets.push({
        id: s,
        file: texture
      });
    }
  }

  console.log('_assets', _assets);

  if (_assets.length > 0) {
    console.debug('ASSETS:');
    console.table(_assets);
  }
};

Assets.destroy = gl => {
  for (let i = 0; i < textures.length; i++) {
    gl.deleteTexture(textures[i]._texture);
  }

  textures.length = 0;
};

Assets.get = function (mId) {
  return _assets.find(a => {
    return a.id === mId;
  }).file;
};

/* harmony default export */ __webpack_exports__["default"] = (Assets);

/***/ }),

/***/ "./src/js/debug/addDropSupport.js":
/*!****************************************!*\
  !*** ./src/js/debug/addDropSupport.js ***!
  \****************************************/
/*! exports provided: addDropSupport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addDropSupport", function() { return addDropSupport; });
const addDropSupport = mCB => {
  const dropArea = window;

  const preventDefaults = e => {
    e.preventDefault();
    e.stopPropagation();
  };

  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, preventDefaults, false);
  });

  const handleDrop = e => {
    const dt = e.dataTransfer;
    const files = dt.files;
    const file = files[0];
    const reader = new FileReader();
    reader.readAsDataURL(file);

    reader.onloadend = () => {
      const img = document.createElement('img');

      img.onload = () => {
        if (mCB) {
          mCB(img);
        }
      };

      img.src = reader.result;
    };
  };

  dropArea.addEventListener('drop', handleDrop, false);
};

/***/ }),

/***/ "./src/js/debug/debugPolyfill.js":
/*!***************************************!*\
  !*** ./src/js/debug/debugPolyfill.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// debugPolyfill.js
window.gui = {
  add: () => {}
};

/***/ }),

/***/ "./src/js/helpers/BitSwitch.js":
/*!*************************************!*\
  !*** ./src/js/helpers/BitSwitch.js ***!
  \*************************************/
/*! exports provided: BitSwitch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BitSwitch", function() { return BitSwitch; });
class BitSwitch {
  constructor(initValue = 0) {
    this._value = initValue;
  }

  set(mNumDigit, mValue = 1) {
    if (mValue === 0) {
      this._value = this._value & 0 << mNumDigit;
    } else {
      this._value = this._value | 1 << mNumDigit;
    }
  }

  toggle(mNumDigit) {
    this._value = this._value ^ 1 << mNumDigit;
  }

  get(mNumDigit) {
    let value = this._value & 1 << mNumDigit;
    value = value >> mNumDigit;
    return value === 1;
  }

  reset() {
    this._value = 0;
  }

  get value() {
    return this._value;
  }

  log() {
    const s = this._value.toString(2);

    return s;
  }

}



/***/ }),

/***/ "./src/js/helpers/OrbitalControlTween.js":
/*!***********************************************!*\
  !*** ./src/js/helpers/OrbitalControlTween.js ***!
  \***********************************************/
/*! exports provided: orbitalControlTween */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orbitalControlTween", function() { return orbitalControlTween; });
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");


class OrbControlTween {
  constructor() {
    this.orbitalControl = null;
    this.initialised = false;
  }

  init(orbitalControl) {
    this.initialised = true;
    this.orbitalControl = orbitalControl;
  }

  tween(options) {
    const orb = this.orbitalControl;
    const o = {
      radius: orb.radius.value,
      rx: orb.rx.value,
      ry: orb.ry.value,
      centerX: orb.center[0],
      centerY: orb.center[1],
      centerZ: orb.center[2],
      offsetX: orb.positionOffset[0],
      offsetY: orb.positionOffset[1],
      offsetZ: orb.positionOffset[2]
    };
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(o, options.duration || 1, {
      delay: options.delay || 0,
      radius: options.radius || 0,
      rx: options.rx || 0,
      ry: options.ry || 0,
      centerX: options.centerX || 0,
      centerY: options.centerY || 0,
      centerZ: options.centerZ || 0,
      offsetX: options.offsetX || 0,
      offsetY: options.offsetY || 0,
      offsetZ: options.offsetZ || 0,
      ease: options.ease || 'sine.out',
      onUpdate: () => {
        if (options.rx !== undefined) orb.rx.setTo(o.rx);
        if (options.ry !== undefined) orb.ry.setTo(o.ry);
        if (options.radius !== undefined) orb.radius.setTo(o.radius);
        if (options.centerX !== undefined) orb.center[0] = o.centerX;
        if (options.centerY !== undefined) orb.center[1] = o.centerY;
        if (options.centerZ !== undefined) orb.center[2] = o.centerZ;
        if (options.offsetX !== undefined) orb.positionOffset[0] = o.offsetX;
        if (options.offsetY !== undefined) orb.positionOffset[1] = o.offsetY;
        if (options.offsetZ !== undefined) orb.positionOffset[2] = o.offsetZ;
      },
      onComplete: options.onComplete || null
    });
  }

  get isReady() {
    return this.initialised;
  }

}

const orbitalControlTween = new OrbControlTween();


/***/ }),

/***/ "./src/js/helpers/index.js":
/*!*********************************!*\
  !*** ./src/js/helpers/index.js ***!
  \*********************************/
/*! exports provided: OrbitalControlTween, BitSwitch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _OrbitalControlTween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OrbitalControlTween */ "./src/js/helpers/OrbitalControlTween.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OrbitalControlTween", function() { return _OrbitalControlTween__WEBPACK_IMPORTED_MODULE_0__["orbitalControlTween"]; });

/* harmony import */ var _BitSwitch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BitSwitch */ "./src/js/helpers/BitSwitch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BitSwitch", function() { return _BitSwitch__WEBPACK_IMPORTED_MODULE_1__["BitSwitch"]; });




/***/ }),

/***/ "./src/js/libs/alfrid/alfrid.js":
/*!**************************************!*\
  !*** ./src/js/libs/alfrid/alfrid.js ***!
  \**************************************/
/*! exports provided: default, GL, GLShader, GLTexture, GLCubeTexture, Mesh, Geom, Batch, FrameBuffer, CubeFrameBuffer, MultisampleFrameBuffer, TransformFeedbackObject, Scheduler, EventDispatcher, EaseNumber, SpringNumber, TweenNumber, OrbitalControl, WebglNumber, QuatRotation, TouchDetector, Camera, CameraOrtho, CameraPerspective, CameraCube, Ray, Object3D, BinaryLoader, ObjLoader, HDRLoader, GLTFParser, BatchCopy, BatchAxis, BatchBall, BatchDotsPlane, BatchLine, BatchSkybox, BatchSky, Scene, View, View3D, Draw, ShaderLibs, FboArray, FboPingPong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _alfrid_Batch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./alfrid/Batch */ "./src/js/libs/alfrid/alfrid/Batch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Batch", function() { return _alfrid_Batch__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _alfrid_helpers_BatchAxis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./alfrid/helpers/BatchAxis */ "./src/js/libs/alfrid/alfrid/helpers/BatchAxis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchAxis", function() { return _alfrid_helpers_BatchAxis__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _alfrid_helpers_BatchBall__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./alfrid/helpers/BatchBall */ "./src/js/libs/alfrid/alfrid/helpers/BatchBall.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchBall", function() { return _alfrid_helpers_BatchBall__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _alfrid_helpers_BatchCopy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./alfrid/helpers/BatchCopy */ "./src/js/libs/alfrid/alfrid/helpers/BatchCopy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchCopy", function() { return _alfrid_helpers_BatchCopy__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _alfrid_helpers_BatchDotsPlane__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./alfrid/helpers/BatchDotsPlane */ "./src/js/libs/alfrid/alfrid/helpers/BatchDotsPlane.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchDotsPlane", function() { return _alfrid_helpers_BatchDotsPlane__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _alfrid_helpers_BatchLine__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./alfrid/helpers/BatchLine */ "./src/js/libs/alfrid/alfrid/helpers/BatchLine.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchLine", function() { return _alfrid_helpers_BatchLine__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _alfrid_helpers_BatchSky__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./alfrid/helpers/BatchSky */ "./src/js/libs/alfrid/alfrid/helpers/BatchSky.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchSky", function() { return _alfrid_helpers_BatchSky__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _alfrid_helpers_BatchSkybox__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./alfrid/helpers/BatchSkybox */ "./src/js/libs/alfrid/alfrid/helpers/BatchSkybox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchSkybox", function() { return _alfrid_helpers_BatchSkybox__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _alfrid_loaders_BinaryLoader__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./alfrid/loaders/BinaryLoader */ "./src/js/libs/alfrid/alfrid/loaders/BinaryLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BinaryLoader", function() { return _alfrid_loaders_BinaryLoader__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _alfrid_cameras_Camera__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./alfrid/cameras/Camera */ "./src/js/libs/alfrid/alfrid/cameras/Camera.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return _alfrid_cameras_Camera__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _alfrid_cameras_CameraCube__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./alfrid/cameras/CameraCube */ "./src/js/libs/alfrid/alfrid/cameras/CameraCube.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CameraCube", function() { return _alfrid_cameras_CameraCube__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _alfrid_cameras_CameraOrtho__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./alfrid/cameras/CameraOrtho */ "./src/js/libs/alfrid/alfrid/cameras/CameraOrtho.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CameraOrtho", function() { return _alfrid_cameras_CameraOrtho__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _alfrid_cameras_CameraPerspective__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./alfrid/cameras/CameraPerspective */ "./src/js/libs/alfrid/alfrid/cameras/CameraPerspective.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CameraPerspective", function() { return _alfrid_cameras_CameraPerspective__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _alfrid_CubeFrameBuffer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./alfrid/CubeFrameBuffer */ "./src/js/libs/alfrid/alfrid/CubeFrameBuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubeFrameBuffer", function() { return _alfrid_CubeFrameBuffer__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _alfrid_helpers_Draw__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./alfrid/helpers/Draw */ "./src/js/libs/alfrid/alfrid/helpers/Draw.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Draw", function() { return _alfrid_helpers_Draw__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _alfrid_utils_EaseNumber__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./alfrid/utils/EaseNumber */ "./src/js/libs/alfrid/alfrid/utils/EaseNumber.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EaseNumber", function() { return _alfrid_utils_EaseNumber__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _alfrid_utils_EventDispatcher__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./alfrid/utils/EventDispatcher */ "./src/js/libs/alfrid/alfrid/utils/EventDispatcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return _alfrid_utils_EventDispatcher__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _alfrid_FboArray__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./alfrid/FboArray */ "./src/js/libs/alfrid/alfrid/FboArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FboArray", function() { return _alfrid_FboArray__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _alfrid_FboPingPong__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./alfrid/FboPingPong */ "./src/js/libs/alfrid/alfrid/FboPingPong.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FboPingPong", function() { return _alfrid_FboPingPong__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _alfrid_FrameBuffer__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./alfrid/FrameBuffer */ "./src/js/libs/alfrid/alfrid/FrameBuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FrameBuffer", function() { return _alfrid_FrameBuffer__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _alfrid_GLTool__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./alfrid/GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GL", function() { return _alfrid_GLTool__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _alfrid_GLCubeTexture__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./alfrid/GLCubeTexture */ "./src/js/libs/alfrid/alfrid/GLCubeTexture.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLCubeTexture", function() { return _alfrid_GLCubeTexture__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _alfrid_GLShader__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./alfrid/GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLShader", function() { return _alfrid_GLShader__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _alfrid_loaders_GLTFParser__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./alfrid/loaders/GLTFParser */ "./src/js/libs/alfrid/alfrid/loaders/GLTFParser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFParser", function() { return _alfrid_loaders_GLTFParser__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _alfrid_GLTexture2__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./alfrid/GLTexture2 */ "./src/js/libs/alfrid/alfrid/GLTexture2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTexture", function() { return _alfrid_GLTexture2__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _alfrid_Geom__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./alfrid/Geom */ "./src/js/libs/alfrid/alfrid/Geom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Geom", function() { return _alfrid_Geom__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _alfrid_loaders_HDRLoader__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./alfrid/loaders/HDRLoader */ "./src/js/libs/alfrid/alfrid/loaders/HDRLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HDRLoader", function() { return _alfrid_loaders_HDRLoader__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _alfrid_Mesh__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./alfrid/Mesh */ "./src/js/libs/alfrid/alfrid/Mesh.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return _alfrid_Mesh__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _alfrid_MultisampleFrameBuffer__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./alfrid/MultisampleFrameBuffer */ "./src/js/libs/alfrid/alfrid/MultisampleFrameBuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MultisampleFrameBuffer", function() { return _alfrid_MultisampleFrameBuffer__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _alfrid_loaders_ObjLoader__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./alfrid/loaders/ObjLoader */ "./src/js/libs/alfrid/alfrid/loaders/ObjLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObjLoader", function() { return _alfrid_loaders_ObjLoader__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony import */ var _alfrid_objects_Object3D__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./alfrid/objects/Object3D */ "./src/js/libs/alfrid/alfrid/objects/Object3D.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return _alfrid_objects_Object3D__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _alfrid_utils_OrbitalControl__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./alfrid/utils/OrbitalControl */ "./src/js/libs/alfrid/alfrid/utils/OrbitalControl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OrbitalControl", function() { return _alfrid_utils_OrbitalControl__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _alfrid_utils_QuatRotation__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./alfrid/utils/QuatRotation */ "./src/js/libs/alfrid/alfrid/utils/QuatRotation.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QuatRotation", function() { return _alfrid_utils_QuatRotation__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _alfrid_math_Ray__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./alfrid/math/Ray */ "./src/js/libs/alfrid/alfrid/math/Ray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return _alfrid_math_Ray__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _alfrid_helpers_Scene__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./alfrid/helpers/Scene */ "./src/js/libs/alfrid/alfrid/helpers/Scene.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return _alfrid_helpers_Scene__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony import */ var scheduling__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! scheduling */ "./node_modules/scheduling/src/scheduler.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Scheduler", function() { return scheduling__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _alfrid_utils_ShaderLibs__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./alfrid/utils/ShaderLibs */ "./src/js/libs/alfrid/alfrid/utils/ShaderLibs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShaderLibs", function() { return _alfrid_utils_ShaderLibs__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _alfrid_utils_SpringNumber__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./alfrid/utils/SpringNumber */ "./src/js/libs/alfrid/alfrid/utils/SpringNumber.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SpringNumber", function() { return _alfrid_utils_SpringNumber__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _alfrid_utils_TouchDetector__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./alfrid/utils/TouchDetector */ "./src/js/libs/alfrid/alfrid/utils/TouchDetector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TouchDetector", function() { return _alfrid_utils_TouchDetector__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _alfrid_TransformFeedbackObject__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./alfrid/TransformFeedbackObject */ "./src/js/libs/alfrid/alfrid/TransformFeedbackObject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformFeedbackObject", function() { return _alfrid_TransformFeedbackObject__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _alfrid_utils_TweenNumber__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./alfrid/utils/TweenNumber */ "./src/js/libs/alfrid/alfrid/utils/TweenNumber.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TweenNumber", function() { return _alfrid_utils_TweenNumber__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _alfrid_helpers_View__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./alfrid/helpers/View */ "./src/js/libs/alfrid/alfrid/helpers/View.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "View", function() { return _alfrid_helpers_View__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _alfrid_helpers_View3D__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./alfrid/helpers/View3D */ "./src/js/libs/alfrid/alfrid/helpers/View3D.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "View3D", function() { return _alfrid_helpers_View3D__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _alfrid_utils_WebglNumber__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./alfrid/utils/WebglNumber */ "./src/js/libs/alfrid/alfrid/utils/WebglNumber.js");
/* harmony import */ var _alfrid_utils_WebglNumber__WEBPACK_IMPORTED_MODULE_44___default = /*#__PURE__*/__webpack_require__.n(_alfrid_utils_WebglNumber__WEBPACK_IMPORTED_MODULE_44__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "WebglNumber", function() { return _alfrid_utils_WebglNumber__WEBPACK_IMPORTED_MODULE_44___default.a; });
// alfrid.js



 // HELPERS





 // LOADERS

 // CAMERAS



















 // WEBGL 2


 // OBJECT



 // MATH


 // TOOLS









 // import WebglConst from './alfrid/utils/WebglConst'
// import ColladaParser  from './alfrid/loaders/ColladaParser';

const VERSION = '0.3.9';

class Alfrid {
  constructor() {
    this.glm = gl_matrix__WEBPACK_IMPORTED_MODULE_0__;
    this.GL = _alfrid_GLTool__WEBPACK_IMPORTED_MODULE_21__["default"];
    this.GLTool = _alfrid_GLTool__WEBPACK_IMPORTED_MODULE_21__["default"];
    this.GLShader = _alfrid_GLShader__WEBPACK_IMPORTED_MODULE_23__["default"];
    this.GLTexture = _alfrid_GLTexture2__WEBPACK_IMPORTED_MODULE_25__["default"];
    this.GLCubeTexture = _alfrid_GLCubeTexture__WEBPACK_IMPORTED_MODULE_22__["default"];
    this.Mesh = _alfrid_Mesh__WEBPACK_IMPORTED_MODULE_28__["default"];
    this.Geom = _alfrid_Geom__WEBPACK_IMPORTED_MODULE_26__["default"];
    this.Batch = _alfrid_Batch__WEBPACK_IMPORTED_MODULE_1__["default"];
    this.FrameBuffer = _alfrid_FrameBuffer__WEBPACK_IMPORTED_MODULE_20__["default"];
    this.CubeFrameBuffer = _alfrid_CubeFrameBuffer__WEBPACK_IMPORTED_MODULE_14__["default"];
    this.Scheduler = scheduling__WEBPACK_IMPORTED_MODULE_36__["default"];
    this.EventDispatcher = _alfrid_utils_EventDispatcher__WEBPACK_IMPORTED_MODULE_17__["default"];
    this.EaseNumber = _alfrid_utils_EaseNumber__WEBPACK_IMPORTED_MODULE_16__["default"];
    this.SpringNumber = _alfrid_utils_SpringNumber__WEBPACK_IMPORTED_MODULE_38__["default"];
    this.TweenNumber = _alfrid_utils_TweenNumber__WEBPACK_IMPORTED_MODULE_41__["default"];
    this.Camera = _alfrid_cameras_Camera__WEBPACK_IMPORTED_MODULE_10__["default"];
    this.CameraOrtho = _alfrid_cameras_CameraOrtho__WEBPACK_IMPORTED_MODULE_12__["default"];
    this.CameraPerspective = _alfrid_cameras_CameraPerspective__WEBPACK_IMPORTED_MODULE_13__["default"];
    this.Ray = _alfrid_math_Ray__WEBPACK_IMPORTED_MODULE_34__["default"];
    this.CameraCube = _alfrid_cameras_CameraCube__WEBPACK_IMPORTED_MODULE_11__["default"];
    this.OrbitalControl = _alfrid_utils_OrbitalControl__WEBPACK_IMPORTED_MODULE_32__["default"];
    this.QuatRotation = _alfrid_utils_QuatRotation__WEBPACK_IMPORTED_MODULE_33__["default"];
    this.BinaryLoader = _alfrid_loaders_BinaryLoader__WEBPACK_IMPORTED_MODULE_9__["default"];
    this.ObjLoader = _alfrid_loaders_ObjLoader__WEBPACK_IMPORTED_MODULE_30__["default"];
    this.GLTFParser = _alfrid_loaders_GLTFParser__WEBPACK_IMPORTED_MODULE_24__["default"]; // this.ColladaParser     = ColladaParser;

    this.HDRLoader = _alfrid_loaders_HDRLoader__WEBPACK_IMPORTED_MODULE_27__["default"];
    this.BatchCopy = _alfrid_helpers_BatchCopy__WEBPACK_IMPORTED_MODULE_4__["default"];
    this.BatchAxis = _alfrid_helpers_BatchAxis__WEBPACK_IMPORTED_MODULE_2__["default"];
    this.BatchBall = _alfrid_helpers_BatchBall__WEBPACK_IMPORTED_MODULE_3__["default"];
    this.BatchBall = _alfrid_helpers_BatchBall__WEBPACK_IMPORTED_MODULE_3__["default"];
    this.BatchLine = _alfrid_helpers_BatchLine__WEBPACK_IMPORTED_MODULE_6__["default"];
    this.BatchSkybox = _alfrid_helpers_BatchSkybox__WEBPACK_IMPORTED_MODULE_8__["default"];
    this.BatchSky = _alfrid_helpers_BatchSky__WEBPACK_IMPORTED_MODULE_7__["default"];
    this.BatchDotsPlane = _alfrid_helpers_BatchDotsPlane__WEBPACK_IMPORTED_MODULE_5__["default"];
    this.Scene = _alfrid_helpers_Scene__WEBPACK_IMPORTED_MODULE_35__["default"];
    this.View = _alfrid_helpers_View__WEBPACK_IMPORTED_MODULE_42__["default"];
    this.View3D = _alfrid_helpers_View3D__WEBPACK_IMPORTED_MODULE_43__["default"];
    this.Draw = _alfrid_helpers_Draw__WEBPACK_IMPORTED_MODULE_15__["default"];
    this.Object3D = _alfrid_objects_Object3D__WEBPACK_IMPORTED_MODULE_31__["default"];
    this.ShaderLibs = _alfrid_utils_ShaderLibs__WEBPACK_IMPORTED_MODULE_37__["default"];
    this.WebglNumber = _alfrid_utils_WebglNumber__WEBPACK_IMPORTED_MODULE_44___default.a;
    this.FboArray = _alfrid_FboArray__WEBPACK_IMPORTED_MODULE_18__["default"];
    this.FboPingPong = _alfrid_FboPingPong__WEBPACK_IMPORTED_MODULE_19__["default"];
    this.MultisampleFrameBuffer = _alfrid_MultisampleFrameBuffer__WEBPACK_IMPORTED_MODULE_29__["default"];
    this.TransformFeedbackObject = _alfrid_TransformFeedbackObject__WEBPACK_IMPORTED_MODULE_40__["default"];

    for (const s in gl_matrix__WEBPACK_IMPORTED_MODULE_0__) {
      if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__[s]) {
        if (window) window[s] = gl_matrix__WEBPACK_IMPORTED_MODULE_0__[s];
      }
    }
  }

  log() {
    if (navigator.userAgent.indexOf('Chrome') > -1) {
      console.log(`%clib alfrid : VERSION ${VERSION}`, 'background: #193441; color: #FCFFF5');
    } else {
      console.log('lib alfrid : VERSION ', VERSION);
    }

    console.log('%cClasses : ', 'color: #193441');

    for (const s in this) {
      if (this[s]) {
        console.log(`%c - ${s}`, 'color: #3E606F');
      }
    }
  }

}

const al = new Alfrid();
/* harmony default export */ __webpack_exports__["default"] = (al);


/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/Batch.js":
/*!********************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/Batch.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
// Batch.js


class Batch {
  constructor(mMesh, mShader) {
    this._mesh = mMesh;
    this._shader = mShader;
  } //	PUBLIC METHODS


  draw() {
    this._shader.bind();

    _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].draw(this.mesh);
  } //	GETTER AND SETTER


  get mesh() {
    return this._mesh;
  }

  get shader() {
    return this._shader;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Batch);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/CubeFrameBuffer.js":
/*!******************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/CubeFrameBuffer.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _GLCubeTexture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLCubeTexture */ "./src/js/libs/alfrid/alfrid/GLCubeTexture.js");
// CubeFrameBuffer.js




let gl;

class CubeFrameBuffer {
  constructor(size, mParameters = {}) {
    gl = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl;
    this._size = size;
    this.magFilter = mParameters.magFilter || gl.LINEAR;
    this.minFilter = mParameters.minFilter || gl.LINEAR;
    this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
    this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;

    this._init();
  }

  _init() {
    this.texture = gl.createTexture();
    this.glTexture = new _GLCubeTexture__WEBPACK_IMPORTED_MODULE_1__["default"](this.texture, {}, true);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);
    const targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

    for (let i = 0; i < targets.length; i++) {
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      gl.texImage2D(targets[i], 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.FLOAT, null);
    }

    this._frameBuffers = [];

    for (let i = 0; i < targets.length; i++) {
      const frameBuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, targets[i], this.texture, 0);
      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

      if (status !== gl.FRAMEBUFFER_COMPLETE) {
        console.log(`'gl.checkFramebufferStatus() returned '${status}`);
      }

      this._frameBuffers.push(frameBuffer);
    } // gl.generateMipmap(gl.TEXTURE_CUBE_MAP);


    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
  }

  bind(mTargetIndex) {
    // if(Math.random() > .99) console.log('bind :', mTargetIndex, this._frameBuffers[mTargetIndex]);
    _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].viewport(0, 0, this.width, this.height);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffers[mTargetIndex]);
  }

  unbind() {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].viewport(0, 0, _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].width, _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].height);
  } //	TEXTURES


  getTexture() {
    return this.glTexture;
  } //	GETTERS AND SETTERS


  get width() {
    return this._size;
  }

  get height() {
    return this._size;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (CubeFrameBuffer);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/FboArray.js":
/*!***********************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/FboArray.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _FrameBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FrameBuffer */ "./src/js/libs/alfrid/alfrid/FrameBuffer.js");
// FboArray.js


class FboArray {
  constructor(mNum, width, height, params = {}, mNumTargets = 1) {
    this._fbos = [];

    for (let i = 0; i < mNum; i++) {
      const fbo = new _FrameBuffer__WEBPACK_IMPORTED_MODULE_0__["default"](width, height, params, mNumTargets);

      this._fbos.push(fbo);
    }
  }

  swap() {
    const a = this._fbos.shift();

    this._fbos.push(a);
  }

  get read() {
    return this._fbos[this._fbos.length - 1];
  }

  get write() {
    return this._fbos[0];
  }

  get all() {
    return this._fbos;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (FboArray);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/FboPingPong.js":
/*!**************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/FboPingPong.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _FboArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FboArray */ "./src/js/libs/alfrid/alfrid/FboArray.js");
// FboPingPong.js


class FboPingPong extends _FboArray__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(width, height, params = {}, mNumTargets = 1) {
    super(2, width, height, params, mNumTargets);
  }

}

/* harmony default export */ __webpack_exports__["default"] = (FboPingPong);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/FrameBuffer.js":
/*!**************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/FrameBuffer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _GLTexture2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLTexture2 */ "./src/js/libs/alfrid/alfrid/GLTexture2.js");
/* harmony import */ var _utils_WebglNumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/WebglNumber */ "./src/js/libs/alfrid/alfrid/utils/WebglNumber.js");
/* harmony import */ var _utils_WebglNumber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_utils_WebglNumber__WEBPACK_IMPORTED_MODULE_2__);
// FrameBuffer.js



let gl;
let webglDepthTexture;
let hasCheckedMultiRenderSupport = false;
let extDrawBuffer;

const checkMultiRender = function () {
  if (_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].webgl2) {
    return true;
  } else {
    extDrawBuffer = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension('WEBGL_draw_buffers');
    return !!extDrawBuffer;
  }

  hasCheckedMultiRenderSupport = true;
};

class FrameBuffer {
  constructor(mWidth, mHeight, mParameters = {}, mNumTargets = 1) {
    gl = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl;
    webglDepthTexture = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].checkExtension('WEBGL_depth_texture') || _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].webgl2;
    this.width = mWidth;
    this.height = mHeight;
    this._numTargets = mNumTargets;
    this._multipleTargets = mNumTargets > 1;
    this._parameters = mParameters;

    if (!hasCheckedMultiRenderSupport) {
      checkMultiRender();
    }

    if (this._multipleTargets) {
      this._checkMaxNumRenderTarget();
    }

    this._init();
  }

  _init() {
    this._initTextures();

    this.frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

    if (_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].webgl2) {
      // this.renderBufferDepth = gl.createRenderbuffer();
      // gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferDepth);
      // gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
      // gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBufferDepth);
      const buffers = [];

      for (let i = 0; i < this._numTargets; i++) {
        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, this._textures[i].texture, 0);
        buffers.push(gl[`COLOR_ATTACHMENT${i}`]);
      }

      gl.drawBuffers(buffers);
      gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
    } else {
      for (let i = 0; i < this._numTargets; i++) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, this._textures[i].texture, 0);
      }

      if (this._multipleTargets) {
        const drawBuffers = [];

        for (let i = 0; i < this._numTargets; i++) {
          drawBuffers.push(extDrawBuffer[`COLOR_ATTACHMENT${i}_WEBGL`]);
        }

        extDrawBuffer.drawBuffersWEBGL(drawBuffers);
      }

      if (webglDepthTexture) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
      }
    } //	CHECKING FBO


    const FBOstatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    if (FBOstatus != gl.FRAMEBUFFER_COMPLETE) {
      console.error('FBOstatus', FBOstatus);
      console.error('GL_FRAMEBUFFER_COMPLETE failed, CANNOT use Framebuffer');
    } //	UNBIND


    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null); //	CLEAR FRAMEBUFFER

    this.clear();
  }

  _checkMaxNumRenderTarget() {
    const maxNumDrawBuffers = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getParameter(extDrawBuffer.MAX_DRAW_BUFFERS_WEBGL);

    if (this._numTargets > maxNumDrawBuffers) {
      console.error('Over max number of draw buffers supported : ', maxNumDrawBuffers);
      this._numTargets = maxNumDrawBuffers;
    }
  }

  _initTextures() {
    this._textures = [];

    for (let i = 0; i < this._numTargets; i++) {
      const glt = this._createTexture();

      this._textures.push(glt);
    }

    if (_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].webgl2) {
      this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT16, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, {
        minFilter: _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].NEAREST,
        magFilter: _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].NEAREST,
        mipmap: false
      });
    } else {
      this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, {
        minFilter: _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].LINEAR
      });
    }
  }

  _createTexture(mInternalformat, mTexelType, mFormat, mParameters = {}) {
    const parameters = Object.assign({}, this._parameters);

    if (!mFormat) {
      mFormat = mInternalformat;
    }

    parameters.internalFormat = mInternalformat || gl.RGBA;
    parameters.format = mFormat;
    parameters.type = parameters.type || mTexelType || _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].UNSIGNED_BYTE;

    if (mTexelType === gl.UNSIGNED_SHORT) {
      // fix for depth textures
      parameters.type = mTexelType;
    }

    for (const s in mParameters) {
      parameters[s] = mParameters[s];
    }

    const texture = new _GLTexture2__WEBPACK_IMPORTED_MODULE_1__["default"](null, parameters, this.width, this.height);
    return texture;
  } //	PUBLIC METHODS


  bind(mAutoSetViewport = true) {
    if (mAutoSetViewport) {
      _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].viewport(0, 0, this.width, this.height);
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
  }

  unbind(mAutoSetViewport = true) {
    if (mAutoSetViewport) {
      _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].viewport(0, 0, _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].width, _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].height);
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    this._textures.forEach(texture => {
      texture.generateMipmap();
    });
  }

  clear(r = 0, g = 0, b = 0, a = 0) {
    this.bind();
    _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].clear(r, g, b, a);
    this.unbind();
  } //	TEXTURES


  getTexture(mIndex = 0) {
    return this._textures[mIndex];
  }

  getDepthTexture() {
    return this.glDepthTexture;
  }

  get texture() {
    return this._textures[0];
  }

  get depthTexture() {
    return this.glDepthTexture;
  } //	TOUGHTS : Should I remove these from frame buffer ?
  //	Shouldn't these be set individually to each texture ?
  //	e.g. fbo.getTexture(0).minFilter = GL.NEAREST;
  //		 fbo.getTexture(1).minFilter = GL.LINEAR; ... etc ?
  //	MIPMAP FILTER


  get minFilter() {
    return this._textures[0].minFilter;
  }

  set minFilter(mValue) {
    this._textures.forEach(texture => {
      texture.minFilter = mValue;
    });
  }

  get magFilter() {
    return this._textures[0].magFilter;
  }

  set magFilter(mValue) {
    this._textures.forEach(texture => {
      texture.magFilter = mValue;
    });
  } //	WRAPPING


  get wrapS() {
    return this._textures[0].wrapS;
  }

  set wrapS(mValue) {
    this._textures.forEach(texture => {
      texture.wrapS = mValue;
    });
  }

  get wrapT() {
    return this._textures[0].wrapT;
  }

  set wrapT(mValue) {
    this._textures.forEach(texture => {
      texture.wrapT = mValue;
    });
  } //	UTILS


  showParameters() {
    this._textures[0].showParameters();
  }

  get numTargets() {
    return this._numTargets;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (FrameBuffer);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/GLCubeTexture.js":
/*!****************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/GLCubeTexture.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var parse_dds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! parse-dds */ "./node_modules/parse-dds/index.js");
/* harmony import */ var parse_dds__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(parse_dds__WEBPACK_IMPORTED_MODULE_1__);
// GLCubeTexture.js




let gl;
const DDSD_MIPMAPCOUNT = 0x20000;
const OFF_MIPMAPCOUNT = 7;
const headerLengthInt = 31;

class GLCubeTexture {
  constructor(mSource, mParameters = {}, isCubeTexture = false) {
    gl = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl;

    if (isCubeTexture) {
      this.texture = mSource;
      return;
    }

    let hasMipmaps = mSource.length > 6;

    if (mSource[0].mipmapCount) {
      hasMipmaps = mSource[0].mipmapCount > 1;
    }

    this.texture = gl.createTexture();
    this.magFilter = mParameters.magFilter || gl.LINEAR;
    this.minFilter = mParameters.minFilter || gl.LINEAR_MIPMAP_LINEAR;
    this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
    this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;

    if (!hasMipmaps && this.minFilter == gl.LINEAR_MIPMAP_LINEAR) {
      this.minFilter = gl.LINEAR;
    }

    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
    const targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];
    let numLevels = 1;
    let index = 0;
    numLevels = mSource.length / 6;
    this.numLevels = numLevels;

    if (hasMipmaps) {
      for (let j = 0; j < 6; j++) {
        for (let i = 0; i < numLevels; i++) {
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          index = j * numLevels + i;

          if (mSource[index].shape) {
            gl.texImage2D(targets[j], i, gl.RGBA, mSource[index].shape[0], mSource[index].shape[1], 0, gl.RGBA, gl.FLOAT, mSource[index].data);
          } else {
            gl.texImage2D(targets[j], i, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource[index]);
          }

          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
        }
      }
    } else {
      let index = 0;

      for (let j = 0; j < 6; j++) {
        index = j * numLevels;
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

        if (mSource[index].shape) {
          gl.texImage2D(targets[j], 0, gl.RGBA, mSource[index].shape[0], mSource[index].shape[1], 0, gl.RGBA, gl.FLOAT, mSource[index].data);
        } else {
          gl.texImage2D(targets[j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource[index]);
        }

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
      }

      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
    }

    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
  } //	PUBLIC METHOD


  bind(index = 0) {
    if (!_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].shader) {
      return;
    }

    gl.activeTexture(gl.TEXTURE0 + index);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
    gl.uniform1i(_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].shader.uniformTextures[index], index);
    this._bindIndex = index;
  }

  unbind() {
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
  }

}

GLCubeTexture.parseDDS = function parseDDS(mArrayBuffer) {
  function clamp(value, min, max) {
    if (min > max) {
      return clamp(value, max, min);
    }

    if (value < min) return min;else if (value > max) return max;else return value;
  } //	CHECKING MIP MAP LEVELS


  const ddsInfos = parse_dds__WEBPACK_IMPORTED_MODULE_1___default()(mArrayBuffer);
  const {
    flags
  } = ddsInfos;
  const header = new Int32Array(mArrayBuffer, 0, headerLengthInt);
  let mipmapCount = 1;

  if (flags & DDSD_MIPMAPCOUNT) {
    mipmapCount = Math.max(1, header[OFF_MIPMAPCOUNT]);
  }

  const sources = ddsInfos.images.map(img => {
    const faceData = new Float32Array(mArrayBuffer.slice(img.offset, img.offset + img.length));
    return {
      data: faceData,
      shape: img.shape,
      mipmapCount
    };
  });
  return new GLCubeTexture(sources);
};

/* harmony default export */ __webpack_exports__["default"] = (GLCubeTexture);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/GLShader.js":
/*!***********************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/GLShader.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _shaders_basic_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/basic.frag */ "./src/js/libs/alfrid/alfrid/shaders/basic.frag");
/* harmony import */ var _shaders_basic_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaders/basic.vert */ "./src/js/libs/alfrid/alfrid/shaders/basic.vert");
/* harmony import */ var glslify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! glslify */ "./node_modules/glslify/browser.js");
/* harmony import */ var glslify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(glslify__WEBPACK_IMPORTED_MODULE_3__);
// GLShader.js







const isSame = (array1, array2) => {
  if (array1.length !== array2.length) {
    return false;
  }

  for (let i = 0; i < array1.length; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }

  return true;
};

const addLineNumbers = string => {
  const lines = string.split('\n');

  for (let i = 0; i < lines.length; i++) {
    lines[i] = `${i + 1}: ${lines[i]}`;
  }

  return lines.join('\n');
};

const cloneArray = mArray => {
  if (mArray.slice) {
    return mArray.slice(0);
  } else {
    return new Float32Array(mArray);
  }
};

let gl;
const uniformMapping = {
  float: 'uniform1f',
  vec2: 'uniform2fv',
  vec3: 'uniform3fv',
  vec4: 'uniform4fv',
  int: 'uniform1i',
  mat3: 'uniformMatrix3fv',
  mat4: 'uniformMatrix4fv'
};

class GLShader {
  constructor(strVertexShader = _shaders_basic_vert__WEBPACK_IMPORTED_MODULE_2__["default"], strFragmentShader = _shaders_basic_frag__WEBPACK_IMPORTED_MODULE_1__["default"], mVaryings) {
    gl = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl;
    this.parameters = [];
    this.uniformTextures = [];
    this._varyings = mVaryings;

    if (!strVertexShader) {
      strVertexShader = _shaders_basic_vert__WEBPACK_IMPORTED_MODULE_2__["default"];
    }

    if (!strFragmentShader) {
      strFragmentShader = _shaders_basic_vert__WEBPACK_IMPORTED_MODULE_2__["default"];
    }

    const vsShader = this._createShaderProgram(strVertexShader, true);

    const fsShader = this._createShaderProgram(strFragmentShader, false);

    this._attachShaderProgram(vsShader, fsShader);
  }

  bind() {
    if (_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].shader === this) {
      return;
    }

    gl.useProgram(this.shaderProgram);
    _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].useShader(this);
    this.uniformTextures = [];
  }

  uniform(mName, mType, mValue) {
    if (typeof mName === 'object') {
      this.uniformObject(mName);
      return;
    }
    /*
    if(!!mValue === undefined || mValue === null) {
    	console.warn('mValue Error:', mName);
    	return;
    }
    */


    const uniformType = uniformMapping[mType] || mType;
    let hasUniform = false;
    let oUniform;
    let parameterIndex = -1;

    for (let i = 0; i < this.parameters.length; i++) {
      oUniform = this.parameters[i];

      if (oUniform.name === mName) {
        hasUniform = true;
        parameterIndex = i;
        break;
      }
    }

    let isNumber = false;

    if (!hasUniform) {
      isNumber = uniformType === 'uniform1i' || uniformType === 'uniform1f';
      this.shaderProgram[mName] = gl.getUniformLocation(this.shaderProgram, mName);

      if (isNumber) {
        this.parameters.push({
          name: mName,
          type: uniformType,
          value: mValue,
          uniformLoc: this.shaderProgram[mName],
          isNumber
        });
      } else {
        this.parameters.push({
          name: mName,
          type: uniformType,
          value: cloneArray(mValue),
          uniformLoc: this.shaderProgram[mName],
          isNumber
        });
      }

      parameterIndex = this.parameters.length - 1;
    } else {
      this.shaderProgram[mName] = oUniform.uniformLoc;
      isNumber = oUniform.isNumber;
    }

    if (!this.parameters[parameterIndex].uniformLoc) {
      return;
    }

    if (uniformType.indexOf('Matrix') === -1) {
      if (!isNumber) {
        if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
          gl[uniformType](this.shaderProgram[mName], mValue);
          this.parameters[parameterIndex].value = cloneArray(mValue);
        }
      } else {
        const needUpdate = this.parameters[parameterIndex].value !== mValue || !hasUniform;

        if (needUpdate) {
          gl[uniformType](this.shaderProgram[mName], mValue);
          this.parameters[parameterIndex].value = mValue;
        }
      }
    } else {
      if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
        gl[uniformType](this.shaderProgram[mName], false, mValue);
        this.parameters[parameterIndex].value = cloneArray(mValue);
      }
    }
  }

  uniformObject(mUniformObj) {
    for (const uniformName in mUniformObj) {
      let uniformValue = mUniformObj[uniformName];
      const uniformType = GLShader.getUniformType(uniformValue);

      if (uniformValue.concat && uniformValue[0].concat) {
        let tmp = [];

        for (let i = 0; i < uniformValue.length; i++) {
          tmp = tmp.concat(uniformValue[i]);
        }

        uniformValue = tmp;
      }

      this.uniform(uniformName, uniformType, uniformValue);
    }
  }

  _createShaderProgram(mShaderStr, isVertexShader) {
    const shaderType = isVertexShader ? _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].VERTEX_SHADER : _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].FRAGMENT_SHADER;
    const shader = gl.createShader(shaderType);
    gl.shaderSource(shader, mShaderStr);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.warn('Error in Shader : ', gl.getShaderInfoLog(shader));
      console.log(addLineNumbers(mShaderStr));
      return null;
    }

    return shader;
  }

  _attachShaderProgram(mVertexShader, mFragmentShader) {
    this.shaderProgram = gl.createProgram();
    gl.attachShader(this.shaderProgram, mVertexShader);
    gl.attachShader(this.shaderProgram, mFragmentShader);
    gl.deleteShader(mVertexShader);
    gl.deleteShader(mFragmentShader);

    if (this._varyings) {
      console.log('Transform feedback setup : ', this._varyings);
      gl.transformFeedbackVaryings(this.shaderProgram, this._varyings, gl.SEPARATE_ATTRIBS);
    }

    gl.linkProgram(this.shaderProgram);
  }

}

GLShader.getUniformType = function (mValue) {
  const isArray = !!mValue.concat;

  const getArrayUniformType = function (mValue) {
    if (mValue.length === 9) {
      return 'uniformMatrix3fv';
    } else if (mValue.length === 16) {
      return 'uniformMatrix4fv';
    } else {
      return `vec${mValue.length}`;
    }
  };

  if (!isArray) {
    return 'float';
  } else {
    if (!mValue[0].concat) {
      return getArrayUniformType(mValue);
    } else {
      return getArrayUniformType(mValue[0]);
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (GLShader);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/GLTexture.js":
/*!************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/GLTexture.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _utils_WebglNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/WebglNumber */ "./src/js/libs/alfrid/alfrid/utils/WebglNumber.js");
/* harmony import */ var _utils_WebglNumber__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_utils_WebglNumber__WEBPACK_IMPORTED_MODULE_1__);
// GLTexture.js



function isPowerOfTwo(x) {
  return x !== 0 && !(x & x - 1);
}

;

function isSourcePowerOfTwo(obj) {
  const w = obj.width || obj.videoWidth;
  const h = obj.height || obj.videoHeight;

  if (!w || !h) {
    return false;
  }

  return isPowerOfTwo(w) && isPowerOfTwo(h);
}

;
let gl;

class GLTexture {
  constructor(mSource, isTexture = false, mParameters = {}) {
    gl = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl;

    if (isTexture) {
      this._texture = mSource;
    } else {
      this._mSource = mSource;
      this._texture = gl.createTexture();
      this._isVideo = mSource.tagName === 'VIDEO';
      this._premultiplyAlpha = true;
      this._magFilter = mParameters.magFilter || gl.LINEAR;
      this._minFilter = mParameters.minFilter || gl.NEAREST_MIPMAP_LINEAR;
      this._wrapS = mParameters.wrapS || gl.MIRRORED_REPEAT;
      this._wrapT = mParameters.wrapT || gl.MIRRORED_REPEAT;
      const width = mSource.width || mSource.videoWidth;

      if (width) {
        if (!isSourcePowerOfTwo(mSource)) {
          this._wrapS = this._wrapT = gl.CLAMP_TO_EDGE;

          if (this._minFilter === gl.NEAREST_MIPMAP_LINEAR) {
            this._minFilter = gl.LINEAR;
          }
        }
      } else {
        this._wrapS = this._wrapT = gl.CLAMP_TO_EDGE;

        if (this._minFilter === gl.NEAREST_MIPMAP_LINEAR) {
          this._minFilter = gl.LINEAR;
        }
      }

      gl.bindTexture(gl.TEXTURE_2D, this._texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      if (mSource.exposure) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, mSource.shape[0], mSource.shape[1], 0, gl.RGBA, gl.FLOAT, mSource.data);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource); // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._minFilter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT); // console.log('Texture Min :', WebglNumber[this._minFilter]);
      // console.log('Texture Mag :', WebglNumber[this._magFilter]);

      const ext = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension('EXT_texture_filter_anisotropic');

      if (ext) {
        const max = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, max);
      }

      if (this._canGenerateMipmap()) {
        gl.generateMipmap(gl.TEXTURE_2D);
      }

      gl.bindTexture(gl.TEXTURE_2D, null);
    }
  }

  generateMipmap() {
    if (!this._canGenerateMipmap()) {
      return;
    }

    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.bindTexture(gl.TEXTURE_2D, null);
  } //	MIPMAP FILTER


  set minFilter(mValue) {
    if (mValue !== gl.LINEAR && mValue !== gl.NEAREST && mValue !== gl.NEAREST_MIPMAP_LINEAR && mValue !== gl.NEAREST_MIPMAP_LINEAR && mValue !== gl.LINEAR_MIPMAP_LINEAR && mValue !== gl.NEAREST_MIPMAP_NEAREST) {
      return this;
    }

    this._minFilter = mValue;
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._minFilter);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  get minFilter() {
    return this._minFilter;
  }

  set magFilter(mValue) {
    if (mValue !== gl.LINEAR && mValue !== gl.NEAREST) {
      return this;
    }

    this._magFilter = mValue;
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  get magFilter() {
    return this._magFilter;
  } //	WRAP


  set wrapS(mValue) {
    if (mValue !== gl.CLAMP_TO_EDGE && mValue !== gl.REPEAT && mValue !== gl.MIRRORED_REPEAT) {
      return this;
    }

    this._wrapS = mValue;
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  get wrapS() {
    return this._wrapS;
  }

  set wrapT(mValue) {
    if (mValue !== gl.CLAMP_TO_EDGE && mValue !== gl.REPEAT && mValue !== gl.MIRRORED_REPEAT) {
      return this;
    }

    this._wrapT = mValue;
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  get wrapT() {
    return this._wrapT;
  } //	PREMULTIPLY ALPHA


  set premultiplyAlpha(mValue) {
    this._premultiplyAlpha = mValue;
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    console.log('premultiplyAlpha:', mValue);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  get premultiplyAlpha() {
    return this._premultiplyAlpha;
  } //	UPDATE TEXTURE


  updateTexture(mSource) {
    if (mSource) {
      this._mSource = mSource;
    }

    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._mSource);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._minFilter);

    if (this._canGenerateMipmap()) {
      gl.generateMipmap(gl.TEXTURE_2D);
    }

    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  bind(index) {
    if (index === undefined) {
      index = 0;
    }

    if (!_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].shader) {
      return;
    }

    gl.activeTexture(gl.TEXTURE0 + index);
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    this._bindIndex = index;
  }

  _canGenerateMipmap() {
    return this._minFilter === gl.LINEAR_MIPMAP_NEAREST || this._minFilter === gl.NEAREST_MIPMAP_LINEAR || this._minFilter === gl.LINEAR_MIPMAP_LINEAR || this._minFilter === gl.NEAREST_MIPMAP_NEAREST;
  } //	GETTER


  get texture() {
    return this._texture;
  }

}

let _whiteTexture, _greyTexture, _blackTexture;

GLTexture.whiteTexture = function whiteTexture() {
  if (_whiteTexture === undefined) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 4;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, 4, 4);
    _whiteTexture = new GLTexture(canvas);
  }

  return _whiteTexture;
};

GLTexture.greyTexture = function greyTexture() {
  if (_greyTexture === undefined) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 4;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgb(127, 127, 127)';
    ctx.fillRect(0, 0, 4, 4);
    _greyTexture = new GLTexture(canvas);
  }

  return _greyTexture;
};

GLTexture.blackTexture = function blackTexture() {
  if (_blackTexture === undefined) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 4;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgb(127, 127, 127)';
    ctx.fillRect(0, 0, 4, 4);
    _blackTexture = new GLTexture(canvas);
  }

  return _blackTexture;
};

/* harmony default export */ __webpack_exports__["default"] = (GLTexture);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/GLTexture2.js":
/*!*************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/GLTexture2.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_getTextureParameters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getTextureParameters */ "./src/js/libs/alfrid/alfrid/utils/getTextureParameters.js");
/* harmony import */ var _utils_WebglNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/WebglNumber */ "./src/js/libs/alfrid/alfrid/utils/WebglNumber.js");
/* harmony import */ var _utils_WebglNumber__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_utils_WebglNumber__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var scheduling__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduling */ "./node_modules/scheduling/src/scheduler.js");
// GLTexture2.js




let gl;

class GLTexture {
  constructor(mSource, mParam = {}, mWidth = 0, mHeight = 0) {
    gl = _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].gl;
    this._source = mSource;

    this._getDimension(mSource, mWidth, mHeight);

    this._sourceType = mParam.type || getSourceType(mSource);

    this._checkSource();

    this._texelType = this._getTexelType();
    this._isTextureReady = true;
    this._params = Object(_utils_getTextureParameters__WEBPACK_IMPORTED_MODULE_0__["default"])(mParam, mSource, this._width, this._height);

    this._checkMipmap();

    this._checkWrapping(); // setup texture


    this._texture = gl.createTexture();

    if (this._sourceType === 'video') {
      this._isTextureReady = false;
      scheduling__WEBPACK_IMPORTED_MODULE_3__["default"].addEF(() => this._loop());
    } else {
      this._uploadTexture();
    }
  }

  _loop() {
    if (this._source.readyState === 4) {
      this._isTextureReady = true;

      this._uploadTexture();
    }
  }

  _uploadTexture() {
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    if (this._isSourceHtmlElement()) {
      gl.texImage2D(gl.TEXTURE_2D, 0, this._params.internalFormat, this._params.format, this._texelType, this._source);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, this._params.internalFormat, this._width, this._height, 0, this._params.format, this._texelType, this._source);
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._params.magFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._params.minFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._params.wrapS);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._params.wrapT);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha); // const ext = GL.getExtension('EXT_texture_filter_anisotropic');
    // if(ext) {
    // 	const max = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    // 	let level;
    // 	if(!this._params.anisotropy) {
    // 		level = max;
    // 	}
    // 	gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, level);
    // }

    if (this._generateMipmap) {
      gl.generateMipmap(gl.TEXTURE_2D);
    } //	unbind texture


    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  bind(index) {
    if (index === undefined) {
      index = 0;
    }

    if (!_GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].shader) {
      return;
    }

    gl.activeTexture(gl.TEXTURE0 + index);

    if (this._isTextureReady) {
      gl.bindTexture(gl.TEXTURE_2D, this._texture);
    } else {
      gl.bindTexture(gl.TEXTURE_2D, GLTexture.blackTexture().texture);
    }

    this._bindIndex = index;
  }

  updateTexture(mSource) {
    this._source = mSource;

    this._checkSource();

    this._uploadTexture();
  }

  generateMipmap() {
    if (!this._generateMipmap) {
      return;
    }

    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  showParameters() {
    console.log('Source type : ', _utils_WebglNumber__WEBPACK_IMPORTED_MODULE_1___default.a[this._sourceType] || this._sourceType);
    console.log('Texel type:', _utils_WebglNumber__WEBPACK_IMPORTED_MODULE_1___default.a[this.texelType]);
    console.log('Dimension :', this._width, this._height);

    for (const s in this._params) {
      console.log(s, _utils_WebglNumber__WEBPACK_IMPORTED_MODULE_1___default.a[this._params[s]] || this._params[s]);
    }

    console.log('Mipmapping :', this._generateMipmap);
  }

  _getDimension(mSource, mWidth, mHeight) {
    if (mSource) {
      // for html image / video element
      this._width = mSource.width || mSource.videoWidth;
      this._height = mSource.height || mSource.videoWidth; // for manual width / height settings

      this._width = this._width || mWidth;
      this._height = this._height || mHeight; // auto detect ( data array) ? not sure is good idea ?
      // todo : check HDR

      if (!this._width || !this._height) {
        this._width = this._height = Math.sqrt(mSource.length / 4); // console.log('Auto detect, data dimension : ', this._width, this._height);
      }
    } else {
      this._width = mWidth;
      this._height = mHeight;
    }
  }

  _checkSource() {
    if (!this._source) {
      return;
    }

    if (this._sourceType === _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].UNSIGNED_BYTE) {
      if (!(this._source instanceof Uint8Array)) {
        // console.log('Converting to Uint8Array');
        this._source = new Uint8Array(this._source);
      }
    } else if (this._sourceType === _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].FLOAT) {
      if (!(this._source instanceof Float32Array)) {
        // console.log('Converting to Float32Array');
        this._source = new Float32Array(this._source);
      }
    }
  }

  _getTexelType() {
    if (this._isSourceHtmlElement()) {
      return _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].UNSIGNED_BYTE;
    }

    return _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"][_utils_WebglNumber__WEBPACK_IMPORTED_MODULE_1___default.a[this._sourceType]];
  }

  _checkMipmap() {
    this._generateMipmap = this._params.mipmap;

    if (!(isPowerOfTwo(this._width) && isPowerOfTwo(this._height))) {
      this._generateMipmap = false;
    }

    const minFilter = _utils_WebglNumber__WEBPACK_IMPORTED_MODULE_1___default.a[this._params.minFilter];

    if (minFilter.indexOf('MIPMAP') === -1) {
      this._generateMipmap = false;
    }
  }

  _checkWrapping() {
    if (!this._generateMipmap) {
      this._params.wrapS = _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].CLAMP_TO_EDGE;
      this._params.wrapT = _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].CLAMP_TO_EDGE;
    }
  }

  _isSourceHtmlElement() {
    return this._sourceType === 'image' || this._sourceType === 'video' || this._sourceType === 'canvas';
  }

  get minFilter() {
    return this._params.minFilter;
  }

  set minFilter(mValue) {
    this._params.minFilter = mValue;

    this._checkMipmap();

    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._params.minFilter);
    gl.bindTexture(gl.TEXTURE_2D, null);
    this.generateMipmap();
  }

  get magFilter() {
    return this._params.minFilter;
  }

  set magFilter(mValue) {
    this._params.magFilter = mValue;
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._params.magFilter);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  get wrapS() {
    return this._params.wrapS;
  }

  set wrapS(mValue) {
    this._params.wrapS = mValue;

    this._checkWrapping();

    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._params.wrapS);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  get wrapT() {
    return this._params.wrapT;
  }

  set wrapT(mValue) {
    this._params.wrapT = mValue;

    this._checkWrapping();

    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._params.wrapT);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  get texelType() {
    return this._texelType;
  }

  get width() {
    return this._width;
  }

  get height() {
    return this._height;
  }

  get texture() {
    return this._texture;
  }

  get isTextureReady() {
    return this._isTextureReady;
  }

}

function isPowerOfTwo(x) {
  return x !== 0 && !(x & x - 1);
}

;

function getSourceType(mSource) {
  //	possible source type : Image / Video / Unit8Array / Float32Array
  //	this list must be flexible
  let type = _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].UNSIGNED_BYTE;

  if (mSource instanceof Array) {
    type = _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].UNSIGNED_BYTE;
  } else if (mSource instanceof Uint8Array) {
    type = _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].UNSIGNED_BYTE;
  } else if (mSource instanceof Float32Array) {
    type = _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].FLOAT;
  } else if (mSource instanceof HTMLImageElement) {
    type = 'image';
  } else if (mSource instanceof HTMLCanvasElement) {
    type = 'canvas';
  } else if (mSource instanceof HTMLVideoElement) {
    type = 'video';
  }

  return type;
}

let _whiteTexture, _greyTexture, _blackTexture;

GLTexture.whiteTexture = function whiteTexture() {
  if (_whiteTexture === undefined) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 2;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, 2, 2);
    _whiteTexture = new GLTexture(canvas);
  }

  return _whiteTexture;
};

GLTexture.greyTexture = function greyTexture() {
  if (_greyTexture === undefined) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 2;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgb(127, 127, 127)';
    ctx.fillRect(0, 0, 2, 2);
    _greyTexture = new GLTexture(canvas);
  }

  return _greyTexture;
};

GLTexture.blackTexture = function blackTexture() {
  if (_blackTexture === undefined) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 2;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgb(0, 0, 0)';
    ctx.fillRect(0, 0, 2, 2);
    _blackTexture = new GLTexture(canvas);
  }

  return _blackTexture;
};

/* harmony default export */ __webpack_exports__["default"] = (GLTexture);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/GLTool.js":
/*!*********************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/GLTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _utils_getAndApplyExtension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/getAndApplyExtension */ "./src/js/libs/alfrid/alfrid/utils/getAndApplyExtension.js");
/* harmony import */ var _utils_exposeAttributes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/exposeAttributes */ "./src/js/libs/alfrid/alfrid/utils/exposeAttributes.js");
/* harmony import */ var _utils_getFloat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/getFloat */ "./src/js/libs/alfrid/alfrid/utils/getFloat.js");
/* harmony import */ var _utils_getHalfFloat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/getHalfFloat */ "./src/js/libs/alfrid/alfrid/utils/getHalfFloat.js");
/* harmony import */ var _utils_getAttribLoc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/getAttribLoc */ "./src/js/libs/alfrid/alfrid/utils/getAttribLoc.js");
/* harmony import */ var _utils_ExtensionsList__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/ExtensionsList */ "./src/js/libs/alfrid/alfrid/utils/ExtensionsList.js");
// GLTool.js







let gl;

class GLTool {
  constructor() {
    this._viewport = [0, 0, 0, 0];
    this._enabledVertexAttribute = [];
    this.identityMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this._normalMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].create();
    this._inverseModelViewMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].create();
    this._modelMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this._matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this._matrixStacks = [];
    this._lastMesh = null;
    this._useWebGL2 = false;
    this._hasArrayInstance = false;
    this._extArrayInstance = false;
    this._hasCheckedExt = false;
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(this.identityMatrix, this.identityMatrix);
    this.isMobile = false;

    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      this.isMobile = true;
    }
  } // INITIALIZE


  init(mCanvas, mParameters = {}) {
    if (mCanvas === null || mCanvas === undefined) {
      console.error('Canvas not exist');
      return;
    }

    if (this.canvas !== undefined && this.canvas !== null) {
      this.destroy();
    }

    this.canvas = mCanvas;
    this.setSize(window.innerWidth, window.innerHeight);
    mParameters.useWebgl2 = mParameters.useWebgl2 || false;
    let ctx;

    if (mParameters.useWebgl2) {
      ctx = this.canvas.getContext('experimental-webgl2', mParameters) || this.canvas.getContext('webgl2', mParameters);

      if (!ctx) {
        ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
        this._useWebGL2 = false;
      } else {
        this._useWebGL2 = true;
        console.log('Using WebGL 2 : ', ctx);
      }
    } else {
      ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
      this._useWebGL2 = false;
    } // extensions


    this.initWithGL(ctx);
  }

  initWithGL(ctx) {
    if (!this.canvas) {
      this.canvas = ctx.canvas;
    }

    gl = this.gl = ctx;
    this.extensions = {};

    for (let i = 0; i < _utils_ExtensionsList__WEBPACK_IMPORTED_MODULE_6__["default"].length; i++) {
      this.extensions[_utils_ExtensionsList__WEBPACK_IMPORTED_MODULE_6__["default"][i]] = gl.getExtension(_utils_ExtensionsList__WEBPACK_IMPORTED_MODULE_6__["default"][i]);
    } // Copy gl Attributes


    Object(_utils_exposeAttributes__WEBPACK_IMPORTED_MODULE_2__["default"])();
    Object(_utils_getAndApplyExtension__WEBPACK_IMPORTED_MODULE_1__["default"])(gl, 'OES_vertex_array_object');
    Object(_utils_getAndApplyExtension__WEBPACK_IMPORTED_MODULE_1__["default"])(gl, 'ANGLE_instanced_arrays');
    Object(_utils_getAndApplyExtension__WEBPACK_IMPORTED_MODULE_1__["default"])(gl, 'WEBGL_draw_buffers');
    this.enable(this.DEPTH_TEST);
    this.enable(this.CULL_FACE);
    this.enable(this.BLEND);
    this.enableAlphaBlending();
  } // PUBLIC METHODS


  setViewport(x, y, w, h) {
    let hasChanged = false;

    if (x !== this._viewport[0]) {
      hasChanged = true;
    }

    if (y !== this._viewport[1]) {
      hasChanged = true;
    }

    if (w !== this._viewport[2]) {
      hasChanged = true;
    }

    if (h !== this._viewport[3]) {
      hasChanged = true;
    }

    if (hasChanged) {
      gl.viewport(x, y, w, h);
      this._viewport = [x, y, w, h];
    }
  }

  scissor(x, y, w, h) {
    gl.scissor(x, y, w, h);
  }

  clear(r, g, b, a) {
    gl.clearColor(r, g, b, a);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }

  cullFace(mValue) {
    gl.cullFace(mValue);
  }

  setMatrices(mCamera) {
    this.camera = mCamera;
    this.rotate(this.identityMatrix);
  }

  useShader(mShader) {
    this.shader = mShader;
    this.shaderProgram = this.shader.shaderProgram;
  }

  rotate(mRotation) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(this._modelMatrix, mRotation);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(this._matrix, this.camera.matrix, this._modelMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].fromMat4(this._normalMatrix, this._matrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].invert(this._normalMatrix, this._normalMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].transpose(this._normalMatrix, this._normalMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].fromMat4(this._inverseModelViewMatrix, this._matrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].invert(this._inverseModelViewMatrix, this._inverseModelViewMatrix);
  }

  draw(mMesh, mDrawingType) {
    if (mMesh.length) {
      for (let i = 0; i < mMesh.length; i++) {
        this.draw(mMesh[i]);
      }

      return;
    }

    mMesh.bind(this.shaderProgram); //	DEFAULT UNIFORMS

    if (this.camera !== undefined) {
      this.shader.uniform('uProjectionMatrix', 'mat4', this.camera.projection);
      this.shader.uniform('uViewMatrix', 'mat4', this.camera.matrix);
    }

    this.shader.uniform('uModelMatrix', 'mat4', this._modelMatrix);
    this.shader.uniform('uNormalMatrix', 'mat3', this._normalMatrix);
    this.shader.uniform('uModelViewMatrixInverse', 'mat3', this._inverseModelViewMatrix);
    let drawType = mMesh.drawType;

    if (mDrawingType !== undefined) {
      drawType = mDrawingType;
    }

    if (mMesh.isInstanced) {
      //	DRAWING
      gl.drawElementsInstanced(mMesh.drawType, mMesh.iBuffer.numItems, gl.UNSIGNED_SHORT, 0, mMesh.numInstance);
    } else {
      if (drawType === gl.POINTS) {
        gl.drawArrays(drawType, 0, mMesh.vertexSize);
      } else {
        gl.drawElements(drawType, mMesh.iBuffer.numItems, gl.UNSIGNED_SHORT, 0);
      }
    }

    mMesh.unbind();
  }

  drawTransformFeedback(mTransformObject) {
    const {
      meshSource,
      meshDestination,
      numPoints,
      transformFeedback
    } = mTransformObject; //	BIND SOURCE BUFFERS -> setupVertexAttr(sourceVAO)

    meshSource.bind(this.shaderProgram);
    meshDestination.generateBuffers(this.shaderProgram); //	BIND DESTINATION BUFFERS

    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);
    meshDestination.attributes.forEach((attr, i) => {
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attr.buffer);
    });
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArrays(gl.POINTS, 0, numPoints);
    gl.endTransformFeedback(); //	reset state

    gl.disable(gl.RASTERIZER_DISCARD);
    gl.useProgram(null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    meshDestination.attributes.forEach((attr, i) => {
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, null);
    });
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    meshSource.unbind();
  }

  setSize(mWidth, mHeight) {
    this._width = mWidth;
    this._height = mHeight;
    this.canvas.width = this._width;
    this.canvas.height = this._height;
    this._aspectRatio = this._width / this._height;

    if (gl) {
      this.viewport(0, 0, this._width, this._height);
    }
  }

  showExtensions() {
    console.log('Extensions : ', this.extensions);

    for (const ext in this.extensions) {
      if (this.extensions[ext]) {
        console.log(ext, ':', this.extensions[ext]);
      }
    }
  }

  checkExtension(mExtension) {
    return !!this.extensions[mExtension];
  }

  getExtension(mExtension) {
    return this.extensions[mExtension];
  } //	BLEND MODES


  enableAlphaBlending() {
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  }

  enableAdditiveBlending() {
    gl.blendFunc(gl.ONE, gl.ONE);
  } //	matrices


  pushMatrix() {
    const mtx = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].clone(this._modelMatrix);

    this._matrixStacks.push(mtx);
  }

  popMatrix() {
    if (this._matrixStacks.length == 0) {
      return null;
    }

    const mtx = this._matrixStacks.pop();

    this.rotate(mtx);
  } //	GL NATIVE FUNCTIONS


  enable(mParameter) {
    gl.enable(mParameter);
  }

  disable(mParameter) {
    gl.disable(mParameter);
  }

  viewport(x, y, w, h) {
    this.setViewport(x, y, w, h);
  } //	GETTER AND SETTERS


  get FLOAT() {
    return Object(_utils_getFloat__WEBPACK_IMPORTED_MODULE_3__["default"])();
  }

  get HALF_FLOAT() {
    return Object(_utils_getHalfFloat__WEBPACK_IMPORTED_MODULE_4__["default"])();
  }

  get width() {
    return this._width;
  }

  get height() {
    return this._height;
  }

  get aspectRatio() {
    return this._aspectRatio;
  }

  get webgl2() {
    return this._useWebGL2;
  } //	DESTROY


  destroy() {
    if (this.canvas.parentNode) {
      try {
        this.canvas.parentNode.removeChild(this.canvas);
      } catch (e) {
        console.log('Error : ', e);
      }
    }

    this.canvas = null;
  }

}

const GL = new GLTool();
/* harmony default export */ __webpack_exports__["default"] = (GL);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/Geom.js":
/*!*******************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/Geom.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mesh */ "./src/js/libs/alfrid/alfrid/Mesh.js");
// Geom.js



const Geom = {};
let meshTri;

Geom.plane = function plane(width, height, numSegments, axis = 'xy', drawType = 4) {
  const positions = [];
  const coords = [];
  const indices = [];
  const normals = [];
  const gapX = width / numSegments;
  const gapY = height / numSegments;
  const gapUV = 1 / numSegments;
  const sx = -width * 0.5;
  const sy = -height * 0.5;
  let index = 0;

  for (let i = 0; i < numSegments; i++) {
    for (let j = 0; j < numSegments; j++) {
      const tx = gapX * i + sx;
      const ty = gapY * j + sy;
      const u = i / numSegments;
      const v = j / numSegments;

      if (axis === 'xz') {
        positions.push([tx, 0, ty + gapY]);
        positions.push([tx + gapX, 0, ty + gapY]);
        positions.push([tx + gapX, 0, ty]);
        positions.push([tx, 0, ty]);
        coords.push([u, 1.0 - (v + gapUV)]);
        coords.push([u + gapUV, 1.0 - (v + gapUV)]);
        coords.push([u + gapUV, 1.0 - v]);
        coords.push([u, 1.0 - v]);
        normals.push([0, 1, 0]);
        normals.push([0, 1, 0]);
        normals.push([0, 1, 0]);
        normals.push([0, 1, 0]);
      } else if (axis === 'yz') {
        positions.push([0, ty, tx]);
        positions.push([0, ty, tx + gapX]);
        positions.push([0, ty + gapY, tx + gapX]);
        positions.push([0, ty + gapY, tx]);
        coords.push([u, v]);
        coords.push([u + gapUV, v]);
        coords.push([u + gapUV, v + gapUV]);
        coords.push([u, v + gapUV]);
        normals.push([1, 0, 0]);
        normals.push([1, 0, 0]);
        normals.push([1, 0, 0]);
        normals.push([1, 0, 0]);
      } else {
        positions.push([tx, ty, 0]);
        positions.push([tx + gapX, ty, 0]);
        positions.push([tx + gapX, ty + gapY, 0]);
        positions.push([tx, ty + gapY, 0]);
        coords.push([u, v]);
        coords.push([u + gapUV, v]);
        coords.push([u + gapUV, v + gapUV]);
        coords.push([u, v + gapUV]);
        normals.push([0, 0, 1]);
        normals.push([0, 0, 1]);
        normals.push([0, 0, 1]);
        normals.push([0, 0, 1]);
      }

      indices.push(index * 4 + 0);
      indices.push(index * 4 + 1);
      indices.push(index * 4 + 2);
      indices.push(index * 4 + 0);
      indices.push(index * 4 + 2);
      indices.push(index * 4 + 3);
      index++;
    }
  }

  const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_0__["default"](drawType);
  mesh.bufferVertex(positions);
  mesh.bufferTexCoord(coords);
  mesh.bufferIndex(indices);
  mesh.bufferNormal(normals);
  return mesh;
};

Geom.sphere = function sphere(size, numSegments, isInvert = false, drawType = 4) {
  const positions = [];
  const coords = [];
  const indices = [];
  const normals = [];
  const gapUV = 1 / numSegments;
  let index = 0;

  function getPosition(i, j, isNormal = false) {
    //	rx : -90 ~ 90 , ry : 0 ~ 360
    const rx = i / numSegments * Math.PI - Math.PI * 0.5;
    const ry = j / numSegments * Math.PI * 2;
    const r = isNormal ? 1 : size;
    const pos = [];
    pos[1] = Math.sin(rx) * r;
    const t = Math.cos(rx) * r;
    pos[0] = Math.cos(ry) * t;
    pos[2] = Math.sin(ry) * t;
    const precision = 10000;
    pos[0] = Math.floor(pos[0] * precision) / precision;
    pos[1] = Math.floor(pos[1] * precision) / precision;
    pos[2] = Math.floor(pos[2] * precision) / precision;
    return pos;
  }

  ;

  for (let i = 0; i < numSegments; i++) {
    for (let j = 0; j < numSegments; j++) {
      positions.push(getPosition(i, j));
      positions.push(getPosition(i + 1, j));
      positions.push(getPosition(i + 1, j + 1));
      positions.push(getPosition(i, j + 1));
      normals.push(getPosition(i, j, true));
      normals.push(getPosition(i + 1, j, true));
      normals.push(getPosition(i + 1, j + 1, true));
      normals.push(getPosition(i, j + 1, true));
      const u = j / numSegments;
      const v = i / numSegments;
      coords.push([1.0 - u, v]);
      coords.push([1.0 - u, v + gapUV]);
      coords.push([1.0 - u - gapUV, v + gapUV]);
      coords.push([1.0 - u - gapUV, v]);
      indices.push(index * 4 + 0);
      indices.push(index * 4 + 1);
      indices.push(index * 4 + 2);
      indices.push(index * 4 + 0);
      indices.push(index * 4 + 2);
      indices.push(index * 4 + 3);
      index++;
    }
  }

  if (isInvert) {
    indices.reverse();
  }

  const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_0__["default"](drawType);
  mesh.bufferVertex(positions);
  mesh.bufferTexCoord(coords);
  mesh.bufferIndex(indices);
  mesh.bufferNormal(normals);
  return mesh;
};

Geom.cube = function cube(w, h, d, drawType = 4) {
  h = h || w;
  d = d || w;
  const x = w / 2;
  const y = h / 2;
  const z = d / 2;
  const positions = [];
  const coords = [];
  const indices = [];
  const normals = [];
  let count = 0; // BACK

  positions.push([-x, y, -z]);
  positions.push([x, y, -z]);
  positions.push([x, -y, -z]);
  positions.push([-x, -y, -z]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // RIGHT

  positions.push([x, y, -z]);
  positions.push([x, y, z]);
  positions.push([x, -y, z]);
  positions.push([x, -y, -z]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // FRONT

  positions.push([x, y, z]);
  positions.push([-x, y, z]);
  positions.push([-x, -y, z]);
  positions.push([x, -y, z]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // LEFT

  positions.push([-x, y, z]);
  positions.push([-x, y, -z]);
  positions.push([-x, -y, -z]);
  positions.push([-x, -y, z]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // TOP

  positions.push([x, y, -z]);
  positions.push([-x, y, -z]);
  positions.push([-x, y, z]);
  positions.push([x, y, z]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // BOTTOM

  positions.push([x, -y, z]);
  positions.push([-x, -y, z]);
  positions.push([-x, -y, -z]);
  positions.push([x, -y, -z]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++;
  const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_0__["default"](drawType);
  mesh.bufferVertex(positions);
  mesh.bufferTexCoord(coords);
  mesh.bufferIndex(indices);
  mesh.bufferNormal(normals);
  return mesh;
};

Geom.skybox = function skybox(size, drawType = 4) {
  const positions = [];
  const coords = [];
  const indices = [];
  const normals = [];
  let count = 0; // BACK

  positions.push([size, size, -size]);
  positions.push([-size, size, -size]);
  positions.push([-size, -size, -size]);
  positions.push([size, -size, -size]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // RIGHT

  positions.push([size, -size, -size]);
  positions.push([size, -size, size]);
  positions.push([size, size, size]);
  positions.push([size, size, -size]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // FRONT

  positions.push([-size, size, size]);
  positions.push([size, size, size]);
  positions.push([size, -size, size]);
  positions.push([-size, -size, size]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // LEFT

  positions.push([-size, -size, size]);
  positions.push([-size, -size, -size]);
  positions.push([-size, size, -size]);
  positions.push([-size, size, size]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // TOP

  positions.push([size, size, size]);
  positions.push([-size, size, size]);
  positions.push([-size, size, -size]);
  positions.push([size, size, -size]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // BOTTOM

  positions.push([size, -size, -size]);
  positions.push([-size, -size, -size]);
  positions.push([-size, -size, size]);
  positions.push([size, -size, size]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_0__["default"](drawType);
  mesh.bufferVertex(positions);
  mesh.bufferTexCoord(coords);
  mesh.bufferIndex(indices);
  mesh.bufferNormal(normals);
  return mesh;
};

Geom.bigTriangle = function bigTriangle() {
  if (!meshTri) {
    const indices = [2, 1, 0];
    const positions = [[-1, -1], [-1, 4], [4, -1]];
    meshTri = new _Mesh__WEBPACK_IMPORTED_MODULE_0__["default"]();
    meshTri.bufferData(positions, 'aPosition', 2);
    meshTri.bufferIndex(indices);
  }

  return meshTri;
};

/* harmony default export */ __webpack_exports__["default"] = (Geom);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/Mesh.js":
/*!*******************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/Mesh.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _utils_getAttribLoc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/getAttribLoc */ "./src/js/libs/alfrid/alfrid/utils/getAttribLoc.js");





let gl;
const STATIC_DRAW = 35044;

const getBuffer = function (attr) {
  let buffer;

  if (attr.buffer !== undefined) {
    buffer = attr.buffer;
  } else {
    buffer = gl.createBuffer();
    attr.buffer = buffer;
  }

  return buffer;
};

const formBuffer = function (mData, mNum) {
  const ary = [];

  for (let i = 0; i < mData.length; i += mNum) {
    const o = [];

    for (let j = 0; j < mNum; j++) {
      o.push(mData[i + j]);
    }

    ary.push(o);
  }

  return ary;
};

class Mesh {
  constructor(mDrawingType = 4, mUseVao = true) {
    gl = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl;
    this.drawType = mDrawingType;
    this._attributes = [];
    this._numInstance = -1;
    this._enabledVertexAttribute = [];
    this._indices = [];
    this._faces = [];
    this._bufferChanged = [];
    this._hasIndexBufferChanged = false;
    this._hasVAO = false;
    this._isInstanced = false;
    this._extVAO = !!_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createVertexArray;
    this._useVAO = !!this._extVAO && mUseVao; // this._useVAO = false;
  }

  bufferVertex(mArrayVertices, mDrawType = STATIC_DRAW) {
    this.bufferData(mArrayVertices, 'aVertexPosition', 3, mDrawType);

    if (this.normals.length < this.vertices.length) {
      this.bufferNormal(mArrayVertices, mDrawType);
    }

    return this;
  }

  bufferTexCoord(mArrayTexCoords, mDrawType = STATIC_DRAW) {
    this.bufferData(mArrayTexCoords, 'aTextureCoord', 2, mDrawType);
    return this;
  }

  bufferNormal(mNormals, mDrawType = STATIC_DRAW) {
    this.bufferData(mNormals, 'aNormal', 3, mDrawType);
    return this;
  }

  bufferIndex(mArrayIndices, isDynamic = false) {
    this._drawType = isDynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
    this._indices = new Uint16Array(mArrayIndices);
    this._numItems = this._indices.length;
    return this;
  }

  bufferFlattenData(mData, mName, mItemSize, mDrawType = STATIC_DRAW, isInstanced = false) {
    const data = formBuffer(mData, mItemSize);
    this.bufferData(data, mName, mItemSize, mDrawType = STATIC_DRAW, isInstanced = false);
    return this;
  }

  bufferData(mData, mName, mItemSize, mDrawType = STATIC_DRAW, isInstanced = false) {
    let i = 0;
    const drawType = mDrawType;
    if (!drawType) debugger;
    const bufferData = [];

    if (!mItemSize) {
      mItemSize = mData[0].length;
    }

    this._isInstanced = isInstanced || this._isInstanced; //	flatten buffer data		

    for (i = 0; i < mData.length; i++) {
      for (let j = 0; j < mData[i].length; j++) {
        bufferData.push(mData[i][j]);
      }
    }

    const dataArray = new Float32Array(bufferData);
    const attribute = this.getAttribute(mName);

    if (attribute) {
      //	attribute existed, replace with new data
      attribute.itemSize = mItemSize;
      attribute.dataArray = dataArray;
      attribute.source = mData;
    } else {
      //	attribute not exist yet, create new attribute object
      this._attributes.push({
        name: mName,
        source: mData,
        itemSize: mItemSize,
        drawType,
        dataArray,
        isInstanced
      });
    }

    this._bufferChanged.push(mName);

    return this;
  }

  bufferInstance(mData, mName) {
    if (!_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl.vertexAttribDivisor) {
      console.error('Extension : ANGLE_instanced_arrays is not supported with this device !');
      return;
    }

    const itemSize = mData[0].length;
    this._numInstance = mData.length;
    this.bufferData(mData, mName, itemSize, STATIC_DRAW, true);
  }

  bind(mShaderProgram) {
    this.generateBuffers(mShaderProgram);

    if (this.hasVAO) {
      gl.bindVertexArray(this.vao);
    } else {
      this.attributes.forEach(attribute => {
        gl.bindBuffer(gl.ARRAY_BUFFER, attribute.buffer);
        const attrPosition = attribute.attrPosition;
        gl.vertexAttribPointer(attrPosition, attribute.itemSize, gl.FLOAT, false, 0, 0);

        if (attribute.isInstanced) {
          gl.vertexAttribDivisor(attrPosition, 1);
        }
      }); //	BIND INDEX BUFFER

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuffer);
    }
  }

  generateBuffers(mShaderProgram) {
    if (this._bufferChanged.length == 0) {
      return;
    }

    if (this._useVAO) {
      //	IF SUPPORTED, CREATE VAO
      //	CREATE & BIND VAO
      if (!this._vao) {
        this._vao = gl.createVertexArray();
      }

      gl.bindVertexArray(this._vao); //	UPDATE BUFFERS

      this._attributes.forEach(attrObj => {
        if (this._bufferChanged.indexOf(attrObj.name) !== -1) {
          const buffer = getBuffer(attrObj);
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(gl.ARRAY_BUFFER, attrObj.dataArray, attrObj.drawType);
          const attrPosition = Object(_utils_getAttribLoc__WEBPACK_IMPORTED_MODULE_2__["default"])(gl, mShaderProgram, attrObj.name);
          gl.enableVertexAttribArray(attrPosition);
          gl.vertexAttribPointer(attrPosition, attrObj.itemSize, gl.FLOAT, false, 0, 0);
          attrObj.attrPosition = attrPosition;

          if (attrObj.isInstanced) {
            gl.vertexAttribDivisor(attrPosition, 1);
          }
        }
      }); //	check index buffer


      this._updateIndexBuffer(); //	UNBIND VAO


      gl.bindVertexArray(null);
      this._hasVAO = true;
    } else {
      //	ELSE, USE TRADITIONAL METHOD
      this._attributes.forEach(attrObj => {
        //	SKIP IF BUFFER HASN'T CHANGED
        if (this._bufferChanged.indexOf(attrObj.name) !== -1) {
          const buffer = getBuffer(attrObj);
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(gl.ARRAY_BUFFER, attrObj.dataArray, attrObj.drawType);
          const attrPosition = Object(_utils_getAttribLoc__WEBPACK_IMPORTED_MODULE_2__["default"])(gl, mShaderProgram, attrObj.name);
          gl.enableVertexAttribArray(attrPosition);
          gl.vertexAttribPointer(attrPosition, attrObj.itemSize, gl.FLOAT, false, 0, 0);
          attrObj.attrPosition = attrPosition;

          if (attrObj.isInstanced) {
            gl.vertexAttribDivisor(attrPosition, 1);
          }
        }
      });

      this._updateIndexBuffer();
    }

    this._hasIndexBufferChanged = false;
    this._bufferChanged = [];
  }

  unbind() {
    if (this._useVAO) {
      gl.bindVertexArray(null);
    }

    this._attributes.forEach(attribute => {
      if (attribute.isInstanced) {
        gl.vertexAttribDivisor(attribute.attrPosition, 0);
      }
    });
  }

  _updateIndexBuffer() {
    if (!this._hasIndexBufferChanged) {
      if (!this.iBuffer) {
        this.iBuffer = gl.createBuffer();
      }

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, this._drawType);
      this.iBuffer.itemSize = 1;
      this.iBuffer.numItems = this._numItems;
    }
  }

  computeNormals(usingFaceNormals = false) {
    this.generateFaces();

    if (usingFaceNormals) {
      this._computeFaceNormals();
    } else {
      this._computeVertexNormals();
    }
  } //	PRIVATE METHODS


  _computeFaceNormals() {
    let faceIndex;
    let face;
    const normals = [];

    for (let i = 0; i < this._indices.length; i += 3) {
      faceIndex = i / 3;
      face = this._faces[faceIndex];
      const N = face.normal;
      normals[face.indices[0]] = N;
      normals[face.indices[1]] = N;
      normals[face.indices[2]] = N;
    }

    this.bufferNormal(normals);
  }

  _computeVertexNormals() {
    //	loop through all vertices
    let face;
    const sumNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
    const normals = [];
    const {
      vertices
    } = this;

    for (let i = 0; i < vertices.length; i++) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(sumNormal, 0, 0, 0);

      for (let j = 0; j < this._faces.length; j++) {
        face = this._faces[j]; //	if vertex exist in the face, add the normal to sum normal

        if (face.indices.indexOf(i) >= 0) {
          sumNormal[0] += face.normal[0];
          sumNormal[1] += face.normal[1];
          sumNormal[2] += face.normal[2];
        }
      }

      gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].normalize(sumNormal, sumNormal);
      normals.push([sumNormal[0], sumNormal[1], sumNormal[2]]);
    }

    this.bufferNormal(normals);
  }

  generateFaces() {
    let ia, ib, ic;
    let a, b, c;
    const vba = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create(),
          vca = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create(),
          vNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
    const {
      vertices
    } = this;

    for (let i = 0; i < this._indices.length; i += 3) {
      ia = this._indices[i];
      ib = this._indices[i + 1];
      ic = this._indices[i + 2];
      a = vertices[ia];
      b = vertices[ib];
      c = vertices[ic];
      const face = {
        indices: [ia, ib, ic],
        vertices: [a, b, c]
      };

      this._faces.push(face);
    }
  }

  getAttribute(mName) {
    return this._attributes.find(a => a.name === mName);
  }

  getSource(mName) {
    const attr = this.getAttribute(mName);
    return attr ? attr.source : [];
  } //	GETTER AND SETTERS


  get vertices() {
    return this.getSource('aVertexPosition');
  }

  get normals() {
    return this.getSource('aNormal');
  }

  get coords() {
    return this.getSource('aTextureCoord');
  }

  get indices() {
    return this._indices;
  }

  get vertexSize() {
    return this.vertices.length;
  }

  get faces() {
    return this._faces;
  }

  get attributes() {
    return this._attributes;
  }

  get hasVAO() {
    return this._hasVAO;
  }

  get vao() {
    return this._vao;
  }

  get numInstance() {
    return this._numInstance;
  }

  get isInstanced() {
    return this._isInstanced;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Mesh);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/MultisampleFrameBuffer.js":
/*!*************************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/MultisampleFrameBuffer.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _GLTexture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLTexture */ "./src/js/libs/alfrid/alfrid/GLTexture.js");
// MultisampleFrameBuffer.js


let gl;

function isPowerOfTwo(x) {
  return x !== 0 && !(x & x - 1);
}

;

class MultisampleFrameBuffer {
  constructor(mWidth, mHeight, mParameters = {}) {
    gl = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl;
    this.width = mWidth;
    this.height = mHeight;
    this.magFilter = mParameters.magFilter || gl.LINEAR;
    this.minFilter = mParameters.minFilter || gl.LINEAR;
    this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
    this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;
    this.useDepth = mParameters.useDepth || true;
    this.useStencil = mParameters.useStencil || false;
    this.texelType = mParameters.type;
    this._numSample = mParameters.numSample || 8;

    if (!isPowerOfTwo(this.width) || !isPowerOfTwo(this.height)) {
      this.wrapS = this.wrapT = gl.CLAMP_TO_EDGE;

      if (this.minFilter === gl.LINEAR_MIPMAP_NEAREST) {
        this.minFilter = gl.LINEAR;
      }
    }

    this._init();
  }

  _init() {
    let texelType = gl.UNSIGNED_BYTE;

    if (this.texelType) {
      texelType = this.texelType;
    }

    this.texelType = texelType;
    this.frameBuffer = gl.createFramebuffer();
    this.frameBufferColor = gl.createFramebuffer();
    this.renderBufferColor = gl.createRenderbuffer();
    this.renderBufferDepth = gl.createRenderbuffer();
    this.glTexture = this._createTexture();
    this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT16, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, true);
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferColor);
    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._numSample, gl.RGBA8, this.width, this.height);
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferDepth);
    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._numSample, gl.DEPTH_COMPONENT16, this.width, this.height);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this.renderBufferColor);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBufferDepth);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferColor);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.glTexture.texture, 0); // gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null); // gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferDepth);
    // gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
    // gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  _createTexture(mInternalformat, mTexelType, mFormat, forceNearest = false) {
    if (mInternalformat === undefined) {
      mInternalformat = gl.RGBA;
    }

    if (mTexelType === undefined) {
      mTexelType = this.texelType;
    }

    if (!mFormat) {
      mFormat = mInternalformat;
    }

    const t = gl.createTexture();
    const glt = new _GLTexture__WEBPACK_IMPORTED_MODULE_1__["default"](t, true);
    const magFilter = forceNearest ? _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].NEAREST : this.magFilter;
    const minFilter = forceNearest ? _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].NEAREST : this.minFilter;
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.wrapS);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.wrapT);
    gl.texImage2D(gl.TEXTURE_2D, 0, mInternalformat, this.width, this.height, 0, mFormat, mTexelType, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return glt;
  }

  bind(mAutoSetViewport = true) {
    if (mAutoSetViewport) {
      _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].viewport(0, 0, this.width, this.height);
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
  }

  unbind(mAutoSetViewport = true) {
    if (mAutoSetViewport) {
      _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].viewport(0, 0, _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].width, _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].height);
    }

    const {
      width,
      height
    } = this;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBufferColor);
    gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 0.0]);
    gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].NEAREST); // gl.blitFramebuffer(
    // 	0, 0, width, height,
    // 	0, 0, width, height,
    // 	gl.COLOR_BUFFER_BIT|gl.DEPTH_STENCIL, GL.NEAREST
    // );
    // gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
    // gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBufferDepth);
    // gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1.0, 0);
    // gl.blitFramebuffer(
    // 	0, 0, width, height,
    // 	0, 0, width, height,
    // 	gl.DEPTH_BUFFER_BIT, gl.NEAREST
    // );

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  getTexture(mIndex = 0) {
    return this.glTexture;
  }

  getDepthTexture() {
    return this.glDepthTexture;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (MultisampleFrameBuffer);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/TransformFeedbackObject.js":
/*!**************************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/TransformFeedbackObject.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _GLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Mesh */ "./src/js/libs/alfrid/alfrid/Mesh.js");
// TransformFeedbackObject.js



let gl;

class TransformFeedbackObject {
  constructor(strVertexShader, strFragmentShader) {
    gl = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl;
    this._vs = strVertexShader;
    this._fs = strFragmentShader;

    this._init();
  }

  _init() {
    this._meshCurrent = new _Mesh__WEBPACK_IMPORTED_MODULE_2__["default"]();
    this._meshTarget = new _Mesh__WEBPACK_IMPORTED_MODULE_2__["default"]();
    this._numPoints = -1;
    this._varyings = [];
    this.transformFeedback = gl.createTransformFeedback();
  }

  bufferData(mData, mName, mVaryingName) {
    const isTransformFeedback = !!mVaryingName;
    console.log('is Transform feedback ?', mName, isTransformFeedback);

    this._meshCurrent.bufferData(mData, mName, null, gl.STREAM_COPY, false);

    this._meshTarget.bufferData(mData, mName, null, gl.STREAM_COPY, false);

    if (isTransformFeedback) {
      this._varyings.push(mVaryingName);

      if (this._numPoints < 0) {
        this._numPoints = mData.length;
      }
    }
  }

  bufferIndex(mArrayIndices) {
    this._meshCurrent.bufferIndex(mArrayIndices);

    this._meshTarget.bufferIndex(mArrayIndices);
  }

  uniform(mName, mType, mValue) {
    if (this.shader) {
      this.shader.uniform(mName, mType, mValue);
    }
  }

  generate() {
    this.shader = new _GLShader__WEBPACK_IMPORTED_MODULE_1__["default"](this._vs, this._fs, this._varyings);
  }

  render() {
    if (!this.shader) {
      this.generate();
    }

    this.shader.bind();
    _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].drawTransformFeedback(this);

    this._swap();
  }

  _swap() {
    const tmp = this._meshCurrent;
    this._meshCurrent = this._meshTarget;
    this._meshTarget = tmp;
  }

  get numPoints() {
    return this._numPoints;
  }

  get meshCurrent() {
    return this._meshCurrent;
  }

  get meshTarget() {
    return this._meshTarget;
  }

  get meshSource() {
    return this._meshCurrent;
  }

  get meshDestination() {
    return this._meshTarget;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (TransformFeedbackObject);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/cameras/Camera.js":
/*!*****************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/cameras/Camera.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
// Camera.js


class Camera {
  constructor() {
    //	VIEW MATRIX
    this._matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create(); //	FOR TRANSFORM FROM ORIENTATION

    this._quat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].create();
    this._orientation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create(); //	PROJECTION MATRIX

    this._projection = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create(); //	POSITION OF CAMERA

    this.position = vec3.create();
  }

  lookAt(aEye, aCenter, aUp = [0, 1, 0]) {
    this._eye = vec3.clone(aEye);
    this._center = vec3.clone(aCenter);
    vec3.copy(this.position, aEye);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(this._matrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].lookAt(this._matrix, aEye, aCenter, aUp);
  }

  setFromOrientation(x, y, z, w) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].set(this._quat, x, y, z, w);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].fromQuat(this._orientation, this._quat);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(this._matrix, this._orientation, this.positionOffset);
  }

  setProjection(mProj) {
    this._projection = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].clone(mProj);
  }

  setView(mView) {
    this._matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].clone(mView);
  }

  setFromViewProj(mView, mProj) {
    this.setView(mView);
    this.setProjection(mProj);
  } //	GETTERS 


  get matrix() {
    return this._matrix;
  }

  get viewMatrix() {
    return this._matrix;
  }

  get projection() {
    return this._projection;
  }

  get projectionMatrix() {
    return this._projection;
  }

  get eye() {
    return this._eye;
  }

  get center() {
    return this._center;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Camera);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/cameras/CameraCube.js":
/*!*********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/cameras/CameraCube.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CameraPerspective__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CameraPerspective */ "./src/js/libs/alfrid/alfrid/cameras/CameraPerspective.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
// CameraCube.js




const CAMERA_SETTINGS = [[gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(-1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 0, 1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, -1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 0, -1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 0, 1), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 0, -1), gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, -1, 0)]];

class CameraCube extends _CameraPerspective__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();
    this.setPerspective(Math.PI / 2, 1, 0.1, 1000);
  }

  face(mIndex) {
    const o = CAMERA_SETTINGS[mIndex];
    this.lookAt(o[0], o[1], o[2]);
  }

}

/* harmony default export */ __webpack_exports__["default"] = (CameraCube);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/cameras/CameraOrtho.js":
/*!**********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/cameras/CameraOrtho.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Camera */ "./src/js/libs/alfrid/alfrid/cameras/Camera.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
// CameraOrtho.js



class CameraOrtho extends _Camera__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();
    const eye = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].clone([0, 0, 5]);
    const center = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
    const up = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].clone([0, 1, 0]);
    this.lookAt(eye, center, up);
    this.ortho(-1, 1, 1, -1);
  }

  setBoundary(left, right, top, bottom, near = 0.1, far = 100) {
    this.ortho(left, right, top, bottom, near, far);
  }

  ortho(left, right, top, bottom, near = 0.1, far = 100) {
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    mat4.ortho(this._projection, left, right, bottom, top, near, far);
  }

}

/* harmony default export */ __webpack_exports__["default"] = (CameraOrtho);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/cameras/CameraPerspective.js":
/*!****************************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/cameras/CameraPerspective.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Camera */ "./src/js/libs/alfrid/alfrid/cameras/Camera.js");
/* harmony import */ var _math_Ray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Ray */ "./src/js/libs/alfrid/alfrid/math/Ray.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
// CameraPerspective.js



const mInverseViewProj = gl_matrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].create();
const cameraDir = gl_matrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();

class CameraPerspective extends _Camera__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(mFov, mAspectRatio, mNear, mFar) {
    super();

    if (mFov) {
      this.setPerspective(mFov, mAspectRatio, mNear, mFar);
    }
  }

  setPerspective(mFov, mAspectRatio, mNear, mFar) {
    this._fov = mFov;
    this._near = mNear;
    this._far = mFar;
    this._aspectRatio = mAspectRatio;
    gl_matrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].perspective(this._projection, mFov, mAspectRatio, mNear, mFar); // this._frustumTop = this._near * Math.tan(this._fov * 0.5);
    // this._frustumButtom = -this._frustumTop;
    // this._frustumRight = this._frustumTop * this._aspectRatio;
    // this._frustumLeft = -this._frustumRight;
  }

  setAspectRatio(mAspectRatio) {
    this._aspectRatio = mAspectRatio;
    gl_matrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].perspective(this.projection, this._fov, mAspectRatio, this._near, this._far);
  }

  generateRay(mScreenPosition, mRay) {
    const proj = this.projectionMatrix;
    const view = this.viewMatrix;
    gl_matrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].multiply(mInverseViewProj, proj, view);
    gl_matrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].invert(mInverseViewProj, mInverseViewProj);
    gl_matrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].transformMat4(cameraDir, mScreenPosition, mInverseViewProj);
    gl_matrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].sub(cameraDir, cameraDir, this.position);
    gl_matrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].normalize(cameraDir, cameraDir);

    if (!mRay) {
      mRay = new _math_Ray__WEBPACK_IMPORTED_MODULE_1__["default"](this.position, cameraDir);
    } else {
      mRay.origin = this.position;
      mRay.direction = cameraDir;
    }

    return mRay;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (CameraPerspective);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/helpers/BatchAxis.js":
/*!********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/helpers/BatchAxis.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Mesh */ "./src/js/libs/alfrid/alfrid/Mesh.js");
/* harmony import */ var _GLShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
/* harmony import */ var _Batch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Batch */ "./src/js/libs/alfrid/alfrid/Batch.js");
/* harmony import */ var _shaders_axis_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/axis.vert */ "./src/js/libs/alfrid/alfrid/shaders/axis.vert");
/* harmony import */ var _shaders_axis_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shaders/axis.frag */ "./src/js/libs/alfrid/alfrid/shaders/axis.frag");
// BatchAxis.js







class BatchAxis extends _Batch__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor() {
    const positions = [];
    const colors = [];
    const indices = [0, 1, 2, 3, 4, 5];
    const r = 9999;
    positions.push([-r, 0, 0]);
    positions.push([r, 0, 0]);
    positions.push([0, -r, 0]);
    positions.push([0, r, 0]);
    positions.push([0, 0, -r]);
    positions.push([0, 0, r]);
    colors.push([1, 0, 0]);
    colors.push([1, 0, 0]);
    colors.push([0, 1, 0]);
    colors.push([0, 1, 0]);
    colors.push([0, 0, 1]);
    colors.push([0, 0, 1]);
    const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_1__["default"](_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].LINES);
    mesh.bufferVertex(positions);
    mesh.bufferIndex(indices);
    mesh.bufferData(colors, 'aColor', 3);
    const shader = new _GLShader__WEBPACK_IMPORTED_MODULE_2__["default"](_shaders_axis_vert__WEBPACK_IMPORTED_MODULE_4__["default"], _shaders_axis_frag__WEBPACK_IMPORTED_MODULE_5__["default"]);
    super(mesh, shader);
  }

}

/* harmony default export */ __webpack_exports__["default"] = (BatchAxis);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/helpers/BatchBall.js":
/*!********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/helpers/BatchBall.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geom */ "./src/js/libs/alfrid/alfrid/Geom.js");
/* harmony import */ var _GLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
/* harmony import */ var _Batch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Batch */ "./src/js/libs/alfrid/alfrid/Batch.js");
/* harmony import */ var _shaders_general_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/general.vert */ "./src/js/libs/alfrid/alfrid/shaders/general.vert");
/* harmony import */ var _shaders_simpleColor_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/simpleColor.frag */ "./src/js/libs/alfrid/alfrid/shaders/simpleColor.frag");
// BatchBall.js






class BatchBall extends _Batch__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    const mesh = _Geom__WEBPACK_IMPORTED_MODULE_0__["default"].sphere(1, 24);
    const shader = new _GLShader__WEBPACK_IMPORTED_MODULE_1__["default"](_shaders_general_vert__WEBPACK_IMPORTED_MODULE_3__["default"], _shaders_simpleColor_frag__WEBPACK_IMPORTED_MODULE_4__["default"]);
    super(mesh, shader);
  }

  draw(position = [0, 0, 0], scale = [1, 1, 1], color = [1, 1, 1], opacity = 1) {
    this.shader.bind();
    this.shader.uniform('position', 'uniform3fv', position);
    this.shader.uniform('scale', 'uniform3fv', scale);
    this.shader.uniform('color', 'uniform3fv', color);
    this.shader.uniform('opacity', 'uniform1f', opacity);
    super.draw();
  }

}

/* harmony default export */ __webpack_exports__["default"] = (BatchBall);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/helpers/BatchCopy.js":
/*!********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/helpers/BatchCopy.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geom */ "./src/js/libs/alfrid/alfrid/Geom.js");
/* harmony import */ var _GLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
/* harmony import */ var _Batch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Batch */ "./src/js/libs/alfrid/alfrid/Batch.js");
/* harmony import */ var _shaders_bigTriangle_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/bigTriangle.vert */ "./src/js/libs/alfrid/alfrid/shaders/bigTriangle.vert");
/* harmony import */ var _shaders_copy_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/copy.frag */ "./src/js/libs/alfrid/alfrid/shaders/copy.frag");
// BatchCopy.js






class BatchCopy extends _Batch__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    const mesh = _Geom__WEBPACK_IMPORTED_MODULE_0__["default"].bigTriangle();
    const shader = new _GLShader__WEBPACK_IMPORTED_MODULE_1__["default"](_shaders_bigTriangle_vert__WEBPACK_IMPORTED_MODULE_3__["default"], _shaders_copy_frag__WEBPACK_IMPORTED_MODULE_4__["default"]);
    super(mesh, shader);
    shader.bind();
    shader.uniform('texture', 'uniform1i', 0);
  }

  draw(texture) {
    this.shader.bind();
    texture.bind(0);
    super.draw();
  }

}

/* harmony default export */ __webpack_exports__["default"] = (BatchCopy);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/helpers/BatchDotsPlane.js":
/*!*************************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/helpers/BatchDotsPlane.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Mesh */ "./src/js/libs/alfrid/alfrid/Mesh.js");
/* harmony import */ var _GLShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
/* harmony import */ var _Batch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Batch */ "./src/js/libs/alfrid/alfrid/Batch.js");
/* harmony import */ var _shaders_dotsPlane_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/dotsPlane.vert */ "./src/js/libs/alfrid/alfrid/shaders/dotsPlane.vert");
/* harmony import */ var _shaders_dotsPlane_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shaders/dotsPlane.frag */ "./src/js/libs/alfrid/alfrid/shaders/dotsPlane.frag");
// BatchDotsPlane.js







class BatchDotsPlane extends _Batch__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor() {
    const positions = [];
    const indices = [];
    let index = 0;
    const size = 100;
    let i, j;

    for (i = -size; i < size; i += 1) {
      for (j = -size; j < size; j += 1) {
        positions.push([i, j, 0]);
        indices.push(index);
        index++;
        positions.push([i, 0, j]);
        indices.push(index);
        index++;
      }
    }

    const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_1__["default"](_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].POINTS);
    mesh.bufferVertex(positions);
    mesh.bufferIndex(indices);
    const shader = new _GLShader__WEBPACK_IMPORTED_MODULE_2__["default"](_shaders_dotsPlane_vert__WEBPACK_IMPORTED_MODULE_4__["default"], _shaders_dotsPlane_frag__WEBPACK_IMPORTED_MODULE_5__["default"]);
    super(mesh, shader);
    this.color = [1, 1, 1];
    this.opacity = 0.65;
  }

  draw() {
    this.shader.bind();
    this.shader.uniform('color', 'uniform3fv', this.color);
    this.shader.uniform('opacity', 'uniform1f', this.opacity);
    this.shader.uniform('viewport', 'vec2', [_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].width, _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].height]); // GL.draw(this.mesh);

    super.draw();
  }

}

/* harmony default export */ __webpack_exports__["default"] = (BatchDotsPlane);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/helpers/BatchLine.js":
/*!********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/helpers/BatchLine.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Batch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Batch */ "./src/js/libs/alfrid/alfrid/Batch.js");
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _GLShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Mesh */ "./src/js/libs/alfrid/alfrid/Mesh.js");
/* harmony import */ var _shaders_simpleColor_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/simpleColor.frag */ "./src/js/libs/alfrid/alfrid/shaders/simpleColor.frag");
/* harmony import */ var _shaders_basic_vert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shaders/basic.vert */ "./src/js/libs/alfrid/alfrid/shaders/basic.vert");
// BatchLine.js







class BatchAxis extends _Batch__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    const positions = [];
    const indices = [0, 1];
    const coords = [[0, 0], [1, 1]];
    positions.push([0, 0, 0]);
    positions.push([0, 0, 0]);
    const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_3__["default"](_GLTool__WEBPACK_IMPORTED_MODULE_1__["default"].LINES);
    mesh.bufferVertex(positions);
    mesh.bufferTexCoord(coords);
    mesh.bufferIndex(indices);
    const shader = new _GLShader__WEBPACK_IMPORTED_MODULE_2__["default"](_shaders_basic_vert__WEBPACK_IMPORTED_MODULE_5__["default"], _shaders_simpleColor_frag__WEBPACK_IMPORTED_MODULE_4__["default"]);
    super(mesh, shader);
  }

  draw(mPositionA, mPositionB, color = [1, 1, 1], opacity = 1.0) {
    this._mesh.bufferVertex([mPositionA, mPositionB]);

    this._shader.bind();

    this._shader.uniform('color', 'vec3', color);

    this._shader.uniform('opacity', 'float', opacity);

    super.draw();
  }

}

/* harmony default export */ __webpack_exports__["default"] = (BatchAxis);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/helpers/BatchSky.js":
/*!*******************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/helpers/BatchSky.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Batch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Batch */ "./src/js/libs/alfrid/alfrid/Batch.js");
/* harmony import */ var _GLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
/* harmony import */ var _Geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Geom */ "./src/js/libs/alfrid/alfrid/Geom.js");
/* harmony import */ var _shaders_copy_frag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/copy.frag */ "./src/js/libs/alfrid/alfrid/shaders/copy.frag");
/* harmony import */ var _shaders_sky_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/sky.vert */ "./src/js/libs/alfrid/alfrid/shaders/sky.vert");
// BatchSky.js






class BatchSky extends _Batch__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(size = 50, seg = 24) {
    const mesh = _Geom__WEBPACK_IMPORTED_MODULE_2__["default"].sphere(size, seg, true);
    const shader = new _GLShader__WEBPACK_IMPORTED_MODULE_1__["default"](_shaders_sky_vert__WEBPACK_IMPORTED_MODULE_4__["default"], _shaders_copy_frag__WEBPACK_IMPORTED_MODULE_3__["default"]);
    super(mesh, shader);
  }

  draw(texture) {
    this.shader.bind();
    texture.bind(0);
    super.draw();
  }

}

/* harmony default export */ __webpack_exports__["default"] = (BatchSky);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/helpers/BatchSkybox.js":
/*!**********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/helpers/BatchSkybox.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Batch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Batch */ "./src/js/libs/alfrid/alfrid/Batch.js");
/* harmony import */ var _GLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
/* harmony import */ var _Geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Geom */ "./src/js/libs/alfrid/alfrid/Geom.js");
/* harmony import */ var _shaders_skybox_frag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/skybox.frag */ "./src/js/libs/alfrid/alfrid/shaders/skybox.frag");
/* harmony import */ var _shaders_skybox_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/skybox.vert */ "./src/js/libs/alfrid/alfrid/shaders/skybox.vert");
// BatchSkybox.js






class BatchSkybox extends _Batch__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(size = 20) {
    const mesh = _Geom__WEBPACK_IMPORTED_MODULE_2__["default"].skybox(size);
    const shader = new _GLShader__WEBPACK_IMPORTED_MODULE_1__["default"](_shaders_skybox_vert__WEBPACK_IMPORTED_MODULE_4__["default"], _shaders_skybox_frag__WEBPACK_IMPORTED_MODULE_3__["default"]);
    super(mesh, shader);
  }

  draw(texture) {
    this.shader.bind();
    texture.bind(0);
    super.draw();
  }

}

/* harmony default export */ __webpack_exports__["default"] = (BatchSkybox);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/helpers/Draw.js":
/*!***************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/helpers/Draw.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Mesh */ "./src/js/libs/alfrid/alfrid/Mesh.js");
/* harmony import */ var _GLShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
// Draw.js




class Draw {
  constructor() {
    this._uniforms = {};
    this._uniformTextures = [];
    this._fbo;
    this._clearColor = {
      r: 0,
      g: 0,
      b: 0,
      a: 0
    };
    return this;
  }

  setClearColor(r = 0, g = 0, b = 0, a = 0) {
    this._clearColor.r = r;
    this._clearColor.g = g;
    this._clearColor.b = b;
    this._clearColor.a = a;
    return this;
  }

  useProgram(vs, fs) {
    if (vs instanceof _GLShader__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      this._shader = vs;
    } else {
      this._shader = new _GLShader__WEBPACK_IMPORTED_MODULE_2__["default"](vs, fs);
    }

    return this;
  }

  setMesh(mMesh) {
    this._mesh = mMesh;
    return this;
  }

  createMesh(mType) {
    this._mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_1__["default"](mType);
    return this;
  }

  bufferVertex(mArrayVertices) {
    if (!this._mesh) {
      this._mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_1__["default"]();
    }

    this._mesh.bufferVertex(mArrayVertices);

    return this;
  }

  bufferTexCoord(mArrayTexCoords) {
    if (!this._mesh) {
      this._mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_1__["default"]();
    }

    this._mesh.bufferTexCoord(mArrayTexCoords);

    return this;
  }

  bufferNormal(mArrayNormals) {
    if (!this._mesh) {
      this._mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_1__["default"]();
    }

    this._mesh.bufferNormal(mArrayNormals);

    return this;
  }

  bufferIndex(mIndices) {
    if (!this._mesh) {
      this._mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_1__["default"]();
    }

    this._mesh.bufferIndex(mIndices);

    return this;
  }

  bufferInstance(mData, mName) {
    if (!this._mesh) {
      console.warn('Need to create mesh first');
      return this;
    }

    this._mesh.bufferInstance(mData, mName);

    return this;
  }

  bufferData(mArrayData, mName) {
    if (!this._mesh) {
      this._mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_1__["default"]();
    }

    this._mesh.bufferData(mArrayData, mName);

    return this;
  }

  uniform(name, type, value) {
    this._uniforms[name] = {
      type,
      value
    };
    return this;
  }

  uniformTexture(name, texture, index) {
    if (index !== undefined) {
      this._uniformTextures[index] = {
        name,
        texture
      };
    } else {
      this._uniformTextures.push({
        name,
        texture
      });
    }

    return this;
  }

  bindFrameBuffer(fbo) {
    this._fbo = fbo;
    return this;
  }

  draw() {
    if (!this._shader) {
      return;
    }

    if (!this._mesh) {
      return;
    }

    if (this._fbo) {
      const {
        r,
        g,
        b,
        a
      } = this._clearColor;

      this._fbo.bind();

      _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].clear(r, g, b, a);
    }

    this._shader.bind();

    for (const s in this._uniforms) {
      const o = this._uniforms[s];

      this._shader.uniform(s, o.type, o.value);
    }

    this._uniformTextures.forEach((o, i) => {
      if (o !== undefined) {
        this._shader.uniform(o.name, 'uniform1i', i);

        o.texture.bind(i);
      }
    });

    _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].draw(this._mesh);

    if (this._fbo) {
      this._fbo.unbind();
    }

    return this;
  }

  get shader() {
    return this._shader;
  }

  get framebuffer() {
    return this._fbo;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Draw);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/helpers/Scene.js":
/*!****************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/helpers/Scene.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cameras_CameraOrtho__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cameras/CameraOrtho */ "./src/js/libs/alfrid/alfrid/cameras/CameraOrtho.js");
/* harmony import */ var _cameras_CameraPerspective__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cameras/CameraPerspective */ "./src/js/libs/alfrid/alfrid/cameras/CameraPerspective.js");
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _utils_OrbitalControl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/OrbitalControl */ "./src/js/libs/alfrid/alfrid/utils/OrbitalControl.js");
/* harmony import */ var scheduling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! scheduling */ "./node_modules/scheduling/src/scheduler.js");
// Scene.js






class Scene {
  constructor(options = {}) {
    this._children = [];
    this._matrixIdentity = mat4.create();
    _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].enableAlphaBlending();

    this._init(options);

    this._initTextures(options);

    this._initViews(options);

    this._efIndex = scheduling__WEBPACK_IMPORTED_MODULE_4__["default"].addEF(() => this._loop());
    this._targetListener = options.container || window;
    window.addEventListener('resize', () => this.resize());
  } //	PUBLIC METHODS


  update() {}

  render() {}

  stop() {
    if (this._efIndex === -1) {
      return;
    }

    this._efIndex = scheduling__WEBPACK_IMPORTED_MODULE_4__["default"].removeEF(this._efIndex);
  }

  start() {
    if (this._efIndex !== -1) {
      return;
    }

    this._efIndex = scheduling__WEBPACK_IMPORTED_MODULE_4__["default"].addEF(() => this._loop());
  }

  resize(width, height) {
    _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].setSize(width || window.innerWidth, height || window.innerHeight);
    this.camera.setAspectRatio(_GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].aspectRatio);
  }

  addChild(mChild) {
    this._children.push(mChild);
  }

  removeChild(mChild) {
    const index = this._children.indexOf(mChild);

    if (index == -1) {
      console.warn('Child no exist');
      return;
    }

    this._children.splice(index, 1);
  } //	PROTECTED METHODS TO BE OVERRIDEN BY CHILDREN


  _initTextures() {}

  _initViews() {}

  _renderChildren() {
    let child;

    for (let i = 0; i < this._children.length; i++) {
      child = this._children[i];
      child.toRender();
    }

    _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].rotate(this._matrixIdentity);
  } //	PRIVATE METHODS


  _init(options) {
    this.camera = new _cameras_CameraPerspective__WEBPACK_IMPORTED_MODULE_1__["default"]();
    this.camera.setPerspective(45 * Math.PI / 180, _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].aspectRatio, 0.1, 100);
    this.orbitalControl = new _utils_OrbitalControl__WEBPACK_IMPORTED_MODULE_3__["default"](this.camera, this._targetListener, 15);
    console.log('options', options);

    if (!options.noControl) {
      this.orbitalControl.connect();
    }

    this.orbitalControl.radius.value = 10;
    this.cameraOrtho = new _cameras_CameraOrtho__WEBPACK_IMPORTED_MODULE_0__["default"]();
  }

  _loop() {
    //	RESET VIEWPORT
    _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].viewport(0, 0, _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].width, _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].height); //	RESET CAMERA

    _GLTool__WEBPACK_IMPORTED_MODULE_2__["default"].setMatrices(this.camera);
    this.update();

    this._renderChildren();

    this.render();
  }

  destroy() {
    this.orbitalControl.disconnect();
    alfrid.Scheduler.removeEF(this._efIndex);
    window.removeEventListener('resize', () => this.resize());
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Scene);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/helpers/View.js":
/*!***************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/helpers/View.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _GLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
// View.js



class View {
  constructor(mStrVertex, mStrFrag) {
    this.shader = new _GLShader__WEBPACK_IMPORTED_MODULE_1__["default"](mStrVertex, mStrFrag);

    this._init();
  } //	PROTECTED METHODS


  _init() {} // 	PUBLIC METHODS


  render() {}

  destroy() {
    const gl = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl;
    gl.useProgram(null);
    gl.deleteProgram(this.shader.shaderProgram);
  }

}

/* harmony default export */ __webpack_exports__["default"] = (View);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/helpers/View3D.js":
/*!*****************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/helpers/View3D.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _GLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GLShader */ "./src/js/libs/alfrid/alfrid/GLShader.js");
/* harmony import */ var _objects_Object3D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../objects/Object3D */ "./src/js/libs/alfrid/alfrid/objects/Object3D.js");
// View3D.js




class View3D extends _objects_Object3D__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(mStrVertex, mStrFrag) {
    super();
    this._children = [];
    this.shader = new _GLShader__WEBPACK_IMPORTED_MODULE_1__["default"](mStrVertex, mStrFrag);

    this._init();
  } //	PROTECTED METHODS


  _init() {} // 	PUBLIC METHODS


  render() {}

  destroy() {
    const gl = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl;
    gl.useProgram(null);
    gl.deleteProgram(this.shader.shaderProgram);
  }

}

/* harmony default export */ __webpack_exports__["default"] = (View3D);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/loaders/BinaryLoader.js":
/*!***********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/loaders/BinaryLoader.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// BinaryLoader.js
class BinaryLoader {
  constructor(isArrayBuffer = false) {
    this._req = new XMLHttpRequest();

    this._req.addEventListener('load', e => this._onLoaded(e));

    this._req.addEventListener('progress', e => this._onProgress(e));

    if (isArrayBuffer) {
      this._req.responseType = 'arraybuffer';
    }
  }

  load(url, callback) {
    console.log('Loading : ', url);
    this._callback = callback;

    this._req.open('GET', url);

    this._req.send();
  }

  _onLoaded() {
    this._callback(this._req.response);
  }

  _onProgress()
  /* e*/
  {// console.log('on Progress:', (e.loaded/e.total*100).toFixed(2));
  }

}

/* harmony default export */ __webpack_exports__["default"] = (BinaryLoader);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/loaders/GLTFParser.js":
/*!*********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/loaders/GLTFParser.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Mesh */ "./src/js/libs/alfrid/alfrid/Mesh.js");
// GLTFParser.js

const ARRAY_CTOR_MAP = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
const SIZE_MAP = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
const semanticAttributeMap = {
  NORMAL: 'aNormal',
  POSITION: 'aVertexPosition',
  // 'TANGENT': 'aTangent',
  TEXCOORD_0: 'aTextureCoord',
  // TEXCOORD_1: 'aTextureCoord1',
  WEIGHTS_0: 'aWeight',
  JOINTS_0: 'aJoint',
  COLOR: 'aColor'
};

const parse = (gltf, bin) => new Promise((resolve, reject) => {
  gltf.output = {
    meshes: [],
    scenes: [],
    textures: []
  };

  _getBufferViewData(gltf, bin).then(_parseMesh).then(gltfInfo => {
    resolve(gltfInfo);
  }).catch(e => {
    console.log('Error:', e);
  }); // resolve(o);

});

const _getBufferViewData = (gltfInfo, bin) => new Promise((resolve, reject) => {
  const {
    bufferViews,
    buffers
  } = gltfInfo;
  bufferViews.forEach((bufferViewInfo, i) => {
    const buffer = bin;
    bufferViewInfo.data = buffer.slice(bufferViewInfo.byteOffset || 0, (bufferViewInfo.byteOffset || 0) + (bufferViewInfo.byteLength || 0));
  });
  resolve(gltfInfo);
});

const _parseMesh = gltf => new Promise((resolve, reject) => {
  const {
    meshes
  } = gltf;
  gltf.geometries = [];
  meshes.forEach((mesh, i) => {
    const {
      primitives
    } = mesh;
    const geometry = {};
    primitives.forEach((primitiveInfo, i) => {
      const semantics = Object.keys(primitiveInfo.attributes);
      let defines = {};
      semantics.forEach((semantic, i) => {
        const accessorIdx = primitiveInfo.attributes[semantic];
        const attributeInfo = gltf.accessors[accessorIdx];
        const attributeName = semanticAttributeMap[semantic];

        if (!attributeName) {
          return;
        }

        if (semantic === 'NORMAL') {
          defines.HAS_NORMALS = 1;
        }

        if (semantic.indexOf('TEXCOORD') > -1) {
          defines.HAS_UV = 1;
        }

        const size = SIZE_MAP[attributeInfo.type];

        let attributeArray = _getAccessorData(gltf, accessorIdx);

        if (attributeArray instanceof Uint32Array) {
          attributeArray = new Float32Array(attributeArray);
        }

        if (semantic === 'TEXCOORD_1') {
          console.log(size, attributeArray);
        }

        geometry[attributeName] = {
          value: attributeArray,
          size
        }; // console.log('attribute', attributeName, geometry[attributeName]);
      }); //	parse index

      if (primitiveInfo.indices != null) {
        const attributeArray = _getAccessorData(gltf, primitiveInfo.indices, true);

        geometry.indices = {
          value: attributeArray,
          size: 1
        };
      }

      const m = new _Mesh__WEBPACK_IMPORTED_MODULE_0__["default"]();

      for (const s in geometry) {
        const data = geometry[s];

        if (s !== 'indices') {
          m.bufferFlattenData(data.value, s, data.size);
        } else {
          m.bufferIndex(data.value);
        }
      }

      gltf.output.meshes.push(m);

      if (primitiveInfo.material) {
        console.log('gltf.output', gltf.output, primitiveInfo.material);
        const material = gltf.output.materials[primitiveInfo.material];
        m.material = material;
        defines = objectAssign(defines, m.material.defines);
        m.defines = defines;
        const shader = Shaders.get(ShaderLibs.gltfVert, ShaderLibs.gltfFrag, defines);
        const {
          emissiveFacotr,
          normalTexture,
          occlusionTexture,
          pbrMetallicRoughness
        } = material;
        const {
          baseColorTexture,
          metallicRoughnessTexture
        } = pbrMetallicRoughness;
        const uniforms = {
          uEmissiveFactor: emissiveFacotr || [0, 0, 0],
          uBaseColor: pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1],
          uRoughness: pbrMetallicRoughness.roughnessFactor || 1,
          uMetallic: pbrMetallicRoughness.metallicFactor || 1,
          uScaleDiffBaseMR: [0, 0, 0, 0],
          uScaleFGDSpec: [0, 0, 0, 0],
          uScaleIBLAmbient: [1, 1, 1, 1],
          uLightDirection: [1, 1, 1],
          uLightColor: [1, 1, 1],
          uGamma: 1
        };

        if (baseColorTexture) {
          uniforms.uColorMap = baseColorTexture.glTexture;
        }

        if (metallicRoughnessTexture) {
          uniforms.uMetallicRoughnessMap = metallicRoughnessTexture.glTexture;
        }

        if (normalTexture) {
          uniforms.uNormalScale = normalTexture.scale || 1;
          uniforms.uNormalMap = normalTexture.glTexture;
        }

        if (occlusionTexture) {
          uniforms.uAoMap = occlusionTexture.glTexture;
          uniforms.uOcclusionStrength = occlusionTexture.strength || 1;
        }

        shader.bind();
        shader.uniform(uniforms);
        m.material.shader = shader;
        m.material.uniforms = uniforms;
      }

      gltf.geometries.push(geometry);
    });
  });
  resolve(gltf);
});

const _getAccessorData = (gltf, accessorIdx, isIndices = false) => {
  const accessorInfo = gltf.accessors[accessorIdx];
  const buffer = gltf.bufferViews[accessorInfo.bufferView].data;
  const byteOffset = accessorInfo.byteOffset || 0;
  const ArrayCtor = ARRAY_CTOR_MAP[accessorInfo.componentType] || Float32Array;
  let size = SIZE_MAP[accessorInfo.type];

  if (size == null && isIndices) {
    size = 1;
  }

  let arr = new ArrayCtor(buffer, byteOffset, size * accessorInfo.count);
  const quantizeExtension = accessorInfo.extensions && accessorInfo.extensions['WEB3D_quantized_attributes'];

  if (quantizeExtension) {
    const decodedArr = new Float32Array(size * accessorInfo.count);
    const decodeMatrix = quantizeExtension.decodeMatrix;
    const decodeOffset = new Array(size);
    const decodeScale = new Array(size);

    for (let k = 0; k < size; k++) {
      decodeOffset[k] = decodeMatrix[size * (size + 1) + k];
      decodeScale[k] = decodeMatrix[k * (size + 1) + k];
    }

    for (let i = 0; i < accessorInfo.count; i++) {
      for (let k = 0; k < size; k++) {
        decodedArr[i * size + k] = arr[i * size + k] * decodeScale[k] + decodeOffset[k];
      }
    }

    arr = decodedArr;
  } // console.log({buffer, byteOffset, ArrayCtor, size, arr});


  return arr;
};

/* harmony default export */ __webpack_exports__["default"] = ({
  parse
});

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/loaders/HDRLoader.js":
/*!********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/loaders/HDRLoader.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BinaryLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryLoader */ "./src/js/libs/alfrid/alfrid/loaders/BinaryLoader.js");
/* harmony import */ var _utils_HDRParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/HDRParser */ "./src/js/libs/alfrid/alfrid/utils/HDRParser.js");
// HDRLoader.js





class HDRLoader extends _BinaryLoader__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super(true);
  }

  parse(mArrayBuffer) {
    return Object(_utils_HDRParser__WEBPACK_IMPORTED_MODULE_1__["default"])(mArrayBuffer);
  }

  _onLoaded() {
    const o = this.parse(this._req.response);

    if (this._callback) {
      this._callback(o);
    }
  }

}

HDRLoader.parse = function (mArrayBuffer) {
  return Object(_utils_HDRParser__WEBPACK_IMPORTED_MODULE_1__["default"])(mArrayBuffer);
};

/* harmony default export */ __webpack_exports__["default"] = (HDRLoader);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/loaders/ObjLoader.js":
/*!********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/loaders/ObjLoader.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BinaryLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryLoader */ "./src/js/libs/alfrid/alfrid/loaders/BinaryLoader.js");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Mesh */ "./src/js/libs/alfrid/alfrid/Mesh.js");
// ObjLoader.js





class ObjLoader extends _BinaryLoader__WEBPACK_IMPORTED_MODULE_0__["default"] {
  load(url, callback, drawType = 4) {
    this._drawType = drawType;
    super.load(url, callback);
  }

  _onLoaded() {
    this.parseObj(this._req.response);
  }

  parseObj(objStr) {
    const lines = objStr.split('\n');
    const positions = [];
    const coords = [];
    const finalNormals = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    let count = 0;
    let result; // v float float float

    const vertexPattern = /v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/; // vn float float float

    const normalPattern = /vn( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/; // vt float float

    const uvPattern = /vt( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/; // f vertex vertex vertex ...

    const facePattern1 = /f( +-?\d+)( +-?\d+)( +-?\d+)( +-?\d+)?/; // f vertex/uv vertex/uv vertex/uv ...

    const facePattern2 = /f( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))?/; // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...

    const facePattern3 = /f( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))?/; // f vertex//normal vertex//normal vertex//normal ... 

    const facePattern4 = /f( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))?/;

    function parseVertexIndex(value) {
      const index = parseInt(value);
      return (index >= 0 ? index - 1 : index + vertices.length / 3) * 3;
    }

    function parseNormalIndex(value) {
      const index = parseInt(value);
      return (index >= 0 ? index - 1 : index + normals.length / 3) * 3;
    }

    function parseUVIndex(value) {
      const index = parseInt(value);
      return (index >= 0 ? index - 1 : index + uvs.length / 2) * 2;
    }

    function addVertex(a, b, c) {
      positions.push([vertices[a], vertices[a + 1], vertices[a + 2]]);
      positions.push([vertices[b], vertices[b + 1], vertices[b + 2]]);
      positions.push([vertices[c], vertices[c + 1], vertices[c + 2]]);
      indices.push(count * 3 + 0);
      indices.push(count * 3 + 1);
      indices.push(count * 3 + 2);
      count++;
    }

    function addUV(a, b, c) {
      coords.push([uvs[a], uvs[a + 1]]);
      coords.push([uvs[b], uvs[b + 1]]);
      coords.push([uvs[c], uvs[c + 1]]);
    }

    function addNormal(a, b, c) {
      finalNormals.push([normals[a], normals[a + 1], normals[a + 2]]);
      finalNormals.push([normals[b], normals[b + 1], normals[b + 2]]);
      finalNormals.push([normals[c], normals[c + 1], normals[c + 2]]);
    }

    function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
      let ia = parseVertexIndex(a);
      let ib = parseVertexIndex(b);
      let ic = parseVertexIndex(c);
      let id;

      if (d === undefined) {
        addVertex(ia, ib, ic);
      } else {
        id = parseVertexIndex(d);
        addVertex(ia, ib, id);
        addVertex(ib, ic, id);
      }

      if (ua !== undefined) {
        ia = parseUVIndex(ua);
        ib = parseUVIndex(ub);
        ic = parseUVIndex(uc);

        if (d === undefined) {
          addUV(ia, ib, ic);
        } else {
          id = parseUVIndex(ud);
          addUV(ia, ib, id);
          addUV(ib, ic, id);
        }
      }

      if (na !== undefined) {
        ia = parseNormalIndex(na);
        ib = parseNormalIndex(nb);
        ic = parseNormalIndex(nc);

        if (d === undefined) {
          addNormal(ia, ib, ic);
        } else {
          id = parseNormalIndex(nd);
          addNormal(ia, ib, id);
          addNormal(ib, ic, id);
        }
      }
    }

    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      line = line.trim();

      if (line.length === 0 || line.charAt(0) === '#') {
        continue;
      } else if ((result = vertexPattern.exec(line)) !== null) {
        vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
      } else if ((result = normalPattern.exec(line)) !== null) {
        normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
      } else if ((result = uvPattern.exec(line)) !== null) {
        uvs.push(parseFloat(result[1]), parseFloat(result[2]));
      } else if ((result = facePattern1.exec(line)) !== null) {
        addFace(result[1], result[2], result[3], result[4]);
      } else if ((result = facePattern2.exec(line)) !== null) {
        addFace(result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
      } else if ((result = facePattern3.exec(line)) !== null) {
        addFace(result[2], result[6], result[10], result[14], result[3], result[7], result[11], result[15], result[4], result[8], result[12], result[16]);
      } else if ((result = facePattern4.exec(line)) !== null) {
        addFace(result[2], result[5], result[8], result[11], undefined, undefined, undefined, undefined, result[3], result[6], result[9], result[12]);
      }
    }

    return this._generateMeshes({
      positions,
      coords,
      normals: finalNormals,
      indices
    });
  }

  _generateMeshes(o) {
    const maxNumVertices = 65535;
    const hasNormals = o.normals.length > 0;
    const hasUVs = o.coords.length > 0;
    let mesh;

    if (o.positions.length > maxNumVertices) {
      const meshes = [];
      let lastIndex = 0;
      const oCopy = {};
      oCopy.positions = o.positions.concat();
      oCopy.coords = o.coords.concat();
      oCopy.indices = o.indices.concat();
      oCopy.normals = o.normals.concat();

      while (o.indices.length > 0) {
        const sliceNum = Math.min(maxNumVertices, o.positions.length);
        const indices = o.indices.splice(0, sliceNum);
        const positions = [];
        const coords = [];
        const normals = [];
        let index,
            tmpIndex = 0;

        for (let i = 0; i < indices.length; i++) {
          if (indices[i] > tmpIndex) {
            tmpIndex = indices[i];
          }

          index = indices[i];
          positions.push(oCopy.positions[index]);

          if (hasUVs) {
            coords.push(oCopy.coords[index]);
          }

          if (hasNormals) {
            normals.push(oCopy.normals[index]);
          }

          indices[i] -= lastIndex;
        }

        lastIndex = tmpIndex + 1;
        mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_1__["default"](this._drawType);
        mesh.bufferVertex(positions);

        if (hasUVs) {
          mesh.bufferTexCoord(coords);
        }

        mesh.bufferIndex(indices);

        if (hasNormals) {
          mesh.bufferNormal(normals);
        }

        meshes.push(mesh);
      }

      if (this._callback) {
        this._callback(meshes, oCopy);
      }

      return meshes;
    } else {
      mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_1__["default"](this._drawType);
      mesh.bufferVertex(o.positions);

      if (hasUVs) {
        mesh.bufferTexCoord(o.coords);
      }

      mesh.bufferIndex(o.indices);

      if (hasNormals) {
        mesh.bufferNormal(o.normals);
      }

      if (this._callback) {
        this._callback(mesh, o);
      }

      return mesh;
    }

    return null;
  }

}

ObjLoader.parse = function (objStr) {
  const loader = new ObjLoader();
  return loader.parseObj(objStr);
};

/* harmony default export */ __webpack_exports__["default"] = (ObjLoader);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/math/Ray.js":
/*!***********************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/math/Ray.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
// Ray.js

const a = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
const b = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
const c = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
const target = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
const edge1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
const edge2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
const normal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
const diff = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();

class Ray {
  constructor(mOrigin, mDirection) {
    this.origin = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].clone(mOrigin);
    this.direction = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].clone(mDirection);
  }

  at(t) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].copy(target, this.direction);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].scale(target, target, t);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].add(target, target, this.origin);
    return target;
  }

  lookAt(mTarget) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].sub(this.direction, mTarget, this.origin);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].normalize(this.origin, this.origin);
  }

  closestPointToPoint(mPoint) {
    const result = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].sub(mPoint, this.origin);
    const directionDistance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(result, this.direction);

    if (directionDistance < 0) {
      return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].clone(this.origin);
    }

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].copy(result, this.direction);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].scale(result, result, directionDistance);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].add(result, result, this.origin);
    return result;
  }

  distanceToPoint(mPoint) {
    return Math.sqrt(this.distanceSqToPoint(mPoint));
  }

  distanceSqToPoint(mPoint) {
    const v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].sub(v1, mPoint, this.origin);
    const directionDistance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(v1, this.direction);

    if (directionDistance < 0) {
      return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].squaredDistance(this.origin, mPoint);
    }

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].copy(v1, this.direction);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].scale(v1, v1, directionDistance);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].add(v1, v1, this.origin);
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].squaredDistance(v1, mPoint);
  }

  intersectsSphere(mCenter, mRadius) {
    return this.distanceToPoint(mCenter) <= mRadius;
  }

  intersectSphere(mCenter, mRadius) {
    const v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].sub(v1, mCenter, this.origin);
    const tca = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(v1, this.direction);
    const d2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(v1, v1) - tca * tca;
    const radius2 = mRadius * mRadius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0) return null;
    if (t0 < 0) return this.at(t1);
    return this.at(t0);
  }

  distanceToPlane(mPlaneCenter, mNormal) {
    const denominator = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(mNormal, this.direction);

    if (denominator === 0) {}
  }

  intersectTriangle(mPA, mPB, mPC, backfaceCulling = true) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].copy(a, mPA);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].copy(b, mPB);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].copy(c, mPC); // const edge1 = vec3.create();
    // const edge2 = vec3.create();
    // const normal = vec3.create();
    // const diff = vec3.create();

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].sub(edge1, b, a);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].sub(edge2, c, a);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].cross(normal, edge1, edge2);
    let DdN = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(this.direction, normal);
    let sign;

    if (DdN > 0) {
      if (backfaceCulling) {
        return null;
      }

      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].sub(diff, this.origin, a);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].cross(edge2, diff, edge2);
    const DdQxE2 = sign * gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(this.direction, edge2);

    if (DdQxE2 < 0) {
      return null;
    }

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].cross(edge1, edge1, diff);
    const DdE1xQ = sign * gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(this.direction, edge1);

    if (DdE1xQ < 0) {
      return null;
    }

    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }

    const Qdn = -sign * gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(diff, normal);

    if (Qdn < 0) {
      return null;
    }

    return this.at(Qdn / DdN);
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Ray);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/objects/Object3D.js":
/*!*******************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/objects/Object3D.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var scheduling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! scheduling */ "./node_modules/scheduling/src/scheduler.js");
// Object3D.js



class Object3D {
  constructor() {
    this._needUpdate = true;
    this._x = 0;
    this._y = 0;
    this._z = 0;
    this._sx = 1;
    this._sy = 1;
    this._sz = 1;
    this._rx = 0;
    this._ry = 0;
    this._rz = 0;
    this._position = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
    this._scale = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(1, 1, 1);
    this._rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
    this._matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this._matrixParent = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this._matrixRotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this._matrixScale = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this._matrixTranslation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this._matrixQuaternion = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this._quat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].create();
    this._children = [];
  }

  addChild(mChild) {
    this._children.push(mChild);
  }

  removeChild(mChild) {
    const index = this._children.indexOf(mChild);

    if (index == -1) {
      console.warn('Child no exist');
      return;
    }

    this._children.splice(index, 1);
  }

  _update() {
    if (!this._needUpdate) {
      return;
    }

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(this._scale, this._sx, this._sy, this._sz);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(this._rotation, this._rx, this._ry, this._rz);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(this._position, this._x, this._y, this._z);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(this._matrixTranslation, this._matrixTranslation);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(this._matrixScale, this._matrixScale);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(this._matrixRotation, this._matrixRotation);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotateX(this._matrixRotation, this._matrixRotation, this._rx);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotateY(this._matrixRotation, this._matrixRotation, this._ry);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotateZ(this._matrixRotation, this._matrixRotation, this._rz);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].fromQuat(this._matrixQuaternion, this._quat);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].mul(this._matrixRotation, this._matrixQuaternion, this._matrixRotation);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].scale(this._matrixScale, this._matrixScale, this._scale);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(this._matrixTranslation, this._matrixTranslation, this._position);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].mul(this._matrix, this._matrixTranslation, this._matrixRotation);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].mul(this._matrix, this._matrix, this._matrixScale); // mat4.mul(this._matrix, this._matrix, this._matrixParent);

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].mul(this._matrix, this._matrixParent, this._matrix);
    this.updateMatrix();
    this._needUpdate = false;
  }

  updateMatrix(mParentMatrix) {
    if (mParentMatrix) {
      this._needUpdate = true;
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(this._matrixParent, mParentMatrix);
    }

    if (!this._needUpdate) {
      return;
    }

    this._children.forEach(child => {
      child.updateMatrix(this._matrix);
    });
  }

  setRotationFromQuaternion(mQuat) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].copy(this._quat, mQuat);
    this._needUpdate = true;
    scheduling__WEBPACK_IMPORTED_MODULE_1__["default"].next(() => this._update());
  }

  get matrix() {
    if (this._needUpdate) {
      this._update();
    }

    return this._matrix;
  }

  get x() {
    return this._x;
  }

  set x(mValue) {
    this._needUpdate = true;
    this._x = mValue;
    scheduling__WEBPACK_IMPORTED_MODULE_1__["default"].next(() => this._update());
  }

  get y() {
    return this._y;
  }

  set y(mValue) {
    this._needUpdate = true;
    this._y = mValue;
    scheduling__WEBPACK_IMPORTED_MODULE_1__["default"].next(() => this._update());
  }

  get z() {
    return this._z;
  }

  set z(mValue) {
    this._needUpdate = true;
    this._z = mValue;
    scheduling__WEBPACK_IMPORTED_MODULE_1__["default"].next(() => this._update());
  }

  get scaleX() {
    return this._sx;
  }

  set scaleX(mValue) {
    this._needUpdate = true;
    this._sx = mValue;
    scheduling__WEBPACK_IMPORTED_MODULE_1__["default"].next(() => this._update());
  }

  get scaleY() {
    return this._sy;
  }

  set scaleY(mValue) {
    this._needUpdate = true;
    this._sy = mValue;
    scheduling__WEBPACK_IMPORTED_MODULE_1__["default"].next(() => this._update());
  }

  get scaleZ() {
    return this._sz;
  }

  set scaleZ(mValue) {
    this._needUpdate = true;
    this._sz = mValue;
    scheduling__WEBPACK_IMPORTED_MODULE_1__["default"].next(() => this._update());
  }

  get rotationX() {
    return this._rx;
  }

  set rotationX(mValue) {
    this._needUpdate = true;
    this._rx = mValue;
    scheduling__WEBPACK_IMPORTED_MODULE_1__["default"].next(() => this._update());
  }

  get rotationY() {
    return this._ry;
  }

  set rotationY(mValue) {
    this._needUpdate = true;
    this._ry = mValue;
    scheduling__WEBPACK_IMPORTED_MODULE_1__["default"].next(() => this._update());
  }

  get rotationZ() {
    return this._rz;
  }

  set rotationZ(mValue) {
    this._needUpdate = true;
    this._rz = mValue;
    scheduling__WEBPACK_IMPORTED_MODULE_1__["default"].next(() => this._update());
  }

  get children() {
    return this._children;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Object3D);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/axis.frag":
/*!*****************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/axis.frag ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// axis.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\t// vec3 color = vNormal;\n\tvec3 color = vColor + vNormal * 0.0001;\n    gl_FragColor = vec4(color, 1.0);\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/axis.vert":
/*!*****************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/axis.vert ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// axis.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aColor;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vColor = aColor;\n    vNormal = aNormal;\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/basic.frag":
/*!******************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/basic.frag ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// basic.frag\n\n#define SHADER_NAME BASIC_FRAGMENT\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float time;\n// uniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/basic.vert":
/*!******************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/basic.vert ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/bigTriangle.vert":
/*!************************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/bigTriangle.vert ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// bigTriangle.vert\n\n#define SHADER_NAME BIG_TRIANGLE_VERTEX\n\nprecision mediump float;\n#define GLSLIFY 1\nattribute vec2 aPosition;\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vTextureCoord = aPosition * .5 + .5;\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/copy.frag":
/*!*****************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/copy.frag ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// copy.frag\n\n#define SHADER_NAME COPY_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = texture2D(texture, vTextureCoord);\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/dotsPlane.frag":
/*!**********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/dotsPlane.frag ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// dotsPlane.frag\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec3 color;\nuniform float opacity;\n\nvoid main(void) {\n\tif(distance(gl_PointCoord, vec2(.5)) > .5) {\n\t\tdiscard;\n\t}\n    gl_FragColor = vec4(color, opacity);\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/dotsPlane.vert":
/*!**********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/dotsPlane.vert ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// basic.vert\n\n#define SHADER_NAME DOTS_PLANE_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform vec2 viewport;\n\nvarying vec3 vNormal;\n\nconst float radius = 0.008;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition + aNormal * 0.000001, 1.0);\n    // gl_PointSize = 1.0;\n    vNormal = aNormal;\n\n\tfloat distOffset = viewport.y * uProjectionMatrix[1][1] * radius / gl_Position.w;\n    gl_PointSize = distOffset;\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/general.vert":
/*!********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/general.vert ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// generalWithNormal.vert\n\n#define SHADER_NAME GENERAL_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nuniform vec3 position;\nuniform vec3 scale;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tvec3 pos      = aVertexPosition * scale;\n\tpos           += position;\n\tgl_Position   = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\t\n\tvTextureCoord = aTextureCoord;\n\tvNormal       = normalize(uNormalMatrix * aNormal);\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/simpleColor.frag":
/*!************************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/simpleColor.frag ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// simpleColor.frag\n\n#define SHADER_NAME SIMPLE_COLOR\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform vec3 color;\nuniform float opacity;\n\nvoid main(void) {\n    gl_FragColor = vec4(color, opacity);\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/sky.vert":
/*!****************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/sky.vert ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// sky.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n    gl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/skybox.frag":
/*!*******************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/skybox.frag ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// basic.frag\n\n#define SHADER_NAME SKYBOX_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\nuniform samplerCube texture;\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\n\nvoid main(void) {\n    gl_FragColor = textureCube(texture, vVertex);\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/shaders/skybox.vert":
/*!*******************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/shaders/skybox.vert ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// basic.vert\n\n#define SHADER_NAME SKYBOX_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n\tgl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n\tvTextureCoord = aTextureCoord;\n\t\n\tvVertex = aVertexPosition;\n\tvNormal = aNormal;\n}");

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/EaseNumber.js":
/*!*******************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/EaseNumber.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var scheduling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! scheduling */ "./node_modules/scheduling/src/scheduler.js");
// EaseNumber.js


class EaseNumber {
  constructor(mValue, mEasing = 0.1) {
    this.easing = mEasing;
    this._value = mValue;
    this._targetValue = mValue;
    this._efIndex = scheduling__WEBPACK_IMPORTED_MODULE_0__["default"].addEF(() => this._update());
  }

  _update() {
    const MIN_DIFF = 0.0001;

    this._checkLimit();

    this._value += (this._targetValue - this._value) * this.easing;

    if (Math.abs(this._targetValue - this._value) < MIN_DIFF) {
      this._value = this._targetValue;
    }
  }

  setTo(mValue) {
    this._targetValue = this._value = mValue;
  }

  add(mAdd) {
    this._targetValue += mAdd;
  }

  limit(mMin, mMax) {
    if (mMin > mMax) {
      this.limit(mMax, mMin);
      return;
    }

    this._min = mMin;
    this._max = mMax;

    this._checkLimit();
  }

  _checkLimit() {
    if (this._min !== undefined && this._targetValue < this._min) {
      this._targetValue = this._min;
    }

    if (this._max !== undefined && this._targetValue > this._max) {
      this._targetValue = this._max;
    }
  }

  destroy() {
    scheduling__WEBPACK_IMPORTED_MODULE_0__["default"].removeEF(this._efIndex);
  } //	GETTERS / SETTERS


  set value(mValue) {
    this._targetValue = mValue;
  }

  get value() {
    return this._value;
  }

  get targetValue() {
    return this._targetValue;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (EaseNumber);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/EventDispatcher.js":
/*!************************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/EventDispatcher.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// EventDispatcher.js
let supportsCustomEvents = true;

try {
  let newTestCustomEvent = document.createEvent('CustomEvent');
  newTestCustomEvent = null;
} catch (e) {
  supportsCustomEvents = false;
}

class EventDispatcher {
  constructor() {
    this._eventListeners = {};
  }

  addEventListener(aEventType, aFunction) {
    if (this._eventListeners === null || this._eventListeners === undefined) {
      this._eventListeners = {};
    }

    if (!this._eventListeners[aEventType]) {
      this._eventListeners[aEventType] = [];
    }

    this._eventListeners[aEventType].push(aFunction);

    return this;
  }

  on(aEventType, aFunction) {
    return this.addEventListener(aEventType, aFunction);
  }

  removeEventListener(aEventType, aFunction) {
    if (this._eventListeners === null || this._eventListeners === undefined) {
      this._eventListeners = {};
    }

    const currentArray = this._eventListeners[aEventType];

    if (typeof currentArray === 'undefined') {
      return this;
    }

    let currentArrayLength = currentArray.length;

    for (let i = 0; i < currentArrayLength; i++) {
      if (currentArray[i] === aFunction) {
        currentArray.splice(i, 1);
        i--;
        currentArrayLength--;
      }
    }

    return this;
  }

  off(aEventType, aFunction) {
    return this.removeEventListener(aEventType, aFunction);
  }

  dispatchEvent(aEvent) {
    if (this._eventListeners === null || this._eventListeners === undefined) {
      this._eventListeners = {};
    }

    const eventType = aEvent.type;

    try {
      if (aEvent.target === null) {
        aEvent.target = this;
      }

      aEvent.currentTarget = this;
    } catch (theError) {
      const newEvent = {
        type: eventType,
        detail: aEvent.detail,
        dispatcher: this
      };
      return this.dispatchEvent(newEvent);
    }

    const currentEventListeners = this._eventListeners[eventType];

    if (currentEventListeners !== null && currentEventListeners !== undefined) {
      const currentArray = this._copyArray(currentEventListeners);

      const currentArrayLength = currentArray.length;

      for (let i = 0; i < currentArrayLength; i++) {
        const currentFunction = currentArray[i];
        currentFunction.call(this, aEvent);
      }
    }

    return this;
  }

  dispatchCustomEvent(aEventType, aDetail) {
    let newEvent;

    if (supportsCustomEvents) {
      newEvent = document.createEvent('CustomEvent');
      newEvent.dispatcher = this;
      newEvent.initCustomEvent(aEventType, false, false, aDetail);
    } else {
      newEvent = {
        type: aEventType,
        detail: aDetail,
        dispatcher: this
      };
    }

    return this.dispatchEvent(newEvent);
  }

  trigger(aEventType, aDetail) {
    return this.dispatchCustomEvent(aEventType, aDetail);
  }

  _destroy() {
    if (this._eventListeners !== null) {
      for (const objectName in this._eventListeners) {
        if (this._eventListeners.hasOwnProperty(objectName)) {
          const currentArray = this._eventListeners[objectName];
          const currentArrayLength = currentArray.length;

          for (let i = 0; i < currentArrayLength; i++) {
            currentArray[i] = null;
          }

          delete this._eventListeners[objectName];
        }
      }

      this._eventListeners = null;
    }
  }

  _copyArray(aArray) {
    const currentArray = new Array(aArray.length);
    const currentArrayLength = currentArray.length;

    for (let i = 0; i < currentArrayLength; i++) {
      currentArray[i] = aArray[i];
    }

    return currentArray;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (EventDispatcher);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/ExtensionsList.js":
/*!***********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/ExtensionsList.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// ExtensionsList.js
/* harmony default export */ __webpack_exports__["default"] = (['EXT_shader_texture_lod', 'EXT_sRGB', 'EXT_frag_depth', 'OES_texture_float', 'OES_texture_half_float', 'OES_texture_float_linear', 'OES_texture_half_float_linear', 'OES_standard_derivatives', 'WEBGL_depth_texture', 'EXT_texture_filter_anisotropic', 'OES_vertex_array_object', 'ANGLE_instanced_arrays', 'WEBGL_draw_buffers']);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/HDRParser.js":
/*!******************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/HDRParser.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// HDRParser.js
 // Code ported by Marcin Ignac (2014)
// Based on Java implementation from
// https://code.google.com/r/cys12345-research/source/browse/hdr/image_processor/RGBE.java?r=7d84e9fd866b24079dbe61fa0a966ce8365f5726

const radiancePattern = '#\\?RADIANCE';
const commentPattern = '#.*'; // let gammaPattern = 'GAMMA=';

const exposurePattern = 'EXPOSURE=\\s*([0-9]*[.][0-9]*)';
const formatPattern = 'FORMAT=32-bit_rle_rgbe';
const widthHeightPattern = '-Y ([0-9]+) \\+X ([0-9]+)'; // http://croquetweak.blogspot.co.uk/2014/08/deconstructing-floats-frexp-and-ldexp.html
// function ldexp(mantissa, exponent) {
//     return exponent > 1023 ? mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023) : exponent < -1074 ? mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074) : mantissa * Math.pow(2, exponent);
// }

function readPixelsRawRLE(buffer, data, offset, fileOffset, scanlineWidth, numScanlines) {
  const rgbe = new Array(4);
  let scanlineBuffer = null;
  let ptr;
  let ptrEnd;
  let count;
  const buf = new Array(2);
  const bufferLength = buffer.length;

  function readBuf(buf) {
    let bytesRead = 0;

    do {
      buf[bytesRead++] = buffer[fileOffset];
    } while (++fileOffset < bufferLength && bytesRead < buf.length);

    return bytesRead;
  }

  function readBufOffset(buf, offset, length) {
    let bytesRead = 0;

    do {
      buf[offset + bytesRead++] = buffer[fileOffset];
    } while (++fileOffset < bufferLength && bytesRead < length);

    return bytesRead;
  }

  function readPixelsRaw(buffer, data, offset, numpixels) {
    const numExpected = 4 * numpixels;
    const numRead = readBufOffset(data, offset, numExpected);

    if (numRead < numExpected) {
      throw new Error(`Error reading raw pixels: got ${numRead} bytes, expected ${numExpected}`);
    }
  }

  while (numScanlines > 0) {
    if (readBuf(rgbe) < rgbe.length) {
      throw new Error(`Error reading bytes: expected ${rgbe.length}`);
    }

    if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
      // this file is not run length encoded
      data[offset++] = rgbe[0];
      data[offset++] = rgbe[1];
      data[offset++] = rgbe[2];
      data[offset++] = rgbe[3];
      readPixelsRaw(buffer, data, offset, scanlineWidth * numScanlines - 1);
      return;
    }

    if (((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) !== scanlineWidth) {
      throw new Error(`Wrong scanline width ${(rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF}, expected ${scanlineWidth}`);
    }

    if (scanlineBuffer === null) {
      scanlineBuffer = new Array(4 * scanlineWidth);
    }

    ptr = 0;
    /* read each of the four channels for the scanline into the buffer */

    for (let i = 0; i < 4; i++) {
      ptrEnd = (i + 1) * scanlineWidth;

      while (ptr < ptrEnd) {
        if (readBuf(buf) < buf.length) {
          throw new Error('Error reading 2-byte buffer');
        }

        if ((buf[0] & 0xFF) > 128) {
          /* a run of the same value */
          count = (buf[0] & 0xFF) - 128;

          if (count === 0 || count > ptrEnd - ptr) {
            throw new Error('Bad scanline data');
          }

          while (count-- > 0) {
            scanlineBuffer[ptr++] = buf[1];
          }
        } else {
          /* a non-run */
          count = buf[0] & 0xFF;

          if (count === 0 || count > ptrEnd - ptr) {
            throw new Error('Bad scanline data');
          }

          scanlineBuffer[ptr++] = buf[1];

          if (--count > 0) {
            if (readBufOffset(scanlineBuffer, ptr, count) < count) {
              throw new Error('Error reading non-run data');
            }

            ptr += count;
          }
        }
      }
    }
    /* copy byte data to output */


    for (let i = 0; i < scanlineWidth; i++) {
      data[offset + 0] = scanlineBuffer[i];
      data[offset + 1] = scanlineBuffer[i + scanlineWidth];
      data[offset + 2] = scanlineBuffer[i + 2 * scanlineWidth];
      data[offset + 3] = scanlineBuffer[i + 3 * scanlineWidth];
      offset += 4;
    }

    numScanlines--;
  }
} // Returns data as floats and flipped along Y by default


function parseHdr(buffer) {
  if (buffer instanceof ArrayBuffer) {
    buffer = new Uint8Array(buffer);
  }

  let fileOffset = 0;
  const bufferLength = buffer.length;
  const NEW_LINE = 10;

  function readLine() {
    let buf = '';

    do {
      const b = buffer[fileOffset];

      if (b === NEW_LINE) {
        ++fileOffset;
        break;
      }

      buf += String.fromCharCode(b);
    } while (++fileOffset < bufferLength);

    return buf;
  }

  let width = 0;
  let height = 0;
  let exposure = 1;
  const gamma = 1;
  let rle = false;

  for (let i = 0; i < 20; i++) {
    const line = readLine();
    let match;

    if (match = line.match(radiancePattern)) {} else if (match = line.match(formatPattern)) {
      rle = true;
    } else if (match = line.match(exposurePattern)) {
      exposure = Number(match[1]);
    } else if (match = line.match(commentPattern)) {} else if (match = line.match(widthHeightPattern)) {
      height = Number(match[1]);
      width = Number(match[2]);
      break;
    }
  }

  if (!rle) {
    throw new Error('File is not run length encoded!');
  }

  const data = new Uint8Array(width * height * 4);
  const scanlineWidth = width;
  const numScanlines = height;
  readPixelsRawRLE(buffer, data, 0, fileOffset, scanlineWidth, numScanlines); // TODO: Should be Float16

  const floatData = new Float32Array(width * height * 4);

  for (let offset = 0; offset < data.length; offset += 4) {
    let r = data[offset + 0] / 255;
    let g = data[offset + 1] / 255;
    let b = data[offset + 2] / 255;
    const e = data[offset + 3];
    const f = Math.pow(2.0, e - 128.0);
    r *= f;
    g *= f;
    b *= f;
    const floatOffset = offset;
    floatData[floatOffset + 0] = r;
    floatData[floatOffset + 1] = g;
    floatData[floatOffset + 2] = b;
    floatData[floatOffset + 3] = 1.0;
  }

  return {
    shape: [width, height],
    exposure,
    gamma,
    data: floatData
  };
}

/* harmony default export */ __webpack_exports__["default"] = (parseHdr);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/OrbitalControl.js":
/*!***********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/OrbitalControl.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
// OrbitalControl.js



const getMouse = function (mEvent, mTarget) {
  const o = mTarget || {};

  if (mEvent.touches) {
    o.x = mEvent.touches[0].pageX;
    o.y = mEvent.touches[0].pageY;
  } else {
    o.x = mEvent.clientX;
    o.y = mEvent.clientY;
  }

  return o;
};

class OrbitalControl {
  constructor(mTarget, mListenerTarget = window, mRadius = 500) {
    this._target = mTarget;
    this._listenerTarget = mListenerTarget;
    this._mouse = {};
    this._preMouse = {};
    this.center = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
    this._up = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 1, 0);
    this.radius = new alfrid__WEBPACK_IMPORTED_MODULE_0__["EaseNumber"](mRadius);
    this.position = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(0, 0, this.radius.value);
    this.positionOffset = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
    this._rx = new alfrid__WEBPACK_IMPORTED_MODULE_0__["EaseNumber"](0);

    this._rx.limit(-Math.PI / 2, Math.PI / 2);

    this._ry = new alfrid__WEBPACK_IMPORTED_MODULE_0__["EaseNumber"](0);
    this._preRX = 0;
    this._preRY = 0;
    this._isLockZoom = false;
    this._isLockRotation = false;
    this._isInvert = false;
    this.sensitivity = 1.0;

    this._wheelBind = e => this._onWheel(e);

    this._downBind = e => this._onDown(e);

    this._moveBind = e => this._onMove(e);

    this._upBind = () => this._onUp();

    this._efIndex = alfrid__WEBPACK_IMPORTED_MODULE_0__["Scheduler"].addEF(() => this._loop());
  }

  connect(mListenerTarget) {
    if (mListenerTarget) this._listenerTarget = mListenerTarget;
    this.disconnect();

    this._listenerTarget.addEventListener('mousewheel', this._wheelBind);

    this._listenerTarget.addEventListener('DOMMouseScroll', this._wheelBind);

    this._listenerTarget.addEventListener('mousedown', this._downBind);

    this._listenerTarget.addEventListener('touchstart', this._downBind);

    this._listenerTarget.addEventListener('mousemove', this._moveBind);

    this._listenerTarget.addEventListener('touchmove', this._moveBind);

    window.addEventListener('touchend', this._upBind);
    window.addEventListener('mouseup', this._upBind);
  }

  disconnect() {
    this._listenerTarget.removeEventListener('mousewheel', this._wheelBind);

    this._listenerTarget.removeEventListener('DOMMouseScroll', this._wheelBind);

    this._listenerTarget.removeEventListener('mousedown', this._downBind);

    this._listenerTarget.removeEventListener('touchstart', this._downBind);

    this._listenerTarget.removeEventListener('mousemove', this._moveBind);

    this._listenerTarget.removeEventListener('touchmove', this._moveBind);

    window.removeEventListener('touchend', this._upBind);
    window.removeEventListener('mouseup', this._upBind);
  } //	PUBLIC METHODS


  lock(mValue = true) {
    this._isLockZoom = mValue;
    this._isLockRotation = mValue;
    this._isMouseDown = false;
  }

  lockZoom(mValue = true) {
    this._isLockZoom = mValue;
  }

  lockRotation(mValue = true) {
    this._isLockRotation = mValue;
  }

  inverseControl(isInvert = true) {
    this._isInvert = isInvert;
  } //	EVENT HANDLERES


  _onDown(mEvent) {
    if (this._isLockRotation) {
      return;
    }

    this._isMouseDown = true;
    getMouse(mEvent, this._mouse);
    getMouse(mEvent, this._preMouse);
    this._preRX = this._rx.targetValue;
    this._preRY = this._ry.targetValue;
  }

  _onMove(mEvent) {
    if (this._isLockRotation) {
      return;
    }

    getMouse(mEvent, this._mouse);

    if (mEvent.touches) {
      mEvent.preventDefault();
    }

    if (this._isMouseDown) {
      let diffX = -(this._mouse.x - this._preMouse.x);

      if (this._isInvert) {
        diffX *= -1;
      }

      this._ry.value = this._preRY - diffX * 0.01 * this.sensitivity;
      let diffY = -(this._mouse.y - this._preMouse.y);

      if (this._isInvert) {
        diffY *= -1;
      }

      this._rx.value = this._preRX - diffY * 0.01 * this.sensitivity;
    }
  }

  _onUp() {
    if (this._isLockRotation) {
      return;
    }

    this._isMouseDown = false;
  }

  _onWheel(mEvent) {
    if (this._isLockZoom) {
      return;
    }

    const w = mEvent.wheelDelta;
    const d = mEvent.detail;
    let value = 0;

    if (d) {
      if (w) {
        value = w / d / 40 * d > 0 ? 1 : -1; // Opera
      } else {
        value = -d / 3; // Firefox;         TODO: do not /3 for OS X
      }
    } else {
      value = w / 120;
    }

    this.radius.add(-value * 2);
  } //	PRIVATE METHODS


  _loop() {
    this._updatePosition();

    if (this._target) {
      this._updateCamera();
    }
  }

  _updatePosition() {
    this.position[1] = Math.sin(this._rx.value) * this.radius.value;
    const tr = Math.cos(this._rx.value) * this.radius.value;
    this.position[0] = Math.cos(this._ry.value + Math.PI * 0.5) * tr;
    this.position[2] = Math.sin(this._ry.value + Math.PI * 0.5) * tr;
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].add(this.position, this.position, this.positionOffset);
  }

  getPosition(rx, ry, radius) {
    const y = Math.sin(rx) * radius;
    const tr = Math.cos(rx) * radius;
    const x = Math.cos(ry + Math.PI * 0.5) * tr;
    const z = Math.sin(ry + Math.PI * 0.5) * tr;
    return [x, y, z];
  }

  _updateCamera() {
    this._target.lookAt(this.position, this.center, this._up);
  }

  destroy() {
    this.disconnect();
    alfrid__WEBPACK_IMPORTED_MODULE_0__["Scheduler"].removeEF(this._efIndex);
  } //	GETTER / SETTER


  get rx() {
    return this._rx;
  }

  get ry() {
    return this._ry;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (OrbitalControl);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/QuatRotation.js":
/*!*********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/QuatRotation.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _EaseNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EaseNumber */ "./src/js/libs/alfrid/alfrid/utils/EaseNumber.js");
/* harmony import */ var scheduling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! scheduling */ "./node_modules/scheduling/src/scheduler.js");
// QuatRotation.js






const getMouse = function (mEvent, mTarget) {
  const o = mTarget || {};

  if (mEvent.touches) {
    o.x = mEvent.touches[0].pageX;
    o.y = mEvent.touches[0].pageY;
  } else {
    o.x = mEvent.clientX;
    o.y = mEvent.clientY;
  }

  return o;
};

class QuatRotation {
  constructor(mTarget, mListenerTarget = window, mEasing = 0.1) {
    this._target = mTarget;
    this._listenerTarget = mListenerTarget;
    this.matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this.m = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this._vZaxis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].clone([0, 0, 0]);
    this._zAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].clone([0, 0, 1]);
    this.preMouse = {
      x: 0,
      y: 0
    };
    this.mouse = {
      x: 0,
      y: 0
    };
    this._isMouseDown = false;
    this._rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].create();
    this.tempRotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].create();
    this._rotateZMargin = 0;
    this._offset = 0.004;
    this._slerp = -1;
    this._isLocked = false;
    this._diffX = new _EaseNumber__WEBPACK_IMPORTED_MODULE_1__["default"](0, mEasing);
    this._diffY = new _EaseNumber__WEBPACK_IMPORTED_MODULE_1__["default"](0, mEasing);

    this._listenerTarget.addEventListener('mousedown', e => this._onDown(e));

    this._listenerTarget.addEventListener('touchstart', e => this._onDown(e));

    this._listenerTarget.addEventListener('mousemove', e => this._onMove(e));

    this._listenerTarget.addEventListener('touchmove', e => this._onMove(e));

    window.addEventListener('touchend', () => this._onUp());
    window.addEventListener('mouseup', () => this._onUp());
    scheduling__WEBPACK_IMPORTED_MODULE_2__["default"].addEF(() => this._loop());
  } // 	PUBLIC METHODS


  inverseControl(isInvert = true) {
    this._isInvert = isInvert;
  }

  lock(mValue = true) {
    this._isLocked = mValue;
  }

  setCameraPos(mQuat, speed = 0.1) {
    this.easing = speed;

    if (this._slerp > 0) {
      return;
    }

    const tempRotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].clone(this._rotation);

    this._updateRotation(tempRotation);

    this._rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].clone(tempRotation);
    this._currDiffX = this.diffX = 0;
    this._currDiffY = this.diffY = 0;
    this._isMouseDown = false;
    this._isRotateZ = 0;
    this._targetQuat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].clone(mQuat);
    this._slerp = 1;
  }

  resetQuat() {
    this._rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].clone([0, 0, 1, 0]);
    this.tempRotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].clone([0, 0, 0, 0]);
    this._targetQuat = undefined;
    this._slerp = -1;
  } //	EVENT HANDLER


  _onDown(mEvent) {
    if (this._isLocked) {
      return;
    }

    const mouse = getMouse(mEvent);
    const tempRotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].clone(this._rotation);

    this._updateRotation(tempRotation);

    this._rotation = tempRotation;
    this._isMouseDown = true;
    this._isRotateZ = 0;
    this.preMouse = {
      x: mouse.x,
      y: mouse.y
    };

    if (mouse.y < this._rotateZMargin || mouse.y > window.innerHeight - this._rotateZMargin) {
      this._isRotateZ = 1;
    } else if (mouse.x < this._rotateZMargin || mouse.x > window.innerWidth - this._rotateZMargin) {
      this._isRotateZ = 2;
    }

    this._diffX.setTo(0);

    this._diffY.setTo(0);
  }

  _onMove(mEvent) {
    if (this._isLocked) {
      return;
    }

    getMouse(mEvent, this.mouse);
  }

  _onUp() {
    if (this._isLocked) {
      return;
    }

    this._isMouseDown = false;
  } //	PRIVATE METHODS


  _updateRotation(mTempRotation) {
    if (this._isMouseDown && !this._isLocked) {
      this._diffX.value = -(this.mouse.x - this.preMouse.x);
      this._diffY.value = this.mouse.y - this.preMouse.y;

      if (this._isInvert) {
        this._diffX.value = -this._diffX.targetValue;
        this._diffY.value = -this._diffY.targetValue;
      }
    }

    let angle, _quat;

    if (this._isRotateZ > 0) {
      if (this._isRotateZ === 1) {
        angle = -this._diffX.value * this._offset;
        angle *= this.preMouse.y < this._rotateZMargin ? -1 : 1;
        _quat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].clone([0, 0, Math.sin(angle), Math.cos(angle)]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].multiply(_quat, mTempRotation, _quat);
      } else {
        angle = -this._diffY.value * this._offset;
        angle *= this.preMouse.x < this._rotateZMargin ? 1 : -1;
        _quat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].clone([0, 0, Math.sin(angle), Math.cos(angle)]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].multiply(_quat, mTempRotation, _quat);
      }
    } else {
      const v = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].clone([this._diffX.value, this._diffY.value, 0]);
      const axis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].cross(axis, v, this._zAxis);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].normalize(axis, axis);
      angle = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].length(v) * this._offset;
      _quat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].clone([Math.sin(angle) * axis[0], Math.sin(angle) * axis[1], Math.sin(angle) * axis[2], Math.cos(angle)]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].multiply(mTempRotation, _quat, mTempRotation);
    }
  }

  _loop() {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(this.m);

    if (this._targetQuat === undefined) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].set(this.tempRotation, this._rotation[0], this._rotation[1], this._rotation[2], this._rotation[3]);

      this._updateRotation(this.tempRotation);
    } else {
      this._slerp += (0 - this._slerp) * 0.1;

      if (this._slerp < 0.0005) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].copy(this._rotation, this._targetQuat);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].copy(this.tempRotation, this._targetQuat);
        this._targetQuat = undefined;

        this._diffX.setTo(0);

        this._diffY.setTo(0);

        this._slerp = -1;
      } else {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].set(this.tempRotation, 0, 0, 0, 0);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].slerp(this.tempRotation, this._targetQuat, this._rotation, this._slerp);
      }
    }

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformQuat(this._vZaxis, this._vZaxis, this.tempRotation);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].fromQuat(this.matrix, this.tempRotation);
  } //	GETTER AND SETTER


  set easing(mValue) {
    this._diffX.easing = mValue;
    this._diffY.easing = mValue;
  }

  get easing() {
    return this._diffX.easing;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (QuatRotation);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/ShaderLibs.js":
/*!*******************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/ShaderLibs.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shaders_simpleColor_frag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shaders/simpleColor.frag */ "./src/js/libs/alfrid/alfrid/shaders/simpleColor.frag");
/* harmony import */ var _shaders_bigTriangle_vert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shaders/bigTriangle.vert */ "./src/js/libs/alfrid/alfrid/shaders/bigTriangle.vert");
/* harmony import */ var _shaders_general_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shaders/general.vert */ "./src/js/libs/alfrid/alfrid/shaders/general.vert");
/* harmony import */ var _shaders_copy_frag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/copy.frag */ "./src/js/libs/alfrid/alfrid/shaders/copy.frag");
/* harmony import */ var _shaders_basic_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/basic.vert */ "./src/js/libs/alfrid/alfrid/shaders/basic.vert");
/* harmony import */ var _shaders_skybox_vert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shaders/skybox.vert */ "./src/js/libs/alfrid/alfrid/shaders/skybox.vert");
/* harmony import */ var _shaders_skybox_frag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shaders/skybox.frag */ "./src/js/libs/alfrid/alfrid/shaders/skybox.frag");
// ShaderLbs.js









const ShaderLibs = {
  simpleColorFrag: _shaders_simpleColor_frag__WEBPACK_IMPORTED_MODULE_0__["default"],
  bigTriangleVert: _shaders_bigTriangle_vert__WEBPACK_IMPORTED_MODULE_1__["default"],
  generalVert: _shaders_general_vert__WEBPACK_IMPORTED_MODULE_2__["default"],
  copyFrag: _shaders_copy_frag__WEBPACK_IMPORTED_MODULE_3__["default"],
  basicVert: _shaders_basic_vert__WEBPACK_IMPORTED_MODULE_4__["default"],
  skyboxVert: _shaders_skybox_vert__WEBPACK_IMPORTED_MODULE_5__["default"],
  skyboxFrag: _shaders_skybox_frag__WEBPACK_IMPORTED_MODULE_6__["default"]
};
/* harmony default export */ __webpack_exports__["default"] = (ShaderLibs);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/SpringNumber.js":
/*!*********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/SpringNumber.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var scheduling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! scheduling */ "./node_modules/scheduling/src/scheduler.js");
// SpringNumber.js


class SpringNumber {
  constructor(mValue, mSpeed = 0.1, mDecreaseRate = 0.9) {
    this._value = mValue;
    this._targetValue = mValue;
    this.speed = mSpeed;
    this.decreaseRate = mDecreaseRate;
    this._velocity = 0;
    this._efIndex = scheduling__WEBPACK_IMPORTED_MODULE_0__["default"].addEF(() => this._update());
  }

  _update() {
    const MIN_DIFF = 0.0001;

    this._checkLimit();

    if (Math.abs(this._targetValue - this._value) < MIN_DIFF) {
      this._value = this._targetValue;
      return;
    }

    this._velocity += (this._targetValue - this._value) * this.speed;
    this._value += this._velocity;
    this._velocity *= this.decreaseRate;

    if (Math.abs(this._targetValue - this._value) < MIN_DIFF) {
      this._value = this._targetValue;
    }
  }

  limit(mMin, mMax) {
    if (mMin > mMax) {
      this.limit(mMax, mMin);
      return;
    }

    this._min = mMin;
    this._max = mMax;

    this._checkLimit();
  }

  _checkLimit() {
    if (this._min !== undefined && this._targetValue < this._min) {
      this._targetValue = this._min;
    }

    if (this._max !== undefined && this._targetValue > this._max) {
      this._targetValue = this._max;
    }
  }

  destroy() {
    scheduling__WEBPACK_IMPORTED_MODULE_0__["default"].removeEF(this._efIndex);
  }

  set value(mValue) {
    this._targetValue = mValue;
  }

  get value() {
    return this._value;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (SpringNumber);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/TouchDetector.js":
/*!**********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/TouchDetector.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher */ "./src/js/libs/alfrid/alfrid/utils/EventDispatcher.js");
/* harmony import */ var _math_Ray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Ray */ "./src/js/libs/alfrid/alfrid/math/Ray.js");
/* harmony import */ var _getMouse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMouse */ "./src/js/libs/alfrid/alfrid/utils/getMouse.js");
// TouchDetector.js





function distance(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy);
}

class TouchDetector extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(mMesh, mCamera, mSkipMoveCheck = false, mListenerTarget = window) {
    super();
    this._mesh = mMesh;

    this._mesh.generateFaces();

    this._camera = mCamera;
    this.faceVertices = mMesh.faces.map(face => face.vertices);
    this.clickTolerance = 8;
    this._ray = new _math_Ray__WEBPACK_IMPORTED_MODULE_2__["default"]([0, 0, 0], [0, 0, -1]);
    this._hit = vec3.fromValues(-999, -999, -999);
    this._lastPos;
    this._firstPos;
    this.mtxModel = mat4.create();
    this._listenerTarget = mListenerTarget;
    this._skippingMove = mSkipMoveCheck;

    this._onMoveBind = e => this._onMove(e);

    this._onDownBind = e => this._onDown(e);

    this._onUpBind = () => this._onUp();

    this.connect();
  }

  connect() {
    this._listenerTarget.addEventListener('mousedown', this._onDownBind);

    this._listenerTarget.addEventListener('mousemove', this._onMoveBind);

    this._listenerTarget.addEventListener('mouseup', this._onUpBind);
  }

  disconnect() {
    this._listenerTarget.removeEventListener('mousedown', this._onDownBind);

    this._listenerTarget.removeEventListener('mousemove', this._onMoveBind);

    this._listenerTarget.removeEventListener('mouseup', this._onUpBind);
  }

  _checkHit(mType = 'onHit') {
    const camera = this._camera;

    if (!camera) {
      return;
    }

    const mx = this._lastPos.x / _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].width * 2.0 - 1.0;
    const my = -(this._lastPos.y / _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].height) * 2.0 + 1.0;
    camera.generateRay([mx, my, 0], this._ray);
    let hit;
    const v0 = vec3.create();
    const v1 = vec3.create();
    const v2 = vec3.create();
    let dist = 0;

    const getVector = (v, target) => {
      vec3.transformMat4(target, v, this.mtxModel);
    };

    for (let i = 0; i < this.faceVertices.length; i++) {
      const vertices = this.faceVertices[i];
      getVector(vertices[0], v0);
      getVector(vertices[1], v1);
      getVector(vertices[2], v2);

      const t = this._ray.intersectTriangle(v0, v1, v2);

      if (t) {
        if (hit) {
          const distToCam = vec3.dist(t, camera.position);

          if (distToCam < dist) {
            hit = vec3.clone(t);
            dist = distToCam;
          }
        } else {
          hit = vec3.clone(t);
          dist = vec3.dist(hit, camera.position);
        }
      }
    }

    if (hit) {
      this._hit = vec3.clone(hit);
      this.dispatchCustomEvent(mType, {
        hit
      });
    } else {
      this.dispatchCustomEvent('onUp');
    }
  }

  _onDown(e) {
    this._firstPos = Object(_getMouse__WEBPACK_IMPORTED_MODULE_3__["default"])(e);
    this._lastPos = Object(_getMouse__WEBPACK_IMPORTED_MODULE_3__["default"])(e);

    this._checkHit('onDown');
  }

  _onMove(e) {
    this._lastPos = Object(_getMouse__WEBPACK_IMPORTED_MODULE_3__["default"])(e);

    if (!this._skippingMove) {
      this._checkHit();
    }
  }

  _onUp() {
    const dist = distance(this._firstPos, this._lastPos);

    if (dist < this.clickTolerance) {
      this._checkHit();
    }
  }

}

/* harmony default export */ __webpack_exports__["default"] = (TouchDetector);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/TweenNumber.js":
/*!********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/TweenNumber.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var scheduling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! scheduling */ "./node_modules/scheduling/src/scheduler.js");
// TweenNumber.js



const Easing = {
  Linear: {
    None(k) {
      return k;
    }

  },
  Quadratic: {
    In(k) {
      return k * k;
    },

    Out(k) {
      return k * (2 - k);
    },

    InOut(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k;
      }

      return -0.5 * (--k * (k - 2) - 1);
    }

  },
  Cubic: {
    In(k) {
      return k * k * k;
    },

    Out(k) {
      return --k * k * k + 1;
    },

    InOut(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k;
      }

      return 0.5 * ((k -= 2) * k * k + 2);
    }

  },
  Quartic: {
    In(k) {
      return k * k * k * k;
    },

    Out(k) {
      return 1 - --k * k * k * k;
    },

    InOut(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k;
      }

      return -0.5 * ((k -= 2) * k * k * k - 2);
    }

  },
  Quintic: {
    In(k) {
      return k * k * k * k * k;
    },

    Out(k) {
      return --k * k * k * k * k + 1;
    },

    InOut(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k * k;
      }

      return 0.5 * ((k -= 2) * k * k * k * k + 2);
    }

  },
  Sinusoidal: {
    In(k) {
      return 1 - Math.cos(k * Math.PI / 2);
    },

    Out(k) {
      return Math.sin(k * Math.PI / 2);
    },

    InOut(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    }

  },
  Exponential: {
    In(k) {
      return k === 0 ? 0 : Math.pow(1024, k - 1);
    },

    Out(k) {
      return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    },

    InOut(k) {
      if (k === 0) {
        return 0;
      }

      if (k === 1) {
        return 1;
      }

      if ((k *= 2) < 1) {
        return 0.5 * Math.pow(1024, k - 1);
      }

      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    }

  },
  Circular: {
    In(k) {
      return 1 - Math.sqrt(1 - k * k);
    },

    Out(k) {
      return Math.sqrt(1 - --k * k);
    },

    InOut(k) {
      if ((k *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - k * k) - 1);
      }

      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    }

  },
  Elastic: {
    In(k) {
      let s;
      let a = 0.1;
      const p = 0.4;

      if (k === 0) {
        return 0;
      }

      if (k === 1) {
        return 1;
      }

      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }

      return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    },

    Out(k) {
      let s;
      let a = 0.1;
      const p = 0.4;

      if (k === 0) {
        return 0;
      }

      if (k === 1) {
        return 1;
      }

      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }

      return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
    },

    InOut(k) {
      let s;
      let a = 0.1;
      const p = 0.4;

      if (k === 0) {
        return 0;
      }

      if (k === 1) {
        return 1;
      }

      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }

      if ((k *= 2) < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      }

      return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
    }

  },
  Back: {
    In(k) {
      const s = 1.70158;
      return k * k * ((s + 1) * k - s);
    },

    Out(k) {
      const s = 1.70158;
      return --k * k * ((s + 1) * k + s) + 1;
    },

    InOut(k) {
      const s = 1.70158 * 1.525;

      if ((k *= 2) < 1) {
        return 0.5 * (k * k * ((s + 1) * k - s));
      }

      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    }

  },
  Bounce: {
    in(k) {
      return 1 - Easing.Bounce.out(1 - k);
    },

    out(k) {
      if (k < 1 / 2.75) {
        return 7.5625 * k * k;
      } else if (k < 2 / 2.75) {
        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
      } else if (k < 2.5 / 2.75) {
        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
      } else {
        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
      }
    },

    inOut(k) {
      if (k < 0.5) {
        return Easing.Bounce.in(k * 2) * 0.5;
      }

      return Easing.Bounce.out(k * 2 - 1) * 0.5 + 0.5;
    }

  }
};

function getFunc(mEasing) {
  switch (mEasing) {
    default:
    case 'linear':
      return Easing.Linear.None;

    case 'expIn':
      return Easing.Exponential.In;

    case 'expOut':
      return Easing.Exponential.Out;

    case 'expInOut':
      return Easing.Exponential.InOut;

    case 'cubicIn':
      return Easing.Cubic.In;

    case 'cubicOut':
      return Easing.Cubic.Out;

    case 'cubicInOut':
      return Easing.Cubic.InOut;

    case 'quarticIn':
      return Easing.Quartic.In;

    case 'quarticOut':
      return Easing.Quartic.Out;

    case 'quarticInOut':
      return Easing.Quartic.InOut;

    case 'quinticIn':
      return Easing.Quintic.In;

    case 'quinticOut':
      return Easing.Quintic.Out;

    case 'quinticInOut':
      return Easing.Quintic.InOut;

    case 'sinusoidalIn':
      return Easing.Sinusoidal.In;

    case 'sinusoidalOut':
      return Easing.Sinusoidal.Out;

    case 'sinusoidalInOut':
      return Easing.Sinusoidal.InOut;

    case 'circularIn':
      return Easing.Circular.In;

    case 'circularOut':
      return Easing.Circular.Out;

    case 'circularInOut':
      return Easing.Circular.InOut;

    case 'elasticIn':
      return Easing.Elastic.In;

    case 'elasticOut':
      return Easing.Elastic.Out;

    case 'elasticInOut':
      return Easing.Elastic.InOut;

    case 'backIn':
      return Easing.Back.In;

    case 'backOut':
      return Easing.Back.Out;

    case 'backInOut':
      return Easing.Back.InOut;

    case 'bounceIn':
      return Easing.Bounce.in;

    case 'bounceOut':
      return Easing.Bounce.out;

    case 'bounceInOut':
      return Easing.Bounce.inOut;
  }
}

class TweenNumber {
  constructor(mValue, mEasing = 'expOut', mSpeed = 0.01) {
    this._value = mValue;
    this._startValue = mValue;
    this._targetValue = mValue;
    this._counter = 1;
    this.speed = mSpeed;
    this.easing = mEasing;
    this._needUpdate = true;
    this._efIndex = scheduling__WEBPACK_IMPORTED_MODULE_0__["default"].addEF(() => this._update());
  }

  _update() {
    let newCounter = this._counter + this.speed;

    if (newCounter > 1) {
      newCounter = 1;
    }

    if (this._counter === newCounter) {
      this._needUpdate = false;
      return;
    }

    this._counter = newCounter;
    this._needUpdate = true;
  }

  limit(mMin, mMax) {
    if (mMin > mMax) {
      this.limit(mMax, mMin);
      return;
    }

    this._min = mMin;
    this._max = mMax;

    this._checkLimit();
  }

  setTo(mValue) {
    this._value = mValue;
    this._targetValue = mValue;
    this._counter = 1;
  }

  _checkLimit() {
    if (this._min !== undefined && this._targetValue < this._min) {
      this._targetValue = this._min;
    }

    if (this._max !== undefined && this._targetValue > this._max) {
      this._targetValue = this._max;
    }
  }

  destroy() {
    scheduling__WEBPACK_IMPORTED_MODULE_0__["default"].removeEF(this._efIndex);
  } //	GETTERS / SETTERS


  set value(mValue) {
    this._startValue = this._value;
    this._targetValue = mValue;

    this._checkLimit();

    this._counter = 0;
  }

  get value() {
    if (this._needUpdate) {
      const f = getFunc(this.easing);
      const p = f(this._counter);
      this._value = this._startValue + p * (this._targetValue - this._startValue);
      this._needUpdate = false;
    }

    return this._value;
  }

  get targetValue() {
    return this._targetValue;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (TweenNumber);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/WebglConst.js":
/*!*******************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/WebglConst.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// WebglConst.js
// stolen there https://github.com/mattdesl/gl-constants thanks @mattdesl ^^
module.exports = {
  ACTIVE_ATTRIBUTES: 35721,
  ACTIVE_ATTRIBUTE_MAX_LENGTH: 35722,
  ACTIVE_TEXTURE: 34016,
  ACTIVE_UNIFORMS: 35718,
  ACTIVE_UNIFORM_MAX_LENGTH: 35719,
  ALIASED_LINE_WIDTH_RANGE: 33902,
  ALIASED_POINT_SIZE_RANGE: 33901,
  ALPHA: 6406,
  ALPHA_BITS: 3413,
  ALWAYS: 519,
  ARRAY_BUFFER: 34962,
  ARRAY_BUFFER_BINDING: 34964,
  ATTACHED_SHADERS: 35717,
  BACK: 1029,
  BLEND: 3042,
  BLEND_COLOR: 32773,
  BLEND_DST_ALPHA: 32970,
  BLEND_DST_RGB: 32968,
  BLEND_EQUATION: 32777,
  BLEND_EQUATION_ALPHA: 34877,
  BLEND_EQUATION_RGB: 32777,
  BLEND_SRC_ALPHA: 32971,
  BLEND_SRC_RGB: 32969,
  BLUE_BITS: 3412,
  BOOL: 35670,
  BOOL_VEC2: 35671,
  BOOL_VEC3: 35672,
  BOOL_VEC4: 35673,
  BROWSER_DEFAULT_WEBGL: 37444,
  BUFFER_SIZE: 34660,
  BUFFER_USAGE: 34661,
  BYTE: 5120,
  CCW: 2305,
  CLAMP_TO_EDGE: 33071,
  COLOR_ATTACHMENT0: 36064,
  COLOR_BUFFER_BIT: 16384,
  COLOR_CLEAR_VALUE: 3106,
  COLOR_WRITEMASK: 3107,
  COMPILE_STATUS: 35713,
  COMPRESSED_TEXTURE_FORMATS: 34467,
  CONSTANT_ALPHA: 32771,
  CONSTANT_COLOR: 32769,
  CONTEXT_LOST_WEBGL: 37442,
  CULL_FACE: 2884,
  CULL_FACE_MODE: 2885,
  CURRENT_PROGRAM: 35725,
  CURRENT_VERTEX_ATTRIB: 34342,
  CW: 2304,
  DECR: 7683,
  DECR_WRAP: 34056,
  DELETE_STATUS: 35712,
  DEPTH_ATTACHMENT: 36096,
  DEPTH_BITS: 3414,
  DEPTH_BUFFER_BIT: 256,
  DEPTH_CLEAR_VALUE: 2931,
  DEPTH_COMPONENT: 6402,
  RED: 6403,
  DEPTH_COMPONENT16: 33189,
  DEPTH_FUNC: 2932,
  DEPTH_RANGE: 2928,
  DEPTH_STENCIL: 34041,
  DEPTH_STENCIL_ATTACHMENT: 33306,
  DEPTH_TEST: 2929,
  DEPTH_WRITEMASK: 2930,
  DITHER: 3024,
  DONT_CARE: 4352,
  DST_ALPHA: 772,
  DST_COLOR: 774,
  DYNAMIC_DRAW: 35048,
  ELEMENT_ARRAY_BUFFER: 34963,
  ELEMENT_ARRAY_BUFFER_BINDING: 34965,
  EQUAL: 514,
  FASTEST: 4353,
  FLOAT: 5126,
  FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  FRAGMENT_SHADER: 35632,
  FRAMEBUFFER: 36160,
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
  FRAMEBUFFER_BINDING: 36006,
  FRAMEBUFFER_COMPLETE: 36053,
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
  FRAMEBUFFER_UNSUPPORTED: 36061,
  FRONT: 1028,
  FRONT_AND_BACK: 1032,
  FRONT_FACE: 2886,
  FUNC_ADD: 32774,
  FUNC_REVERSE_SUBTRACT: 32779,
  FUNC_SUBTRACT: 32778,
  GENERATE_MIPMAP_HINT: 33170,
  GEQUAL: 518,
  GREATER: 516,
  GREEN_BITS: 3411,
  HIGH_FLOAT: 36338,
  HIGH_INT: 36341,
  INCR: 7682,
  INCR_WRAP: 34055,
  INFO_LOG_LENGTH: 35716,
  INT: 5124,
  INT_VEC2: 35667,
  INT_VEC3: 35668,
  INT_VEC4: 35669,
  INVALID_ENUM: 1280,
  INVALID_FRAMEBUFFER_OPERATION: 1286,
  INVALID_OPERATION: 1282,
  INVALID_VALUE: 1281,
  INVERT: 5386,
  KEEP: 7680,
  LEQUAL: 515,
  LESS: 513,
  LINEAR: 9729,
  LINEAR_MIPMAP_LINEAR: 9987,
  LINEAR_MIPMAP_NEAREST: 9985,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  LINE_WIDTH: 2849,
  LINK_STATUS: 35714,
  LOW_FLOAT: 36336,
  LOW_INT: 36339,
  LUMINANCE: 6409,
  LUMINANCE_ALPHA: 6410,
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
  MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
  MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
  MAX_RENDERBUFFER_SIZE: 34024,
  MAX_TEXTURE_IMAGE_UNITS: 34930,
  MAX_TEXTURE_SIZE: 3379,
  MAX_VARYING_VECTORS: 36348,
  MAX_VERTEX_ATTRIBS: 34921,
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
  MAX_VERTEX_UNIFORM_VECTORS: 36347,
  MAX_VIEWPORT_DIMS: 3386,
  MEDIUM_FLOAT: 36337,
  MEDIUM_INT: 36340,
  MIRRORED_REPEAT: 33648,
  NEAREST: 9728,
  NEAREST_MIPMAP_LINEAR: 9986,
  NEAREST_MIPMAP_NEAREST: 9984,
  NEVER: 512,
  NICEST: 4354,
  NONE: 0,
  NOTEQUAL: 517,
  NO_ERROR: 0,
  NUM_COMPRESSED_TEXTURE_FORMATS: 34466,
  ONE: 1,
  ONE_MINUS_CONSTANT_ALPHA: 32772,
  ONE_MINUS_CONSTANT_COLOR: 32770,
  ONE_MINUS_DST_ALPHA: 773,
  ONE_MINUS_DST_COLOR: 775,
  ONE_MINUS_SRC_ALPHA: 771,
  ONE_MINUS_SRC_COLOR: 769,
  OUT_OF_MEMORY: 1285,
  PACK_ALIGNMENT: 3333,
  POINTS: 0,
  POLYGON_OFFSET_FACTOR: 32824,
  POLYGON_OFFSET_FILL: 32823,
  POLYGON_OFFSET_UNITS: 10752,
  RED_BITS: 3410,
  RENDERBUFFER: 36161,
  RENDERBUFFER_ALPHA_SIZE: 36179,
  RENDERBUFFER_BINDING: 36007,
  RENDERBUFFER_BLUE_SIZE: 36178,
  RENDERBUFFER_DEPTH_SIZE: 36180,
  RENDERBUFFER_GREEN_SIZE: 36177,
  RENDERBUFFER_HEIGHT: 36163,
  RENDERBUFFER_INTERNAL_FORMAT: 36164,
  RENDERBUFFER_RED_SIZE: 36176,
  RENDERBUFFER_STENCIL_SIZE: 36181,
  RENDERBUFFER_WIDTH: 36162,
  RENDERER: 7937,
  REPEAT: 10497,
  REPLACE: 7681,
  RGB: 6407,
  RGB5_A1: 32855,
  RGB565: 36194,
  RGBA: 6408,
  RGBA4: 32854,
  SAMPLER_2D: 35678,
  SAMPLER_CUBE: 35680,
  SAMPLES: 32937,
  SAMPLE_ALPHA_TO_COVERAGE: 32926,
  SAMPLE_BUFFERS: 32936,
  SAMPLE_COVERAGE: 32928,
  SAMPLE_COVERAGE_INVERT: 32939,
  SAMPLE_COVERAGE_VALUE: 32938,
  SCISSOR_BOX: 3088,
  SCISSOR_TEST: 3089,
  SHADER_COMPILER: 36346,
  SHADER_SOURCE_LENGTH: 35720,
  SHADER_TYPE: 35663,
  SHADING_LANGUAGE_VERSION: 35724,
  SHORT: 5122,
  SRC_ALPHA: 770,
  SRC_ALPHA_SATURATE: 776,
  SRC_COLOR: 768,
  STATIC_DRAW: 35044,
  STENCIL_ATTACHMENT: 36128,
  STENCIL_BACK_FAIL: 34817,
  STENCIL_BACK_FUNC: 34816,
  STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
  STENCIL_BACK_PASS_DEPTH_PASS: 34819,
  STENCIL_BACK_REF: 36003,
  STENCIL_BACK_VALUE_MASK: 36004,
  STENCIL_BACK_WRITEMASK: 36005,
  STENCIL_BITS: 3415,
  STENCIL_BUFFER_BIT: 1024,
  STENCIL_CLEAR_VALUE: 2961,
  STENCIL_FAIL: 2964,
  STENCIL_FUNC: 2962,
  STENCIL_INDEX: 6401,
  STENCIL_INDEX8: 36168,
  STENCIL_PASS_DEPTH_FAIL: 2965,
  STENCIL_PASS_DEPTH_PASS: 2966,
  STENCIL_REF: 2967,
  STENCIL_TEST: 2960,
  STENCIL_VALUE_MASK: 2963,
  STENCIL_WRITEMASK: 2968,
  STREAM_DRAW: 35040,
  SUBPIXEL_BITS: 3408,
  TEXTURE: 5890,
  TEXTURE0: 33984,
  TEXTURE1: 33985,
  TEXTURE2: 33986,
  TEXTURE3: 33987,
  TEXTURE4: 33988,
  TEXTURE5: 33989,
  TEXTURE6: 33990,
  TEXTURE7: 33991,
  TEXTURE8: 33992,
  TEXTURE9: 33993,
  TEXTURE10: 33994,
  TEXTURE11: 33995,
  TEXTURE12: 33996,
  TEXTURE13: 33997,
  TEXTURE14: 33998,
  TEXTURE15: 33999,
  TEXTURE16: 34000,
  TEXTURE17: 34001,
  TEXTURE18: 34002,
  TEXTURE19: 34003,
  TEXTURE20: 34004,
  TEXTURE21: 34005,
  TEXTURE22: 34006,
  TEXTURE23: 34007,
  TEXTURE24: 34008,
  TEXTURE25: 34009,
  TEXTURE26: 34010,
  TEXTURE27: 34011,
  TEXTURE28: 34012,
  TEXTURE29: 34013,
  TEXTURE30: 34014,
  TEXTURE31: 34015,
  TEXTURE_2D: 3553,
  TEXTURE_BINDING_2D: 32873,
  TEXTURE_BINDING_CUBE_MAP: 34068,
  TEXTURE_CUBE_MAP: 34067,
  TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
  TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
  TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
  TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  TRIANGLES: 4,
  TRIANGLE_FAN: 6,
  TRIANGLE_STRIP: 5,
  UNPACK_ALIGNMENT: 3317,
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
  UNPACK_FLIP_Y_WEBGL: 37440,
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_INT: 5125,
  UNSIGNED_SHORT: 5123,
  UNSIGNED_SHORT_4_4_4_4: 32819,
  UNSIGNED_SHORT_5_5_5_1: 32820,
  UNSIGNED_SHORT_5_6_5: 33635,
  VALIDATE_STATUS: 35715,
  VENDOR: 7936,
  VERSION: 7938,
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
  VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
  VERTEX_ATTRIB_ARRAY_POINTER: 34373,
  VERTEX_ATTRIB_ARRAY_SIZE: 34339,
  VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
  VERTEX_ATTRIB_ARRAY_TYPE: 34341,
  VERTEX_SHADER: 35633,
  VIEWPORT: 2978,
  ZERO: 0,
  R8: 33321
};

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/WebglNumber.js":
/*!********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/WebglNumber.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// stolen there https://github.com/mattdesl/gl-constants thanks @mattdesl ^^
module.exports = {
  0: 'NONE',
  1: 'ONE',
  2: 'LINE_LOOP',
  3: 'LINE_STRIP',
  4: 'TRIANGLES',
  5: 'TRIANGLE_STRIP',
  6: 'TRIANGLE_FAN',
  256: 'DEPTH_BUFFER_BIT',
  512: 'NEVER',
  513: 'LESS',
  514: 'EQUAL',
  515: 'LEQUAL',
  516: 'GREATER',
  517: 'NOTEQUAL',
  518: 'GEQUAL',
  519: 'ALWAYS',
  768: 'SRC_COLOR',
  769: 'ONE_MINUS_SRC_COLOR',
  770: 'SRC_ALPHA',
  771: 'ONE_MINUS_SRC_ALPHA',
  772: 'DST_ALPHA',
  773: 'ONE_MINUS_DST_ALPHA',
  774: 'DST_COLOR',
  775: 'ONE_MINUS_DST_COLOR',
  776: 'SRC_ALPHA_SATURATE',
  1024: 'STENCIL_BUFFER_BIT',
  1028: 'FRONT',
  1029: 'BACK',
  1032: 'FRONT_AND_BACK',
  1280: 'INVALID_ENUM',
  1281: 'INVALID_VALUE',
  1282: 'INVALID_OPERATION',
  1285: 'OUT_OF_MEMORY',
  1286: 'INVALID_FRAMEBUFFER_OPERATION',
  2304: 'CW',
  2305: 'CCW',
  2849: 'LINE_WIDTH',
  2884: 'CULL_FACE',
  2885: 'CULL_FACE_MODE',
  2886: 'FRONT_FACE',
  2928: 'DEPTH_RANGE',
  2929: 'DEPTH_TEST',
  2930: 'DEPTH_WRITEMASK',
  2931: 'DEPTH_CLEAR_VALUE',
  2932: 'DEPTH_FUNC',
  2960: 'STENCIL_TEST',
  2961: 'STENCIL_CLEAR_VALUE',
  2962: 'STENCIL_FUNC',
  2963: 'STENCIL_VALUE_MASK',
  2964: 'STENCIL_FAIL',
  2965: 'STENCIL_PASS_DEPTH_FAIL',
  2966: 'STENCIL_PASS_DEPTH_PASS',
  2967: 'STENCIL_REF',
  2968: 'STENCIL_WRITEMASK',
  2978: 'VIEWPORT',
  3024: 'DITHER',
  3042: 'BLEND',
  3088: 'SCISSOR_BOX',
  3089: 'SCISSOR_TEST',
  3106: 'COLOR_CLEAR_VALUE',
  3107: 'COLOR_WRITEMASK',
  3317: 'UNPACK_ALIGNMENT',
  3333: 'PACK_ALIGNMENT',
  3379: 'MAX_TEXTURE_SIZE',
  3386: 'MAX_VIEWPORT_DIMS',
  3408: 'SUBPIXEL_BITS',
  3410: 'RED_BITS',
  3411: 'GREEN_BITS',
  3412: 'BLUE_BITS',
  3413: 'ALPHA_BITS',
  3414: 'DEPTH_BITS',
  3415: 'STENCIL_BITS',
  3553: 'TEXTURE_2D',
  4352: 'DONT_CARE',
  4353: 'FASTEST',
  4354: 'NICEST',
  5120: 'BYTE',
  5121: 'UNSIGNED_BYTE',
  5122: 'SHORT',
  5123: 'UNSIGNED_SHORT',
  5124: 'INT',
  5125: 'UNSIGNED_INT',
  5126: 'FLOAT',
  5386: 'INVERT',
  5890: 'TEXTURE',
  6401: 'STENCIL_INDEX',
  6402: 'DEPTH_COMPONENT',
  6403: 'RED',
  6406: 'ALPHA',
  6407: 'RGB',
  6408: 'RGBA',
  6409: 'LUMINANCE',
  6410: 'LUMINANCE_ALPHA',
  7680: 'KEEP',
  7681: 'REPLACE',
  7682: 'INCR',
  7683: 'DECR',
  7936: 'VENDOR',
  7937: 'RENDERER',
  7938: 'VERSION',
  9728: 'NEAREST',
  9729: 'LINEAR',
  9984: 'NEAREST_MIPMAP_NEAREST',
  9985: 'LINEAR_MIPMAP_NEAREST',
  9986: 'NEAREST_MIPMAP_LINEAR',
  9987: 'LINEAR_MIPMAP_LINEAR',
  10240: 'TEXTURE_MAG_FILTER',
  10241: 'TEXTURE_MIN_FILTER',
  10242: 'TEXTURE_WRAP_S',
  10243: 'TEXTURE_WRAP_T',
  10497: 'REPEAT',
  10752: 'POLYGON_OFFSET_UNITS',
  16384: 'COLOR_BUFFER_BIT',
  32769: 'CONSTANT_COLOR',
  32770: 'ONE_MINUS_CONSTANT_COLOR',
  32771: 'CONSTANT_ALPHA',
  32772: 'ONE_MINUS_CONSTANT_ALPHA',
  32773: 'BLEND_COLOR',
  32774: 'FUNC_ADD',
  32777: 'BLEND_EQUATION_RGB',
  32778: 'FUNC_SUBTRACT',
  32779: 'FUNC_REVERSE_SUBTRACT',
  32819: 'UNSIGNED_SHORT_4_4_4_4',
  32820: 'UNSIGNED_SHORT_5_5_5_1',
  32823: 'POLYGON_OFFSET_FILL',
  32824: 'POLYGON_OFFSET_FACTOR',
  32854: 'RGBA4',
  32855: 'RGB5_A1',
  32873: 'TEXTURE_BINDING_2D',
  32926: 'SAMPLE_ALPHA_TO_COVERAGE',
  32928: 'SAMPLE_COVERAGE',
  32936: 'SAMPLE_BUFFERS',
  32937: 'SAMPLES',
  32938: 'SAMPLE_COVERAGE_VALUE',
  32939: 'SAMPLE_COVERAGE_INVERT',
  32968: 'BLEND_DST_RGB',
  32969: 'BLEND_SRC_RGB',
  32970: 'BLEND_DST_ALPHA',
  32971: 'BLEND_SRC_ALPHA',
  33071: 'CLAMP_TO_EDGE',
  33170: 'GENERATE_MIPMAP_HINT',
  33189: 'DEPTH_COMPONENT16',
  33306: 'DEPTH_STENCIL_ATTACHMENT',
  33321: 'R8',
  33635: 'UNSIGNED_SHORT_5_6_5',
  33648: 'MIRRORED_REPEAT',
  33901: 'ALIASED_POINT_SIZE_RANGE',
  33902: 'ALIASED_LINE_WIDTH_RANGE',
  33984: 'TEXTURE0',
  33985: 'TEXTURE1',
  33986: 'TEXTURE2',
  33987: 'TEXTURE3',
  33988: 'TEXTURE4',
  33989: 'TEXTURE5',
  33990: 'TEXTURE6',
  33991: 'TEXTURE7',
  33992: 'TEXTURE8',
  33993: 'TEXTURE9',
  33994: 'TEXTURE10',
  33995: 'TEXTURE11',
  33996: 'TEXTURE12',
  33997: 'TEXTURE13',
  33998: 'TEXTURE14',
  33999: 'TEXTURE15',
  34000: 'TEXTURE16',
  34001: 'TEXTURE17',
  34002: 'TEXTURE18',
  34003: 'TEXTURE19',
  34004: 'TEXTURE20',
  34005: 'TEXTURE21',
  34006: 'TEXTURE22',
  34007: 'TEXTURE23',
  34008: 'TEXTURE24',
  34009: 'TEXTURE25',
  34010: 'TEXTURE26',
  34011: 'TEXTURE27',
  34012: 'TEXTURE28',
  34013: 'TEXTURE29',
  34014: 'TEXTURE30',
  34015: 'TEXTURE31',
  34016: 'ACTIVE_TEXTURE',
  34024: 'MAX_RENDERBUFFER_SIZE',
  34041: 'DEPTH_STENCIL',
  34055: 'INCR_WRAP',
  34056: 'DECR_WRAP',
  34067: 'TEXTURE_CUBE_MAP',
  34068: 'TEXTURE_BINDING_CUBE_MAP',
  34069: 'TEXTURE_CUBE_MAP_POSITIVE_X',
  34070: 'TEXTURE_CUBE_MAP_NEGATIVE_X',
  34071: 'TEXTURE_CUBE_MAP_POSITIVE_Y',
  34072: 'TEXTURE_CUBE_MAP_NEGATIVE_Y',
  34073: 'TEXTURE_CUBE_MAP_POSITIVE_Z',
  34074: 'TEXTURE_CUBE_MAP_NEGATIVE_Z',
  34076: 'MAX_CUBE_MAP_TEXTURE_SIZE',
  34338: 'VERTEX_ATTRIB_ARRAY_ENABLED',
  34339: 'VERTEX_ATTRIB_ARRAY_SIZE',
  34340: 'VERTEX_ATTRIB_ARRAY_STRIDE',
  34341: 'VERTEX_ATTRIB_ARRAY_TYPE',
  34342: 'CURRENT_VERTEX_ATTRIB',
  34373: 'VERTEX_ATTRIB_ARRAY_POINTER',
  34466: 'NUM_COMPRESSED_TEXTURE_FORMATS',
  34467: 'COMPRESSED_TEXTURE_FORMATS',
  34660: 'BUFFER_SIZE',
  34661: 'BUFFER_USAGE',
  34816: 'STENCIL_BACK_FUNC',
  34817: 'STENCIL_BACK_FAIL',
  34818: 'STENCIL_BACK_PASS_DEPTH_FAIL',
  34819: 'STENCIL_BACK_PASS_DEPTH_PASS',
  34877: 'BLEND_EQUATION_ALPHA',
  34921: 'MAX_VERTEX_ATTRIBS',
  34922: 'VERTEX_ATTRIB_ARRAY_NORMALIZED',
  34930: 'MAX_TEXTURE_IMAGE_UNITS',
  34962: 'ARRAY_BUFFER',
  34963: 'ELEMENT_ARRAY_BUFFER',
  34964: 'ARRAY_BUFFER_BINDING',
  34965: 'ELEMENT_ARRAY_BUFFER_BINDING',
  34975: 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING',
  35040: 'STREAM_DRAW',
  35044: 'STATIC_DRAW',
  35048: 'DYNAMIC_DRAW',
  35632: 'FRAGMENT_SHADER',
  35633: 'VERTEX_SHADER',
  35660: 'MAX_VERTEX_TEXTURE_IMAGE_UNITS',
  35661: 'MAX_COMBINED_TEXTURE_IMAGE_UNITS',
  35663: 'SHADER_TYPE',
  35664: 'FLOAT_VEC2',
  35665: 'FLOAT_VEC3',
  35666: 'FLOAT_VEC4',
  35667: 'INT_VEC2',
  35668: 'INT_VEC3',
  35669: 'INT_VEC4',
  35670: 'BOOL',
  35671: 'BOOL_VEC2',
  35672: 'BOOL_VEC3',
  35673: 'BOOL_VEC4',
  35674: 'FLOAT_MAT2',
  35675: 'FLOAT_MAT3',
  35676: 'FLOAT_MAT4',
  35678: 'SAMPLER_2D',
  35680: 'SAMPLER_CUBE',
  35712: 'DELETE_STATUS',
  35713: 'COMPILE_STATUS',
  35714: 'LINK_STATUS',
  35715: 'VALIDATE_STATUS',
  35716: 'INFO_LOG_LENGTH',
  35717: 'ATTACHED_SHADERS',
  35718: 'ACTIVE_UNIFORMS',
  35719: 'ACTIVE_UNIFORM_MAX_LENGTH',
  35720: 'SHADER_SOURCE_LENGTH',
  35721: 'ACTIVE_ATTRIBUTES',
  35722: 'ACTIVE_ATTRIBUTE_MAX_LENGTH',
  35724: 'SHADING_LANGUAGE_VERSION',
  35725: 'CURRENT_PROGRAM',
  36003: 'STENCIL_BACK_REF',
  36004: 'STENCIL_BACK_VALUE_MASK',
  36005: 'STENCIL_BACK_WRITEMASK',
  36006: 'FRAMEBUFFER_BINDING',
  36007: 'RENDERBUFFER_BINDING',
  36048: 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE',
  36049: 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME',
  36050: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL',
  36051: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE',
  36053: 'FRAMEBUFFER_COMPLETE',
  36054: 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',
  36055: 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',
  36057: 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',
  36061: 'FRAMEBUFFER_UNSUPPORTED',
  36064: 'COLOR_ATTACHMENT0',
  36096: 'DEPTH_ATTACHMENT',
  36128: 'STENCIL_ATTACHMENT',
  36160: 'FRAMEBUFFER',
  36161: 'RENDERBUFFER',
  36162: 'RENDERBUFFER_WIDTH',
  36163: 'RENDERBUFFER_HEIGHT',
  36164: 'RENDERBUFFER_INTERNAL_FORMAT',
  36168: 'STENCIL_INDEX8',
  36176: 'RENDERBUFFER_RED_SIZE',
  36177: 'RENDERBUFFER_GREEN_SIZE',
  36178: 'RENDERBUFFER_BLUE_SIZE',
  36179: 'RENDERBUFFER_ALPHA_SIZE',
  36180: 'RENDERBUFFER_DEPTH_SIZE',
  36181: 'RENDERBUFFER_STENCIL_SIZE',
  36194: 'RGB565',
  36336: 'LOW_FLOAT',
  36337: 'MEDIUM_FLOAT',
  36338: 'HIGH_FLOAT',
  36339: 'LOW_INT',
  36340: 'MEDIUM_INT',
  36341: 'HIGH_INT',
  36346: 'SHADER_COMPILER',
  36347: 'MAX_VERTEX_UNIFORM_VECTORS',
  36348: 'MAX_VARYING_VECTORS',
  36349: 'MAX_FRAGMENT_UNIFORM_VECTORS',
  37440: 'UNPACK_FLIP_Y_WEBGL',
  37441: 'UNPACK_PREMULTIPLY_ALPHA_WEBGL',
  37442: 'CONTEXT_LOST_WEBGL',
  37443: 'UNPACK_COLORSPACE_CONVERSION_WEBGL',
  37444: 'BROWSER_DEFAULT_WEBGL'
};

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/exposeAttributes.js":
/*!*************************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/exposeAttributes.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
/* harmony import */ var _WebglConst__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebglConst */ "./src/js/libs/alfrid/alfrid/utils/WebglConst.js");
/* harmony import */ var _WebglConst__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_WebglConst__WEBPACK_IMPORTED_MODULE_1__);
// exposeAttributes.js



const exposeAttributes = function () {
  for (const s in _WebglConst__WEBPACK_IMPORTED_MODULE_1___default.a) {
    if (!_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"][s]) {
      _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"][s] = _WebglConst__WEBPACK_IMPORTED_MODULE_1___default.a[s];
    } else {
      if (s !== 'FLOAT') console.log('already exist : ', s);
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (exposeAttributes);

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/getAndApplyExtension.js":
/*!*****************************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/getAndApplyExtension.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getAndApplyExtension; });
// VertexArrayObject.js
function getAndApplyExtension(gl, name) {
  const ext = gl.getExtension(name);

  if (!ext) {
    return false;
  }

  const suffix = name.split('_')[0];
  const suffixRE = new RegExp(`${suffix}$`);

  for (const key in ext) {
    const val = ext[key];

    if (typeof val === 'function') {
      const unsuffixedKey = key.replace(suffixRE, '');

      if (key.substring) {
        gl[unsuffixedKey] = ext[key].bind(ext); // console.log('Replacing :', key, '=>', unsuffixedKey);
      }
    }
  }

  return true;
}

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/getAttribLoc.js":
/*!*********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/getAttribLoc.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// getAttribLoc.js
/* harmony default export */ __webpack_exports__["default"] = (function (gl, shaderProgram, name) {
  if (shaderProgram.cacheAttribLoc === undefined) {
    shaderProgram.cacheAttribLoc = {};
  }

  if (shaderProgram.cacheAttribLoc[name] === undefined) {
    shaderProgram.cacheAttribLoc[name] = gl.getAttribLocation(shaderProgram, name);
  }

  return shaderProgram.cacheAttribLoc[name];
});
;

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/getFloat.js":
/*!*****************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/getFloat.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
// getFloat.js

let hasChecked = false;

let _float;

function checkFloat() {
  if (_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].webgl2) {
    return _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl.FLOAT;
  } else {
    const extFloat = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension('OES_texture_float');

    if (extFloat) {
      return _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl.FLOAT;
    } else {
      console.warn('USING FLOAT BUT OES_texture_float NOT SUPPORTED');
      return _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNSIGNED_BYTE;
    }
  }

  hasChecked = true;
}

;
/* harmony default export */ __webpack_exports__["default"] = (function () {
  if (!hasChecked) {
    _float = checkFloat();
  }

  return _float;
});

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/getHalfFloat.js":
/*!*********************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/getHalfFloat.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
// getHalfFloat.js

let hasChecked = false;
let halfFloat;

function checkHalfFloat() {
  if (_GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].webgl2) {
    return _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl.HALF_FLOAT;
  } else {
    const extHalfFloat = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension('OES_texture_half_float');

    if (extHalfFloat) {
      return extHalfFloat.HALF_FLOAT_OES;
    } else {
      console.warn('USING HALF FLOAT BUT OES_texture_half_float NOT SUPPORTED');
      return _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNSIGNED_BYTE;
    }
  }

  hasChecked = true;
}

;
/* harmony default export */ __webpack_exports__["default"] = (function () {
  if (!hasChecked) {
    halfFloat = checkHalfFloat();
  }

  return halfFloat;
});

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/getMouse.js":
/*!*****************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/getMouse.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// getMouse.js
/* harmony default export */ __webpack_exports__["default"] = (function (e) {
  let x, y;

  if (e.touches) {
    x = e.touches[0].pageX;
    y = e.touches[0].pageY;
  } else {
    x = e.clientX;
    y = e.clientY;
  }

  return {
    x,
    y
  };
});

/***/ }),

/***/ "./src/js/libs/alfrid/alfrid/utils/getTextureParameters.js":
/*!*****************************************************************!*\
  !*** ./src/js/libs/alfrid/alfrid/utils/getTextureParameters.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GLTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLTool */ "./src/js/libs/alfrid/alfrid/GLTool.js");
// getTextureParameters.js


function isPowerOfTwo(x) {
  return x !== 0 && !(x & x - 1);
}

;

const getTextureParameters = function (mParams, mSource, mWidth, mHeight) {
  if (!mParams.minFilter) {
    let minFilter = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].LINEAR;

    if (mWidth && mWidth) {
      if (isPowerOfTwo(mWidth) && isPowerOfTwo(mHeight)) {
        minFilter = _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].NEAREST_MIPMAP_LINEAR;
      }
    }

    mParams.minFilter = minFilter;
  }

  mParams.mipmap = mParams.mipmap === undefined ? true : mParams.mipmap;
  mParams.magFilter = mParams.magFilter || _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].LINEAR;
  mParams.wrapS = mParams.wrapS || _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].CLAMP_TO_EDGE;
  mParams.wrapT = mParams.wrapT || _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].CLAMP_TO_EDGE;
  mParams.internalFormat = mParams.internalFormat || _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].RGBA;
  mParams.format = mParams.format || _GLTool__WEBPACK_IMPORTED_MODULE_0__["default"].RGBA;
  mParams.premultiplyAlpha = mParams.premultiplyAlpha === undefined ? false : mParams.premultiplyAlpha;
  mParams.level = mParams.level || 0;
  return mParams;
};

/* harmony default export */ __webpack_exports__["default"] = (getTextureParameters);

/***/ }),

/***/ "./src/js/modelViewer/CameraSpots.js":
/*!*******************************************!*\
  !*** ./src/js/modelViewer/CameraSpots.js ***!
  \*******************************************/
/*! exports provided: CameraSpots */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraSpots", function() { return CameraSpots; });
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils */ "./src/js/utils/index.js");
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Config */ "./src/js/modelViewer/Config.js");
/* harmony import */ var _geom_Line__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geom/Line */ "./src/js/modelViewer/geom/Line.js");
/* harmony import */ var mini_signals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! mini-signals */ "./node_modules/mini-signals/lib/mini-signals.js");
/* harmony import */ var mini_signals__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(mini_signals__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_color_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! shaders/color.frag */ "./src/shaders/color.frag");
/* harmony import */ var shaders_line_frag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! shaders/line.frag */ "./src/shaders/line.frag");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var shaders_marker_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! shaders/marker.vert */ "./src/shaders/marker.vert");
/* harmony import */ var shaders_line_vert__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! shaders/line.vert */ "./src/shaders/line.vert");










const tempVec3 = vec3.create();
class CameraSpots {
  constructor(scene, container, spots) {
    this.shader = new alfrid__WEBPACK_IMPORTED_MODULE_0__["GLShader"](shaders_marker_vert__WEBPACK_IMPORTED_MODULE_8__["default"], shaders_color_frag__WEBPACK_IMPORTED_MODULE_5__["default"]);
    this.shaderLine = new alfrid__WEBPACK_IMPORTED_MODULE_0__["GLShader"](shaders_line_vert__WEBPACK_IMPORTED_MODULE_9__["default"], shaders_line_frag__WEBPACK_IMPORTED_MODULE_6__["default"]);
    this.onSpotClicked = new mini_signals__WEBPACK_IMPORTED_MODULE_4___default.a();
    this.scene = scene;
    this.active = false;
    this.shown = true;
    this.orbitalControl = scene.orbitalControl;
    this.spots = [];
    this.lines = [];
    if (spots) this.addSpots(spots);
  }

  show() {
    this.shown = true;
  }

  hide() {
    this.shown = false;
  }

  start() {
    this.active = true;
  }

  stop() {
    this.active = false;
  }

  addSpots(spots) {
    if (!spots.length) return;
    const s = 0.02;
    this.mesh = alfrid__WEBPACK_IMPORTED_MODULE_0__["Geom"].sphere(s, 20);
    const posOffset = [];

    for (let i = 0; i < spots.length; i++) {
      const currentSpot = spots[i];
      const name = currentSpot.name || `Annotation ${i + 1}`;
      const origin = currentSpot.target; // this.orbitalControl.getPosition(currentSpot.rx, currentSpot.ry, currentSpot.zoom);

      const pos = this.orbitalControl.getPosition(currentSpot.rx, currentSpot.ry, currentSpot.zoom);
      pos[0] += currentSpot.offset[0];
      pos[1] += currentSpot.offset[1];
      pos[2] += currentSpot.offset[2];
      const dist = Object(utils__WEBPACK_IMPORTED_MODULE_1__["getDistOptim3D"])(origin[0], pos[0], origin[1], pos[1], origin[2], pos[2]);

      if (dist > 2) {
        let p = 2 / dist;
        pos[0] = origin[0] + (pos[0] - origin[0]) * p;
        pos[1] = origin[1] + (pos[1] - origin[1]) * p;
        pos[2] = origin[2] + (pos[2] - origin[2]) * p;
      }

      posOffset.push(origin); // create html

      const text = this.addSpotText(name, currentSpot);
      this.spots.push({
        target: currentSpot.target,
        pos,
        text,
        opacity: 0
      });
      const line = new _geom_Line__WEBPACK_IMPORTED_MODULE_3__["Line"]([pos, currentSpot.target]);
      this.lines.push(line);
    }

    this.mesh.bufferInstance(posOffset, 'aPosOffset');
  }

  addSpotText(name, data) {
    const text = document.createElement('p');
    text.className = 'spot';

    text.onclick = () => {
      this.onSpotClicked.dispatch(data);
    };

    text.innerHTML = data.label;
    this.scene.containerHTML.appendChild(text);
    return text;
  }

  getXY(pos, viewMatrix, projectionMatrix, screenWidth, screenHeight) {
    vec3.transformMat4(tempVec3, pos, viewMatrix);
    vec3.transformMat4(tempVec3, tempVec3, projectionMatrix);
    tempVec3[0] /= tempVec3[2];
    tempVec3[1] /= tempVec3[2];
    tempVec3[0] = (tempVec3[0] + 1) * screenWidth / 2;
    tempVec3[1] = screenHeight - (tempVec3[1] + 1) * screenHeight / 2;
    return tempVec3;
  }

  render(currentSpot) {
    const opacity = this.active && this.shown ? 1 : 0;

    for (let i = 0; i < this.spots.length; i++) {
      const spot = this.spots[i];
      spot.opacity += (opacity - spot.opacity) * 0.3;

      if (Math.abs(spot.opacity - opacity) < 0.05 && spot.opacity !== opacity) {
        spot.opacity = opacity;
      }

      if (spot.text.style.opacity !== spot.opacity) {
        spot.text.style.opacity = spot.opacity;

        if (spot.opacity === 0) {
          spot.text.style.display = 'none';
        } else if (spot.opacity === 1) {
          spot.text.style.display = 'block';
        }
      }

      if (opacity) {
        const res = Object(utils__WEBPACK_IMPORTED_MODULE_1__["get2dPos"])(spot.pos);
        spot.text.style.left = `${res[0]}px`;
        spot.text.style.top = `${res[1] - 20}px`;
      }
    }

    if (!this.active || !this.shown || !this.mesh) return;
    const colorSpot = _Config__WEBPACK_IMPORTED_MODULE_2__["default"].annotations.color.map(v => v / 255);
    this.shader.bind();
    this.shader.uniform('uColor', 'vec3', colorSpot);
    this.shader.uniform('uAlpha', 'float', _Config__WEBPACK_IMPORTED_MODULE_2__["default"].annotations.alpha);
    this.shader.uniform('uScale', 'float', _Config__WEBPACK_IMPORTED_MODULE_2__["default"].annotations.scale);
    alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].draw(this.mesh); // Draw the lines

    this.shaderLine.bind();
    this.shaderLine.uniform('uAlpha', 'float', 1);
    this.shaderLine.uniform('thickness', 'float', .02);
    this.shaderLine.uniform('uColor', 'vec3', colorSpot);
    this.shaderLine.uniform('aspect', 'float', alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].aspectRatio);

    for (let i = 0; i < this.lines.length; i++) {
      const line = this.lines[i];
      alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].draw(line);
    }
  }

}

/***/ }),

/***/ "./src/js/modelViewer/Config.js":
/*!**************************************!*\
  !*** ./src/js/modelViewer/Config.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Config.js
/* harmony default export */ __webpack_exports__["default"] = ({
  metallic: 0,
  debug: {
    shape: {
      active: false,
      rot: {
        x: 0,
        y: 0,
        z: 0
      },
      scale: {
        x: 1,
        y: 1,
        z: 1
      },
      pos: {
        x: 0,
        y: 0,
        z: 0
      }
    }
  },
  editor: {
    active: false,
    points: []
  },
  annotations: {
    scale: 1,
    color: [0, 154, 221],
    alpha: 1
  },
  home: {
    cameraMovement: true
  },
  debugShadow: false,
  cameraLightPosition: [0.01, 7, 0],
  cameraOrtho: {
    size: 2,
    near: 3,
    far: 7.8
  },
  shadowMapSize: 1024,
  shadow: {
    spread: 1.0,
    opacity: 0.7,
    color: [207, 189, 171]
  }
});

/***/ }),

/***/ "./src/js/modelViewer/Settings.js":
/*!****************************************!*\
  !*** ./src/js/modelViewer/Settings.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ "./src/js/modelViewer/Config.js");
/* harmony import */ var fast_url_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fast-url-parser */ "./node_modules/fast-url-parser/src/urlparser.js");
/* harmony import */ var fast_url_parser__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fast_url_parser__WEBPACK_IMPORTED_MODULE_1__);
// Settings.js


fast_url_parser__WEBPACK_IMPORTED_MODULE_1___default.a.queryString = __webpack_require__(/*! querystringparser */ "./node_modules/querystringparser/js/querystringparser.js");
let enabled = true;

const reload = () => {
  if (!enabled) {
    return;
  }

  window.location.href = window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config__WEBPACK_IMPORTED_MODULE_0__["default"]);
};

const refresh = () => {
  if (!enabled) {
    return;
  }

  window.history.pushState('experiment', 'Title', window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config__WEBPACK_IMPORTED_MODULE_0__["default"]));
};

const reset = () => {
  window.location.href = window.location.origin + window.location.pathname;
};

let delayIndex = -1;

const delayReload = () => {
  if (!enabled) {
    return;
  }

  window.clearTimeout(delayIndex);
  delayIndex = window.setTimeout(() => {
    window.location.href = window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config__WEBPACK_IMPORTED_MODULE_0__["default"]);
  }, 500);
};

const init = (mEnabled = true) => {
  enabled = mEnabled;
  const parsed = fast_url_parser__WEBPACK_IMPORTED_MODULE_1___default.a.parse(window.location.search, true);
  let parsedJson = {};

  if (parsed.query.config) {
    parsedJson = JSON.parse(parsed.query.config);
  }

  Object.assign(_Config__WEBPACK_IMPORTED_MODULE_0__["default"], parsedJson);
  refresh();
};

/* harmony default export */ __webpack_exports__["default"] = ({
  enabled,
  reload,
  reset,
  refresh,
  delayReload,
  init
});

/***/ }),

/***/ "./src/js/modelViewer/ShadowManager.js":
/*!*********************************************!*\
  !*** ./src/js/modelViewer/ShadowManager.js ***!
  \*********************************************/
/*! exports provided: ShadowManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowManager", function() { return ShadowManager; });
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Config */ "./src/js/modelViewer/Config.js");
/* harmony import */ var utils_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utils-viewer */ "./src/js/modelViewer/utils/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");




class ShadowManager {
  constructor() {
    this.shadowMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"].create();
    this.cameraLightTarget = [0, 0, 0];
    this.cameraLight = new alfrid__WEBPACK_IMPORTED_MODULE_0__["CameraOrtho"]();
    this.size = _Config__WEBPACK_IMPORTED_MODULE_1__["default"].cameraOrtho.size;
    this.cameraLight.ortho(-this.size, this.size, this.size, -this.size, _Config__WEBPACK_IMPORTED_MODULE_1__["default"].cameraOrtho.near, _Config__WEBPACK_IMPORTED_MODULE_1__["default"].cameraOrtho.far);
    this.updateLightCamera();
    const oSettings = {
      minFilter: alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].LINEAR_MIPMAP_NEAREST,
      magFilter: alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].LINEAR
    };
    this.fbo = new alfrid__WEBPACK_IMPORTED_MODULE_0__["FrameBuffer"](1024, 1024, oSettings);
  }

  updateLightCamera() {
    this.cameraLight.lookAt(_Config__WEBPACK_IMPORTED_MODULE_1__["default"].cameraLightPosition, [0, 0, 0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"].identity(this.shadowMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"].multiply(this.shadowMatrix, this.cameraLight.projection, this.cameraLight.viewMatrix);
    console.log(utils_viewer__WEBPACK_IMPORTED_MODULE_2__["biasMatrix"]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"].multiply(this.shadowMatrix, utils_viewer__WEBPACK_IMPORTED_MODULE_2__["biasMatrix"], this.shadowMatrix);
  }

  setSize(size) {
    this.size = size;
    this.recalculateShadow();
  }

  recalculateShadow() {
    this.cameraLight.ortho(-this.size, this.size, this.size, -this.size, _Config__WEBPACK_IMPORTED_MODULE_1__["default"].cameraOrtho.near, _Config__WEBPACK_IMPORTED_MODULE_1__["default"].cameraOrtho.far);
    this.updateLightCamera();
  }

  render(mesh) {
    this.fbo.bind();
    alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].clear(0, 0, 0, 1);
    alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].setMatrices(this.cameraLight);
    alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].gl.depthFunc(alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].gl.LESS);
    mesh.renderShadow();
    this.fbo.unbind();
  }

}

/***/ }),

/***/ "./src/js/modelViewer/StatesManager.js":
/*!*********************************************!*\
  !*** ./src/js/modelViewer/StatesManager.js ***!
  \*********************************************/
/*! exports provided: StatesManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatesManager", function() { return StatesManager; });
const NOOP = () => {};

class StatesManager {
  constructor(scene) {
    this.scene = scene;
    this.states = {};
    this.currentStateId = 'empty';
    this.transitionMap = {};
    this.add('empty', {
      end: NOOP,
      begin: NOOP,
      update: NOOP,
      render: NOOP
    });
  }

  get id() {
    return this.currentStateId;
  }

  addTransition(id1, id2, bothways) {
    this.transitionMap[id1][id2] = true;

    if (bothways) {
      this.transitionMap[id2][id1] = true;
    }

    return this;
  }

  add(id, state) {
    this.states[id] = state;
    state.scene = this.scene;
    if (!state.empty) state.empty = NOOP;
    if (!state.begin) state.begin = NOOP;
    if (!state.update) state.update = NOOP;
    if (!state.render) state.render = NOOP;
    if (!state.end) state.end = NOOP;
    this.transitionMap[id] = {};
    this.addTransition('empty', id, true);
    return this;
  }

  set(id, data) {
    if (this.transitionMap[this.currentStateId][id]) {
      this.states[this.currentStateId].end();
      this.currentStateId = id;
      this.states[this.currentStateId].begin(data);
      console.log(this.states[this.currentStateId]);
    }
  }

  render() {
    this.states[this.currentStateId].render();
  }

}

/***/ }),

/***/ "./src/js/modelViewer/TouchController.js":
/*!***********************************************!*\
  !*** ./src/js/modelViewer/TouchController.js ***!
  \***********************************************/
/*! exports provided: TouchController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TouchController", function() { return TouchController; });
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils */ "./src/js/utils/index.js");
/* harmony import */ var mini_signals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mini-signals */ "./node_modules/mini-signals/lib/mini-signals.js");
/* harmony import */ var mini_signals__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mini_signals__WEBPACK_IMPORTED_MODULE_2__);




const getMouse = function (mEvent, mTarget) {
  const o = mTarget || {};

  if (mEvent.touches) {
    o.x = mEvent.touches[0].pageX;
    o.y = mEvent.touches[0].pageY;
  } else {
    o.x = mEvent.clientX;
    o.y = mEvent.clientY;
  }

  return o;
};

class TouchController {
  constructor(scene) {
    this.scene = scene;
    this.camera = this.scene.camera;
    this.mouseDown = {
      x: 0,
      y: 0
    };
    this.mouse = {
      x: 0,
      y: 0
    };
    this.ray = new alfrid__WEBPACK_IMPORTED_MODULE_0__["Ray"]([0, 0, 0], [0, 1, 0]);
    this.onMoveCallback = null;
    this.onClickCallback = null;
    this.onUpCallback = null;
    this.targets = [];
    this._onDown = this.onDown.bind(this);
    this._onMove = this.onMove.bind(this);
    this._onUp = this.onUp.bind(this);
  }

  pause(id, val = true) {
    const method = val ? this.scene.containerHTML.removeEventListener : this.scene.containerHTML.addEventListener;

    if (id === 'onMove') {
      method('mousemove', this._onMove);
    }
  }

  generateRay(e, mouse) {
    const o = getMouse(e, mouse);
    const mx = o.x / window.innerWidth * 2.0 - 1.0;
    const my = -(o.y / window.innerHeight) * 2.0 + 1.0;
    this.camera.generateRay([mx, my, 0], this.ray);
  }

  setCallbacks(cbs) {
    for (const key in cbs) {
      this[key] = cbs[key];
    }
  }

  start(targets, cbs) {
    this.targets = targets;
    this.setCallbacks(cbs);
    this.scene.containerHTML.addEventListener('mousedown', this._onDown);
    this.scene.containerHTML.addEventListener('mouseup', this._onUp);
    this.scene.containerHTML.addEventListener('mousemove', this._onMove);
  }

  stop() {
    this.scene.containerHTML.removeEventListener('mousedown', this._onDown);
    this.scene.containerHTML.removeEventListener('mouseup', this._onUp);
    this.scene.containerHTML.removeEventListener('mousemove', this._onMove);
  }

  setTargets(targets) {
    this.targets = targets;
  }

  onDown(e) {
    this.down = true;
    this.mouseDown = getMouse(e);
  }

  onMove(e) {
    if (this.onMoveCallback) this.onMoveCallback(this.down);
  }

  onUp(e) {
    this.down = false;
    const o = getMouse(e);
    const dist = Object(utils__WEBPACK_IMPORTED_MODULE_1__["getDistOptim"])(o.x, o.y, this.mouseDown.x, this.mouseDown.y);

    if (dist < 5) {
      // check if click somewhere
      this.generateRay(e, this.mouse);
      let hit;

      for (let i = 0; i < this.targets.length; i++) {
        const mesh = this.targets[i];
        hit = Object(utils__WEBPACK_IMPORTED_MODULE_1__["intersectionRayMesh"])(this.ray, mesh.faces, mesh.matrix, false);
        if (hit && this.onClickCallback) this.onClickCallback(mesh);
      }
    }

    if (this.onUpCallback) this.onUpCallback();
  }

}

/***/ }),

/***/ "./src/js/modelViewer/ViewerApp.js":
/*!*****************************************!*\
  !*** ./src/js/modelViewer/ViewerApp.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! helpers */ "./src/js/helpers/index.js");
/* harmony import */ var _states__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./states */ "./src/js/modelViewer/states/index.js");
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var _Assets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Assets */ "./src/js/Assets.js");
/* harmony import */ var _CameraSpots__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CameraSpots */ "./src/js/modelViewer/CameraSpots.js");
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Config */ "./src/js/modelViewer/Config.js");
/* harmony import */ var _ShadowManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ShadowManager */ "./src/js/modelViewer/ShadowManager.js");
/* harmony import */ var _StatesManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./StatesManager */ "./src/js/modelViewer/StatesManager.js");
/* harmony import */ var _TouchController__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TouchController */ "./src/js/modelViewer/TouchController.js");
/* harmony import */ var _views_ViewAnnotation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./views/ViewAnnotation */ "./src/js/modelViewer/views/ViewAnnotation.js");
/* harmony import */ var _views_ViewFloor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./views/ViewFloor */ "./src/js/modelViewer/views/ViewFloor.js");
/* harmony import */ var _views_ViewObjModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./views/ViewObjModel */ "./src/js/modelViewer/views/ViewObjModel.js");
/* harmony import */ var _debug_addUI__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./debug/addUI */ "./src/js/modelViewer/debug/addUI.js");
/* harmony import */ var _data_camera_points__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./data-camera-points */ "./src/js/modelViewer/data-camera-points.js");
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! utils */ "./src/js/utils/index.js");
/* harmony import */ var consts_viewer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! consts-viewer */ "./src/js/modelViewer/consts/index.js");
/* harmony import */ var consts_viewer__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(consts_viewer__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
// SceneApp.js


















class ViewerApp extends alfrid__WEBPACK_IMPORTED_MODULE_2__["Scene"] {
  constructor(options = {}) {
    let container;

    if (options.container) {
      options.noControl = true;
      container = document.createElement('div');
      container.className = 'camera-spots';
      options.container.appendChild(container);
    } else {
      container = document.querySelector('.camera-spots');
      options.container = container;
    }

    super(options);
    if (!options.noControl) Object(_debug_addUI__WEBPACK_IMPORTED_MODULE_12__["addUI"])(this, container);
    this.options = options;
    alfrid__WEBPACK_IMPORTED_MODULE_2__["GL"].enableAlphaBlending();
    this.orbitalControl.rx.value = this.orbitalControl.ry.value = 0.3;
    this.orbitalControl.radius.value = 5;

    this.orbitalControl._rx.limit(0, Math.PI / 2);

    if (!_Config__WEBPACK_IMPORTED_MODULE_5__["default"].editor.active && !_Config__WEBPACK_IMPORTED_MODULE_5__["default"].debug.shape.active) {
      this.orbitalControl.radius.limit(2, 6);
    }

    this.currentSpot = null;
    this.resize();
    this.positionDebug = gl_matrix__WEBPACK_IMPORTED_MODULE_16__["vec3"].create();
    this.positionCenterDebug = gl_matrix__WEBPACK_IMPORTED_MODULE_16__["vec3"].create();
    this.stateManager = new _StatesManager__WEBPACK_IMPORTED_MODULE_7__["StatesManager"](this);
    this.stateManager.add('home', new _states__WEBPACK_IMPORTED_MODULE_1__["StateHome"]());
    this.stateManager.add('orbit', new _states__WEBPACK_IMPORTED_MODULE_1__["StateOrbit"]());
    this.stateManager.add('annotate', new _states__WEBPACK_IMPORTED_MODULE_1__["StateAnnotate"]());
    this.stateManager.addTransition('home', 'orbit', true);
    this.stateManager.addTransition('home', 'annotate', true);
    this.stateManager.addTransition('orbit', 'annotate', true);
    this.home(true);
  }

  _init(options) {
    super._init(options);

    this.containerHTML = options.container;
    helpers__WEBPACK_IMPORTED_MODULE_0__["OrbitalControlTween"].init(this.orbitalControl);
    this.touchController = new _TouchController__WEBPACK_IMPORTED_MODULE_8__["TouchController"](this);
    this.cameraSpots = new _CameraSpots__WEBPACK_IMPORTED_MODULE_4__["CameraSpots"](this, options.container, _Config__WEBPACK_IMPORTED_MODULE_5__["default"].editor.points || _data_camera_points__WEBPACK_IMPORTED_MODULE_13__["default"]);
    this.cameraSpots.onSpotClicked.add(this.onSpotClicked.bind(this));
    this.touchController.start([], {
      // onClickCallback: this.onSpotClicked.bind(this),
      onMoveCallback: this.onTouchControllerMove.bind(this)
    });
  }

  home(snap = false) {
    this.stateManager.set('home', {
      snap
    }); // this.state = states.home;
    // // move model to match an exact position / rotation
    // this._vModel.onHome(snap);
    // // same for camera
    // listened for when the camera move
    // display popup
    // hide markers
  }

  annotate() {
    if (this.stateManager.currentStateId === 'annotate') {
      this.stateManager.set('orbit');
    } else {
      this.stateManager.set('annotate', {
        previousState: this.stateManager.currentStateId
      });
    }
  }

  onMove() {// move model
    // move camera?
  }

  _initTextures() {
    console.log('init textures');
    this.studioRadiance = _Assets__WEBPACK_IMPORTED_MODULE_3__["default"].get('studio_radiance');
    this.irr = _Assets__WEBPACK_IMPORTED_MODULE_3__["default"].get('irr');
    this.aomap = _Assets__WEBPACK_IMPORTED_MODULE_3__["default"].get('aomap');
    this.colormap = _Assets__WEBPACK_IMPORTED_MODULE_3__["default"].get('colormap');
    this.roughnessmap = _Assets__WEBPACK_IMPORTED_MODULE_3__["default"].get('roughnessmap');
  }

  _initViews(options) {
    this.shadowManager = new _ShadowManager__WEBPACK_IMPORTED_MODULE_6__["ShadowManager"]();
    this._bCopy = new alfrid__WEBPACK_IMPORTED_MODULE_2__["default"].BatchCopy();
    this._bAxis = new alfrid__WEBPACK_IMPORTED_MODULE_2__["default"].BatchAxis();
    this._bDots = new alfrid__WEBPACK_IMPORTED_MODULE_2__["default"].BatchDotsPlane();

    if (_Config__WEBPACK_IMPORTED_MODULE_5__["default"].editor.active) {
      this._bBall = new alfrid__WEBPACK_IMPORTED_MODULE_2__["default"].BatchBall();
      this._bBallOrbCenter = new alfrid__WEBPACK_IMPORTED_MODULE_2__["default"].BatchBall();
      this._bBallCenter = new alfrid__WEBPACK_IMPORTED_MODULE_2__["default"].BatchBall();
    }

    this._bSky = new alfrid__WEBPACK_IMPORTED_MODULE_2__["default"].BatchSky();
    this.skymap = _Assets__WEBPACK_IMPORTED_MODULE_3__["default"].get('sky-default');
    this._vModel = new _views_ViewObjModel__WEBPACK_IMPORTED_MODULE_11__["default"]();
    this._vFloor = new _views_ViewFloor__WEBPACK_IMPORTED_MODULE_10__["default"]();
    this._vAnnotation = new _views_ViewAnnotation__WEBPACK_IMPORTED_MODULE_9__["default"](options.container); // HTML
  }

  onSpotClicked(spot) {
    this.oldRadius = this.orbitalControl.radius.value;
    this.currentSpot = spot;
    this.cameraSpots.hide();
    this.touchController.pause('onMove', false);
    helpers__WEBPACK_IMPORTED_MODULE_0__["OrbitalControlTween"].tween({
      centerX: spot.center[0],
      centerY: spot.center[1],
      centerZ: spot.center[2],
      offsetX: spot.offset[0],
      offsetY: spot.offset[1],
      offsetZ: spot.offset[2],
      ease: 'sine.out',
      duration: 0.2
    });
    setTimeout(() => {
      this._vAnnotation.onSpotClicked(spot);
    }, 1000);
  }

  onTouchControllerMove(isDown) {
    if (isDown && this.currentSpot) {
      this.cameraSpots.show();
      this.currentSpot = null;

      this._vAnnotation.hide();

      helpers__WEBPACK_IMPORTED_MODULE_0__["OrbitalControlTween"].tween({
        offsetX: 0,
        offsetY: 0,
        offsetZ: 0,
        centerX: 0,
        centerY: 0,
        centerZ: 0,
        ease: 'sine.out',
        duration: 0.3
      });
      this.orbitalControl.radius.value = this.oldRadius;
      this.touchController.pause('onMove', true);
    }
  }

  updateBallCenter(pos) {
    // editor debug
    this.positionCenterDebug = pos;
  }

  updateBallPos(pos) {
    // editor debug
    this.positionDebug = pos;
  }

  render() {
    if (this.stateManager) this.stateManager.render();

    if (this.currentSpot) {
      const data = this.currentSpot;
      this.orbitalControl.rx._targetValue += (data.rx - this.orbitalControl.rx._targetValue) * 0.1;
      this.orbitalControl.ry._targetValue += (data.ry - this.orbitalControl.ry._targetValue) * 0.1;
      this.orbitalControl.radius._targetValue += (data.zoom - this.orbitalControl.radius._targetValue) * 0.1;
    }

    alfrid__WEBPACK_IMPORTED_MODULE_2__["GL"].clear(0, 0, 0, 0);

    if (_Config__WEBPACK_IMPORTED_MODULE_5__["default"].editor.active) {
      this._bBall.draw(this.positionDebug, [0.1, 0.1, 0.1], [1, 0, 0]);

      this._bBallCenter.draw(this.positionCenterDebug, [0.025, 0.025, 0.025], [0, 1, 1]);

      this._bBallOrbCenter.draw(this.orbitalControl.center, [0.05, 0.05, 0.05], [0, 0, 1]);
    }

    this.shadowManager.render(this._vModel);
    alfrid__WEBPACK_IMPORTED_MODULE_2__["GL"].setMatrices(this.camera); // set back the camera because shadows switch to an ortographic one

    this._bSky.draw(this.skymap); // this._bAxis.draw();
    // this._bDots.draw();


    if (this.cameraSpots) this.cameraSpots.render();

    this._vFloor.render(this.shadowManager.shadowMatrix, this.shadowManager.fbo.depthTexture);

    this._vModel.render(this.studioRadiance, this.irr, this.aomap, this.colormap, this.roughnessmap, this.currentSpot);

    if (_Config__WEBPACK_IMPORTED_MODULE_5__["default"].debugShadow) {
      alfrid__WEBPACK_IMPORTED_MODULE_2__["GL"].disable(alfrid__WEBPACK_IMPORTED_MODULE_2__["GL"].DEPTH_TEST);
      const s = 200;
      alfrid__WEBPACK_IMPORTED_MODULE_2__["GL"].viewport(0, 0, s, s);

      this._bCopy.draw(this.shadowManager.fbo.getDepthTexture());

      alfrid__WEBPACK_IMPORTED_MODULE_2__["GL"].enable(alfrid__WEBPACK_IMPORTED_MODULE_2__["GL"].DEPTH_TEST);
    }
  }

  resize(w, h) {
    Object(utils__WEBPACK_IMPORTED_MODULE_14__["resize"])(w, h, this.options.container.clientWidth, this.options.container.clientHeight);
    this.camera.setAspectRatio(alfrid__WEBPACK_IMPORTED_MODULE_2__["GL"].aspectRatio);
  }

}

/* harmony default export */ __webpack_exports__["default"] = (ViewerApp);

/***/ }),

/***/ "./src/js/modelViewer/app.js":
/*!***********************************!*\
  !*** ./src/js/modelViewer/app.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _scss_global_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../scss/global.scss */ "./src/scss/global.scss");
/* harmony import */ var _scss_global_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_scss_global_scss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _scss_modelViewer_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../scss/modelViewer.scss */ "./src/scss/modelViewer.scss");
/* harmony import */ var _scss_modelViewer_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_scss_modelViewer_scss__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Settings */ "./src/js/modelViewer/Settings.js");
/* harmony import */ var _ViewerApp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ViewerApp */ "./src/js/modelViewer/ViewerApp.js");
/* harmony import */ var _debug_addControls__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./debug/addControls */ "./src/js/modelViewer/debug/addControls.js");
/* harmony import */ var _debug_addDropSupport__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../debug/addDropSupport */ "./src/js/debug/addDropSupport.js");
/* harmony import */ var _asset_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./asset-list */ "./src/js/modelViewer/asset-list.js");
/* harmony import */ var utils_preload__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! utils/preload */ "./src/js/utils/preload.js");









if (document.body) {
  _init();
} else {
  window.addEventListener('DOMContentLoaded', _init);
}

function _init() {
  Object(utils_preload__WEBPACK_IMPORTED_MODULE_7__["default"])({
    assets: _asset_list__WEBPACK_IMPORTED_MODULE_6__["default"]
  }).then(init3D, logError);
}

function logError(e) {
  console.log('Error', e);
}

function init3D() {
  if (true) {
    _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].init();
  } // CREATE SCENE


  const scene = new _ViewerApp__WEBPACK_IMPORTED_MODULE_3__["default"]();

  if (true) {
    console.log('IS_DEVELOPMENT');
    Object(_debug_addControls__WEBPACK_IMPORTED_MODULE_4__["default"])(scene);
    Object(_debug_addDropSupport__WEBPACK_IMPORTED_MODULE_5__["addDropSupport"])(img => {
      scene.skymap.updateTexture(img);
    });
  }
}

/***/ }),

/***/ "./src/js/modelViewer/asset-list.js":
/*!******************************************!*\
  !*** ./src/js/modelViewer/asset-list.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const assetsToLoad = [{
  "id": "model",
  "url": "assets/model-viewer/obj/model.obj",
  "type": "text"
}, {
  "id": "modelFlex",
  "url": "assets/model-viewer/obj/modelFlex.obj",
  "type": "text"
}, {
  "id": "modelFlex_explode",
  "url": "assets/model-viewer/obj/modelFlex_explode.obj",
  "type": "text"
}, {
  "id": "aomap",
  "url": "assets/model-viewer/img/aomap.jpg",
  "type": "jpg"
}, {
  "id": "brdfLUT",
  "url": "assets/model-viewer/img/brdfLUT.png",
  "type": "png"
}, {
  "id": "colormap",
  "url": "assets/model-viewer/img/colormap.jpg",
  "type": "jpg"
}, {
  "id": "irr_negx",
  "url": "assets/model-viewer/img/irr_negx.hdr",
  "type": "binary"
}, {
  "id": "irr_negy",
  "url": "assets/model-viewer/img/irr_negy.hdr",
  "type": "binary"
}, {
  "id": "irr_negz",
  "url": "assets/model-viewer/img/irr_negz.hdr",
  "type": "binary"
}, {
  "id": "irr_posx",
  "url": "assets/model-viewer/img/irr_posx.hdr",
  "type": "binary"
}, {
  "id": "irr_posy",
  "url": "assets/model-viewer/img/irr_posy.hdr",
  "type": "binary"
}, {
  "id": "irr_posz",
  "url": "assets/model-viewer/img/irr_posz.hdr",
  "type": "binary"
}, {
  "id": "lutMap",
  "url": "assets/model-viewer/img/lutMap.png",
  "type": "png"
}, {
  "id": "noise",
  "url": "assets/model-viewer/img/noise.png",
  "type": "png"
}, {
  "id": "roughnessmap",
  "url": "assets/model-viewer/img/roughnessmap.jpg",
  "type": "jpg"
}, {
  "id": "sky-default",
  "url": "assets/model-viewer/img/sky-default.jpg",
  "type": "jpg"
}, {
  "id": "studio_radiance",
  "url": "assets/model-viewer/img/studio_radiance.dds",
  "type": "binary"
}, {
  "id": "body_aomap",
  "url": "assets/model-viewer/img/tex_explode/body_aomap.jpg",
  "type": "jpg"
}, {
  "id": "body_colormap",
  "url": "assets/model-viewer/img/tex_explode/body_colormap.jpg",
  "type": "jpg"
}, {
  "id": "body_roughnessmap",
  "url": "assets/model-viewer/img/tex_explode/body_roughnessmap.jpg",
  "type": "jpg"
}, {
  "id": "pen_aomap",
  "url": "assets/model-viewer/img/tex_explode/pen_aomap.jpg",
  "type": "jpg"
}, {
  "id": "pen_colormap",
  "url": "assets/model-viewer/img/tex_explode/pen_colormap.jpg",
  "type": "jpg"
}, {
  "id": "pen_roughnessmap",
  "url": "assets/model-viewer/img/tex_explode/pen_roughnessmap.jpg",
  "type": "jpg"
}];
/* harmony default export */ __webpack_exports__["default"] = (assetsToLoad);

/***/ }),

/***/ "./src/js/modelViewer/consts/index.js":
/*!********************************************!*\
  !*** ./src/js/modelViewer/consts/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./src/js/modelViewer/data-camera-points.js":
/*!**************************************************!*\
  !*** ./src/js/modelViewer/data-camera-points.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ([]);

/***/ }),

/***/ "./src/js/modelViewer/debug/PointsEditor.js":
/*!**************************************************!*\
  !*** ./src/js/modelViewer/debug/PointsEditor.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils */ "./src/js/utils/index.js");
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config */ "./src/js/modelViewer/Config.js");
/* harmony import */ var mini_signals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mini-signals */ "./node_modules/mini-signals/lib/mini-signals.js");
/* harmony import */ var mini_signals__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mini_signals__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");






const getMouse = function (mEvent, mTarget) {
  const o = mTarget || {};

  if (mEvent.touches) {
    o.x = mEvent.touches[0].pageX;
    o.y = mEvent.touches[0].pageY;
  } else {
    o.x = mEvent.clientX;
    o.y = mEvent.clientY;
  }

  return o;
};

const tempMat4 = mat4.create();
const identityMatrix = mat4.create();

class PointsEditor {
  constructor() {
    this.container = document.querySelector('.editor-points');
    this.nbPoints = 0;
    this.onPointClick = new mini_signals__WEBPACK_IMPORTED_MODULE_3___default.a();
    this.onPointDelete = new mini_signals__WEBPACK_IMPORTED_MODULE_3___default.a();
    this.mouseDown = {
      x: 0,
      y: 0
    };
    this.mouse = {
      x: 0,
      y: 0
    };
    this.ray = new alfrid__WEBPACK_IMPORTED_MODULE_0__["Ray"]([0, 0, 0], [0, 0, -1]);
    this.currentPos = null;
  }

  init(scene, targets) {
    this.targets = targets;
    this.scene = scene;
    this.camera = scene.camera;

    if (_Config__WEBPACK_IMPORTED_MODULE_2__["default"].editor.active) {
      this.addPointsToDOM();
      this.scene.containerHTML.addEventListener('mousedown', this.onDown.bind(this));
      this.scene.containerHTML.addEventListener('mousemove', this.onMove.bind(this));
      this.scene.containerHTML.addEventListener('mouseup', this.onUp.bind(this));
      window.addEventListener("keydown", event => {
        const key = event.keyCode;
        if (key < 37 || key > 40) return;
        console.log(event.keyCode);
        const orb = this.scene.orbitalControl;
        const dirX = orb.center[0] - orb.position[0]; // + orb.positionOffset[0]);

        const dirZ = orb.center[2] - orb.position[2]; // + orb.positionOffset[2]);

        let angle = Math.atan2(dirZ, dirX);
        if (key === 40) angle += Math.PI;else if (key === 39) angle += Math.PI / 2;else if (key === 37) angle -= Math.PI / 2;
        const x = Math.cos(angle);
        const z = Math.sin(angle);
        orb.positionOffset[0] += x * 0.1;
        orb.positionOffset[2] += z * 0.1;
        orb.center[0] += x * 0.1;
        orb.center[2] += z * 0.1;
      });
    }
  }

  generateRay(e, mouse) {
    const o = getMouse(e, mouse);
    const mx = o.x / window.innerWidth * 2.0 - 1.0;
    const my = -(o.y / window.innerHeight) * 2.0 + 1.0;
    this.camera.generateRay([mx, my, 0], this.ray);
  }

  onDown(e) {
    e.preventDefault();
    this.mouseDown = getMouse(e);
  }

  onMove(e) {
    e.preventDefault();
    const views = this.targets;
    if (views.length === 0) return;
    this.generateRay(e, this.mouse);
    let hit;
    let closestHit;
    let previousDist = 100000000;
    let dist;

    for (let k = 0; k < views.length; k++) {
      const view = views[k];
      const meshes = view.debugShapes;
      if (!meshes) continue;

      for (let i = 0; i < meshes.length; i++) {
        const mesh = meshes[i];
        mat4.multiply(tempMat4, view._matrix || identityMatrix, mesh.matrix);
        hit = Object(utils__WEBPACK_IMPORTED_MODULE_1__["intersectionRayMesh"])(this.ray, mesh.faces, tempMat4, true);

        if (hit) {
          dist = Object(utils__WEBPACK_IMPORTED_MODULE_1__["getDistOptim3D"])(this.ray.origin[0], this.ray.origin[1], this.ray.origin[2], hit[0], hit[1], hit[2]);

          if (dist < previousDist) {
            previousDist = dist;
            closestHit = [...hit];
          }
        }
      }
    }

    if (closestHit) {
      this.scene.updateBallPos(closestHit);
    }
  }

  onUp(e) {
    e.preventDefault();
    const o = getMouse(e);
    const dist = Object(utils__WEBPACK_IMPORTED_MODULE_1__["getDistOptim"])(o.x, o.y, this.mouseDown.x, this.mouseDown.y);

    if (dist < 5) {
      this.scene.updateBallCenter([...this.scene.positionDebug]);
      this.currentPos = [...this.scene.positionDebug]; // this.scene.orbitalControl.positionOffset = [0, 0, 0];

      this.scene.orbitalControl.center = [...this.scene.positionDebug];
    }
  }

  addPointsToDOM() {
    _Config__WEBPACK_IMPORTED_MODULE_2__["default"].editor.points.forEach(point => {
      this.addPoint(point);
    });
  }

  addPoint(point) {
    this.nbPoints++;
    const div = document.createElement('div');
    const p = document.createElement('p');

    p.onclick = () => this.onPointClick.dispatch(point); // p.innerText = `rx: ${point.rx}, ry: ${point.ry}, zoom: ${point.zoom}`;


    p.innerText = point.label;
    const p2 = document.createElement('p');
    p2.className = 'delete';

    p2.onclick = () => {
      this.container.removeChild(div);
      this.onPointDelete.dispatch(point);
    };

    p2.innerText = 'X';
    div.appendChild(p);
    div.appendChild(p2);
    this.container.appendChild(div);
  }

}

/* harmony default export */ __webpack_exports__["default"] = (new PointsEditor());

/***/ }),

/***/ "./src/js/modelViewer/debug/addControls.js":
/*!*************************************************!*\
  !*** ./src/js/modelViewer/debug/addControls.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Config */ "./src/js/modelViewer/Config.js");
/* harmony import */ var _PointsEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PointsEditor */ "./src/js/modelViewer/debug/PointsEditor.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Settings */ "./src/js/modelViewer/Settings.js");
/* harmony import */ var hex_rgb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hex-rgb */ "./node_modules/hex-rgb/index.js");
/* harmony import */ var hex_rgb__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(hex_rgb__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! utils */ "./src/js/utils/index.js");
// addControls.js






const debugColor = (debugTarget, target, id, reload = false, name) => {
  debugTarget.addColor(target, id).onChange(() => {
    checkColor(target, id, reload);
  }).name(name || id);
};

const checkColor = (target, id, reload = false) => {
  if (target[id].indexOf('#') > -1) {
    const oColor = hex_rgb__WEBPACK_IMPORTED_MODULE_3___default()(target[id]);
    target[id] = [oColor.red, oColor.green, oColor.blue];
  }

  if (reload) {
    _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].reload();
  } else {
    _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh();
  }
};

const addControls = scene => {
  const oControl = {
    save: () => {
      Object(utils__WEBPACK_IMPORTED_MODULE_4__["saveJson"])(_Config__WEBPACK_IMPORTED_MODULE_0__["default"], 'Settings');
    }
  };
  setTimeout(() => {
    /**
     * EDITOR
     */
    const editorO = {
      resetCenter: () => {
        scene.orbitalControl.center = [0, 0, 0];
      },
      savePoints: () => {
        Object(utils__WEBPACK_IMPORTED_MODULE_4__["saveJson"])(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].editor.points, 'Save points');
      },
      addPoint: () => {
        if (_PointsEditor__WEBPACK_IMPORTED_MODULE_1__["default"].currentPos === null) return;
        const label = prompt("Label", "");
        if (label === null) return;
        const offset = scene.orbitalControl.positionOffset;
        const center = _PointsEditor__WEBPACK_IMPORTED_MODULE_1__["default"].currentPos;
        const data = {
          rx: scene.orbitalControl._rx.value,
          ry: scene.orbitalControl._ry.value,
          center: scene.orbitalControl.center,
          target: _PointsEditor__WEBPACK_IMPORTED_MODULE_1__["default"].currentPos,
          offset,
          zoom: scene.orbitalControl.radius.value,
          label
        };
        _Config__WEBPACK_IMPORTED_MODULE_0__["default"].editor.points.push(data);
        _PointsEditor__WEBPACK_IMPORTED_MODULE_1__["default"].addPoint(data);
        _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh();
        _PointsEditor__WEBPACK_IMPORTED_MODULE_1__["default"].currentPos = null;
      }
    };
    const fEditor = gui.addFolder('Editor');
    fEditor.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].editor, 'active').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].reload);
    const fDebug = gui.addFolder('mesh editor');
    fDebug.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].debug.shape, 'active').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].reload);
    fDebug.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].debug.shape.rot, 'x', 0, Math.PI * 2).step(0.1).name('rot x').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh);
    fDebug.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].debug.shape.rot, 'y', 0, Math.PI * 2).step(0.1).name('rot y').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh);
    fDebug.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].debug.shape.rot, 'z', 0, Math.PI * 2).step(0.1).name('rot z').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh);
    fDebug.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].debug.shape.scale, 'x', 0, 2).step(0.001).name('scale x').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh);
    fDebug.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].debug.shape.scale, 'y', 0, 2).step(0.001).name('scale y').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh);
    fDebug.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].debug.shape.scale, 'z', 0, 2).step(0.001).name('scale z').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh);
    fDebug.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].debug.shape.pos, 'x', -1, 1).step(0.01).name('pos x').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh);
    fDebug.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].debug.shape.pos, 'y', -2.5, 2.5).step(0.01).name('pos y').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh);
    fDebug.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].debug.shape.pos, 'z', -1, 1).step(0.01).name('pos z').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh);
    const o = {
      toggleOrbital: () => scene.orbitalControl.lock(!scene.orbitalControl._isLockZoom)
    };
    fDebug.add(o, 'toggleOrbital');

    if (_Config__WEBPACK_IMPORTED_MODULE_0__["default"].editor.active) {
      _PointsEditor__WEBPACK_IMPORTED_MODULE_1__["default"].init(scene, [scene._vModel]);
      fEditor.add(editorO, 'addPoint').name('add point');
      fEditor.add(editorO, 'resetCenter').name('Reset target');
      fEditor.add(editorO, 'savePoints').name('save');
      _PointsEditor__WEBPACK_IMPORTED_MODULE_1__["default"].onPointDelete.add(pt => {
        const indexPt = _Config__WEBPACK_IMPORTED_MODULE_0__["default"].editor.points.indexOf(pt);
        _Config__WEBPACK_IMPORTED_MODULE_0__["default"].editor.points.splice(indexPt, 1);
        _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh();
      });
      _PointsEditor__WEBPACK_IMPORTED_MODULE_1__["default"].onPointClick.add(pt => {
        scene.orbitalControl.rx.setTo(pt.rx);
        scene.orbitalControl.ry.setTo(pt.ry);
        scene.orbitalControl.radius.setTo(pt.zoom);
        scene.orbitalControl.center = pt.center;
      });
    }
    /**
     * SHADOWS
     */


    const oCameraLightPosition = {
      x: _Config__WEBPACK_IMPORTED_MODULE_0__["default"].cameraLightPosition[0],
      y: _Config__WEBPACK_IMPORTED_MODULE_0__["default"].cameraLightPosition[1],
      z: _Config__WEBPACK_IMPORTED_MODULE_0__["default"].cameraLightPosition[2]
    };
    const fCamLight = gui.addFolder('Camera Light');
    fCamLight.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"], 'debugShadow').onChange(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh);
    fCamLight.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].cameraOrtho, 'size', 0.1, 10).onChange(() => {
      scene.shadowManager.setSize(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].cameraOrtho.size);
      _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh();
    });
    debugColor(fCamLight, _Config__WEBPACK_IMPORTED_MODULE_0__["default"].shadow, 'color', false, 'shadow color');
    fCamLight.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].cameraOrtho, 'near', 1, 10).step(0.1).onChange(() => {
      scene.shadowManager.recalculateShadow();
      _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh();
    });
    fCamLight.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].cameraOrtho, 'far', 2, 10).step(0.1).onChange(() => {
      scene.shadowManager.recalculateShadow();
      _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh();
    });
    const range = 2;
    fCamLight.add(oCameraLightPosition, 'x', -range, range).onChange(() => {
      _Config__WEBPACK_IMPORTED_MODULE_0__["default"].cameraLightPosition[0] = oCameraLightPosition.x;
      scene.shadowManager.updateLightCamera();
      _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh();
    });
    fCamLight.add(oCameraLightPosition, 'y', 0, 10).onChange(() => {
      _Config__WEBPACK_IMPORTED_MODULE_0__["default"].cameraLightPosition[1] = oCameraLightPosition.y;
      scene.shadowManager.updateLightCamera();
      _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh();
    });
    fCamLight.add(oCameraLightPosition, 'z', -range, range).onChange(() => {
      _Config__WEBPACK_IMPORTED_MODULE_0__["default"].cameraLightPosition[2] = oCameraLightPosition.z;
      scene.shadowManager.updateLightCamera();
      _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].refresh();
    });
    /**
     * OTHER
     */

    const fUIO = {
      home: () => {
        scene.home();
      },
      annotate: () => {
        scene.annotate();
      }
    };
    gui.add(fUIO, 'home').name('Go: home');
    gui.add(fUIO, 'annotate').name('Toggle: annotate');
    gui.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].annotations, 'scale', 0.1, 2).step(0.1).name('Marker scale');
    gui.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].annotations, 'alpha', 0, 1).step(0.01).name('Marker alpha');
    debugColor(gui, _Config__WEBPACK_IMPORTED_MODULE_0__["default"].annotations, 'color', false, 'Marker color');
    gui.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"].home, 'cameraMovement').name('toggle home-motion');
    const fModel = gui.addFolder('model');
    fModel.add(_Config__WEBPACK_IMPORTED_MODULE_0__["default"], 'metallic', 0, 1).step(0.01);
    gui.add(oControl, 'save').name('Save Settings');
    gui.add(_Settings__WEBPACK_IMPORTED_MODULE_2__["default"], 'reset').name('Reset Default');
  }, 200);
};

/* harmony default export */ __webpack_exports__["default"] = (addControls);

/***/ }),

/***/ "./src/js/modelViewer/debug/addUI.js":
/*!*******************************************!*\
  !*** ./src/js/modelViewer/debug/addUI.js ***!
  \*******************************************/
/*! exports provided: addUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addUI", function() { return addUI; });
const addUI = (scene, container) => {
  const nav = document.createElement('nav');
  nav.className = 'nav';
  const p1 = document.createElement('p');
  p1.innerText = 'HOME';

  p1.onclick = () => {
    scene.home();
  };

  nav.appendChild(p1);
  const p2 = document.createElement('p');
  p2.innerText = 'ANNOTATE';

  p2.onclick = () => {
    scene.annotate();
  };

  nav.appendChild(p2);
  container.appendChild(nav);
};



/***/ }),

/***/ "./src/js/modelViewer/debug/debugShape.js":
/*!************************************************!*\
  !*** ./src/js/modelViewer/debug/debugShape.js ***!
  \************************************************/
/*! exports provided: getCube */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCube", function() { return getCube; });
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils */ "./src/js/utils/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");



const getCube = (width, height, depth, pos, rot) => {
  const m = gl_matrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].create();
  if (rot) gl_matrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].rotate(m, m, rot);
  if (pos) gl_matrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].translate(m, m, pos);
  if (pos) gl_matrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].scale(m, m, [width, height, depth]);
  const cube = alfrid__WEBPACK_IMPORTED_MODULE_0__["Geom"].cube(1, 1, 1);
  return {
    mesh: cube,
    faces: Object(utils__WEBPACK_IMPORTED_MODULE_1__["getGeometryFaces"])(cube),
    matrix: m
  };
};

/***/ }),

/***/ "./src/js/modelViewer/geom/Line.js":
/*!*****************************************!*\
  !*** ./src/js/modelViewer/geom/Line.js ***!
  \*****************************************/
/*! exports provided: Line */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");

let gl;
let pivotX;
let pivotY;
let axis;
const tempArray1 = [];
const tempArray2 = [];

class Line extends alfrid__WEBPACK_IMPORTED_MODULE_0__["default"].Mesh {
  constructor(vertices, c, drawMode = alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLES) {
    gl = alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"];
    super(drawMode);
    this.widthCallback = c;
    const vert = [[0, 0, 0], [100 / 800, 250 / 800, 0], [50 / 800, 200 / 800, 0], [0, 200 / 800, 0], [-100 / 800, 220 / 800, 0], [-70 / 800, 300 / 800, 0]];
    this.positions = [];
    this.directions = [];
    this.indicesArray = [];
    this.counters = [];
    this.width = [];
    this.uvs = [];
    this.previous = [];
    this.next = [];
    this.vert = vertices || vert;
    this.line(true);
  }

  line(needsUpdate = true) {
    const v = this.vert;
    this.positions.length = v.length * 2;
    this.counters.length = v.length * 2;
    let index = 0;
    let indexC = 0;
    this.previous.length = this.positions.length;
    this.next.length = this.positions.length;

    for (let i = 0; i < v.length; i++) {
      if (needsUpdate) {
        const c = i / v.length;
        this.counters[indexC++] = [c];
        this.counters[indexC++] = [c];
      } // console.log(this.positions.length);


      this.positions[index++] = v[i][0];
      this.positions[index++] = v[i][1];
      this.positions[index++] = v[i][2];
      this.positions[index++] = v[i][0];
      this.positions[index++] = v[i][1];
      this.positions[index++] = v[i][2];
    }

    this.process(needsUpdate);
  }

  process(needsUpdate) {
    const compareV3 = (a, b) => {
      const aa = a * 6;
      const ab = b * 6;
      return this.positions[aa] === this.positions[ab] && this.positions[aa + 1] === this.positions[ab + 1] && this.positions[aa + 2] === this.positions[ab + 2];
    };

    const copyV3 = (a, out) => {
      if (!out) out = tempArray1;
      const aa = a * 6;
      out[0] = this.positions[aa];
      out[1] = this.positions[aa + 1];
      out[2] = this.positions[aa + 2];
    };

    const l = this.positions.length / 6;
    let index = 0;
    let indexN = 0;

    if (compareV3(0, l - 1)) {
      copyV3(l - 2);
    } else {
      copyV3(0);
    }

    this.previous[index++] = tempArray1[0];
    this.previous[index++] = tempArray1[1];
    this.previous[index++] = tempArray1[2];
    this.previous[index++] = tempArray1[0];
    this.previous[index++] = tempArray1[1];
    this.previous[index++] = tempArray1[2];

    for (var i = 0; i < l; i++) {
      // caluclate pos and next
      copyV3(i, tempArray1);

      if (i > 0) {
        // we can fill the nexts
        this.next[indexN++] = tempArray1[0];
        this.next[indexN++] = tempArray1[1];
        this.next[indexN++] = tempArray1[2];
        this.next[indexN++] = tempArray1[0];
        this.next[indexN++] = tempArray1[1];
        this.next[indexN++] = tempArray1[2];
        this.previous[index++] = tempArray2[0];
        this.previous[index++] = tempArray2[1];
        this.previous[index++] = tempArray2[2];
        this.previous[index++] = tempArray2[0];
        this.previous[index++] = tempArray2[1];
        this.previous[index++] = tempArray2[2];
      }

      tempArray2[0] = tempArray1[0];
      tempArray2[1] = tempArray1[1];
      tempArray2[2] = tempArray1[2];
    }

    if (compareV3(l - 1, 0)) {
      copyV3(1, tempArray1);
    } else {
      copyV3(l - 1, tempArray1);
    }

    this.next[indexN++] = tempArray1[0];
    this.next[indexN++] = tempArray1[1];
    this.next[indexN++] = tempArray1[2];
    this.next[indexN++] = tempArray1[0];
    this.next[indexN++] = tempArray1[1];
    this.next[indexN++] = tempArray1[2];
    index = 0;
    this.bufferFlattenData(this.positions, 'aVertexPosition', 3);
    this.bufferFlattenData(this.next, 'aNext', 3);
    this.bufferFlattenData(this.previous, 'aPrevious', 3);

    if (needsUpdate) {
      index = 0;
      this.uvs = [];
      let w;

      for (var j = 0; j < l; j++) {
        if (this.widthCallback) {
          w = this.widthCallback(j / (l - 1));
        } else {
          w = 0.1;
        }

        this.width[index++] = w;
        this.width[index++] = w;
        this.uvs.push([j / (l - 1), 0]);
        this.uvs.push([j / (l - 1), 1]);
      }

      index = 0;
      this.indicesArray = [];

      for (var j = 0; j < l - 1; j++) {
        const n = j * 2;
        this.indicesArray[index++] = n;
        this.indicesArray[index++] = n + 1;
        this.indicesArray[index++] = n + 2;
        this.indicesArray[index++] = n + 2;
        this.indicesArray[index++] = n + 1;
        this.indicesArray[index++] = n + 3;
      }

      index = 0;
      this.directions = [];

      for (var i = 0; i < this.positions.length / 3; i++) {
        if (i % 2 === 0) {
          this.directions[index++] = [1];
        } else {
          this.directions[index++] = [-1];
        }
      }

      this.bufferIndex(this.indicesArray);
      this.bufferFlattenData(this.directions, 'aDirection', 1);
      this.bufferTexCoord(this.uvs);
      this.bufferFlattenData(this.counters, 'aCounters', 1);
    }
  }

  render(points, needsUpdate = false) {
    this.vert = points || this.vert;
    this.line(needsUpdate);
  }

}



/***/ }),

/***/ "./src/js/modelViewer/states/StateAnnotate.js":
/*!****************************************************!*\
  !*** ./src/js/modelViewer/states/StateAnnotate.js ***!
  \****************************************************/
/*! exports provided: StateAnnotate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StateAnnotate", function() { return StateAnnotate; });
/* harmony import */ var helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! helpers */ "./src/js/helpers/index.js");
/* harmony import */ var _StateDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StateDefault */ "./src/js/modelViewer/states/StateDefault.js");


class StateAnnotate extends _StateDefault__WEBPACK_IMPORTED_MODULE_1__["StateDefault"] {
  begin(data = {}) {
    // if (data.previousState !== 'home') {
    helpers__WEBPACK_IMPORTED_MODULE_0__["OrbitalControlTween"].tween({
      duration: 1,
      rx: 0.515,
      ry: 0.828,
      radius: 3.94,
      ease: 'circ.inout'
    }); // }

    this.scene.cameraSpots.start();
    this.scene.cameraSpots.show();
  }

  end() {
    this.scene.cameraSpots.stop();
  }

}

/***/ }),

/***/ "./src/js/modelViewer/states/StateDefault.js":
/*!***************************************************!*\
  !*** ./src/js/modelViewer/states/StateDefault.js ***!
  \***************************************************/
/*! exports provided: StateDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StateDefault", function() { return StateDefault; });
class StateDefault {
  constructor(scene) {
    this.scene = scene;
  }

  begin() {}

  update() {}

  end() {}

}

/***/ }),

/***/ "./src/js/modelViewer/states/StateHome.js":
/*!************************************************!*\
  !*** ./src/js/modelViewer/states/StateHome.js ***!
  \************************************************/
/*! exports provided: StateHome */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StateHome", function() { return StateHome; });
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Config */ "./src/js/modelViewer/Config.js");
/* harmony import */ var _StateDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StateDefault */ "./src/js/modelViewer/states/StateDefault.js");
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! utils */ "./src/js/utils/index.js");
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");
/* harmony import */ var helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! helpers */ "./src/js/helpers/index.js");






class StateHome extends _StateDefault__WEBPACK_IMPORTED_MODULE_1__["StateDefault"] {
  constructor(scene) {
    super(scene);
    this._onDown = this.onDown.bind(this);
    this._onMove = this.onMove.bind(this);
    this._onUp = this.onUp.bind(this);
  }

  begin(data = {}) {
    this.down = false;
    this.tick = 0;
    this.model = this.scene._vModel;
    this.orb = this.scene.orbitalControl;
    this.ready = false;
    this.pos = {
      x: 0,
      y: 0
    };
    this.removeListeners();

    if (data.snap) {
      this.ready = true;
      this.model.rotationX = -Math.PI / 4;
      this.model.rotationY = -Math.PI / 8;
      this.model.y = 1;
      this.orb.center[1] = 0.75;
      this.orb.rx.setTo(0.355);
      this.orb.ry.setTo(1.218);
      this.addListeners();
    } else {
      helpers__WEBPACK_IMPORTED_MODULE_5__["OrbitalControlTween"].tween({
        centerY: 0.75,
        rx: 0.355,
        ry: 1.218,
        duration: 1,
        ease: 'circ.inout'
      });
      gsap__WEBPACK_IMPORTED_MODULE_4__["default"].to(this.model, 1, {
        y: 1,
        rotationX: -Math.PI / 4,
        rotationY: -Math.PI / 8,
        ease: 'circ.inout',
        onComplete: () => {
          this.addListeners();
          this.ready = true;
        }
      });
    }
  }

  removeListeners() {
    this.scene.containerHTML.removeEventListener('mousedown', this._onDown);
    this.scene.containerHTML.removeEventListener('mouseup', this._onUp);
    this.scene.containerHTML.removeEventListener('mousemove', this._onMove);
  }

  addListeners() {
    this.scene.containerHTML.addEventListener('mousedown', this._onDown);
    this.scene.containerHTML.addEventListener('mouseup', this._onUp);
    this.scene.containerHTML.addEventListener('mousemove', this._onMove);
  }

  onDown(e) {
    this.down = true;
    this.pos = Object(utils__WEBPACK_IMPORTED_MODULE_3__["getMouse"])(e);
  }

  onMove(e) {
    if (!this.down) return;
    const pos = Object(utils__WEBPACK_IMPORTED_MODULE_3__["getMouse"])(e);
    const dist = Object(utils__WEBPACK_IMPORTED_MODULE_3__["getDistOptim"])(this.pos.x, pos.x, this.pos.y, pos.y);

    if (dist > 20 * 20) {
      this.scene.stateManager.set('orbit');
    }
  }

  onUp(e) {
    this.down = false;
  }

  end() {
    gsap__WEBPACK_IMPORTED_MODULE_4__["default"].to(this.model, 1, {
      y: 0,
      rotationX: -Math.PI / 2,
      rotationY: 0,
      ease: 'circ.inout'
    });
    helpers__WEBPACK_IMPORTED_MODULE_5__["OrbitalControlTween"].tween({
      centerX: 0,
      centerY: 0,
      centerZ: 0,
      ease: 'circ.inout',
      duration: 1
    });
    this.removeListeners();
  }

  render() {
    if (_Config__WEBPACK_IMPORTED_MODULE_0__["default"].home.cameraMovement && this.ready) {
      this.orb.ry.value += Math.sin(alfrid__WEBPACK_IMPORTED_MODULE_2__["Scheduler"].deltaTime * 0.25) * 0.005;
      this.model.y = 1 + Math.cos(alfrid__WEBPACK_IMPORTED_MODULE_2__["Scheduler"].deltaTime * 0.5) * 0.1;
      this.model.rotationX = -Math.PI / 4 - 0.025 + Math.cos(alfrid__WEBPACK_IMPORTED_MODULE_2__["Scheduler"].deltaTime * 0.5) * 0.025;
    }
  }

}

/***/ }),

/***/ "./src/js/modelViewer/states/StateOrbit.js":
/*!*************************************************!*\
  !*** ./src/js/modelViewer/states/StateOrbit.js ***!
  \*************************************************/
/*! exports provided: StateOrbit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StateOrbit", function() { return StateOrbit; });
/* harmony import */ var _StateDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StateDefault */ "./src/js/modelViewer/states/StateDefault.js");

class StateOrbit extends _StateDefault__WEBPACK_IMPORTED_MODULE_0__["StateDefault"] {
  begin() {
    this.model = this.scene._vModel;
    this.orb = this.scene.orbitalControl;
  }

}

/***/ }),

/***/ "./src/js/modelViewer/states/index.js":
/*!********************************************!*\
  !*** ./src/js/modelViewer/states/index.js ***!
  \********************************************/
/*! exports provided: StateHome, StateOrbit, StateAnnotate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _StateHome__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StateHome */ "./src/js/modelViewer/states/StateHome.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StateHome", function() { return _StateHome__WEBPACK_IMPORTED_MODULE_0__["StateHome"]; });

/* harmony import */ var _StateOrbit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StateOrbit */ "./src/js/modelViewer/states/StateOrbit.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StateOrbit", function() { return _StateOrbit__WEBPACK_IMPORTED_MODULE_1__["StateOrbit"]; });

/* harmony import */ var _StateAnnotate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StateAnnotate */ "./src/js/modelViewer/states/StateAnnotate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StateAnnotate", function() { return _StateAnnotate__WEBPACK_IMPORTED_MODULE_2__["StateAnnotate"]; });





/***/ }),

/***/ "./src/js/modelViewer/utils/biasMatrix.js":
/*!************************************************!*\
  !*** ./src/js/modelViewer/utils/biasMatrix.js ***!
  \************************************************/
/*! exports provided: biasMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "biasMatrix", function() { return biasMatrix; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");

const biasMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].fromValues(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);


/***/ }),

/***/ "./src/js/modelViewer/utils/index.js":
/*!*******************************************!*\
  !*** ./src/js/modelViewer/utils/index.js ***!
  \*******************************************/
/*! exports provided: biasMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _biasMatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./biasMatrix */ "./src/js/modelViewer/utils/biasMatrix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "biasMatrix", function() { return _biasMatrix__WEBPACK_IMPORTED_MODULE_0__["biasMatrix"]; });



/***/ }),

/***/ "./src/js/modelViewer/views/ViewAnnotation.js":
/*!****************************************************!*\
  !*** ./src/js/modelViewer/views/ViewAnnotation.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewAnnotation; });
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils */ "./src/js/utils/index.js");

class ViewAnnotation {
  constructor(container) {
    this.container = container;
    this.element = document.createElement('div');
    this.element.className = 'annotation';
    this.element.style.display = 'none';
    this.text = document.createElement('p');
    this.text.innerText = 'Title of the annotation plus a description.';
    this.element.appendChild(this.text);
    this.img = document.createElement('img');
    this.img.className = 'image-spot';
    this.element.appendChild(this.img);
    const closeIcon = document.createElement('img');
    closeIcon.className = 'close';
    closeIcon.onclick = this.hide.bind(this);
    this.element.appendChild(closeIcon);
    container.appendChild(this.element);
  }

  show() {
    this.element.style.display = 'block';
  }

  hide() {
    this.element.style.display = 'none';
  }

  onSpotClicked(spot) {
    this.show();
    const w = this.container.offsetWidth;
    this.text.innerHTML = spot.label;
    const pos2d = Object(utils__WEBPACK_IMPORTED_MODULE_0__["get2dPos"])(spot.target);
    const x = pos2d[0];
    const y = pos2d[1];

    if (x < w / 2) {
      this.element.style.right = 'auto';
      this.element.style.left = `${Math.max(w / 2, x + 80)}px`;
    } else {
      this.element.style.left = 'auto';
      this.element.style.right = `${Math.min(w / 2, x - 80)}px`;
    }
  }

  setPosition(x, y) {}

}

/***/ }),

/***/ "./src/js/modelViewer/views/ViewFloor.js":
/*!***********************************************!*\
  !*** ./src/js/modelViewer/views/ViewFloor.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewFloor; });
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config */ "./src/js/modelViewer/Config.js");
/* harmony import */ var shaders_floor_frag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! shaders/floor.frag */ "./src/shaders/floor.frag");
/* harmony import */ var shaders_floor_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! shaders/floor.vert */ "./src/shaders/floor.vert");
// ViewFloor.js





class ViewFloor extends alfrid__WEBPACK_IMPORTED_MODULE_0__["View3D"] {
  constructor() {
    super(shaders_floor_vert__WEBPACK_IMPORTED_MODULE_4__["default"], shaders_floor_frag__WEBPACK_IMPORTED_MODULE_3__["default"]);
    this.shadowColor = [0, 0, 0];
    this.color = [1, 1, 1];
    this.y = -0.6; // this.rotationX = -Math.PI / 2;

    const size = 10;
    this.mesh = alfrid__WEBPACK_IMPORTED_MODULE_0__["Geom"].plane(size, size, 1, 'xz');
  }

  render(shadowMatrix, textureDepth) {
    const colorShadow = _Config__WEBPACK_IMPORTED_MODULE_2__["default"].shadow.color.map(v => v / 255);
    this.shader.bind(); // this.shader.uniform('uColor', 'vec3', this.color);

    this.shader.uniform('uColor', 'vec3', [1, 1, 1]);
    this.shader.uniform('uShadowColor', 'vec3', colorShadow);
    this.shader.uniform('uShadowOpacity', 'float', 0.6);
    this.shader.uniform('textureDepth', 'uniform1i', 0);
    textureDepth.bind(0); // this.shader.uniform('uCameraPos', 'vec3', [0, 5, 0]);
    // this.shader.uniform('uCameraPos', 'vec3', GL.camera.position);

    this.shader.uniform('uMapSize', 'float', _Config__WEBPACK_IMPORTED_MODULE_2__["default"].shadowMapSize); // this.shader.uniform('uSpread', 'float', Config.shadow.spread);

    this.shader.uniform('uShadowMatrix', 'uniformMatrix4fv', shadowMatrix);
    this.shader.uniform('uShadowColor', 'vec3', colorShadow);

    this._update();

    this.shader.uniform('uMatrix', 'mat4', this._matrix);
    alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].draw(this.mesh);
  }

}

/***/ }),

/***/ "./src/js/modelViewer/views/ViewObjModel.js":
/*!**************************************************!*\
  !*** ./src/js/modelViewer/views/ViewObjModel.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var _Assets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Assets */ "./src/js/Assets.js");
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config */ "./src/js/modelViewer/Config.js");
/* harmony import */ var shaders_pbr_frag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! shaders/pbr.frag */ "./src/shaders/pbr.frag");
/* harmony import */ var shaders_depth_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! shaders/depth.frag */ "./src/shaders/depth.frag");
/* harmony import */ var shaders_color_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! shaders/color.frag */ "./src/shaders/color.frag");
/* harmony import */ var _debug_debugShape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../debug/debugShape */ "./src/js/modelViewer/debug/debugShape.js");
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! utils */ "./src/js/utils/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var shaders_pbr_vert__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! shaders/pbr.vert */ "./src/shaders/pbr.vert");
/* harmony import */ var shaders_basic_vert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! shaders/basic.vert */ "./src/shaders/basic.vert");
// ViewObjModel.js











const tempMat4 = gl_matrix__WEBPACK_IMPORTED_MODULE_8__["mat4"].create();

const definesToString = function (defines) {
  let outStr = '';

  for (const def in defines) {
    if (defines[def]) {
      outStr += `#define ${def} ${defines[def]}\n`;
    }
  }

  return outStr;
};

class ViewObjModel extends alfrid__WEBPACK_IMPORTED_MODULE_0__["View3D"] {
  constructor() {
    const defines = {
      USE_TEX_LOD: !!alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].getExtension('EXT_shader_texture_lod') ? 1 : 0,
      USE_IBL: 1,
      HAS_BASECOLORMAP: 1,
      HAS_NORMALMAP: 0,
      HAS_EMISSIVEMAP: 0,
      HAS_OCCLUSIONMAP: 1
    };
    const defineStr = definesToString(defines); // console.log(defineStr);

    const _vs = `${defineStr}\n${shaders_pbr_vert__WEBPACK_IMPORTED_MODULE_9__["default"]}`;
    const _fs = `${defineStr}\n${shaders_pbr_frag__WEBPACK_IMPORTED_MODULE_3__["default"]}`; // console.log(_fs);

    super(_vs, _fs);
    this.shaderDepth = new alfrid__WEBPACK_IMPORTED_MODULE_0__["GLShader"](shaders_pbr_vert__WEBPACK_IMPORTED_MODULE_9__["default"], shaders_depth_frag__WEBPACK_IMPORTED_MODULE_4__["default"]);
    this.shaderEditor = new alfrid__WEBPACK_IMPORTED_MODULE_0__["GLShader"](shaders_basic_vert__WEBPACK_IMPORTED_MODULE_10__["default"], shaders_color_frag__WEBPACK_IMPORTED_MODULE_5__["default"]);
  }

  getFaces() {
    this.faces = [];
    this.debugShapes.forEach(mesh => {
      const faces = Object(utils__WEBPACK_IMPORTED_MODULE_7__["getGeometryFaces"])(mesh);
      this.faces = [...this.faces, ...faces];
    });
  }

  _init() {
    if (_Config__WEBPACK_IMPORTED_MODULE_2__["default"].editor.active || _Config__WEBPACK_IMPORTED_MODULE_2__["default"].debug.shape.active) {
      this.matrixDebug = gl_matrix__WEBPACK_IMPORTED_MODULE_8__["mat4"].create();
      this.cubeDebug = alfrid__WEBPACK_IMPORTED_MODULE_0__["default"].Geom.cube(1, 1, 1);
      this.debugShapes = [];
      this.debugShapes.push(Object(_debug_debugShape__WEBPACK_IMPORTED_MODULE_6__["getCube"])(0.967, 1.4, 0.514, [0, -0.224, 0]));
      this.debugShapes.push(Object(_debug_debugShape__WEBPACK_IMPORTED_MODULE_6__["getCube"])(0.79, 0.914, 0.51, [0, 0.897, 0]));
      this.debugShapes.push(Object(_debug_debugShape__WEBPACK_IMPORTED_MODULE_6__["getCube"])(0.333, 0.51, 0.098, [-0.196, -1.169, -0.015])); // this.getFaces();
    }

    this.mesh = _Assets__WEBPACK_IMPORTED_MODULE_1__["default"].get('modelFlex');
    this.baseColor = [1, 1, 1]; // this.rotationX = -Math.PI / 2;
  }

  renderShadow() {
    this.shaderDepth.bind();
    alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].rotate(this._matrix);
    alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].draw(this.mesh);
  }

  render(textureRad, textureIrr, textureAO, textureColor, textureRough, currentSpotAnnotation) {
    this.shader.bind();
    this.shader.uniform('uAoMap', 'uniform1i', 0);
    textureAO.bind(0);
    this.shader.uniform('uBRDFMap', 'uniform1i', 1);
    _Assets__WEBPACK_IMPORTED_MODULE_1__["default"].get('brdfLUT').bind(1);
    this.shader.uniform('uRadianceMap', 'uniform1i', 3);
    this.shader.uniform('uIrradianceMap', 'uniform1i', 2);
    textureRad.bind(3);
    textureIrr.bind(2);
    this.shader.uniform('uColorMap', 'uniform1i', 4);
    textureColor.bind(4);
    this.shader.uniform('uRoughnessMap', 'uniform1i', 5);
    textureRough.bind(5);
    this.shader.uniform('uMetallic', 'uniform1f', _Config__WEBPACK_IMPORTED_MODULE_2__["default"].metallic);
    this.shader.uniform('uSpecular', 'uniform1f', this.specular); //	pbr

    this.shader.uniform('uLightDirection', 'vec3', [0.5, 0.5, 0.5]);
    this.shader.uniform('uLightColor', 'vec3', [1, 1, 1]);
    this.shader.uniform('uScaleDiffBaseMR', 'vec4', [0, 0, 0, 0]);
    this.shader.uniform('uScaleFGDSpec', 'vec4', [0, 0, 0, 0]);
    this.shader.uniform('uScaleIBLAmbient', 'vec4', [1, 1, 1, 1]);
    this.shader.uniform('uCameraPos', 'vec3', alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].camera.position);
    this.shader.uniform('uOcclusionStrength', 'float', 1);
    this.shader.uniform('uPosAnnotation', 'vec3', currentSpotAnnotation ? currentSpotAnnotation.target : [1000, 1000, 1000]);
    alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].rotate(this._matrix);
    alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].draw(this.mesh);

    if (_Config__WEBPACK_IMPORTED_MODULE_2__["default"].debug.shape.active) {
      this.shaderEditor.bind();
      this.shaderEditor.uniform('uAlpha', 'float', .4);
      this.shaderEditor.uniform('uColor', 'vec3', [1, 0, 0]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__["mat4"].identity(this.matrixDebug);
      const rot = _Config__WEBPACK_IMPORTED_MODULE_2__["default"].debug.shape.rot;
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__["mat4"].rotateX(this.matrixDebug, this.matrixDebug, rot.x);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__["mat4"].rotateY(this.matrixDebug, this.matrixDebug, rot.y);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__["mat4"].rotateZ(this.matrixDebug, this.matrixDebug, rot.z);
      const pos = _Config__WEBPACK_IMPORTED_MODULE_2__["default"].debug.shape.pos;
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__["mat4"].translate(this.matrixDebug, this.matrixDebug, [pos.x, pos.y, pos.z]);
      const scale = _Config__WEBPACK_IMPORTED_MODULE_2__["default"].debug.shape.scale;
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__["mat4"].scale(this.matrixDebug, this.matrixDebug, [scale.x, scale.y, scale.z]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__["mat4"].multiply(tempMat4, this._matrix, this.matrixDebug);
      alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].rotate(tempMat4);
      alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].draw(this.cubeDebug);
      this.shaderEditor.uniform('uColor', 'vec3', [0, 0, 0]);
      this.shaderEditor.uniform('uAlpha', 'float', .2);

      for (let i = 0; i < this.debugShapes.length; i++) {
        const dShape = this.debugShapes[i];
        gl_matrix__WEBPACK_IMPORTED_MODULE_8__["mat4"].multiply(tempMat4, this._matrix, dShape.matrix);
        alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].rotate(tempMat4);
        alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].draw(dShape.mesh);
      }
    }
  }

}

/* harmony default export */ __webpack_exports__["default"] = (ViewObjModel);

/***/ }),

/***/ "./src/js/utils/Capture.js":
/*!*********************************!*\
  !*** ./src/js/utils/Capture.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ */ "./src/js/utils/index.js");
// Capture.js



String.prototype.replaceAll = function (search, replacement) {
  var target = this;
  return target.replace(new RegExp(search, 'g'), replacement);
};

const capture = () => {
  window.addEventListener('keydown', e => {
    if (e.keyCode === 83 && e.metaKey) {
      e.preventDefault();
      const date = new Date();
      let strDate = `${date.getFullYear()}.` + `${date.getMonth() + 1}.` + `${date.getDate()}-` + `${date.getHours()}.` + `${date.getMinutes()}.` + `${date.getSeconds()}`;
      Object(___WEBPACK_IMPORTED_MODULE_1__["saveImage"])(alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].canvas, strDate);
    }
  });
};

/* harmony default export */ __webpack_exports__["default"] = (capture());

/***/ }),

/***/ "./src/js/utils/destroyGL.js":
/*!***********************************!*\
  !*** ./src/js/utils/destroyGL.js ***!
  \***********************************/
/*! exports provided: destroyGL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "destroyGL", function() { return destroyGL; });
const destroyGL = gl => {
  const numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

  for (let unit = 0; unit < numTextureUnits; unit++) {
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
  }

  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};



/***/ }),

/***/ "./src/js/utils/destroyShader.js":
/*!***************************************!*\
  !*** ./src/js/utils/destroyShader.js ***!
  \***************************************/
/*! exports provided: destroyShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "destroyShader", function() { return destroyShader; });
const destroyShader = (shader, gl) => {
  gl.useProgram(null);
  gl.deleteProgram(shader.shaderProgram);
};



/***/ }),

/***/ "./src/js/utils/get2dPos.js":
/*!**********************************!*\
  !*** ./src/js/utils/get2dPos.js ***!
  \**********************************/
/*! exports provided: get2dPos */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get2dPos", function() { return get2dPos; });
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");


const tempVec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create(); // return this.getXY(pos, this.scene.camera._matrix, this.scene.camera.projection, GL.width, GL.height);

const get2dPos = pos => {
  gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformMat4(tempVec3, pos, alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].camera._matrix);
  gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformMat4(tempVec3, tempVec3, alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].camera.projection);
  tempVec3[0] /= tempVec3[2];
  tempVec3[1] /= tempVec3[2];
  tempVec3[0] = (tempVec3[0] + 1) * alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].width / 2;
  tempVec3[1] = alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].height - (tempVec3[1] + 1) * alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].height / 2;
  return tempVec3;
};



/***/ }),

/***/ "./src/js/utils/getDistOptim.js":
/*!**************************************!*\
  !*** ./src/js/utils/getDistOptim.js ***!
  \**************************************/
/*! exports provided: getDistOptim */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistOptim", function() { return getDistOptim; });
const getDistOptim = function (x1, y1, x2, y2) {
  let xDist = x1 - x2;
  let yDist = y1 - y2;
  return xDist * xDist + yDist * yDist;
};



/***/ }),

/***/ "./src/js/utils/getDistOptim3D.js":
/*!****************************************!*\
  !*** ./src/js/utils/getDistOptim3D.js ***!
  \****************************************/
/*! exports provided: getDistOptim3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistOptim3D", function() { return getDistOptim3D; });
const getDistOptim3D = function (x1, y1, z1, x2, y2, z2) {
  let xDist = x1 - x2;
  let yDist = y1 - y2;
  let zDist = z1 - z2;
  return xDist * xDist + yDist * yDist + zDist * zDist;
};



/***/ }),

/***/ "./src/js/utils/getGeometryFaces.js":
/*!******************************************!*\
  !*** ./src/js/utils/getGeometryFaces.js ***!
  \******************************************/
/*! exports provided: getGeometryFaces */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGeometryFaces", function() { return getGeometryFaces; });
const getGeometryFaces = mesh => {
  const faces = [];

  for (let index = 0; index < mesh.indices.length; index += 3) {
    const indice1 = mesh.indices[index];
    const indice2 = mesh.indices[index + 1];
    const indice3 = mesh.indices[index + 2];
    const v1 = mesh.vertices[indice1];
    const v2 = mesh.vertices[indice2];
    const v3 = mesh.vertices[indice3];
    faces.push([v1, v2, v3]);
  }

  return faces;
};



/***/ }),

/***/ "./src/js/utils/getMouse.js":
/*!**********************************!*\
  !*** ./src/js/utils/getMouse.js ***!
  \**********************************/
/*! exports provided: getMouse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMouse", function() { return getMouse; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");


const getMouse = function (mEvent, mTarget) {
  const o = mTarget || {};

  if (mEvent.touches) {
    o.x = mEvent.touches[0].pageX;
    o.y = mEvent.touches[0].pageY;
  } else {
    o.x = mEvent.clientX;
    o.y = mEvent.clientY;
  }

  return o;
};



/***/ }),

/***/ "./src/js/utils/index.js":
/*!*******************************!*\
  !*** ./src/js/utils/index.js ***!
  \*******************************/
/*! exports provided: saveImage, saveJson, destroyGL, destroyShader, getMouse, resize, smallestAngle, intersectionRayMesh, getGeometryFaces, getDistOptim, getDistOptim3D, get2dPos, map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _saveImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./saveImage */ "./src/js/utils/saveImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "saveImage", function() { return _saveImage__WEBPACK_IMPORTED_MODULE_0__["saveImage"]; });

/* harmony import */ var _saveJson__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./saveJson */ "./src/js/utils/saveJson.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "saveJson", function() { return _saveJson__WEBPACK_IMPORTED_MODULE_1__["saveJson"]; });

/* harmony import */ var _destroyGL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./destroyGL */ "./src/js/utils/destroyGL.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "destroyGL", function() { return _destroyGL__WEBPACK_IMPORTED_MODULE_2__["destroyGL"]; });

/* harmony import */ var _destroyShader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./destroyShader */ "./src/js/utils/destroyShader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "destroyShader", function() { return _destroyShader__WEBPACK_IMPORTED_MODULE_3__["destroyShader"]; });

/* harmony import */ var _getMouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getMouse */ "./src/js/utils/getMouse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMouse", function() { return _getMouse__WEBPACK_IMPORTED_MODULE_4__["getMouse"]; });

/* harmony import */ var _resizeCanavs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resizeCanavs */ "./src/js/utils/resizeCanavs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resize", function() { return _resizeCanavs__WEBPACK_IMPORTED_MODULE_5__["resize"]; });

/* harmony import */ var _smallestAngle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./smallestAngle */ "./src/js/utils/smallestAngle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "smallestAngle", function() { return _smallestAngle__WEBPACK_IMPORTED_MODULE_6__["smallestAngle"]; });

/* harmony import */ var _intersectionRayMesh__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./intersectionRayMesh */ "./src/js/utils/intersectionRayMesh.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intersectionRayMesh", function() { return _intersectionRayMesh__WEBPACK_IMPORTED_MODULE_7__["intersectionRayMesh"]; });

/* harmony import */ var _getGeometryFaces__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getGeometryFaces */ "./src/js/utils/getGeometryFaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getGeometryFaces", function() { return _getGeometryFaces__WEBPACK_IMPORTED_MODULE_8__["getGeometryFaces"]; });

/* harmony import */ var _getDistOptim__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getDistOptim */ "./src/js/utils/getDistOptim.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDistOptim", function() { return _getDistOptim__WEBPACK_IMPORTED_MODULE_9__["getDistOptim"]; });

/* harmony import */ var _getDistOptim3D__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getDistOptim3D */ "./src/js/utils/getDistOptim3D.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDistOptim3D", function() { return _getDistOptim3D__WEBPACK_IMPORTED_MODULE_10__["getDistOptim3D"]; });

/* harmony import */ var _get2dPos__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./get2dPos */ "./src/js/utils/get2dPos.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "get2dPos", function() { return _get2dPos__WEBPACK_IMPORTED_MODULE_11__["get2dPos"]; });

/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./map */ "./src/js/utils/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _map__WEBPACK_IMPORTED_MODULE_12__["map"]; });

// index.js














/***/ }),

/***/ "./src/js/utils/intersectionRayMesh.js":
/*!*********************************************!*\
  !*** ./src/js/utils/intersectionRayMesh.js ***!
  \*********************************************/
/*! exports provided: intersectionRayMesh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectionRayMesh", function() { return intersectionRayMesh; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utils */ "./src/js/utils/index.js");



const v = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].create();

function rotate(vec, matrix) {
  gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].copy(v, [vec[0], vec[1], vec[2], 1.0]);
  gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].transformMat4(v, v, matrix);
  return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].clone(v);
}

const intersectionRayMesh = (ray, faces, matrix, getClosest = false) => {
  let hit;
  let v0;
  let v1;
  let v2;
  let closestHit;
  let previousDist = 100000000;
  let dist;

  for (let i = 0; i < faces.length; i++) {
    const vertice = faces[i][0];
    const vertice1 = faces[i][1];
    const vertice2 = faces[i][2];

    if (matrix) {
      v0 = rotate(vertice, matrix);
      v1 = rotate(vertice1, matrix);
      v2 = rotate(vertice2, matrix);
    } else {
      v0 = vertice;
      v1 = vertice1;
      v2 = vertice2;
    }

    hit = ray.intersectTriangle(v0, v1, v2, false);

    if (hit) {
      if (getClosest) {
        dist = Object(utils__WEBPACK_IMPORTED_MODULE_2__["getDistOptim3D"])(ray.origin[0], ray.origin[1], ray.origin[2], hit[0], hit[1], hit[2]);

        if (dist < previousDist) {
          previousDist = dist;
          closestHit = [...hit];
        }
      } else {
        return hit;
      }
    }

    ;
  }

  return closestHit;
};



/***/ }),

/***/ "./src/js/utils/map.js":
/*!*****************************!*\
  !*** ./src/js/utils/map.js ***!
  \*****************************/
/*! exports provided: map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
const map = (val, inputMin, inputMax, outputMin, outputMax) => (outputMax - outputMin) * ((val - inputMin) / (inputMax - inputMin)) + outputMin;



/***/ }),

/***/ "./src/js/utils/preload.js":
/*!*********************************!*\
  !*** ./src/js/utils/preload.js ***!
  \*********************************/
/*! exports provided: preloadBuild, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preloadBuild", function() { return preloadBuild; });
/* harmony import */ var _Assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Assets */ "./src/js/Assets.js");
/* harmony import */ var assets_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! assets-loader */ "./node_modules/assets-loader/src/index.js");
/* harmony import */ var assets_loader__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(assets_loader__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Capture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Capture */ "./src/js/utils/Capture.js");
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
/* harmony import */ var _debug_debugPolyfill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../debug/debugPolyfill */ "./src/js/debug/debugPolyfill.js");
/* harmony import */ var _debug_debugPolyfill__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_debug_debugPolyfill__WEBPACK_IMPORTED_MODULE_4__);



 // preload.js



const getLoadingImage = () => new Promise((resolve, reject) => {
  const img = document.createElement('img');

  img.onload = () => {
    console.log('img loaded', img);
    resolve(img);
  };

  img.src = 'assets/css-img/loading.png';
});

const initAlfrid = (options = {}) => new Promise((resolve, reject) => {
  // CREATE CANVAS
  const canvas = document.createElement('canvas');
  const container = options.container || document.body.querySelector('.container');
  canvas.className = 'Main-Canvas';
  container.appendChild(canvas); // INIT 3D TOOL

  alfrid__WEBPACK_IMPORTED_MODULE_3__["GL"].init(canvas, {
    ignoreWebgl2: false,
    preserveDrawingBuffer: true
  });
  resolve();
});

const createLoadingAnim = () => new Promise((resolve, reject) => {
  console.log('create loading animation');
  resolve();
});

const loadAssets = assets => new Promise((resolve, reject) => {
  console.log('Load Assets');

  if (assets.length > 0) {
    document.body.classList.add('isLoading');
    new assets_loader__WEBPACK_IMPORTED_MODULE_1___default.a({
      assets
    }).on('error', error => {
      console.log('Error :', error);
    }).on('progress', p => {
      // console.log('Progress : ', p);
      const loader = document.body.querySelector('.Loading-Bar');
      if (loader) loader.style.width = `${p * 100}%`;
    }).on('complete', o => {
      resolve(o);
    }).start();
  } else {
    resolve([]);
  }
});

const loadAssetsBuild = (options = {}) => new Promise((resolve, reject) => {
  console.log('Load Assets');

  if (options.assets.length > 0) {
    document.body.classList.add('isLoading');
    const assetsWithUrl = options.assets.map(asset => {
      asset.url = (options.assetsPath || '') + asset.url;
      return asset;
    });
    new assets_loader__WEBPACK_IMPORTED_MODULE_1___default.a({
      assets: assetsWithUrl
    }).on('error', error => {
      console.log('Error :', error);
    }).on('progress', p => {
      // console.log('Progress : ', p);
      if (options.onProgress) options.onProgress();
    }).on('complete', o => {
      if (options.onComplete) options.onComplete();
      resolve(o);
    }).start();
  } else {
    resolve([]);
  }
});

const initAssets = (listAssets, mAssets) => new Promise((resolve, reject) => {
  console.log('Init Assets', mAssets);
  const loader = document.body.querySelector('.Loading-Bar');
  loader.style.width = '100%'; // INIT ASSETS

  _Assets__WEBPACK_IMPORTED_MODULE_0__["default"].init(mAssets, listAssets);
  resolve();
});

const initAssetsBuild = (listAssets, mAssets) => new Promise((resolve, reject) => {
  console.log('Init Assets', mAssets); // INIT ASSETS

  _Assets__WEBPACK_IMPORTED_MODULE_0__["default"].init(mAssets, listAssets);
  resolve();
});

const closeLoadingAnim = () => new Promise((resolve, reject) => {
  console.log('Close loading animation');
  setTimeout(() => {
    document.body.classList.remove('isLoading');
  }, 250);
  setTimeout(() => {
    resolve();
  }, 500);
});

const preload = options => new Promise((resolve, reject) => {
  console.log('preload', options);
  initAlfrid().then(getLoadingImage).then(createLoadingAnim).then(loadAssets.bind(null, options.assets)).then(initAssets.bind(null, options.assets)).then(closeLoadingAnim).then(() => {
    resolve();
  }).catch(e => {
    console.log('Error', e);
  });
});

const preloadBuild = options => new Promise((resolve, reject) => {
  initAlfrid(options).then(loadAssetsBuild.bind(null, options)).then(initAssetsBuild.bind(null, options.assets)).then(() => {
    resolve();
  }).catch(e => {
    console.log('Error', e);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (preload);

/***/ }),

/***/ "./src/js/utils/resizeCanavs.js":
/*!**************************************!*\
  !*** ./src/js/utils/resizeCanavs.js ***!
  \**************************************/
/*! exports provided: resize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resize", function() { return resize; });
/* harmony import */ var alfrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alfrid */ "./src/js/libs/alfrid/alfrid.js");
// resizeCanavs.js


const resize = (w, h, containerWidth, containerHeight) => {
  containerWidth |= window.innerWidth;
  containerHeight |= window.innerHeight;
  w = w || containerWidth;
  h = h || containerHeight;
  alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].setSize(w, h);
  let tw = Math.min(w, containerWidth);
  let th = Math.min(h, containerHeight);
  const sx = containerWidth / w;
  const sy = containerHeight / h;
  const scale = Math.min(sx, sy);
  tw = w * scale;
  th = h * scale;
  alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].canvas.style.width = `${tw}px`;
  alfrid__WEBPACK_IMPORTED_MODULE_0__["GL"].canvas.style.height = `${th}px`;
};



/***/ }),

/***/ "./src/js/utils/saveImage.js":
/*!***********************************!*\
  !*** ./src/js/utils/saveImage.js ***!
  \***********************************/
/*! exports provided: saveImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveImage", function() { return saveImage; });
// saveImage.js
const FILE_EXTENTION = 'jpg';
const MIME_TYPE = "image/jpeg";

const dataURLtoBlob = dataurl => {
  var arr = dataurl.split(','),
      mime = arr[0].match(/:(.*?);/)[1],
      bstr = atob(arr[1]),
      n = bstr.length,
      u8arr = new Uint8Array(n);

  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }

  return new Blob([u8arr], {
    type: mime
  });
};

const saveImage = (canvas, filename) => {
  var link = document.createElement("a");
  var imgData = canvas.toDataURL({
    format: 'png',
    multiplier: 4
  }); // var strDataURI = imgData.substr(22, imgData.length);

  var blob = dataURLtoBlob(imgData);
  var objurl = URL.createObjectURL(blob);
  link.download = `${filename}.png`;
  link.href = objurl;
  link.click();
};



/***/ }),

/***/ "./src/js/utils/saveJson.js":
/*!**********************************!*\
  !*** ./src/js/utils/saveJson.js ***!
  \**********************************/
/*! exports provided: saveJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveJson", function() { return saveJson; });
// saveJson.js
const saveJson = (obj, mName = 'dagta', mPretty = true) => {
  var str = mPretty ? JSON.stringify(obj, null, 4) : JSON.stringify(obj);
  var data = encode(str);
  var blob = new Blob([data], {
    type: 'application/octet-stream'
  });
  var url = URL.createObjectURL(blob);
  var link = document.createElement('a');
  link.setAttribute('href', url);
  link.setAttribute('download', `${mName}.json`);
  var event = document.createEvent('MouseEvents');
  event.initMouseEvent('click', true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
  link.dispatchEvent(event);
};

const encode = s => {
  var out = [];

  for (var i = 0; i < s.length; i++) {
    out[i] = s.charCodeAt(i);
  }

  return new Uint8Array(out);
};



/***/ }),

/***/ "./src/js/utils/smallestAngle.js":
/*!***************************************!*\
  !*** ./src/js/utils/smallestAngle.js ***!
  \***************************************/
/*! exports provided: smallestAngle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smallestAngle", function() { return smallestAngle; });
const smallestAngle = (angle, targetAngle) => {
  targetAngle %= Math.PI * 2;
  angle %= Math.PI * 2;
  if (angle < 0) angle += Math.PI * 2;
  if (targetAngle < 0) targetAngle += Math.PI * 2;
  let difference1 = targetAngle - angle;
  let difference2 = targetAngle + Math.PI * 2 - angle;
  let difference3 = targetAngle - Math.PI * 2 - angle;
  let absDifference1 = Math.abs(difference1);
  let absDifference2 = Math.abs(difference2);
  let absDifference3 = Math.abs(difference3);
  let difference = difference1;

  if (absDifference2 < absDifference1 && absDifference2 < absDifference3) {
    difference = difference2;
  } else if (absDifference3 < absDifference1 && absDifference3 < absDifference2) {
    difference = difference3;
  }

  return difference;
};



/***/ }),

/***/ "./src/scss/global.scss":
/*!******************************!*\
  !*** ./src/scss/global.scss ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./global.scss */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/scss/global.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/scss/modelViewer.scss":
/*!***********************************!*\
  !*** ./src/scss/modelViewer.scss ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./modelViewer.scss */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/scss/modelViewer.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/shaders/basic.vert":
/*!********************************!*\
  !*** ./src/shaders/basic.vert ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// basic.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n}");

/***/ }),

/***/ "./src/shaders/color.frag":
/*!********************************!*\
  !*** ./src/shaders/color.frag ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// copy.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nuniform vec3 uColor;\nuniform float uAlpha;\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n    gl_FragColor = vec4(uColor, uAlpha);\n}");

/***/ }),

/***/ "./src/shaders/depth.frag":
/*!********************************!*\
  !*** ./src/shaders/depth.frag ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("precision highp float;\n#define GLSLIFY 1\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nvoid main(void){        \n    gl_FragColor=vec4(1.);\n}");

/***/ }),

/***/ "./src/shaders/floor.frag":
/*!********************************!*\
  !*** ./src/shaders/floor.frag ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// copy.frag\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nvarying vec4 vWorldPosition;\nvarying vec4 vShadowCoord;\n\nuniform sampler2D textureDepth;\nuniform sampler2D textureAlpha;\nuniform vec3 uCameraPos;\nuniform vec3 uColor;\nuniform vec3 uShadowColor;\nuniform float uShadowOpacity;\nuniform float uSpread;\nuniform float uMapSize;\nuniform vec2 uShadowDistance;\n\nconst int   c_samplesX    = 17;  // must be odd\nconst int   c_samplesY    = 17;  // must be odd\nconst float c_textureSize = 256.0;\n\nconst int   c_halfSamplesX = c_samplesX / 2;\nconst int   c_halfSamplesY = c_samplesY / 2;\nconst float c_pixelSize = (1.0 / c_textureSize);\n\nfloat Gaussian (float sigma, float x){\n    return exp(-(x*x) / (2.0 * sigma*sigma));\n}\n\nvec3 BlurredPixel (in vec2 uv){\n    float c_sigmaX      = 20.0;\n\tfloat c_sigmaY      = c_sigmaX;\n    \n    float total = 0.0;\n    vec3 ret = vec3(0);\n        \n    for (int iy = 0; iy < c_samplesY; ++iy)\n    {\n        float fy = Gaussian (c_sigmaY, float(iy) - float(c_halfSamplesY));\n        float offsety = float(iy-c_halfSamplesY) * c_pixelSize;\n        for (int ix = 0; ix < c_samplesX; ++ix)\n        {\n            float fx = Gaussian (c_sigmaX, float(ix) - float(c_halfSamplesX));\n            float offsetx = float(ix-c_halfSamplesX) * c_pixelSize;\n            total += fx * fy;            \n            ret += texture2D(textureDepth, uv + vec2(offsetx, offsety)).rgb * fx*fy;\n        }\n    }\n    return ret / total;\n}\n\nvoid main(void){\n    vec4 shadowCoord = vShadowCoord / vShadowCoord.w;\n\tvec2 offset = vec2(0.99);\n\tgl_FragColor = vec4(uShadowColor, 1.0-BlurredPixel(offset*shadowCoord.xy).r);\t  \n}");

/***/ }),

/***/ "./src/shaders/floor.vert":
/*!********************************!*\
  !*** ./src/shaders/floor.vert ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("precision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uMatrix;\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uShadowMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec4 vWorldPosition;\n\nvarying vec4 vShadowCoord;\n\nvoid main(void){\n    vWorldPosition       = uMatrix * vec4(aVertexPosition ,1.0);\n\n    gl_Position          = uProjectionMatrix * uViewMatrix * vWorldPosition;\n            \n    vTextureCoord        = aTextureCoord;\n    vNormal              = aNormal;\n    vShadowCoord         = uShadowMatrix * vWorldPosition;\n}");

/***/ }),

/***/ "./src/shaders/line.frag":
/*!*******************************!*\
  !*** ./src/shaders/line.frag ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nuniform vec3 uColor;\nuniform float uAlpha;\nvarying vec2 vTextureCoord;\nvarying float vCounters;\n\nvoid main(void) {\n    gl_FragColor = vec4(uColor, 1.0);\n    gl_FragColor.a *= ((vCounters) * uAlpha);\n}");

/***/ }),

/***/ "./src/shaders/line.vert":
/*!*******************************!*\
  !*** ./src/shaders/line.vert ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute float aDirection;\nattribute vec3 aPrevious;\nattribute vec3 aNext;\nattribute float aCounters;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uTime;\n\nuniform float thickness;\nuniform float aspect;\n\nvarying vec2 vUV;\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying vec3 vNormal;\nvarying float vCounters;\n\nvoid main() {\n\n  // float thickness = .1;\n  int miter = 0;\n\n  vec2 aspectVec = vec2(aspect, 1.0);\n  mat4 projViewModel = uProjectionMatrix * uViewMatrix * uModelMatrix;//projection * view * model;\n\n  vec4 previousProjected = projViewModel * vec4(aPrevious.x, aPrevious.y, aPrevious.z, 1.0);\n  vec4 currentProjected = projViewModel * vec4(aVertexPosition.x, aVertexPosition.y, aVertexPosition.z, 1.0);\n  vec4 nextProjected = projViewModel * vec4(aNext.x, aNext.y, aNext.z, 1.0);\n\n  vPosition = currentProjected.xyz;\n  vNormal = aNormal;\n  vUV = aTextureCoord;\n  //get 2D screen space with W divide and aspect correction\n  vec2 currentScreen = currentProjected.xy / currentProjected.w * aspectVec;\n  vec2 previousScreen = previousProjected.xy / previousProjected.w * aspectVec;\n  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n\n  vCounters = aCounters;\n\n  float scale = 1.0;\n  // float len = thickness;\n  float len = pow(1. - vCounters, .4) * thickness;\n  // float len = thickness * uThicknessOffset;\n\n  float orientation = aDirection;\n\n  vColor = vec3(1.0, .0, 0.0);\n  vec2 dir = vec2(0.0);\n  if (currentScreen == previousScreen) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  else if (currentScreen == nextScreen) {\n    dir = normalize(currentScreen - previousScreen);\n  }\n  else {\n    //get aDirections from (C - B) and (B - A)\n\n    vec2 dirA = normalize((currentScreen - previousScreen));\n    if (miter == 1) {\n      vec2 dirB = normalize((nextScreen - currentScreen));\n      //now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n      len = thickness / dot(miter, perp);\n    } else {\n      dir = dirA;\n\n    }\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  vColor = vec3(normal, 1.0);\n  normal.x /= aspect;\n  normal *= len/2.0;\n\n  vec4 offset =  vec4(normal * orientation, 0.0, 0.0);\n\n  gl_Position = currentProjected + offset;\n}\n");

/***/ }),

/***/ "./src/shaders/marker.vert":
/*!*********************************!*\
  !*** ./src/shaders/marker.vert ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// basic.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aPosOffset;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uScale;\nuniform float uTime;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    vec3 pos = aVertexPosition * uScale;// * (1. + cos((uTime + aExtra) / 20.) * .1);\n    pos.xyz += aPosOffset;\n\n    vec3 dir = aPosOffset;\n\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}");

/***/ }),

/***/ "./src/shaders/pbr.frag":
/*!******************************!*\
  !*** ./src/shaders/pbr.frag ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("#define SHADER_NAME pbr_frag\n\n#extension GL_EXT_shader_texture_lod: enable\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D \tuBRDFMap;\nuniform samplerCube uRadianceMap;\nuniform samplerCube uIrradianceMap;\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D uColorMap;\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D uAoMap;\nuniform float uOcclusionStrength;\n#endif\n\n#ifdef HAS_NORMALMAP\nuniform sampler2D uNormalMap;\nuniform float uNormalScale;\n#endif\n\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D uEmissiveMap;\nuniform vec3 uEmissiveFactor;\n#endif\n\nuniform sampler2D uRoughnessMap;\n\nuniform vec3 uLightDirection;\nuniform vec3 uLightColor;\nuniform vec3 uCameraPos;\n\nuniform vec4 uScaleDiffBaseMR;\nuniform vec4 uScaleFGDSpec;\nuniform vec4 uScaleIBLAmbient;\n\nuniform vec3 uBaseColor;\nuniform float uRoughness;\nuniform float uMetallic;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying float vAlphaAnnotation;\nvarying vec3 vPosition;\n\n//\tFrom GLTF WebGL PBR :\n//\thttps://github.com/KhronosGroup/glTF-WebGL-PBR\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo\n{\n\tfloat NdotL;                  // cos angle between normal and light direction\n\tfloat NdotV;                  // cos angle between normal and view direction\n\tfloat NdotH;                  // cos angle between normal and half vector\n\tfloat LdotH;                  // cos angle between light direction and half vector\n\tfloat VdotH;                  // cos angle between view direction and half vector\n\tfloat perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n\tfloat metalness;              // metallic value at the surface\n\tvec3 reflectance0;            // full reflectance color (normal incidence angle)\n\tvec3 reflectance90;           // reflectance color at grazing angle\n\tfloat alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n\tvec3 diffuseColor;            // color contribution from diffuse lighting\n\tvec3 specularColor;           // color contribution from specular lighting\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n\t#ifdef MANUAL_SRGB\n\t#ifdef SRGB_FAST_APPROXIMATION\n\tvec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n\t#else //SRGB_FAST_APPROXIMATION\n\tvec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n\tvec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n\t#endif //SRGB_FAST_APPROXIMATION\n\treturn vec4(linOut,srgbIn.w);;\n\t#else //MANUAL_SRGB\n\treturn srgbIn;\n\t#endif //MANUAL_SRGB\n}\n\nvec3 getNormal() {\n\tvec3 pos_dx = dFdx(vPosition);\n\tvec3 pos_dy = dFdy(vPosition);\n\tvec3 tex_dx = dFdx(vec3(vTextureCoord, 0.0));\n\tvec3 tex_dy = dFdy(vec3(vTextureCoord, 0.0));\n\tvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n\tvec3 ng = normalize(vNormal);\n\n\tt = normalize(t - ng * dot(ng, t));\n\tvec3 b = normalize(cross(ng, t));\n\tmat3 tbn = mat3(t, b, ng);\n\n#ifdef HAS_NORMALMAP\n\tvec3 n = texture2D(uNormalMap, vTextureCoord).rgb;\n\tn = normalize(tbn * ((2.0 * n - 1.0) * vec3(uNormalScale, uNormalScale, 1.0)));\n#else\n\t// The tbn matrix is linearly interpolated, so we need to re-normalize\n\tvec3 n = normalize(tbn[2].xyz);\n#endif\n\n\treturn n;\n}\n\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n\tfloat mipCount = 7.0; // resolution of 512x512\n\tfloat lod = (pbrInputs.perceptualRoughness * mipCount);\n\t// retrieve a scale and bias to F0. See [1], Figure 3\n\tvec3 brdf = SRGBtoLINEAR(texture2D(uBRDFMap, vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n\tvec3 diffuseLight = SRGBtoLINEAR(textureCube(uIrradianceMap, n)).rgb;\n\n\t\n\t#ifdef USE_TEX_LOD\n\t\tvec3 specularLight = SRGBtoLINEAR(textureCubeLodEXT(uRadianceMap, reflection, lod)).rgb;\n\t    // vec3 specularLight = SRGBtoLINEAR(textureCubeLodEXT(u_SpecularEnvSampler, reflection, lod)).rgb;\n\t#else\n\t\tvec3 specularLight = SRGBtoLINEAR(textureCube(uRadianceMap, reflection)).rgb;\n\t    // vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n\t#endif\n\n\tvec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n\tvec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n\n\t// For presentation, this allows us to disable IBL terms\n\tdiffuse *= uScaleIBLAmbient.x;\n\tspecular *= uScaleIBLAmbient.y;\n\n\treturn diffuse + specular;\n}\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n\tfloat NdotL = pbrInputs.NdotL;\n\tfloat NdotV = pbrInputs.NdotV;\n\tfloat r = pbrInputs.alphaRoughness;\n\n\tfloat attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n\tfloat attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n\treturn attenuationL * attenuationV;\n}\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n\tfloat roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n\tfloat f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n\treturn roughnessSq / (M_PI * f * f);\n}\n\nvoid main() {\n\n\tfloat perceptualRoughness   = 1.0-texture2D(uRoughnessMap, vTextureCoord).r;\n\tfloat metallic              = uMetallic;\n\tperceptualRoughness         = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n\tmetallic                    = clamp(metallic, 0.0, 1.0);\n\tfloat alphaRoughness        = perceptualRoughness * perceptualRoughness;\n\n#ifdef HAS_BASECOLORMAP\t\n\tvec4 baseColor = SRGBtoLINEAR(texture2D(uColorMap, vTextureCoord));\n#else\n\tvec4 baseColor              = vec4(uBaseColor, 1.0);\n#endif\t\n\t\n\tvec3 f0                     = vec3(0.2);\n\tvec3 diffuseColor           = baseColor.rgb * (vec3(1.0) - f0);\n\tdiffuseColor                *= 1.0 - metallic;\n\tvec3 specularColor          = mix(f0, baseColor.rgb, metallic);\n\t\n\t// Compute reflectance.\n\tfloat reflectance           = max(max(specularColor.r, specularColor.g), specularColor.b);\n\t\n\t// For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\n\t// For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\n\tfloat reflectance90         = clamp(reflectance * 25.0, 0.0, 1.0);\n\tvec3 specularEnvironmentR0  = specularColor.rgb;\n\tvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\t\n\tvec3 n                      = getNormal();                             // normal at surface point\n\tvec3 v                      = normalize(uCameraPos - vPosition);        // Vector from surface point to camera\n\tvec3 l                      = normalize(uLightDirection);             // Vector from surface point to light\n\tvec3 h                      = normalize(l+v);                          // Half vector between both l and v\n\tvec3 reflection             = -normalize(reflect(v, n));\n\t\n\tfloat NdotL                 = clamp(dot(n, l), 0.001, 1.0);\n\tfloat NdotV                 = abs(dot(n, v)) + 0.001;\n\tfloat NdotH                 = clamp(dot(n, h), 0.0, 1.0);\n\tfloat LdotH                 = clamp(dot(l, h), 0.0, 1.0);\n\tfloat VdotH                 = clamp(dot(v, h), 0.0, 1.0);\n\n\tPBRInfo pbrInputs = PBRInfo(\n\t\tNdotL,\n\t\tNdotV,\n\t\tNdotH,\n\t\tLdotH,\n\t\tVdotH,\n\t\tperceptualRoughness,\n\t\tmetallic,\n\t\tspecularEnvironmentR0,\n\t\tspecularEnvironmentR90,\n\t\talphaRoughness,\n\t\tdiffuseColor,\n\t\tspecularColor\n\t);\n\n\t// Calculate the shading terms for the microfacet specular shading model\n\tvec3 F              = specularReflection(pbrInputs);\n\tfloat G             = geometricOcclusion(pbrInputs);\n\tfloat D             = microfacetDistribution(pbrInputs);\n\t\n\t// Calculation of analytical lighting contribution\n\tvec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n\tvec3 specContrib    = F * G * D / (4.0 * NdotL * NdotV);\n\t// Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n\tvec3 color          = NdotL * uLightColor * (diffuseContrib + specContrib);\n\t\n#ifdef USE_IBL\n\tcolor += getIBLContribution(pbrInputs, n, reflection);\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\t\n\tfloat ao            = texture2D(uAoMap, vTextureCoord).r;\n\tcolor               = mix(color, color * ao, uOcclusionStrength);\n#endif\t\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture2D(uEmissiveMap, vTextureCoord)).rgb * uEmissiveFactor;\n    color += emissive;\n#endif\n\t\n\t// This section uses mix to override final color for reference app visualization\n\t// of various parameters in the lighting equation.\n\tcolor               = mix(color, F, uScaleFGDSpec.x);\n\tcolor               = mix(color, vec3(G), uScaleFGDSpec.y);\n\tcolor               = mix(color, vec3(D), uScaleFGDSpec.z);\n\tcolor               = mix(color, specContrib, uScaleFGDSpec.w);\n\t\n\tcolor               = mix(color, diffuseContrib, uScaleDiffBaseMR.x);\n\tcolor               = mix(color, baseColor.rgb, uScaleDiffBaseMR.y);\n\tcolor               = mix(color, vec3(metallic), uScaleDiffBaseMR.z);\n\tcolor               = mix(color, vec3(perceptualRoughness), uScaleDiffBaseMR.w);\n\t\n\t// output the fragment color\n\tvec3 colorSpot = vec3(0./255., 154./255., 221./255.);\n\tvec3 fColor = mix(pow(color,vec3(1.0/2.2)), colorSpot, vAlphaAnnotation * 0.5);\n\tgl_FragColor        = vec4(fColor, baseColor.a);\n\t// gl_FragColor        = vec4(, baseColor.a);\n\n}");

/***/ }),

/***/ "./src/shaders/pbr.vert":
/*!******************************!*\
  !*** ./src/shaders/pbr.vert ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("#define SHADER_NAME pbr_vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uMatrix;\nuniform mat3 uNormalMatrix;\nuniform mat3 uModelViewMatrixInverse;\nuniform vec3 uPosAnnotation;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vAlphaAnnotation;\n\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nvoid main(void) {\n\tvec4 position = uModelMatrix * vec4(aVertexPosition, 1.0);\n\tvPosition     = position.xyz / position.w;\n\t\n\tvNormal       = normalize(vec3(uModelMatrix * vec4(aNormal, 0.0)));\n\tvTextureCoord = aTextureCoord;\n\n\tfloat dist = distance(uPosAnnotation, position.xyz);\n\tvAlphaAnnotation = smoothstep(0.5, 0., dist);\n\t// vAlphaAnnotation = smoothstep( 0.5-0.01, 0.5, dist) - smoothstep( 0.5, 0.5+0.01, dist);\n\t\n\tgl_Position   = uProjectionMatrix * uViewMatrix * position;\n}\n");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2Jyb3dzZXItaGFzLWJsb2IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2VtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2dyb3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNzZXRzLWxvYWRlci9zcmMvbG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9zdGF0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9nbG9iYWwuc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9tb2RlbFZpZXdlci5zY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJsLXBhcnNlci9zcmMvdXJscGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vbWF0NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9xdWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3F1YXQyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjMy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWM0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbHNsaWZ5L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dzYXAvQ1NTUGx1Z2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nc2FwL2dzYXAtY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3NhcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGV4LXJnYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWluaS1zaWduYWxzL2xpYi9taW5pLXNpZ25hbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZS1kZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5ncGFyc2VyL2pzL3F1ZXJ5c3RyaW5ncGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ3BhcnNlci9qcy9xdWVyeXN0cmluZ3NlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxpbmcvc3JjL3NjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL0Fzc2V0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZGVidWcvYWRkRHJvcFN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2RlYnVnL2RlYnVnUG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlcnMvQml0U3dpdGNoLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9oZWxwZXJzL09yYml0YWxDb250cm9sVHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL0JhdGNoLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvQ3ViZUZyYW1lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvRmJvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9GYm9QaW5nUG9uZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL0ZyYW1lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvR0xDdWJlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL0dMU2hhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvR0xUZXh0dXJlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvR0xUZXh0dXJlMi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL0dMVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL0dlb20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9NZXNoLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL1RyYW5zZm9ybUZlZWRiYWNrT2JqZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvY2FtZXJhcy9DYW1lcmEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9jYW1lcmFzL0NhbWVyYUN1YmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9jYW1lcmFzL0NhbWVyYU9ydGhvLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvY2FtZXJhcy9DYW1lcmFQZXJzcGVjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL2hlbHBlcnMvQmF0Y2hBeGlzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvaGVscGVycy9CYXRjaEJhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9oZWxwZXJzL0JhdGNoQ29weS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL2hlbHBlcnMvQmF0Y2hEb3RzUGxhbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9oZWxwZXJzL0JhdGNoTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL2hlbHBlcnMvQmF0Y2hTa3kuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9oZWxwZXJzL0JhdGNoU2t5Ym94LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvaGVscGVycy9EcmF3LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvaGVscGVycy9TY2VuZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL2hlbHBlcnMvVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL2hlbHBlcnMvVmlldzNELmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvbG9hZGVycy9CaW5hcnlMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9sb2FkZXJzL0dMVEZQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9sb2FkZXJzL0hEUkxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL2xvYWRlcnMvT2JqTG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvbWF0aC9SYXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9vYmplY3RzL09iamVjdDNELmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvc2hhZGVycy9heGlzLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9zaGFkZXJzL2F4aXMudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3NoYWRlcnMvYmFzaWMuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3NoYWRlcnMvYmFzaWMudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3NoYWRlcnMvYmlnVHJpYW5nbGUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3NoYWRlcnMvY29weS5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvc2hhZGVycy9kb3RzUGxhbmUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3NoYWRlcnMvZG90c1BsYW5lLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9zaGFkZXJzL2dlbmVyYWwudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3NoYWRlcnMvc2ltcGxlQ29sb3IuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3NoYWRlcnMvc2t5LnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC9zaGFkZXJzL3NreWJveC5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvc2hhZGVycy9za3lib3gudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3V0aWxzL0Vhc2VOdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC91dGlscy9FdmVudERpc3BhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC91dGlscy9FeHRlbnNpb25zTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3V0aWxzL0hEUlBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3V0aWxzL09yYml0YWxDb250cm9sLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvdXRpbHMvUXVhdFJvdGF0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvdXRpbHMvU2hhZGVyTGlicy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3V0aWxzL1NwcmluZ051bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3V0aWxzL1RvdWNoRGV0ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC91dGlscy9Ud2Vlbk51bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3V0aWxzL1dlYmdsQ29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC91dGlscy9XZWJnbE51bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3V0aWxzL2V4cG9zZUF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC91dGlscy9nZXRBbmRBcHBseUV4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3V0aWxzL2dldEF0dHJpYkxvYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGlicy9hbGZyaWQvYWxmcmlkL3V0aWxzL2dldEZsb2F0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvdXRpbHMvZ2V0SGFsZkZsb2F0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL2FsZnJpZC9hbGZyaWQvdXRpbHMvZ2V0TW91c2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYnMvYWxmcmlkL2FsZnJpZC91dGlscy9nZXRUZXh0dXJlUGFyYW1ldGVycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kZWxWaWV3ZXIvQ2FtZXJhU3BvdHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL0NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kZWxWaWV3ZXIvU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL1NoYWRvd01hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL1N0YXRlc01hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL1RvdWNoQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kZWxWaWV3ZXIvVmlld2VyQXBwLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tb2RlbFZpZXdlci9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL2Fzc2V0LWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL2RhdGEtY2FtZXJhLXBvaW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kZWxWaWV3ZXIvZGVidWcvUG9pbnRzRWRpdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tb2RlbFZpZXdlci9kZWJ1Zy9hZGRDb250cm9scy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kZWxWaWV3ZXIvZGVidWcvYWRkVUkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL2RlYnVnL2RlYnVnU2hhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL2dlb20vTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kZWxWaWV3ZXIvc3RhdGVzL1N0YXRlQW5ub3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL3N0YXRlcy9TdGF0ZURlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL3N0YXRlcy9TdGF0ZUhvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL3N0YXRlcy9TdGF0ZU9yYml0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tb2RlbFZpZXdlci9zdGF0ZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL3V0aWxzL2JpYXNNYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVsVmlld2VyL3V0aWxzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tb2RlbFZpZXdlci92aWV3cy9WaWV3QW5ub3RhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kZWxWaWV3ZXIvdmlld3MvVmlld0Zsb29yLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tb2RlbFZpZXdlci92aWV3cy9WaWV3T2JqTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL0NhcHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL2Rlc3Ryb3lHTC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMvZGVzdHJveVNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMvZ2V0MmRQb3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL2dldERpc3RPcHRpbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMvZ2V0RGlzdE9wdGltM0QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL2dldEdlb21ldHJ5RmFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL2dldE1vdXNlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMvaW50ZXJzZWN0aW9uUmF5TWVzaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMvbWFwLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy91dGlscy9wcmVsb2FkLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy91dGlscy9yZXNpemVDYW5hdnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL3NhdmVJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMvc2F2ZUpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL3NtYWxsZXN0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvZ2xvYmFsLnNjc3M/MWUzYiIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9tb2RlbFZpZXdlci5zY3NzPzQ1MDQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYmFzaWMudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9jb2xvci5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL2RlcHRoLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvZmxvb3IuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9mbG9vci52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL2xpbmUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9saW5lLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvbWFya2VyLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcGJyLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcGJyLnZlcnQiXSwibmFtZXMiOlsiQXNzZXRzIiwiX2Fzc2V0cyIsImFzc2V0cyIsInRleHR1cmVzIiwiZ2V0QXNzZXQiLCJpZCIsImZpbmQiLCJhIiwiZmlsZSIsImdldEV4dGVuc2lvbiIsIm1GaWxlIiwiYXJ5Iiwic3BsaXQiLCJsZW5ndGgiLCJpbml0IiwibUFzc2V0cyIsImFzc2V0c1RvTG9hZCIsImhkckN1YmVtYXBzIiwibWFwIiwibyIsImV4dCIsInVybCIsInRleHR1cmUiLCJHTFRleHR1cmUiLCJwdXNoIiwiY3ViZW1hcE5hbWUiLCJhbGZyaWQiLCJIRFJMb2FkZXIiLCJwYXJzZSIsIm9Bc3NldCIsIkdMQ3ViZVRleHR1cmUiLCJwYXJzZUREUyIsIm1lc2giLCJPYmpMb2FkZXIiLCJjb25zb2xlIiwibG9nIiwicyIsImdldCIsImRlYnVnIiwidGFibGUiLCJkZXN0cm95IiwiZ2wiLCJpIiwiZGVsZXRlVGV4dHVyZSIsIl90ZXh0dXJlIiwibUlkIiwiYWRkRHJvcFN1cHBvcnQiLCJtQ0IiLCJkcm9wQXJlYSIsIndpbmRvdyIsInByZXZlbnREZWZhdWx0cyIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImZvckVhY2giLCJldmVudE5hbWUiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlRHJvcCIsImR0IiwiZGF0YVRyYW5zZmVyIiwiZmlsZXMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzRGF0YVVSTCIsIm9ubG9hZGVuZCIsImltZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ubG9hZCIsInNyYyIsInJlc3VsdCIsImd1aSIsImFkZCIsIkJpdFN3aXRjaCIsImNvbnN0cnVjdG9yIiwiaW5pdFZhbHVlIiwiX3ZhbHVlIiwic2V0IiwibU51bURpZ2l0IiwibVZhbHVlIiwidG9nZ2xlIiwidmFsdWUiLCJyZXNldCIsInRvU3RyaW5nIiwiT3JiQ29udHJvbFR3ZWVuIiwib3JiaXRhbENvbnRyb2wiLCJpbml0aWFsaXNlZCIsInR3ZWVuIiwib3B0aW9ucyIsIm9yYiIsInJhZGl1cyIsInJ4IiwicnkiLCJjZW50ZXJYIiwiY2VudGVyIiwiY2VudGVyWSIsImNlbnRlcloiLCJvZmZzZXRYIiwicG9zaXRpb25PZmZzZXQiLCJvZmZzZXRZIiwib2Zmc2V0WiIsImdzYXAiLCJ0byIsImR1cmF0aW9uIiwiZGVsYXkiLCJlYXNlIiwib25VcGRhdGUiLCJ1bmRlZmluZWQiLCJzZXRUbyIsIm9uQ29tcGxldGUiLCJpc1JlYWR5Iiwib3JiaXRhbENvbnRyb2xUd2VlbiIsIlZFUlNJT04iLCJBbGZyaWQiLCJnbG0iLCJHTE0iLCJHTCIsIkdMVG9vbCIsIkdMU2hhZGVyIiwiTWVzaCIsIkdlb20iLCJCYXRjaCIsIkZyYW1lQnVmZmVyIiwiQ3ViZUZyYW1lQnVmZmVyIiwiU2NoZWR1bGVyIiwiRXZlbnREaXNwYXRjaGVyIiwiRWFzZU51bWJlciIsIlNwcmluZ051bWJlciIsIlR3ZWVuTnVtYmVyIiwiQ2FtZXJhIiwiQ2FtZXJhT3J0aG8iLCJDYW1lcmFQZXJzcGVjdGl2ZSIsIlJheSIsIkNhbWVyYUN1YmUiLCJPcmJpdGFsQ29udHJvbCIsIlF1YXRSb3RhdGlvbiIsIkJpbmFyeUxvYWRlciIsIkdMVEZQYXJzZXIiLCJCYXRjaENvcHkiLCJCYXRjaEF4aXMiLCJCYXRjaEJhbGwiLCJCYXRjaExpbmUiLCJCYXRjaFNreWJveCIsIkJhdGNoU2t5IiwiQmF0Y2hEb3RzUGxhbmUiLCJTY2VuZSIsIlZpZXciLCJWaWV3M0QiLCJEcmF3IiwiT2JqZWN0M0QiLCJTaGFkZXJMaWJzIiwiV2ViZ2xOdW1iZXIiLCJGYm9BcnJheSIsIkZib1BpbmdQb25nIiwiTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlciIsIlRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5kZXhPZiIsImFsIiwibU1lc2giLCJtU2hhZGVyIiwiX21lc2giLCJfc2hhZGVyIiwiZHJhdyIsImJpbmQiLCJzaGFkZXIiLCJzaXplIiwibVBhcmFtZXRlcnMiLCJfc2l6ZSIsIm1hZ0ZpbHRlciIsIkxJTkVBUiIsIm1pbkZpbHRlciIsIndyYXBTIiwiQ0xBTVBfVE9fRURHRSIsIndyYXBUIiwiX2luaXQiLCJjcmVhdGVUZXh0dXJlIiwiZ2xUZXh0dXJlIiwiYmluZFRleHR1cmUiLCJURVhUVVJFX0NVQkVfTUFQIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIlRFWFRVUkVfV1JBUF9TIiwiVEVYVFVSRV9XUkFQX1QiLCJ0YXJnZXRzIiwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YIiwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YIiwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZIiwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZIiwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aIiwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aIiwicGl4ZWxTdG9yZWkiLCJVTlBBQ0tfRkxJUF9ZX1dFQkdMIiwidGV4SW1hZ2UyRCIsIlJHQkEiLCJ3aWR0aCIsImhlaWdodCIsIkZMT0FUIiwiX2ZyYW1lQnVmZmVycyIsImZyYW1lQnVmZmVyIiwiY3JlYXRlRnJhbWVidWZmZXIiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsImZyYW1lYnVmZmVyVGV4dHVyZTJEIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJzdGF0dXMiLCJjaGVja0ZyYW1lYnVmZmVyU3RhdHVzIiwiRlJBTUVCVUZGRVJfQ09NUExFVEUiLCJiaW5kUmVuZGVyYnVmZmVyIiwiUkVOREVSQlVGRkVSIiwibVRhcmdldEluZGV4Iiwidmlld3BvcnQiLCJ1bmJpbmQiLCJnZXRUZXh0dXJlIiwibU51bSIsInBhcmFtcyIsIm1OdW1UYXJnZXRzIiwiX2Zib3MiLCJmYm8iLCJzd2FwIiwic2hpZnQiLCJyZWFkIiwid3JpdGUiLCJhbGwiLCJGYm9GYXJyYXkiLCJ3ZWJnbERlcHRoVGV4dHVyZSIsImhhc0NoZWNrZWRNdWx0aVJlbmRlclN1cHBvcnQiLCJleHREcmF3QnVmZmVyIiwiY2hlY2tNdWx0aVJlbmRlciIsIndlYmdsMiIsIm1XaWR0aCIsIm1IZWlnaHQiLCJjaGVja0V4dGVuc2lvbiIsIl9udW1UYXJnZXRzIiwiX211bHRpcGxlVGFyZ2V0cyIsIl9wYXJhbWV0ZXJzIiwiX2NoZWNrTWF4TnVtUmVuZGVyVGFyZ2V0IiwiX2luaXRUZXh0dXJlcyIsImJ1ZmZlcnMiLCJEUkFXX0ZSQU1FQlVGRkVSIiwiVEVYVFVSRV8yRCIsIl90ZXh0dXJlcyIsImRyYXdCdWZmZXJzIiwiREVQVEhfQVRUQUNITUVOVCIsImdsRGVwdGhUZXh0dXJlIiwiZHJhd0J1ZmZlcnNXRUJHTCIsIkZCT3N0YXR1cyIsImVycm9yIiwiY2xlYXIiLCJtYXhOdW1EcmF3QnVmZmVycyIsImdldFBhcmFtZXRlciIsIk1BWF9EUkFXX0JVRkZFUlNfV0VCR0wiLCJnbHQiLCJfY3JlYXRlVGV4dHVyZSIsIkRFUFRIX0NPTVBPTkVOVDE2IiwiVU5TSUdORURfU0hPUlQiLCJERVBUSF9DT01QT05FTlQiLCJORUFSRVNUIiwibWlwbWFwIiwibUludGVybmFsZm9ybWF0IiwibVRleGVsVHlwZSIsIm1Gb3JtYXQiLCJwYXJhbWV0ZXJzIiwiT2JqZWN0IiwiYXNzaWduIiwiaW50ZXJuYWxGb3JtYXQiLCJmb3JtYXQiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsIkdMVGV4dHVyZTIiLCJtQXV0b1NldFZpZXdwb3J0IiwiZ2VuZXJhdGVNaXBtYXAiLCJyIiwiZyIsImIiLCJtSW5kZXgiLCJnZXREZXB0aFRleHR1cmUiLCJkZXB0aFRleHR1cmUiLCJzaG93UGFyYW1ldGVycyIsIm51bVRhcmdldHMiLCJERFNEX01JUE1BUENPVU5UIiwiT0ZGX01JUE1BUENPVU5UIiwiaGVhZGVyTGVuZ3RoSW50IiwibVNvdXJjZSIsImlzQ3ViZVRleHR1cmUiLCJoYXNNaXBtYXBzIiwibWlwbWFwQ291bnQiLCJMSU5FQVJfTUlQTUFQX0xJTkVBUiIsIm51bUxldmVscyIsImluZGV4IiwiaiIsInNoYXBlIiwiZGF0YSIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsInVuaWZvcm0xaSIsInVuaWZvcm1UZXh0dXJlcyIsIl9iaW5kSW5kZXgiLCJtQXJyYXlCdWZmZXIiLCJjbGFtcCIsIm1pbiIsIm1heCIsImRkc0luZm9zIiwiZmxhZ3MiLCJoZWFkZXIiLCJJbnQzMkFycmF5IiwiTWF0aCIsInNvdXJjZXMiLCJpbWFnZXMiLCJmYWNlRGF0YSIsIkZsb2F0MzJBcnJheSIsInNsaWNlIiwib2Zmc2V0IiwiaXNTYW1lIiwiYXJyYXkxIiwiYXJyYXkyIiwiYWRkTGluZU51bWJlcnMiLCJzdHJpbmciLCJsaW5lcyIsImpvaW4iLCJjbG9uZUFycmF5IiwibUFycmF5IiwidW5pZm9ybU1hcHBpbmciLCJmbG9hdCIsInZlYzIiLCJ2ZWMzIiwidmVjNCIsImludCIsIm1hdDMiLCJtYXQ0Iiwic3RyVmVydGV4U2hhZGVyIiwiZGVmYXVsdFZlcnRleFNoYWRlciIsInN0ckZyYWdtZW50U2hhZGVyIiwiZGVmYXVsdEZyYWdtZW50U2hhZGVyIiwibVZhcnlpbmdzIiwiX3ZhcnlpbmdzIiwidnNTaGFkZXIiLCJfY3JlYXRlU2hhZGVyUHJvZ3JhbSIsImZzU2hhZGVyIiwiX2F0dGFjaFNoYWRlclByb2dyYW0iLCJ1c2VQcm9ncmFtIiwic2hhZGVyUHJvZ3JhbSIsInVzZVNoYWRlciIsInVuaWZvcm0iLCJtTmFtZSIsIm1UeXBlIiwidW5pZm9ybU9iamVjdCIsInVuaWZvcm1UeXBlIiwiaGFzVW5pZm9ybSIsIm9Vbmlmb3JtIiwicGFyYW1ldGVySW5kZXgiLCJuYW1lIiwiaXNOdW1iZXIiLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ1bmlmb3JtTG9jIiwibmVlZFVwZGF0ZSIsIm1Vbmlmb3JtT2JqIiwidW5pZm9ybU5hbWUiLCJ1bmlmb3JtVmFsdWUiLCJnZXRVbmlmb3JtVHlwZSIsImNvbmNhdCIsInRtcCIsIm1TaGFkZXJTdHIiLCJpc1ZlcnRleFNoYWRlciIsInNoYWRlclR5cGUiLCJWRVJURVhfU0hBREVSIiwiRlJBR01FTlRfU0hBREVSIiwiY3JlYXRlU2hhZGVyIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwid2FybiIsImdldFNoYWRlckluZm9Mb2ciLCJtVmVydGV4U2hhZGVyIiwibUZyYWdtZW50U2hhZGVyIiwiY3JlYXRlUHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImRlbGV0ZVNoYWRlciIsInRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MiLCJTRVBBUkFURV9BVFRSSUJTIiwibGlua1Byb2dyYW0iLCJpc0FycmF5IiwiZ2V0QXJyYXlVbmlmb3JtVHlwZSIsImlzUG93ZXJPZlR3byIsIngiLCJpc1NvdXJjZVBvd2VyT2ZUd28iLCJvYmoiLCJ3IiwidmlkZW9XaWR0aCIsImgiLCJ2aWRlb0hlaWdodCIsImlzVGV4dHVyZSIsIl9tU291cmNlIiwiX2lzVmlkZW8iLCJ0YWdOYW1lIiwiX3ByZW11bHRpcGx5QWxwaGEiLCJfbWFnRmlsdGVyIiwiX21pbkZpbHRlciIsIk5FQVJFU1RfTUlQTUFQX0xJTkVBUiIsIl93cmFwUyIsIk1JUlJPUkVEX1JFUEVBVCIsIl93cmFwVCIsImV4cG9zdXJlIiwiTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUIiwidGV4UGFyYW1ldGVyZiIsIlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUIiwiX2NhbkdlbmVyYXRlTWlwbWFwIiwiTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCIsIlJFUEVBVCIsInByZW11bHRpcGx5QWxwaGEiLCJVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wiLCJ1cGRhdGVUZXh0dXJlIiwiTElORUFSX01JUE1BUF9ORUFSRVNUIiwiX3doaXRlVGV4dHVyZSIsIl9ncmV5VGV4dHVyZSIsIl9ibGFja1RleHR1cmUiLCJ3aGl0ZVRleHR1cmUiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJncmV5VGV4dHVyZSIsImJsYWNrVGV4dHVyZSIsIm1QYXJhbSIsIl9zb3VyY2UiLCJfZ2V0RGltZW5zaW9uIiwiX3NvdXJjZVR5cGUiLCJnZXRTb3VyY2VUeXBlIiwiX2NoZWNrU291cmNlIiwiX3RleGVsVHlwZSIsIl9nZXRUZXhlbFR5cGUiLCJfaXNUZXh0dXJlUmVhZHkiLCJfcGFyYW1zIiwiZ2V0VGV4dHVyZVBhcmFtZXRlcnMiLCJfd2lkdGgiLCJfaGVpZ2h0IiwiX2NoZWNrTWlwbWFwIiwiX2NoZWNrV3JhcHBpbmciLCJhZGRFRiIsIl9sb29wIiwiX3VwbG9hZFRleHR1cmUiLCJyZWFkeVN0YXRlIiwiX2lzU291cmNlSHRtbEVsZW1lbnQiLCJfZ2VuZXJhdGVNaXBtYXAiLCJ0ZXhlbFR5cGUiLCJzcXJ0IiwiVWludDhBcnJheSIsImlzVGV4dHVyZVJlYWR5IiwiQXJyYXkiLCJIVE1MSW1hZ2VFbGVtZW50IiwiSFRNTENhbnZhc0VsZW1lbnQiLCJIVE1MVmlkZW9FbGVtZW50IiwiX3ZpZXdwb3J0IiwiX2VuYWJsZWRWZXJ0ZXhBdHRyaWJ1dGUiLCJpZGVudGl0eU1hdHJpeCIsImNyZWF0ZSIsIl9ub3JtYWxNYXRyaXgiLCJfaW52ZXJzZU1vZGVsVmlld01hdHJpeCIsIl9tb2RlbE1hdHJpeCIsIl9tYXRyaXgiLCJfbWF0cml4U3RhY2tzIiwiX2xhc3RNZXNoIiwiX3VzZVdlYkdMMiIsIl9oYXNBcnJheUluc3RhbmNlIiwiX2V4dEFycmF5SW5zdGFuY2UiLCJfaGFzQ2hlY2tlZEV4dCIsImlkZW50aXR5IiwiaXNNb2JpbGUiLCJ0ZXN0IiwibUNhbnZhcyIsInNldFNpemUiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJ1c2VXZWJnbDIiLCJpbml0V2l0aEdMIiwiZXh0ZW5zaW9ucyIsIkV4dGVuc2lvbnNMaXN0IiwiZXhwb3NlQXR0cmlidXRlcyIsImdldEFuZEFwcGx5RXh0ZW5zaW9uIiwiZW5hYmxlIiwiREVQVEhfVEVTVCIsIkNVTExfRkFDRSIsIkJMRU5EIiwiZW5hYmxlQWxwaGFCbGVuZGluZyIsInNldFZpZXdwb3J0IiwieSIsImhhc0NoYW5nZWQiLCJzY2lzc29yIiwiY2xlYXJDb2xvciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwiY3VsbEZhY2UiLCJzZXRNYXRyaWNlcyIsIm1DYW1lcmEiLCJjYW1lcmEiLCJyb3RhdGUiLCJtUm90YXRpb24iLCJjb3B5IiwibXVsdGlwbHkiLCJtYXRyaXgiLCJmcm9tTWF0NCIsImludmVydCIsInRyYW5zcG9zZSIsIm1EcmF3aW5nVHlwZSIsInByb2plY3Rpb24iLCJkcmF3VHlwZSIsImlzSW5zdGFuY2VkIiwiZHJhd0VsZW1lbnRzSW5zdGFuY2VkIiwiaUJ1ZmZlciIsIm51bUl0ZW1zIiwibnVtSW5zdGFuY2UiLCJQT0lOVFMiLCJkcmF3QXJyYXlzIiwidmVydGV4U2l6ZSIsImRyYXdFbGVtZW50cyIsImRyYXdUcmFuc2Zvcm1GZWVkYmFjayIsIm1UcmFuc2Zvcm1PYmplY3QiLCJtZXNoU291cmNlIiwibWVzaERlc3RpbmF0aW9uIiwibnVtUG9pbnRzIiwidHJhbnNmb3JtRmVlZGJhY2siLCJnZW5lcmF0ZUJ1ZmZlcnMiLCJiaW5kVHJhbnNmb3JtRmVlZGJhY2siLCJUUkFOU0ZPUk1fRkVFREJBQ0siLCJhdHRyaWJ1dGVzIiwiYXR0ciIsImJpbmRCdWZmZXJCYXNlIiwiVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiIsImJ1ZmZlciIsIlJBU1RFUklaRVJfRElTQ0FSRCIsImJlZ2luVHJhbnNmb3JtRmVlZGJhY2siLCJlbmRUcmFuc2Zvcm1GZWVkYmFjayIsImRpc2FibGUiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiX2FzcGVjdFJhdGlvIiwic2hvd0V4dGVuc2lvbnMiLCJtRXh0ZW5zaW9uIiwiYmxlbmRGdW5jIiwiU1JDX0FMUEhBIiwiT05FX01JTlVTX1NSQ19BTFBIQSIsImVuYWJsZUFkZGl0aXZlQmxlbmRpbmciLCJPTkUiLCJwdXNoTWF0cml4IiwibXR4IiwiY2xvbmUiLCJwb3BNYXRyaXgiLCJwb3AiLCJtUGFyYW1ldGVyIiwiZ2V0RmxvYXQiLCJIQUxGX0ZMT0FUIiwiZ2V0SGFsZkZsb2F0IiwiYXNwZWN0UmF0aW8iLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJtZXNoVHJpIiwicGxhbmUiLCJudW1TZWdtZW50cyIsImF4aXMiLCJwb3NpdGlvbnMiLCJjb29yZHMiLCJpbmRpY2VzIiwibm9ybWFscyIsImdhcFgiLCJnYXBZIiwiZ2FwVVYiLCJzeCIsInN5IiwidHgiLCJ0eSIsInUiLCJ2IiwiYnVmZmVyVmVydGV4IiwiYnVmZmVyVGV4Q29vcmQiLCJidWZmZXJJbmRleCIsImJ1ZmZlck5vcm1hbCIsInNwaGVyZSIsImlzSW52ZXJ0IiwiZ2V0UG9zaXRpb24iLCJpc05vcm1hbCIsIlBJIiwicG9zIiwic2luIiwidCIsImNvcyIsInByZWNpc2lvbiIsImZsb29yIiwicmV2ZXJzZSIsImN1YmUiLCJkIiwieiIsImNvdW50Iiwic2t5Ym94IiwiYmlnVHJpYW5nbGUiLCJidWZmZXJEYXRhIiwiU1RBVElDX0RSQVciLCJnZXRCdWZmZXIiLCJjcmVhdGVCdWZmZXIiLCJmb3JtQnVmZmVyIiwibURhdGEiLCJtVXNlVmFvIiwiX2F0dHJpYnV0ZXMiLCJfbnVtSW5zdGFuY2UiLCJfaW5kaWNlcyIsIl9mYWNlcyIsIl9idWZmZXJDaGFuZ2VkIiwiX2hhc0luZGV4QnVmZmVyQ2hhbmdlZCIsIl9oYXNWQU8iLCJfaXNJbnN0YW5jZWQiLCJfZXh0VkFPIiwiY3JlYXRlVmVydGV4QXJyYXkiLCJfdXNlVkFPIiwibUFycmF5VmVydGljZXMiLCJtRHJhd1R5cGUiLCJ2ZXJ0aWNlcyIsIm1BcnJheVRleENvb3JkcyIsIm1Ob3JtYWxzIiwibUFycmF5SW5kaWNlcyIsImlzRHluYW1pYyIsIl9kcmF3VHlwZSIsIkRZTkFNSUNfRFJBVyIsIlVpbnQxNkFycmF5IiwiX251bUl0ZW1zIiwiYnVmZmVyRmxhdHRlbkRhdGEiLCJtSXRlbVNpemUiLCJkYXRhQXJyYXkiLCJhdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJpdGVtU2l6ZSIsInNvdXJjZSIsImJ1ZmZlckluc3RhbmNlIiwidmVydGV4QXR0cmliRGl2aXNvciIsIm1TaGFkZXJQcm9ncmFtIiwiaGFzVkFPIiwiYmluZFZlcnRleEFycmF5IiwidmFvIiwiYXR0clBvc2l0aW9uIiwidmVydGV4QXR0cmliUG9pbnRlciIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiX3ZhbyIsImF0dHJPYmoiLCJnZXRBdHRyaWJMb2MiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsIl91cGRhdGVJbmRleEJ1ZmZlciIsImNvbXB1dGVOb3JtYWxzIiwidXNpbmdGYWNlTm9ybWFscyIsImdlbmVyYXRlRmFjZXMiLCJfY29tcHV0ZUZhY2VOb3JtYWxzIiwiX2NvbXB1dGVWZXJ0ZXhOb3JtYWxzIiwiZmFjZUluZGV4IiwiZmFjZSIsIk4iLCJub3JtYWwiLCJzdW1Ob3JtYWwiLCJub3JtYWxpemUiLCJpYSIsImliIiwiaWMiLCJjIiwidmJhIiwidmNhIiwidk5vcm1hbCIsImdldFNvdXJjZSIsImZhY2VzIiwidXNlRGVwdGgiLCJ1c2VTdGVuY2lsIiwiX251bVNhbXBsZSIsIm51bVNhbXBsZSIsImZyYW1lQnVmZmVyQ29sb3IiLCJyZW5kZXJCdWZmZXJDb2xvciIsImNyZWF0ZVJlbmRlcmJ1ZmZlciIsInJlbmRlckJ1ZmZlckRlcHRoIiwicmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlIiwiUkdCQTgiLCJmcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciIsImZvcmNlTmVhcmVzdCIsIlJFQURfRlJBTUVCVUZGRVIiLCJjbGVhckJ1ZmZlcmZ2IiwiQ09MT1IiLCJibGl0RnJhbWVidWZmZXIiLCJfdnMiLCJfZnMiLCJfbWVzaEN1cnJlbnQiLCJfbWVzaFRhcmdldCIsIl9udW1Qb2ludHMiLCJjcmVhdGVUcmFuc2Zvcm1GZWVkYmFjayIsIm1WYXJ5aW5nTmFtZSIsImlzVHJhbnNmb3JtRmVlZGJhY2siLCJTVFJFQU1fQ09QWSIsImdlbmVyYXRlIiwicmVuZGVyIiwiX3N3YXAiLCJtZXNoQ3VycmVudCIsIm1lc2hUYXJnZXQiLCJfcXVhdCIsInF1YXQiLCJfb3JpZW50YXRpb24iLCJfcHJvamVjdGlvbiIsInBvc2l0aW9uIiwibG9va0F0IiwiYUV5ZSIsImFDZW50ZXIiLCJhVXAiLCJfZXllIiwiX2NlbnRlciIsInNldEZyb21PcmllbnRhdGlvbiIsImZyb21RdWF0IiwidHJhbnNsYXRlIiwic2V0UHJvamVjdGlvbiIsIm1Qcm9qIiwic2V0VmlldyIsIm1WaWV3Iiwic2V0RnJvbVZpZXdQcm9qIiwidmlld01hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJleWUiLCJDQU1FUkFfU0VUVElOR1MiLCJmcm9tVmFsdWVzIiwic2V0UGVyc3BlY3RpdmUiLCJ1cCIsIm9ydGhvIiwic2V0Qm91bmRhcnkiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJuZWFyIiwiZmFyIiwibUludmVyc2VWaWV3UHJvaiIsImNhbWVyYURpciIsIm1Gb3YiLCJtQXNwZWN0UmF0aW8iLCJtTmVhciIsIm1GYXIiLCJfZm92IiwiX25lYXIiLCJfZmFyIiwicGVyc3BlY3RpdmUiLCJzZXRBc3BlY3RSYXRpbyIsImdlbmVyYXRlUmF5IiwibVNjcmVlblBvc2l0aW9uIiwibVJheSIsInByb2oiLCJ2aWV3IiwidHJhbnNmb3JtTWF0NCIsInN1YiIsIm9yaWdpbiIsImRpcmVjdGlvbiIsImNvbG9ycyIsIkxJTkVTIiwidnMiLCJmcyIsInNjYWxlIiwiY29sb3IiLCJvcGFjaXR5IiwibVBvc2l0aW9uQSIsIm1Qb3NpdGlvbkIiLCJzZWciLCJfdW5pZm9ybXMiLCJfdW5pZm9ybVRleHR1cmVzIiwiX2ZibyIsIl9jbGVhckNvbG9yIiwic2V0Q2xlYXJDb2xvciIsInNldE1lc2giLCJjcmVhdGVNZXNoIiwibUFycmF5Tm9ybWFscyIsIm1JbmRpY2VzIiwibUFycmF5RGF0YSIsInVuaWZvcm1UZXh0dXJlIiwiYmluZEZyYW1lQnVmZmVyIiwiZnJhbWVidWZmZXIiLCJfY2hpbGRyZW4iLCJfbWF0cml4SWRlbnRpdHkiLCJfaW5pdFZpZXdzIiwiX2VmSW5kZXgiLCJfdGFyZ2V0TGlzdGVuZXIiLCJjb250YWluZXIiLCJyZXNpemUiLCJ1cGRhdGUiLCJzdG9wIiwicmVtb3ZlRUYiLCJzdGFydCIsImFkZENoaWxkIiwibUNoaWxkIiwic3BsaWNlIiwiX3JlbmRlckNoaWxkcmVuIiwiY2hpbGQiLCJ0b1JlbmRlciIsIm5vQ29udHJvbCIsImNvbm5lY3QiLCJjYW1lcmFPcnRobyIsImRpc2Nvbm5lY3QiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibVN0clZlcnRleCIsIm1TdHJGcmFnIiwiZGVsZXRlUHJvZ3JhbSIsImlzQXJyYXlCdWZmZXIiLCJfcmVxIiwiWE1MSHR0cFJlcXVlc3QiLCJfb25Mb2FkZWQiLCJfb25Qcm9ncmVzcyIsInJlc3BvbnNlVHlwZSIsImxvYWQiLCJjYWxsYmFjayIsIl9jYWxsYmFjayIsIm9wZW4iLCJzZW5kIiwicmVzcG9uc2UiLCJBUlJBWV9DVE9SX01BUCIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIlNJWkVfTUFQIiwiU0NBTEFSIiwiVkVDMiIsIlZFQzMiLCJWRUM0IiwiTUFUMiIsIk1BVDMiLCJNQVQ0Iiwic2VtYW50aWNBdHRyaWJ1dGVNYXAiLCJOT1JNQUwiLCJQT1NJVElPTiIsIlRFWENPT1JEXzAiLCJXRUlHSFRTXzAiLCJKT0lOVFNfMCIsImdsdGYiLCJiaW4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm91dHB1dCIsIm1lc2hlcyIsInNjZW5lcyIsIl9nZXRCdWZmZXJWaWV3RGF0YSIsInRoZW4iLCJfcGFyc2VNZXNoIiwiZ2x0ZkluZm8iLCJjYXRjaCIsImJ1ZmZlclZpZXdzIiwiYnVmZmVyVmlld0luZm8iLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImdlb21ldHJpZXMiLCJwcmltaXRpdmVzIiwiZ2VvbWV0cnkiLCJwcmltaXRpdmVJbmZvIiwic2VtYW50aWNzIiwia2V5cyIsImRlZmluZXMiLCJzZW1hbnRpYyIsImFjY2Vzc29ySWR4IiwiYXR0cmlidXRlSW5mbyIsImFjY2Vzc29ycyIsImF0dHJpYnV0ZU5hbWUiLCJIQVNfTk9STUFMUyIsIkhBU19VViIsImF0dHJpYnV0ZUFycmF5IiwiX2dldEFjY2Vzc29yRGF0YSIsIm0iLCJtYXRlcmlhbCIsIm1hdGVyaWFscyIsIm9iamVjdEFzc2lnbiIsIlNoYWRlcnMiLCJnbHRmVmVydCIsImdsdGZGcmFnIiwiZW1pc3NpdmVGYWNvdHIiLCJub3JtYWxUZXh0dXJlIiwib2NjbHVzaW9uVGV4dHVyZSIsInBick1ldGFsbGljUm91Z2huZXNzIiwiYmFzZUNvbG9yVGV4dHVyZSIsIm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSIsInVuaWZvcm1zIiwidUVtaXNzaXZlRmFjdG9yIiwidUJhc2VDb2xvciIsImJhc2VDb2xvckZhY3RvciIsInVSb3VnaG5lc3MiLCJyb3VnaG5lc3NGYWN0b3IiLCJ1TWV0YWxsaWMiLCJtZXRhbGxpY0ZhY3RvciIsInVTY2FsZURpZmZCYXNlTVIiLCJ1U2NhbGVGR0RTcGVjIiwidVNjYWxlSUJMQW1iaWVudCIsInVMaWdodERpcmVjdGlvbiIsInVMaWdodENvbG9yIiwidUdhbW1hIiwidUNvbG9yTWFwIiwidU1ldGFsbGljUm91Z2huZXNzTWFwIiwidU5vcm1hbFNjYWxlIiwidU5vcm1hbE1hcCIsInVBb01hcCIsInVPY2NsdXNpb25TdHJlbmd0aCIsInN0cmVuZ3RoIiwiaXNJbmRpY2VzIiwiYWNjZXNzb3JJbmZvIiwiYnVmZmVyVmlldyIsIkFycmF5Q3RvciIsImNvbXBvbmVudFR5cGUiLCJhcnIiLCJxdWFudGl6ZUV4dGVuc2lvbiIsImRlY29kZWRBcnIiLCJkZWNvZGVNYXRyaXgiLCJkZWNvZGVPZmZzZXQiLCJkZWNvZGVTY2FsZSIsImsiLCJoZHJQYXJzZXIiLCJwYXJzZU9iaiIsIm9ialN0ciIsImZpbmFsTm9ybWFscyIsInV2cyIsInZlcnRleFBhdHRlcm4iLCJub3JtYWxQYXR0ZXJuIiwidXZQYXR0ZXJuIiwiZmFjZVBhdHRlcm4xIiwiZmFjZVBhdHRlcm4yIiwiZmFjZVBhdHRlcm4zIiwiZmFjZVBhdHRlcm40IiwicGFyc2VWZXJ0ZXhJbmRleCIsInBhcnNlSW50IiwicGFyc2VOb3JtYWxJbmRleCIsInBhcnNlVVZJbmRleCIsImFkZFZlcnRleCIsImFkZFVWIiwiYWRkTm9ybWFsIiwiYWRkRmFjZSIsInVhIiwidWIiLCJ1YyIsInVkIiwibmEiLCJuYiIsIm5jIiwibmQiLCJsaW5lIiwidHJpbSIsImNoYXJBdCIsImV4ZWMiLCJwYXJzZUZsb2F0IiwiX2dlbmVyYXRlTWVzaGVzIiwibWF4TnVtVmVydGljZXMiLCJoYXNOb3JtYWxzIiwiaGFzVVZzIiwibGFzdEluZGV4Iiwib0NvcHkiLCJzbGljZU51bSIsInRtcEluZGV4IiwibG9hZGVyIiwidGFyZ2V0IiwiZWRnZTEiLCJlZGdlMiIsImRpZmYiLCJtT3JpZ2luIiwibURpcmVjdGlvbiIsImF0IiwibVRhcmdldCIsImNsb3Nlc3RQb2ludFRvUG9pbnQiLCJtUG9pbnQiLCJkaXJlY3Rpb25EaXN0YW5jZSIsImRvdCIsImRpc3RhbmNlVG9Qb2ludCIsImRpc3RhbmNlU3FUb1BvaW50IiwidjEiLCJzcXVhcmVkRGlzdGFuY2UiLCJpbnRlcnNlY3RzU3BoZXJlIiwibUNlbnRlciIsIm1SYWRpdXMiLCJpbnRlcnNlY3RTcGhlcmUiLCJ0Y2EiLCJkMiIsInJhZGl1czIiLCJ0aGMiLCJ0MCIsInQxIiwiZGlzdGFuY2VUb1BsYW5lIiwibVBsYW5lQ2VudGVyIiwibU5vcm1hbCIsImRlbm9taW5hdG9yIiwiaW50ZXJzZWN0VHJpYW5nbGUiLCJtUEEiLCJtUEIiLCJtUEMiLCJiYWNrZmFjZUN1bGxpbmciLCJjcm9zcyIsIkRkTiIsInNpZ24iLCJEZFF4RTIiLCJEZEUxeFEiLCJRZG4iLCJfbmVlZFVwZGF0ZSIsIl94IiwiX3kiLCJfeiIsIl9zeCIsIl9zeSIsIl9zeiIsIl9yeCIsIl9yeSIsIl9yeiIsIl9wb3NpdGlvbiIsIl9zY2FsZSIsIl9yb3RhdGlvbiIsIl9tYXRyaXhQYXJlbnQiLCJfbWF0cml4Um90YXRpb24iLCJfbWF0cml4U2NhbGUiLCJfbWF0cml4VHJhbnNsYXRpb24iLCJfbWF0cml4UXVhdGVybmlvbiIsIl91cGRhdGUiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJtdWwiLCJ1cGRhdGVNYXRyaXgiLCJtUGFyZW50TWF0cml4Iiwic2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbiIsIm1RdWF0IiwibmV4dCIsInNjYWxlWCIsInNjYWxlWSIsInNjYWxlWiIsInJvdGF0aW9uWCIsInJvdGF0aW9uWSIsInJvdGF0aW9uWiIsImNoaWxkcmVuIiwibUVhc2luZyIsImVhc2luZyIsIl90YXJnZXRWYWx1ZSIsIk1JTl9ESUZGIiwiX2NoZWNrTGltaXQiLCJhYnMiLCJtQWRkIiwibGltaXQiLCJtTWluIiwibU1heCIsIl9taW4iLCJfbWF4IiwidGFyZ2V0VmFsdWUiLCJzdXBwb3J0c0N1c3RvbUV2ZW50cyIsIm5ld1Rlc3RDdXN0b21FdmVudCIsImNyZWF0ZUV2ZW50IiwiX2V2ZW50TGlzdGVuZXJzIiwiYUV2ZW50VHlwZSIsImFGdW5jdGlvbiIsIm9uIiwiY3VycmVudEFycmF5IiwiY3VycmVudEFycmF5TGVuZ3RoIiwib2ZmIiwiZGlzcGF0Y2hFdmVudCIsImFFdmVudCIsImV2ZW50VHlwZSIsImN1cnJlbnRUYXJnZXQiLCJ0aGVFcnJvciIsIm5ld0V2ZW50IiwiZGV0YWlsIiwiZGlzcGF0Y2hlciIsImN1cnJlbnRFdmVudExpc3RlbmVycyIsIl9jb3B5QXJyYXkiLCJjdXJyZW50RnVuY3Rpb24iLCJjYWxsIiwiZGlzcGF0Y2hDdXN0b21FdmVudCIsImFEZXRhaWwiLCJpbml0Q3VzdG9tRXZlbnQiLCJ0cmlnZ2VyIiwiX2Rlc3Ryb3kiLCJvYmplY3ROYW1lIiwiaGFzT3duUHJvcGVydHkiLCJhQXJyYXkiLCJyYWRpYW5jZVBhdHRlcm4iLCJjb21tZW50UGF0dGVybiIsImV4cG9zdXJlUGF0dGVybiIsImZvcm1hdFBhdHRlcm4iLCJ3aWR0aEhlaWdodFBhdHRlcm4iLCJyZWFkUGl4ZWxzUmF3UkxFIiwiZmlsZU9mZnNldCIsInNjYW5saW5lV2lkdGgiLCJudW1TY2FubGluZXMiLCJyZ2JlIiwic2NhbmxpbmVCdWZmZXIiLCJwdHIiLCJwdHJFbmQiLCJidWYiLCJidWZmZXJMZW5ndGgiLCJyZWFkQnVmIiwiYnl0ZXNSZWFkIiwicmVhZEJ1Zk9mZnNldCIsInJlYWRQaXhlbHNSYXciLCJudW1waXhlbHMiLCJudW1FeHBlY3RlZCIsIm51bVJlYWQiLCJFcnJvciIsInBhcnNlSGRyIiwiQXJyYXlCdWZmZXIiLCJORVdfTElORSIsInJlYWRMaW5lIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZ2FtbWEiLCJybGUiLCJtYXRjaCIsIk51bWJlciIsImZsb2F0RGF0YSIsImYiLCJwb3ciLCJmbG9hdE9mZnNldCIsImdldE1vdXNlIiwibUV2ZW50IiwidG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJjbGllbnRYIiwiY2xpZW50WSIsIm1MaXN0ZW5lclRhcmdldCIsIl90YXJnZXQiLCJfbGlzdGVuZXJUYXJnZXQiLCJfbW91c2UiLCJfcHJlTW91c2UiLCJfdXAiLCJfcHJlUlgiLCJfcHJlUlkiLCJfaXNMb2NrWm9vbSIsIl9pc0xvY2tSb3RhdGlvbiIsIl9pc0ludmVydCIsInNlbnNpdGl2aXR5IiwiX3doZWVsQmluZCIsIl9vbldoZWVsIiwiX2Rvd25CaW5kIiwiX29uRG93biIsIl9tb3ZlQmluZCIsIl9vbk1vdmUiLCJfdXBCaW5kIiwiX29uVXAiLCJsb2NrIiwiX2lzTW91c2VEb3duIiwibG9ja1pvb20iLCJsb2NrUm90YXRpb24iLCJpbnZlcnNlQ29udHJvbCIsImRpZmZYIiwiZGlmZlkiLCJ3aGVlbERlbHRhIiwiX3VwZGF0ZVBvc2l0aW9uIiwiX3VwZGF0ZUNhbWVyYSIsInRyIiwiX3ZaYXhpcyIsIl96QXhpcyIsInByZU1vdXNlIiwibW91c2UiLCJ0ZW1wUm90YXRpb24iLCJfcm90YXRlWk1hcmdpbiIsIl9vZmZzZXQiLCJfc2xlcnAiLCJfaXNMb2NrZWQiLCJfZGlmZlgiLCJfZGlmZlkiLCJzZXRDYW1lcmFQb3MiLCJzcGVlZCIsIl91cGRhdGVSb3RhdGlvbiIsIl9jdXJyRGlmZlgiLCJfY3VyckRpZmZZIiwiX2lzUm90YXRlWiIsIl90YXJnZXRRdWF0IiwicmVzZXRRdWF0IiwibVRlbXBSb3RhdGlvbiIsImFuZ2xlIiwic2xlcnAiLCJ0cmFuc2Zvcm1RdWF0Iiwic2ltcGxlQ29sb3JGcmFnIiwiYmlnVHJpYW5nbGVWZXJ0IiwiZ2VuZXJhbFZlcnQiLCJjb3B5RnJhZyIsImJhc2ljVmVydCIsInNreWJveFZlcnQiLCJza3lib3hGcmFnIiwibVNwZWVkIiwibURlY3JlYXNlUmF0ZSIsImRlY3JlYXNlUmF0ZSIsIl92ZWxvY2l0eSIsImRpc3RhbmNlIiwiZHgiLCJkeSIsIlRvdWNoRGV0ZWN0b3IiLCJtU2tpcE1vdmVDaGVjayIsIl9jYW1lcmEiLCJmYWNlVmVydGljZXMiLCJjbGlja1RvbGVyYW5jZSIsIl9yYXkiLCJfaGl0IiwiX2xhc3RQb3MiLCJfZmlyc3RQb3MiLCJtdHhNb2RlbCIsIl9za2lwcGluZ01vdmUiLCJfb25Nb3ZlQmluZCIsIl9vbkRvd25CaW5kIiwiX29uVXBCaW5kIiwiX2NoZWNrSGl0IiwibXgiLCJteSIsImhpdCIsInYwIiwidjIiLCJkaXN0IiwiZ2V0VmVjdG9yIiwiZGlzdFRvQ2FtIiwiRWFzaW5nIiwiTGluZWFyIiwiTm9uZSIsIlF1YWRyYXRpYyIsIkluIiwiT3V0IiwiSW5PdXQiLCJDdWJpYyIsIlF1YXJ0aWMiLCJRdWludGljIiwiU2ludXNvaWRhbCIsIkV4cG9uZW50aWFsIiwiQ2lyY3VsYXIiLCJFbGFzdGljIiwicCIsImFzaW4iLCJCYWNrIiwiQm91bmNlIiwiaW4iLCJvdXQiLCJpbk91dCIsImdldEZ1bmMiLCJfc3RhcnRWYWx1ZSIsIl9jb3VudGVyIiwibmV3Q291bnRlciIsIm1vZHVsZSIsImV4cG9ydHMiLCJBQ1RJVkVfQVRUUklCVVRFUyIsIkFDVElWRV9BVFRSSUJVVEVfTUFYX0xFTkdUSCIsIkFDVElWRV9URVhUVVJFIiwiQUNUSVZFX1VOSUZPUk1TIiwiQUNUSVZFX1VOSUZPUk1fTUFYX0xFTkdUSCIsIkFMSUFTRURfTElORV9XSURUSF9SQU5HRSIsIkFMSUFTRURfUE9JTlRfU0laRV9SQU5HRSIsIkFMUEhBIiwiQUxQSEFfQklUUyIsIkFMV0FZUyIsIkFSUkFZX0JVRkZFUl9CSU5ESU5HIiwiQVRUQUNIRURfU0hBREVSUyIsIkJBQ0siLCJCTEVORF9DT0xPUiIsIkJMRU5EX0RTVF9BTFBIQSIsIkJMRU5EX0RTVF9SR0IiLCJCTEVORF9FUVVBVElPTiIsIkJMRU5EX0VRVUFUSU9OX0FMUEhBIiwiQkxFTkRfRVFVQVRJT05fUkdCIiwiQkxFTkRfU1JDX0FMUEhBIiwiQkxFTkRfU1JDX1JHQiIsIkJMVUVfQklUUyIsIkJPT0wiLCJCT09MX1ZFQzIiLCJCT09MX1ZFQzMiLCJCT09MX1ZFQzQiLCJCUk9XU0VSX0RFRkFVTFRfV0VCR0wiLCJCVUZGRVJfU0laRSIsIkJVRkZFUl9VU0FHRSIsIkJZVEUiLCJDQ1ciLCJDT0xPUl9DTEVBUl9WQUxVRSIsIkNPTE9SX1dSSVRFTUFTSyIsIkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTIiwiQ09OU1RBTlRfQUxQSEEiLCJDT05TVEFOVF9DT0xPUiIsIkNPTlRFWFRfTE9TVF9XRUJHTCIsIkNVTExfRkFDRV9NT0RFIiwiQ1VSUkVOVF9QUk9HUkFNIiwiQ1VSUkVOVF9WRVJURVhfQVRUUklCIiwiQ1ciLCJERUNSIiwiREVDUl9XUkFQIiwiREVMRVRFX1NUQVRVUyIsIkRFUFRIX0JJVFMiLCJERVBUSF9DTEVBUl9WQUxVRSIsIlJFRCIsIkRFUFRIX0ZVTkMiLCJERVBUSF9SQU5HRSIsIkRFUFRIX1NURU5DSUwiLCJERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQiLCJERVBUSF9XUklURU1BU0siLCJESVRIRVIiLCJET05UX0NBUkUiLCJEU1RfQUxQSEEiLCJEU1RfQ09MT1IiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HIiwiRVFVQUwiLCJGQVNURVNUIiwiRkxPQVRfTUFUMiIsIkZMT0FUX01BVDMiLCJGTE9BVF9NQVQ0IiwiRkxPQVRfVkVDMiIsIkZMT0FUX1ZFQzMiLCJGTE9BVF9WRUM0IiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX1RZUEUiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfQ1VCRV9NQVBfRkFDRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MRVZFTCIsIkZSQU1FQlVGRkVSX0JJTkRJTkciLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCIsIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEIiwiRlJPTlQiLCJGUk9OVF9BTkRfQkFDSyIsIkZST05UX0ZBQ0UiLCJGVU5DX0FERCIsIkZVTkNfUkVWRVJTRV9TVUJUUkFDVCIsIkZVTkNfU1VCVFJBQ1QiLCJHRU5FUkFURV9NSVBNQVBfSElOVCIsIkdFUVVBTCIsIkdSRUFURVIiLCJHUkVFTl9CSVRTIiwiSElHSF9GTE9BVCIsIkhJR0hfSU5UIiwiSU5DUiIsIklOQ1JfV1JBUCIsIklORk9fTE9HX0xFTkdUSCIsIklOVCIsIklOVF9WRUMyIiwiSU5UX1ZFQzMiLCJJTlRfVkVDNCIsIklOVkFMSURfRU5VTSIsIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OIiwiSU5WQUxJRF9PUEVSQVRJT04iLCJJTlZBTElEX1ZBTFVFIiwiSU5WRVJUIiwiS0VFUCIsIkxFUVVBTCIsIkxFU1MiLCJMSU5FX0xPT1AiLCJMSU5FX1NUUklQIiwiTElORV9XSURUSCIsIkxJTktfU1RBVFVTIiwiTE9XX0ZMT0FUIiwiTE9XX0lOVCIsIkxVTUlOQU5DRSIsIkxVTUlOQU5DRV9BTFBIQSIsIk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTIiwiTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSIsIk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMiLCJNQVhfUkVOREVSQlVGRkVSX1NJWkUiLCJNQVhfVEVYVFVSRV9JTUFHRV9VTklUUyIsIk1BWF9URVhUVVJFX1NJWkUiLCJNQVhfVkFSWUlOR19WRUNUT1JTIiwiTUFYX1ZFUlRFWF9BVFRSSUJTIiwiTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTIiwiTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMiLCJNQVhfVklFV1BPUlRfRElNUyIsIk1FRElVTV9GTE9BVCIsIk1FRElVTV9JTlQiLCJORVZFUiIsIk5JQ0VTVCIsIk5PTkUiLCJOT1RFUVVBTCIsIk5PX0VSUk9SIiwiTlVNX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTIiwiT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBIiwiT05FX01JTlVTX0NPTlNUQU5UX0NPTE9SIiwiT05FX01JTlVTX0RTVF9BTFBIQSIsIk9ORV9NSU5VU19EU1RfQ09MT1IiLCJPTkVfTUlOVVNfU1JDX0NPTE9SIiwiT1VUX09GX01FTU9SWSIsIlBBQ0tfQUxJR05NRU5UIiwiUE9MWUdPTl9PRkZTRVRfRkFDVE9SIiwiUE9MWUdPTl9PRkZTRVRfRklMTCIsIlBPTFlHT05fT0ZGU0VUX1VOSVRTIiwiUkVEX0JJVFMiLCJSRU5ERVJCVUZGRVJfQUxQSEFfU0laRSIsIlJFTkRFUkJVRkZFUl9CSU5ESU5HIiwiUkVOREVSQlVGRkVSX0JMVUVfU0laRSIsIlJFTkRFUkJVRkZFUl9ERVBUSF9TSVpFIiwiUkVOREVSQlVGRkVSX0dSRUVOX1NJWkUiLCJSRU5ERVJCVUZGRVJfSEVJR0hUIiwiUkVOREVSQlVGRkVSX0lOVEVSTkFMX0ZPUk1BVCIsIlJFTkRFUkJVRkZFUl9SRURfU0laRSIsIlJFTkRFUkJVRkZFUl9TVEVOQ0lMX1NJWkUiLCJSRU5ERVJCVUZGRVJfV0lEVEgiLCJSRU5ERVJFUiIsIlJFUExBQ0UiLCJSR0IiLCJSR0I1X0ExIiwiUkdCNTY1IiwiUkdCQTQiLCJTQU1QTEVSXzJEIiwiU0FNUExFUl9DVUJFIiwiU0FNUExFUyIsIlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSIsIlNBTVBMRV9CVUZGRVJTIiwiU0FNUExFX0NPVkVSQUdFIiwiU0FNUExFX0NPVkVSQUdFX0lOVkVSVCIsIlNBTVBMRV9DT1ZFUkFHRV9WQUxVRSIsIlNDSVNTT1JfQk9YIiwiU0NJU1NPUl9URVNUIiwiU0hBREVSX0NPTVBJTEVSIiwiU0hBREVSX1NPVVJDRV9MRU5HVEgiLCJTSEFERVJfVFlQRSIsIlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTiIsIlNIT1JUIiwiU1JDX0FMUEhBX1NBVFVSQVRFIiwiU1JDX0NPTE9SIiwiU1RFTkNJTF9BVFRBQ0hNRU5UIiwiU1RFTkNJTF9CQUNLX0ZBSUwiLCJTVEVOQ0lMX0JBQ0tfRlVOQyIsIlNURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUwiLCJTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9QQVNTIiwiU1RFTkNJTF9CQUNLX1JFRiIsIlNURU5DSUxfQkFDS19WQUxVRV9NQVNLIiwiU1RFTkNJTF9CQUNLX1dSSVRFTUFTSyIsIlNURU5DSUxfQklUUyIsIlNURU5DSUxfQlVGRkVSX0JJVCIsIlNURU5DSUxfQ0xFQVJfVkFMVUUiLCJTVEVOQ0lMX0ZBSUwiLCJTVEVOQ0lMX0ZVTkMiLCJTVEVOQ0lMX0lOREVYIiwiU1RFTkNJTF9JTkRFWDgiLCJTVEVOQ0lMX1BBU1NfREVQVEhfRkFJTCIsIlNURU5DSUxfUEFTU19ERVBUSF9QQVNTIiwiU1RFTkNJTF9SRUYiLCJTVEVOQ0lMX1RFU1QiLCJTVEVOQ0lMX1ZBTFVFX01BU0siLCJTVEVOQ0lMX1dSSVRFTUFTSyIsIlNUUkVBTV9EUkFXIiwiU1VCUElYRUxfQklUUyIsIlRFWFRVUkUiLCJURVhUVVJFMSIsIlRFWFRVUkUyIiwiVEVYVFVSRTMiLCJURVhUVVJFNCIsIlRFWFRVUkU1IiwiVEVYVFVSRTYiLCJURVhUVVJFNyIsIlRFWFRVUkU4IiwiVEVYVFVSRTkiLCJURVhUVVJFMTAiLCJURVhUVVJFMTEiLCJURVhUVVJFMTIiLCJURVhUVVJFMTMiLCJURVhUVVJFMTQiLCJURVhUVVJFMTUiLCJURVhUVVJFMTYiLCJURVhUVVJFMTciLCJURVhUVVJFMTgiLCJURVhUVVJFMTkiLCJURVhUVVJFMjAiLCJURVhUVVJFMjEiLCJURVhUVVJFMjIiLCJURVhUVVJFMjMiLCJURVhUVVJFMjQiLCJURVhUVVJFMjUiLCJURVhUVVJFMjYiLCJURVhUVVJFMjciLCJURVhUVVJFMjgiLCJURVhUVVJFMjkiLCJURVhUVVJFMzAiLCJURVhUVVJFMzEiLCJURVhUVVJFX0JJTkRJTkdfMkQiLCJURVhUVVJFX0JJTkRJTkdfQ1VCRV9NQVAiLCJUUklBTkdMRVMiLCJUUklBTkdMRV9GQU4iLCJUUklBTkdMRV9TVFJJUCIsIlVOUEFDS19BTElHTk1FTlQiLCJVTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMIiwiVU5TSUdORURfSU5UIiwiVU5TSUdORURfU0hPUlRfNF80XzRfNCIsIlVOU0lHTkVEX1NIT1JUXzVfNV81XzEiLCJVTlNJR05FRF9TSE9SVF81XzZfNSIsIlZBTElEQVRFX1NUQVRVUyIsIlZFTkRPUiIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfQlVGRkVSX0JJTkRJTkciLCJWRVJURVhfQVRUUklCX0FSUkFZX0VOQUJMRUQiLCJWRVJURVhfQVRUUklCX0FSUkFZX05PUk1BTElaRUQiLCJWRVJURVhfQVRUUklCX0FSUkFZX1BPSU5URVIiLCJWRVJURVhfQVRUUklCX0FSUkFZX1NJWkUiLCJWRVJURVhfQVRUUklCX0FSUkFZX1NUUklERSIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRSIsIlZJRVdQT1JUIiwiWkVSTyIsIlI4IiwiV2ViZ2xDb25zdCIsInN1ZmZpeCIsInN1ZmZpeFJFIiwiUmVnRXhwIiwia2V5IiwidmFsIiwidW5zdWZmaXhlZEtleSIsInJlcGxhY2UiLCJzdWJzdHJpbmciLCJjYWNoZUF0dHJpYkxvYyIsImdldEF0dHJpYkxvY2F0aW9uIiwiaGFzQ2hlY2tlZCIsIl9mbG9hdCIsImNoZWNrRmxvYXQiLCJleHRGbG9hdCIsImhhbGZGbG9hdCIsImNoZWNrSGFsZkZsb2F0IiwiZXh0SGFsZkZsb2F0IiwiSEFMRl9GTE9BVF9PRVMiLCJtUGFyYW1zIiwibGV2ZWwiLCJ0ZW1wVmVjMyIsIkNhbWVyYVNwb3RzIiwic2NlbmUiLCJzcG90cyIsInNoYWRlckxpbmUiLCJ2c0xpbmUiLCJmc0xpbmUiLCJvblNwb3RDbGlja2VkIiwiU2lnbmFsIiwiYWN0aXZlIiwic2hvd24iLCJhZGRTcG90cyIsInNob3ciLCJoaWRlIiwicG9zT2Zmc2V0IiwiY3VycmVudFNwb3QiLCJ6b29tIiwiZ2V0RGlzdE9wdGltM0QiLCJ0ZXh0IiwiYWRkU3BvdFRleHQiLCJMaW5lIiwiY2xhc3NOYW1lIiwib25jbGljayIsImRpc3BhdGNoIiwiaW5uZXJIVE1MIiwibGFiZWwiLCJjb250YWluZXJIVE1MIiwiYXBwZW5kQ2hpbGQiLCJnZXRYWSIsInNjcmVlbldpZHRoIiwic2NyZWVuSGVpZ2h0Iiwic3BvdCIsInN0eWxlIiwiZGlzcGxheSIsInJlcyIsImdldDJkUG9zIiwiY29sb3JTcG90IiwiQ29uZmlnIiwiYW5ub3RhdGlvbnMiLCJhbHBoYSIsIm1ldGFsbGljIiwicm90IiwiZWRpdG9yIiwicG9pbnRzIiwiaG9tZSIsImNhbWVyYU1vdmVtZW50IiwiZGVidWdTaGFkb3ciLCJjYW1lcmFMaWdodFBvc2l0aW9uIiwic2hhZG93TWFwU2l6ZSIsInNoYWRvdyIsInNwcmVhZCIsInF1ZXJ5U3RyaW5nIiwicmVxdWlyZSIsImVuYWJsZWQiLCJyZWxvYWQiLCJsb2NhdGlvbiIsImhyZWYiLCJwYXRobmFtZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZWZyZXNoIiwiaGlzdG9yeSIsInB1c2hTdGF0ZSIsImRlbGF5SW5kZXgiLCJkZWxheVJlbG9hZCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJtRW5hYmxlZCIsInBhcnNlZCIsInNlYXJjaCIsInBhcnNlZEpzb24iLCJxdWVyeSIsImNvbmZpZyIsIlNoYWRvd01hbmFnZXIiLCJzaGFkb3dNYXRyaXgiLCJjYW1lcmFMaWdodFRhcmdldCIsImNhbWVyYUxpZ2h0IiwidXBkYXRlTGlnaHRDYW1lcmEiLCJvU2V0dGluZ3MiLCJiaWFzTWF0cml4IiwicmVjYWxjdWxhdGVTaGFkb3ciLCJkZXB0aEZ1bmMiLCJyZW5kZXJTaGFkb3ciLCJOT09QIiwiU3RhdGVzTWFuYWdlciIsInN0YXRlcyIsImN1cnJlbnRTdGF0ZUlkIiwidHJhbnNpdGlvbk1hcCIsImVuZCIsImJlZ2luIiwiYWRkVHJhbnNpdGlvbiIsImlkMSIsImlkMiIsImJvdGh3YXlzIiwic3RhdGUiLCJlbXB0eSIsIlRvdWNoQ29udHJvbGxlciIsIm1vdXNlRG93biIsInJheSIsIm9uTW92ZUNhbGxiYWNrIiwib25DbGlja0NhbGxiYWNrIiwib25VcENhbGxiYWNrIiwib25Eb3duIiwib25Nb3ZlIiwib25VcCIsInBhdXNlIiwibWV0aG9kIiwic2V0Q2FsbGJhY2tzIiwiY2JzIiwic2V0VGFyZ2V0cyIsImRvd24iLCJnZXREaXN0T3B0aW0iLCJpbnRlcnNlY3Rpb25SYXlNZXNoIiwiVmlld2VyQXBwIiwicXVlcnlTZWxlY3RvciIsImFkZFVJIiwicG9zaXRpb25EZWJ1ZyIsInBvc2l0aW9uQ2VudGVyRGVidWciLCJzdGF0ZU1hbmFnZXIiLCJTdGF0ZUhvbWUiLCJTdGF0ZU9yYml0IiwiU3RhdGVBbm5vdGF0ZSIsIk9yYml0YWxDb250cm9sVHdlZW4iLCJ0b3VjaENvbnRyb2xsZXIiLCJjYW1lcmFTcG90cyIsImRhdGFDYW1lcmFQb2ludHMiLCJvblRvdWNoQ29udHJvbGxlck1vdmUiLCJzbmFwIiwiYW5ub3RhdGUiLCJwcmV2aW91c1N0YXRlIiwic3R1ZGlvUmFkaWFuY2UiLCJpcnIiLCJhb21hcCIsImNvbG9ybWFwIiwicm91Z2huZXNzbWFwIiwic2hhZG93TWFuYWdlciIsIl9iQ29weSIsIl9iQXhpcyIsIl9iRG90cyIsIl9iQmFsbCIsIl9iQmFsbE9yYkNlbnRlciIsIl9iQmFsbENlbnRlciIsIl9iU2t5Iiwic2t5bWFwIiwiX3ZNb2RlbCIsIlZpZXdPYmpNb2RlbCIsIl92Rmxvb3IiLCJWaWV3Rmxvb3IiLCJfdkFubm90YXRpb24iLCJWaWV3QW5ub3RhdGlvbiIsIm9sZFJhZGl1cyIsImlzRG93biIsInVwZGF0ZUJhbGxDZW50ZXIiLCJ1cGRhdGVCYWxsUG9zIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJib2R5IiwicHJlbG9hZCIsImluaXQzRCIsImxvZ0Vycm9yIiwicHJvY2VzcyIsIlNldHRpbmdzIiwiYWRkQ29udHJvbHMiLCJ0ZW1wTWF0NCIsIlBvaW50c0VkaXRvciIsIm5iUG9pbnRzIiwib25Qb2ludENsaWNrIiwib25Qb2ludERlbGV0ZSIsImN1cnJlbnRQb3MiLCJhZGRQb2ludHNUb0RPTSIsImV2ZW50Iiwia2V5Q29kZSIsImRpclgiLCJkaXJaIiwiYXRhbjIiLCJ2aWV3cyIsImNsb3Nlc3RIaXQiLCJwcmV2aW91c0Rpc3QiLCJkZWJ1Z1NoYXBlcyIsInBvaW50IiwiYWRkUG9pbnQiLCJkaXYiLCJpbm5lclRleHQiLCJwMiIsImRlYnVnQ29sb3IiLCJkZWJ1Z1RhcmdldCIsImFkZENvbG9yIiwib25DaGFuZ2UiLCJjaGVja0NvbG9yIiwib0NvbG9yIiwiaGV4UmdiIiwicmVkIiwiZ3JlZW4iLCJibHVlIiwib0NvbnRyb2wiLCJzYXZlIiwic2F2ZUpzb24iLCJlZGl0b3JPIiwicmVzZXRDZW50ZXIiLCJzYXZlUG9pbnRzIiwicHJvbXB0IiwiZkVkaXRvciIsImFkZEZvbGRlciIsImZEZWJ1ZyIsInN0ZXAiLCJ0b2dnbGVPcmJpdGFsIiwicHQiLCJpbmRleFB0Iiwib0NhbWVyYUxpZ2h0UG9zaXRpb24iLCJmQ2FtTGlnaHQiLCJyYW5nZSIsImZVSU8iLCJmTW9kZWwiLCJuYXYiLCJwMSIsImdldEN1YmUiLCJkZXB0aCIsImdldEdlb21ldHJ5RmFjZXMiLCJwaXZvdFgiLCJwaXZvdFkiLCJ0ZW1wQXJyYXkxIiwidGVtcEFycmF5MiIsImRyYXdNb2RlIiwid2lkdGhDYWxsYmFjayIsInZlcnQiLCJkaXJlY3Rpb25zIiwiaW5kaWNlc0FycmF5IiwiY291bnRlcnMiLCJwcmV2aW91cyIsIm5lZWRzVXBkYXRlIiwiaW5kZXhDIiwiY29tcGFyZVYzIiwiYWEiLCJhYiIsImNvcHlWMyIsImwiLCJpbmRleE4iLCJuIiwiU3RhdGVEZWZhdWx0IiwidGljayIsIm1vZGVsIiwicmVhZHkiLCJyZW1vdmVMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lcnMiLCJkZWx0YVRpbWUiLCJlbGVtZW50IiwiY2xvc2VJY29uIiwib2Zmc2V0V2lkdGgiLCJwb3MyZCIsInNldFBvc2l0aW9uIiwic2hhZG93Q29sb3IiLCJ0ZXh0dXJlRGVwdGgiLCJjb2xvclNoYWRvdyIsImRlZmluZXNUb1N0cmluZyIsIm91dFN0ciIsImRlZiIsIlVTRV9URVhfTE9EIiwiVVNFX0lCTCIsIkhBU19CQVNFQ09MT1JNQVAiLCJIQVNfTk9STUFMTUFQIiwiSEFTX0VNSVNTSVZFTUFQIiwiSEFTX09DQ0xVU0lPTk1BUCIsImRlZmluZVN0ciIsInNoYWRlckRlcHRoIiwiZnNEZXB0aCIsInNoYWRlckVkaXRvciIsInZzRWRpdG9yIiwiZnNFZGl0b3IiLCJnZXRGYWNlcyIsIm1hdHJpeERlYnVnIiwiY3ViZURlYnVnIiwiYmFzZUNvbG9yIiwidGV4dHVyZVJhZCIsInRleHR1cmVJcnIiLCJ0ZXh0dXJlQU8iLCJ0ZXh0dXJlQ29sb3IiLCJ0ZXh0dXJlUm91Z2giLCJjdXJyZW50U3BvdEFubm90YXRpb24iLCJzcGVjdWxhciIsImRTaGFwZSIsInByb3RvdHlwZSIsInJlcGxhY2VBbGwiLCJyZXBsYWNlbWVudCIsImNhcHR1cmUiLCJtZXRhS2V5IiwiZGF0ZSIsIkRhdGUiLCJzdHJEYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwic2F2ZUltYWdlIiwiZGVzdHJveUdMIiwibnVtVGV4dHVyZVVuaXRzIiwidW5pdCIsImRlc3Ryb3lTaGFkZXIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsInhEaXN0IiwieURpc3QiLCJ6MSIsInoyIiwiekRpc3QiLCJpbmRpY2UxIiwiaW5kaWNlMiIsImluZGljZTMiLCJ2MyIsInZlYyIsImdldENsb3Nlc3QiLCJ2ZXJ0aWNlIiwidmVydGljZTEiLCJ2ZXJ0aWNlMiIsImlucHV0TWluIiwiaW5wdXRNYXgiLCJvdXRwdXRNaW4iLCJvdXRwdXRNYXgiLCJnZXRMb2FkaW5nSW1hZ2UiLCJpbml0QWxmcmlkIiwiaWdub3JlV2ViZ2wyIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwiY3JlYXRlTG9hZGluZ0FuaW0iLCJsb2FkQXNzZXRzIiwiY2xhc3NMaXN0IiwiQXNzZXRzTG9hZGVyIiwibG9hZEFzc2V0c0J1aWxkIiwiYXNzZXRzV2l0aFVybCIsImFzc2V0IiwiYXNzZXRzUGF0aCIsIm9uUHJvZ3Jlc3MiLCJpbml0QXNzZXRzIiwibGlzdEFzc2V0cyIsImluaXRBc3NldHNCdWlsZCIsImNsb3NlTG9hZGluZ0FuaW0iLCJyZW1vdmUiLCJwcmVsb2FkQnVpbGQiLCJjb250YWluZXJXaWR0aCIsImNvbnRhaW5lckhlaWdodCIsInR3IiwidGgiLCJGSUxFX0VYVEVOVElPTiIsIk1JTUVfVFlQRSIsImRhdGFVUkx0b0Jsb2IiLCJkYXRhdXJsIiwibWltZSIsImJzdHIiLCJhdG9iIiwidThhcnIiLCJjaGFyQ29kZUF0IiwiQmxvYiIsImZpbGVuYW1lIiwibGluayIsImltZ0RhdGEiLCJ0b0RhdGFVUkwiLCJtdWx0aXBsaWVyIiwiYmxvYiIsIm9ianVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImRvd25sb2FkIiwiY2xpY2siLCJtUHJldHR5Iiwic3RyIiwiZW5jb2RlIiwic2V0QXR0cmlidXRlIiwiaW5pdE1vdXNlRXZlbnQiLCJzbWFsbGVzdEFuZ2xlIiwidGFyZ2V0QW5nbGUiLCJkaWZmZXJlbmNlMSIsImRpZmZlcmVuY2UyIiwiZGlmZmVyZW5jZTMiLCJhYnNEaWZmZXJlbmNlMSIsImFic0RpZmZlcmVuY2UyIiwiYWJzRGlmZmVyZW5jZTMiLCJkaWZmZXJlbmNlIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZhOztBQUViO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ1JZOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ3RCYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsaUVBQWM7QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMsNERBQVU7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFPYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQywwREFBUztBQUNwQyxxQkFBcUIsbUJBQU8sQ0FBQywwREFBUzs7QUFFdEM7Ozs7Ozs7Ozs7Ozs7QUNMYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsaUVBQWM7QUFDcEMscUJBQXFCLG1CQUFPLENBQUMsbUZBQXVCO0FBQ3BELFlBQVksbUJBQU8sQ0FBQywwREFBUzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6VGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBLEM7Ozs7Ozs7Ozs7OztBQ3BGYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyw0REFBYTs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHFEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsVUFBVTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsVUFBVTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtEQUFnQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtEQUFnQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsY0FBYztBQUN6QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUCx3QkFBd0IscURBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxhQUFhO0FBQ3pCLFlBQVksS0FBSztBQUNqQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxhQUFhO0FBQ3pCLFlBQVksS0FBSztBQUNqQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixZQUFZLEtBQUs7QUFDakI7O0FBRU87QUFDUCxvQkFBb0IscURBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE1BQU07QUFDakIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtEQUFnQiwrQkFBK0Isa0RBQWdCLCtCQUErQixrREFBZ0I7QUFDL0k7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBZ0IscUVBQXFFLGtEQUFnQixxRUFBcUUsa0RBQWdCLHFFQUFxRSxrREFBZ0IscUVBQXFFLGtEQUFnQixxRUFBcUUsa0RBQWdCLHFFQUFxRSxrREFBZ0IscUVBQXFFLGtEQUFnQixxRUFBcUUsa0RBQWdCLHFFQUFxRSxrREFBZ0IsdUVBQXVFLGtEQUFnQix5RUFBeUUsa0RBQWdCLHlFQUF5RSxrREFBZ0IseUVBQXlFLGtEQUFnQix5RUFBeUUsa0RBQWdCLHlFQUF5RSxrREFBZ0I7QUFDL3pDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU8sbUI7Ozs7Ozs7Ozs7OztBQ3J4RFA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF3QztBQUNOO0FBQ0E7QUFDQTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUCxnQkFBZ0IscURBQW1COztBQUVuQyxNQUFNLHFEQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksYUFBYTtBQUN6QixZQUFZLE9BQU87QUFDbkI7O0FBRU87QUFDUDtBQUNBOztBQUVBLFVBQVUsa0RBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSxhQUFhO0FBQ3pCLFlBQVksT0FBTztBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQyxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdILG9CQUFvQixrREFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0EsV0FBVyxpREFBZTtBQUMxQixXQUFXLGlEQUFlO0FBQzFCLFdBQVcsaURBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjtBQUNBOztBQUVPLFlBQVksOENBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBOztBQUVPLGlCQUFpQixtREFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjtBQUNBOztBQUVPLFdBQVcsNkNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTs7QUFFTyxVQUFVLDRDQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjtBQUNBOztBQUVPLFVBQVUsNENBQVE7QUFDekI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBOztBQUVPLFlBQVksOENBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFTyxVQUFVLDRDQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTs7QUFFTyxXQUFXLDZDQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhLE9BQU87QUFDcEI7O0FBRU8sYUFBYSwrQ0FBVztBQUMvQjtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVPLG9CQUFvQixzREFBa0I7QUFDN0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7O0FBRU8sZ0JBQWdCLGtEQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPLGtCQUFrQixvREFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLFFBQVE7QUFDckI7O0FBRU8sYUFBYSwrQ0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUCxnQkFBZ0IsK0NBQVc7QUFDM0Isa0JBQWtCLG1EQUFlO0FBQ2pDLGtCQUFrQixtREFBZTtBQUNqQztBQUNBLGNBQWMsNENBQVE7O0FBRXRCO0FBQ0EsTUFBTSw4Q0FBVTtBQUNoQixVQUFVLDRDQUFRLHNCQUFzQiw4Q0FBVTtBQUNsRCxNQUFNLGtEQUFjO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNLDhDQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQLGFBQWEsK0NBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHOzs7Ozs7Ozs7Ozs7QUNyc0JEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXdDO0FBQ047QUFDQTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUCxlQUFlLHFEQUFtQjs7QUFFbEMsTUFBTSxxREFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRU87QUFDUCxlQUFlLHFEQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRU87QUFDUCxlQUFlLHFEQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTztBQUNQLGVBQWUscURBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsYUFBYTtBQUN4QixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsYUFBYTtBQUN4QixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsYUFBYTtBQUN4QixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYywrQ0FBVztBQUN6QixFQUFFLG9EQUFnQjtBQUNsQixjQUFjLHFEQUFtQjtBQUNqQyxFQUFFLHVEQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxLQUFLO0FBQ2pCOztBQUVPLGNBQWMsNkNBQVM7QUFDOUI7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxLQUFLO0FBQ2pCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsYUFBYTtBQUN4QixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTyxjQUFjLDZDQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksY0FBYztBQUMxQixZQUFZLEtBQUs7QUFDakI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQSxzQkFBc0Isa0RBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFTyxVQUFVLDRDQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFTyxhQUFhLCtDQUFXO0FBQy9CO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU8sb0JBQW9CLHNEQUFrQjtBQUM3QztBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBZ0IscUVBQXFFLGtEQUFnQixxRUFBcUUsa0RBQWdCLHFFQUFxRSxrREFBZ0IscUVBQXFFLGtEQUFnQixxRUFBcUUsa0RBQWdCLHFFQUFxRSxrREFBZ0IscUVBQXFFLGtEQUFnQjtBQUNqb0IsQzs7Ozs7Ozs7Ozs7O0FDbDBCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQLGdCQUFnQixxREFBbUI7O0FBRW5DLE1BQU0scURBQW1CO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQLGdCQUFnQixxREFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQLGdCQUFnQixxREFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0EsVUFBVSxpREFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0RBQWdCLHFFQUFxRSxrREFBZ0I7QUFDbkk7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLEc7Ozs7Ozs7Ozs7OztBQy9tQkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUCxnQkFBZ0IscURBQW1COztBQUVuQyxNQUFNLHFEQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQLGdCQUFnQixxREFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1AsZ0JBQWdCLHFEQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FB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O0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsOEpBQThKO0FBQzlKO0FBQ0E7O0FBRUEsUUFBUSw0Q0FBNEM7O0FBRXBEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFOztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVILGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNMQUFzTDtBQUN0TDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5R0FBeUc7QUFDekc7O0FBRUE7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTs7QUFFNUUsaUNBQWlDO0FBQ2pDLE9BQU87QUFDUDs7QUFFQSw2QkFBNkI7O0FBRTdCLDhNQUE4TTtBQUM5TTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjs7QUFFbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1IQUFtSDs7QUFFbkg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0VBQWtFOzs7QUFHbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQyx5Q0FBeUM7O0FBRXpDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1IQUFtSDs7QUFFbkg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNEdBQTRHOztBQUU1RztBQUNBOztB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Q0g7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSx5QkFBeUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuTEE7QUFDQSxDQUFDOztBQUVEO0FBQ0EsbUJBQW1CLEtBQTBCO0FBQzdDO0FBQ0Esa0JBQWtCLEtBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4Qix5Q0FBeUMscUJBQXFCOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLGlCQUFpQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFFVTtBQUNaO0FBQ0EsRUFBRSxtQ0FBbUI7QUFDckI7QUFDQSxHQUFHO0FBQUEsb0dBQUM7QUFDSixFQUFFLE1BQU0sRUFhTjs7QUFFRixDQUFDOzs7Ozs7Ozs7Ozs7OztBQ3BoQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BGYTs7QUFFYixpQ0FBaUMsbUJBQU8sQ0FBQywwREFBVTtBQUNuRCxxQ0FBcUMsbUJBQU8sQ0FBQywwREFBVTs7Ozs7Ozs7Ozs7OztBQ0h2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLDRCQUE0QixtQkFBTyxDQUFDLGdHQUE0QjtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsU0FBUztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsVUFBVSxTQUFTO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FD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RUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeEZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUFBO0FBQUE7QUFFQTtBQUVBLE1BQU1BLE1BQU0sR0FBRyxFQUFmO0FBQ0EsSUFBSUMsT0FBTyxHQUFHLEVBQWQ7QUFDQSxJQUFJQyxNQUFKO0FBQ0EsSUFBSUMsUUFBUSxHQUFHLEVBQWY7O0FBRUEsTUFBTUMsUUFBUSxHQUFHLFVBQVNDLEVBQVQsRUFBYTtBQUU3QixTQUFPSCxNQUFNLENBQUNJLElBQVAsQ0FBY0MsQ0FBRCxJQUFPQSxDQUFDLENBQUNGLEVBQUYsS0FBU0EsRUFBN0IsRUFBaUNHLElBQXhDO0FBQ0EsQ0FIRDs7QUFLQSxNQUFNQyxZQUFZLEdBQUcsVUFBU0MsS0FBVCxFQUFnQjtBQUNwQyxRQUFNQyxHQUFHLEdBQUdELEtBQUssQ0FBQ0UsS0FBTixDQUFZLEdBQVosQ0FBWjtBQUNBLFNBQU9ELEdBQUcsQ0FBQ0EsR0FBRyxDQUFDRSxNQUFKLEdBQWEsQ0FBZCxDQUFWO0FBQ0EsQ0FIRDs7QUFLQWIsTUFBTSxDQUFDYyxJQUFQLEdBQWMsVUFBU0MsT0FBVCxFQUFrQkMsWUFBbEIsRUFBZ0M7QUFFN0NkLFFBQU0sR0FBR2EsT0FBVDtBQUNBLE1BQUlFLFdBQVcsR0FBRyxFQUFsQjtBQUNBaEIsU0FBTyxHQUFHZSxZQUFZLENBQUNFLEdBQWIsQ0FBa0JDLENBQUQsSUFBTTtBQUNoQyxVQUFNQyxHQUFHLEdBQUdYLFlBQVksQ0FBQ1UsQ0FBQyxDQUFDRSxHQUFILENBQXhCO0FBRUEsVUFBTWIsSUFBSSxHQUFHSixRQUFRLENBQUNlLENBQUMsQ0FBQ2QsRUFBSCxDQUFyQjtBQUNBLFFBQUlpQixPQUFKOztBQUVBLFlBQU9GLEdBQVA7QUFHQyxXQUFLLEtBQUw7QUFDQSxXQUFLLEtBQUw7QUFDQ0UsZUFBTyxHQUFHLElBQUlDLGdEQUFKLENBQWNmLElBQWQsQ0FBVjtBQUNBTCxnQkFBUSxDQUFDcUIsSUFBVCxDQUFjRixPQUFkO0FBQ0EsZUFBTztBQUNOakIsWUFBRSxFQUFDYyxDQUFDLENBQUNkLEVBREM7QUFFTkcsY0FBSSxFQUFDYztBQUZDLFNBQVA7QUFJQTs7QUFFRCxXQUFLLEtBQUw7QUFDQyxZQUFJRyxXQUFXLEdBQUdOLENBQUMsQ0FBQ2QsRUFBRixDQUFLTyxLQUFMLENBQVcsR0FBWCxFQUFnQixDQUFoQixDQUFsQjtBQUNBVSxlQUFPLEdBQUdJLDhDQUFNLENBQUNDLFNBQVAsQ0FBaUJDLEtBQWpCLENBQXVCcEIsSUFBdkIsQ0FBVjtBQUVBLGNBQU1xQixNQUFNLEdBQUc7QUFDZHhCLFlBQUUsRUFBQ2MsQ0FBQyxDQUFDZCxFQURTO0FBRWRHLGNBQUksRUFBQ2M7QUFGUyxTQUFmOztBQUtBLFlBQUcsQ0FBQ0wsV0FBVyxDQUFDUSxXQUFELENBQWYsRUFBOEI7QUFDN0JSLHFCQUFXLENBQUNRLFdBQUQsQ0FBWCxHQUEyQixFQUEzQjtBQUNBOztBQUVEUixtQkFBVyxDQUFDUSxXQUFELENBQVgsQ0FBeUJELElBQXpCLENBQThCSyxNQUE5QjtBQUNBLGVBQU9BLE1BQVA7QUFFQTs7QUFDRCxXQUFLLEtBQUw7QUFDQ1AsZUFBTyxHQUFHUSxvREFBYSxDQUFDQyxRQUFkLENBQXVCdkIsSUFBdkIsQ0FBVjtBQUNBLGVBQU87QUFDTkgsWUFBRSxFQUFDYyxDQUFDLENBQUNkLEVBREM7QUFFTkcsY0FBSSxFQUFDYztBQUZDLFNBQVA7QUFJQTs7QUFFRCxXQUFLLEtBQUw7QUFDQyxjQUFNVSxJQUFJLEdBQUdDLGdEQUFTLENBQUNMLEtBQVYsQ0FBZ0JwQixJQUFoQixDQUFiO0FBQ0EsZUFBTztBQUNOSCxZQUFFLEVBQUNjLENBQUMsQ0FBQ2QsRUFEQztBQUVORyxjQUFJLEVBQUN3QjtBQUZDLFNBQVA7QUFJQTs7QUFDRDtBQUNDRSxlQUFPLENBQUNDLEdBQVIsQ0FBWSxzQkFBWixFQUFvQ2YsR0FBcEM7QUE5Q0Y7QUFpREEsR0F2RFMsQ0FBVjs7QUF5REEsT0FBSSxJQUFJZ0IsQ0FBUixJQUFhbkIsV0FBYixFQUEwQjtBQUN6QixRQUFHQSxXQUFXLENBQUNtQixDQUFELENBQVgsQ0FBZXZCLE1BQWYsSUFBeUIsQ0FBNUIsRUFBK0I7QUFDOUJxQixhQUFPLENBQUNDLEdBQVIsQ0FBWSxvQkFBWixFQUFrQ0MsQ0FBbEM7QUFFQSxZQUFNekIsR0FBRyxHQUFHLENBQ1hYLE1BQU0sQ0FBQ3FDLEdBQVAsQ0FBWSxHQUFFRCxDQUFFLE9BQWhCLENBRFcsRUFFWHBDLE1BQU0sQ0FBQ3FDLEdBQVAsQ0FBWSxHQUFFRCxDQUFFLE9BQWhCLENBRlcsRUFHWHBDLE1BQU0sQ0FBQ3FDLEdBQVAsQ0FBWSxHQUFFRCxDQUFFLE9BQWhCLENBSFcsRUFJWHBDLE1BQU0sQ0FBQ3FDLEdBQVAsQ0FBWSxHQUFFRCxDQUFFLE9BQWhCLENBSlcsRUFLWHBDLE1BQU0sQ0FBQ3FDLEdBQVAsQ0FBWSxHQUFFRCxDQUFFLE9BQWhCLENBTFcsRUFNWHBDLE1BQU0sQ0FBQ3FDLEdBQVAsQ0FBWSxHQUFFRCxDQUFFLE9BQWhCLENBTlcsQ0FBWjtBQVNBLFlBQU1kLE9BQU8sR0FBRyxJQUFJSSw4Q0FBTSxDQUFDSSxhQUFYLENBQXlCbkIsR0FBekIsQ0FBaEI7O0FBQ0FWLGFBQU8sQ0FBQ3VCLElBQVIsQ0FBYTtBQUNabkIsVUFBRSxFQUFDK0IsQ0FEUztBQUVaNUIsWUFBSSxFQUFDYztBQUZPLE9BQWI7QUFJQTtBQUNEOztBQUVEWSxTQUFPLENBQUNDLEdBQVIsQ0FBWSxTQUFaLEVBQXVCbEMsT0FBdkI7O0FBRUEsTUFBR0EsT0FBTyxDQUFDWSxNQUFSLEdBQWlCLENBQXBCLEVBQXVCO0FBQ3RCcUIsV0FBTyxDQUFDSSxLQUFSLENBQWMsU0FBZDtBQUNBSixXQUFPLENBQUNLLEtBQVIsQ0FBY3RDLE9BQWQ7QUFDQTtBQUVELENBekZEOztBQTJGQUQsTUFBTSxDQUFDd0MsT0FBUCxHQUFrQkMsRUFBRCxJQUFRO0FBQ3hCLE9BQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3ZDLFFBQVEsQ0FBQ1UsTUFBN0IsRUFBcUM2QixDQUFDLEVBQXRDLEVBQTBDO0FBQ3pDRCxNQUFFLENBQUNFLGFBQUgsQ0FBaUJ4QyxRQUFRLENBQUN1QyxDQUFELENBQVIsQ0FBWUUsUUFBN0I7QUFDQTs7QUFFRHpDLFVBQVEsQ0FBQ1UsTUFBVCxHQUFrQixDQUFsQjtBQUNBLENBTkQ7O0FBUUFiLE1BQU0sQ0FBQ3FDLEdBQVAsR0FBYSxVQUFTUSxHQUFULEVBQWM7QUFDMUIsU0FBTzVDLE9BQU8sQ0FBQ0ssSUFBUixDQUFjQyxDQUFELElBQU87QUFDMUIsV0FBT0EsQ0FBQyxDQUFDRixFQUFGLEtBQVN3QyxHQUFoQjtBQUNBLEdBRk0sRUFFSnJDLElBRkg7QUFHQSxDQUpEOztBQU1lUixxRUFBZixFOzs7Ozs7Ozs7Ozs7QUM1SEE7QUFBQTtBQUFPLE1BQU04QyxjQUFjLEdBQUlDLEdBQUQsSUFBUztBQUN0QyxRQUFNQyxRQUFRLEdBQUdDLE1BQWpCOztBQUVBLFFBQU1DLGVBQWUsR0FBSUMsQ0FBRCxJQUFPO0FBQzlCQSxLQUFDLENBQUNDLGNBQUY7QUFDQUQsS0FBQyxDQUFDRSxlQUFGO0FBQ0MsR0FIRjs7QUFLQyxHQUFDLFdBQUQsRUFBYyxVQUFkLEVBQTBCLFdBQTFCLEVBQXVDLE1BQXZDLEVBQStDQyxPQUEvQyxDQUF1REMsU0FBUyxJQUFJO0FBQ3BFUCxZQUFRLENBQUNRLGdCQUFULENBQTBCRCxTQUExQixFQUFxQ0wsZUFBckMsRUFBc0QsS0FBdEQ7QUFDQSxHQUZBOztBQUlELFFBQU1PLFVBQVUsR0FBSU4sQ0FBRCxJQUFPO0FBQ3pCLFVBQU1PLEVBQUUsR0FBR1AsQ0FBQyxDQUFDUSxZQUFiO0FBQ0EsVUFBTUMsS0FBSyxHQUFHRixFQUFFLENBQUNFLEtBQWpCO0FBQ0EsVUFBTXBELElBQUksR0FBR29ELEtBQUssQ0FBQyxDQUFELENBQWxCO0FBRUEsVUFBTUMsTUFBTSxHQUFHLElBQUlDLFVBQUosRUFBZjtBQUNBRCxVQUFNLENBQUNFLGFBQVAsQ0FBcUJ2RCxJQUFyQjs7QUFDQXFELFVBQU0sQ0FBQ0csU0FBUCxHQUFtQixNQUFNO0FBQ3hCLFlBQU1DLEdBQUcsR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQVo7O0FBRUFGLFNBQUcsQ0FBQ0csTUFBSixHQUFhLE1BQU07QUFDbEIsWUFBSXJCLEdBQUosRUFBUztBQUNSQSxhQUFHLENBQUNrQixHQUFELENBQUg7QUFDQTtBQUNELE9BSkQ7O0FBS0FBLFNBQUcsQ0FBQ0ksR0FBSixHQUFVUixNQUFNLENBQUNTLE1BQWpCO0FBQ0EsS0FURDtBQVVBLEdBakJEOztBQW1CQXRCLFVBQVEsQ0FBQ1EsZ0JBQVQsQ0FBMEIsTUFBMUIsRUFBa0NDLFVBQWxDLEVBQThDLEtBQTlDO0FBQ0EsQ0FoQ00sQzs7Ozs7Ozs7Ozs7QUNBUDtBQUVBUixNQUFNLENBQUNzQixHQUFQLEdBQWE7QUFDWkMsS0FBRyxFQUFDLE1BQUksQ0FFUDtBQUhXLENBQWIsQzs7Ozs7Ozs7Ozs7O0FDRkE7QUFBQTtBQUFBLE1BQU1DLFNBQU4sQ0FBZ0I7QUFDZEMsYUFBVyxDQUFFQyxTQUFTLEdBQUcsQ0FBZCxFQUFpQjtBQUMxQixTQUFLQyxNQUFMLEdBQWNELFNBQWQ7QUFDRDs7QUFFREUsS0FBRyxDQUFFQyxTQUFGLEVBQWFDLE1BQU0sR0FBRyxDQUF0QixFQUF5QjtBQUMxQixRQUFJQSxNQUFNLEtBQUssQ0FBZixFQUFrQjtBQUNoQixXQUFLSCxNQUFMLEdBQWMsS0FBS0EsTUFBTCxHQUFlLEtBQUtFLFNBQWxDO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsV0FBS0YsTUFBTCxHQUFjLEtBQUtBLE1BQUwsR0FBZSxLQUFLRSxTQUFsQztBQUNEO0FBQ0Y7O0FBRURFLFFBQU0sQ0FBQ0YsU0FBRCxFQUFZO0FBQ2hCLFNBQUtGLE1BQUwsR0FBYyxLQUFLQSxNQUFMLEdBQWUsS0FBTUUsU0FBbkM7QUFDRDs7QUFFRHpDLEtBQUcsQ0FBRXlDLFNBQUYsRUFBYTtBQUNkLFFBQUlHLEtBQUssR0FBRyxLQUFLTCxNQUFMLEdBQWUsS0FBS0UsU0FBaEM7QUFDQUcsU0FBSyxHQUFHQSxLQUFLLElBQUlILFNBQWpCO0FBRUEsV0FBT0csS0FBSyxLQUFLLENBQWpCO0FBQ0Q7O0FBRURDLE9BQUssR0FBSTtBQUNQLFNBQUtOLE1BQUwsR0FBYyxDQUFkO0FBQ0Q7O0FBRUQsTUFBSUssS0FBSixHQUFhO0FBQ1gsV0FBTyxLQUFLTCxNQUFaO0FBQ0Q7O0FBRUR6QyxLQUFHLEdBQUk7QUFDTCxVQUFNQyxDQUFDLEdBQUcsS0FBS3dDLE1BQUwsQ0FBWU8sUUFBWixDQUFxQixDQUFyQixDQUFWOztBQUNBLFdBQU8vQyxDQUFQO0FBQ0Q7O0FBbkNhOzs7Ozs7Ozs7Ozs7OztBQ0FoQjtBQUFBO0FBQUE7QUFBQTs7QUFFQSxNQUFNZ0QsZUFBTixDQUFzQjtBQUNwQlYsYUFBVyxHQUFHO0FBQ1osU0FBS1csY0FBTCxHQUFzQixJQUF0QjtBQUNBLFNBQUtDLFdBQUwsR0FBbUIsS0FBbkI7QUFDRDs7QUFFRHhFLE1BQUksQ0FBQ3VFLGNBQUQsRUFBaUI7QUFDbkIsU0FBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFNBQUtELGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0Q7O0FBRURFLE9BQUssQ0FBQ0MsT0FBRCxFQUFVO0FBQ2IsVUFBTUMsR0FBRyxHQUFHLEtBQUtKLGNBQWpCO0FBRUEsVUFBTWxFLENBQUMsR0FBRztBQUNSdUUsWUFBTSxFQUFFRCxHQUFHLENBQUNDLE1BQUosQ0FBV1QsS0FEWDtBQUVSVSxRQUFFLEVBQUVGLEdBQUcsQ0FBQ0UsRUFBSixDQUFPVixLQUZIO0FBR1JXLFFBQUUsRUFBRUgsR0FBRyxDQUFDRyxFQUFKLENBQU9YLEtBSEg7QUFJUlksYUFBTyxFQUFFSixHQUFHLENBQUNLLE1BQUosQ0FBVyxDQUFYLENBSkQ7QUFLUkMsYUFBTyxFQUFFTixHQUFHLENBQUNLLE1BQUosQ0FBVyxDQUFYLENBTEQ7QUFNUkUsYUFBTyxFQUFFUCxHQUFHLENBQUNLLE1BQUosQ0FBVyxDQUFYLENBTkQ7QUFPUkcsYUFBTyxFQUFFUixHQUFHLENBQUNTLGNBQUosQ0FBbUIsQ0FBbkIsQ0FQRDtBQVFSQyxhQUFPLEVBQUVWLEdBQUcsQ0FBQ1MsY0FBSixDQUFtQixDQUFuQixDQVJEO0FBU1JFLGFBQU8sRUFBRVgsR0FBRyxDQUFDUyxjQUFKLENBQW1CLENBQW5CO0FBVEQsS0FBVjtBQVlBRyxnREFBSSxDQUFDQyxFQUFMLENBQVFuRixDQUFSLEVBQVdxRSxPQUFPLENBQUNlLFFBQVIsSUFBb0IsQ0FBL0IsRUFBa0M7QUFDaENDLFdBQUssRUFBRWhCLE9BQU8sQ0FBQ2dCLEtBQVIsSUFBaUIsQ0FEUTtBQUVoQ2QsWUFBTSxFQUFFRixPQUFPLENBQUNFLE1BQVIsSUFBa0IsQ0FGTTtBQUdoQ0MsUUFBRSxFQUFFSCxPQUFPLENBQUNHLEVBQVIsSUFBYyxDQUhjO0FBSWhDQyxRQUFFLEVBQUVKLE9BQU8sQ0FBQ0ksRUFBUixJQUFjLENBSmM7QUFLaENDLGFBQU8sRUFBRUwsT0FBTyxDQUFDSyxPQUFSLElBQW1CLENBTEk7QUFNaENFLGFBQU8sRUFBRVAsT0FBTyxDQUFDTyxPQUFSLElBQW1CLENBTkk7QUFPaENDLGFBQU8sRUFBRVIsT0FBTyxDQUFDUSxPQUFSLElBQW1CLENBUEk7QUFRaENDLGFBQU8sRUFBRVQsT0FBTyxDQUFDUyxPQUFSLElBQW1CLENBUkk7QUFTaENFLGFBQU8sRUFBRVgsT0FBTyxDQUFDVyxPQUFSLElBQW1CLENBVEk7QUFVaENDLGFBQU8sRUFBRVosT0FBTyxDQUFDWSxPQUFSLElBQW1CLENBVkk7QUFXaENLLFVBQUksRUFBRWpCLE9BQU8sQ0FBQ2lCLElBQVIsSUFBZ0IsVUFYVTtBQVloQ0MsY0FBUSxFQUFFLE1BQU07QUFDZCxZQUFJbEIsT0FBTyxDQUFDRyxFQUFSLEtBQWVnQixTQUFuQixFQUE4QmxCLEdBQUcsQ0FBQ0UsRUFBSixDQUFPaUIsS0FBUCxDQUFhekYsQ0FBQyxDQUFDd0UsRUFBZjtBQUM5QixZQUFJSCxPQUFPLENBQUNJLEVBQVIsS0FBZWUsU0FBbkIsRUFBOEJsQixHQUFHLENBQUNHLEVBQUosQ0FBT2dCLEtBQVAsQ0FBYXpGLENBQUMsQ0FBQ3lFLEVBQWY7QUFDOUIsWUFBSUosT0FBTyxDQUFDRSxNQUFSLEtBQW1CaUIsU0FBdkIsRUFBa0NsQixHQUFHLENBQUNDLE1BQUosQ0FBV2tCLEtBQVgsQ0FBaUJ6RixDQUFDLENBQUN1RSxNQUFuQjtBQUNsQyxZQUFJRixPQUFPLENBQUNLLE9BQVIsS0FBb0JjLFNBQXhCLEVBQW1DbEIsR0FBRyxDQUFDSyxNQUFKLENBQVcsQ0FBWCxJQUFnQjNFLENBQUMsQ0FBQzBFLE9BQWxCO0FBQ25DLFlBQUlMLE9BQU8sQ0FBQ08sT0FBUixLQUFvQlksU0FBeEIsRUFBbUNsQixHQUFHLENBQUNLLE1BQUosQ0FBVyxDQUFYLElBQWdCM0UsQ0FBQyxDQUFDNEUsT0FBbEI7QUFDbkMsWUFBSVAsT0FBTyxDQUFDUSxPQUFSLEtBQW9CVyxTQUF4QixFQUFtQ2xCLEdBQUcsQ0FBQ0ssTUFBSixDQUFXLENBQVgsSUFBZ0IzRSxDQUFDLENBQUM2RSxPQUFsQjtBQUNuQyxZQUFJUixPQUFPLENBQUNTLE9BQVIsS0FBb0JVLFNBQXhCLEVBQW1DbEIsR0FBRyxDQUFDUyxjQUFKLENBQW1CLENBQW5CLElBQXdCL0UsQ0FBQyxDQUFDOEUsT0FBMUI7QUFDbkMsWUFBSVQsT0FBTyxDQUFDVyxPQUFSLEtBQW9CUSxTQUF4QixFQUFtQ2xCLEdBQUcsQ0FBQ1MsY0FBSixDQUFtQixDQUFuQixJQUF3Qi9FLENBQUMsQ0FBQ2dGLE9BQTFCO0FBQ25DLFlBQUlYLE9BQU8sQ0FBQ1ksT0FBUixLQUFvQk8sU0FBeEIsRUFBbUNsQixHQUFHLENBQUNTLGNBQUosQ0FBbUIsQ0FBbkIsSUFBd0IvRSxDQUFDLENBQUNpRixPQUExQjtBQUNwQyxPQXRCK0I7QUF1QmhDUyxnQkFBVSxFQUFFckIsT0FBTyxDQUFDcUIsVUFBUixJQUFzQjtBQXZCRixLQUFsQztBQXlCRDs7QUFFRCxNQUFJQyxPQUFKLEdBQWU7QUFDYixXQUFPLEtBQUt4QixXQUFaO0FBQ0Q7O0FBdkRtQjs7QUEwRHRCLE1BQU15QixtQkFBbUIsR0FBRyxJQUFJM0IsZUFBSixFQUE1Qjs7Ozs7Ozs7Ozs7OztBQzVEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FDQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0NBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Q0FFQTs7Q0FFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Q0FFQTs7QUFDQTtDQUVBOztBQUNBO0FBQ0E7Q0FFQTs7QUFDQTtDQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Q0FHQTtBQUtBOztBQUlBLE1BQU00QixPQUFPLEdBQUcsT0FBaEI7O0FBRUEsTUFBTUMsTUFBTixDQUFhO0FBQ1h2QyxhQUFXLEdBQUk7QUFDYixTQUFLd0MsR0FBTCxHQUFXQyxzQ0FBWDtBQUNBLFNBQUtDLEVBQUwsR0FBVUEsdURBQVY7QUFDQSxTQUFLQyxNQUFMLEdBQWNELHVEQUFkO0FBQ0EsU0FBS0UsUUFBTCxHQUFnQkEseURBQWhCO0FBQ0EsU0FBSy9GLFNBQUwsR0FBaUJBLDJEQUFqQjtBQUNBLFNBQUtPLGFBQUwsR0FBcUJBLDhEQUFyQjtBQUNBLFNBQUt5RixJQUFMLEdBQVlBLHFEQUFaO0FBQ0EsU0FBS0MsSUFBTCxHQUFZQSxxREFBWjtBQUNBLFNBQUtDLEtBQUwsR0FBYUEscURBQWI7QUFDQSxTQUFLQyxXQUFMLEdBQW1CQSw0REFBbkI7QUFDQSxTQUFLQyxlQUFMLEdBQXVCQSxnRUFBdkI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCQSxtREFBakI7QUFDQSxTQUFLQyxlQUFMLEdBQXVCQSxzRUFBdkI7QUFDQSxTQUFLQyxVQUFMLEdBQWtCQSxpRUFBbEI7QUFDQSxTQUFLQyxZQUFMLEdBQW9CQSxtRUFBcEI7QUFDQSxTQUFLQyxXQUFMLEdBQW1CQSxrRUFBbkI7QUFDQSxTQUFLQyxNQUFMLEdBQWNBLCtEQUFkO0FBQ0EsU0FBS0MsV0FBTCxHQUFtQkEsb0VBQW5CO0FBQ0EsU0FBS0MsaUJBQUwsR0FBeUJBLDBFQUF6QjtBQUNBLFNBQUtDLEdBQUwsR0FBV0EseURBQVg7QUFDQSxTQUFLQyxVQUFMLEdBQWtCQSxtRUFBbEI7QUFDQSxTQUFLQyxjQUFMLEdBQXNCQSxxRUFBdEI7QUFDQSxTQUFLQyxZQUFMLEdBQW9CQSxtRUFBcEI7QUFDQSxTQUFLQyxZQUFMLEdBQW9CQSxvRUFBcEI7QUFDQSxTQUFLdkcsU0FBTCxHQUFpQkEsa0VBQWpCO0FBQ0EsU0FBS3dHLFVBQUwsR0FBa0JBLG1FQUFsQixDQTFCYSxDQTJCYjs7QUFDQSxTQUFLOUcsU0FBTCxHQUFpQkEsa0VBQWpCO0FBQ0EsU0FBSytHLFNBQUwsR0FBaUJBLGlFQUFqQjtBQUNBLFNBQUtDLFNBQUwsR0FBaUJBLGlFQUFqQjtBQUNBLFNBQUtDLFNBQUwsR0FBaUJBLGlFQUFqQjtBQUNBLFNBQUtBLFNBQUwsR0FBaUJBLGlFQUFqQjtBQUNBLFNBQUtDLFNBQUwsR0FBaUJBLGlFQUFqQjtBQUNBLFNBQUtDLFdBQUwsR0FBbUJBLG1FQUFuQjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0JBLGdFQUFoQjtBQUNBLFNBQUtDLGNBQUwsR0FBc0JBLHNFQUF0QjtBQUNBLFNBQUtDLEtBQUwsR0FBYUEsOERBQWI7QUFDQSxTQUFLQyxJQUFMLEdBQVlBLDZEQUFaO0FBQ0EsU0FBS0MsTUFBTCxHQUFjQSwrREFBZDtBQUNBLFNBQUtDLElBQUwsR0FBWUEsNkRBQVo7QUFDQSxTQUFLQyxRQUFMLEdBQWdCQSxpRUFBaEI7QUFDQSxTQUFLQyxVQUFMLEdBQWtCQSxpRUFBbEI7QUFDQSxTQUFLQyxXQUFMLEdBQW1CQSxpRUFBbkI7QUFFQSxTQUFLQyxRQUFMLEdBQWdCQSx5REFBaEI7QUFDQSxTQUFLQyxXQUFMLEdBQW1CQSw0REFBbkI7QUFFQSxTQUFLQyxzQkFBTCxHQUE4QkEsdUVBQTlCO0FBQ0EsU0FBS0MsdUJBQUwsR0FBK0JBLHdFQUEvQjs7QUFFQSxTQUFLLE1BQU12SCxDQUFYLElBQWdCK0Usc0NBQWhCLEVBQXFCO0FBQ25CLFVBQUlBLHNDQUFHLENBQUMvRSxDQUFELENBQVAsRUFBWTtBQUNWLFlBQUlhLE1BQUosRUFBWUEsTUFBTSxDQUFDYixDQUFELENBQU4sR0FBWStFLHNDQUFHLENBQUMvRSxDQUFELENBQWY7QUFDYjtBQUNGO0FBQ0Y7O0FBRURELEtBQUcsR0FBSTtBQUNMLFFBQUl5SCxTQUFTLENBQUNDLFNBQVYsQ0FBb0JDLE9BQXBCLENBQTRCLFFBQTVCLElBQXdDLENBQUMsQ0FBN0MsRUFBZ0Q7QUFDOUM1SCxhQUFPLENBQUNDLEdBQVIsQ0FBYSwwQkFBeUI2RSxPQUFRLEVBQTlDLEVBQWlELHFDQUFqRDtBQUNELEtBRkQsTUFFTztBQUNMOUUsYUFBTyxDQUFDQyxHQUFSLENBQVksdUJBQVosRUFBcUM2RSxPQUFyQztBQUNEOztBQUNEOUUsV0FBTyxDQUFDQyxHQUFSLENBQVksY0FBWixFQUE0QixnQkFBNUI7O0FBRUEsU0FBSyxNQUFNQyxDQUFYLElBQWdCLElBQWhCLEVBQXNCO0FBQ3BCLFVBQUksS0FBS0EsQ0FBTCxDQUFKLEVBQWE7QUFDWEYsZUFBTyxDQUFDQyxHQUFSLENBQWEsUUFBT0MsQ0FBRSxFQUF0QixFQUF5QixnQkFBekI7QUFDRDtBQUNGO0FBQ0Y7O0FBeEVVOztBQTJFYixNQUFNMkgsRUFBRSxHQUFHLElBQUk5QyxNQUFKLEVBQVg7QUFFZThDLGlFQUFmOzs7Ozs7Ozs7Ozs7O0FDaEpBO0FBQUE7QUFBQTtBQUVBOztBQUVBLE1BQU10QyxLQUFOLENBQVk7QUFFWC9DLGFBQVcsQ0FBQ3NGLEtBQUQsRUFBUUMsT0FBUixFQUFpQjtBQUMzQixTQUFLQyxLQUFMLEdBQWFGLEtBQWI7QUFDQSxTQUFLRyxPQUFMLEdBQWVGLE9BQWY7QUFDQSxHQUxVLENBUVg7OztBQUVBRyxNQUFJLEdBQUc7QUFDTixTQUFLRCxPQUFMLENBQWFFLElBQWI7O0FBQ0FqRCxtREFBRSxDQUFDZ0QsSUFBSCxDQUFRLEtBQUtwSSxJQUFiO0FBQ0EsR0FiVSxDQWdCWDs7O0FBRUEsTUFBSUEsSUFBSixHQUFXO0FBQUUsV0FBTyxLQUFLa0ksS0FBWjtBQUFvQjs7QUFFakMsTUFBSUksTUFBSixHQUFhO0FBQUUsV0FBTyxLQUFLSCxPQUFaO0FBQXNCOztBQXBCMUI7O0FBdUJHMUMsb0VBQWYsRTs7Ozs7Ozs7Ozs7O0FDM0JBO0FBQUE7QUFBQTtBQUFBO0FBRWE7O0FBRWI7QUFDQTtBQUVBLElBQUloRixFQUFKOztBQUdBLE1BQU1rRixlQUFOLENBQXNCO0FBRXJCakQsYUFBVyxDQUFDNkYsSUFBRCxFQUFPQyxXQUFXLEdBQUcsRUFBckIsRUFBeUI7QUFDbkMvSCxNQUFFLEdBQUcyRSwrQ0FBRSxDQUFDM0UsRUFBUjtBQUNBLFNBQUtnSSxLQUFMLEdBQWFGLElBQWI7QUFDQSxTQUFLRyxTQUFMLEdBQWlCRixXQUFXLENBQUNFLFNBQVosSUFBeUJqSSxFQUFFLENBQUNrSSxNQUE3QztBQUNBLFNBQUtDLFNBQUwsR0FBaUJKLFdBQVcsQ0FBQ0ksU0FBWixJQUF5Qm5JLEVBQUUsQ0FBQ2tJLE1BQTdDO0FBQ0EsU0FBS0UsS0FBTCxHQUFpQkwsV0FBVyxDQUFDSyxLQUFaLElBQXFCcEksRUFBRSxDQUFDcUksYUFBekM7QUFDQSxTQUFLQyxLQUFMLEdBQWlCUCxXQUFXLENBQUNPLEtBQVosSUFBcUJ0SSxFQUFFLENBQUNxSSxhQUF6Qzs7QUFFQSxTQUFLRSxLQUFMO0FBQ0E7O0FBR0RBLE9BQUssR0FBRztBQUNQLFNBQUsxSixPQUFMLEdBQWlCbUIsRUFBRSxDQUFDd0ksYUFBSCxFQUFqQjtBQUNBLFNBQUtDLFNBQUwsR0FBaUIsSUFBSXBKLHNEQUFKLENBQWtCLEtBQUtSLE9BQXZCLEVBQWdDLEVBQWhDLEVBQW9DLElBQXBDLENBQWpCO0FBRUFtQixNQUFFLENBQUMwSSxXQUFILENBQWUxSSxFQUFFLENBQUMySSxnQkFBbEIsRUFBb0MsS0FBSzlKLE9BQXpDO0FBQ0FtQixNQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDMkksZ0JBQXBCLEVBQXNDM0ksRUFBRSxDQUFDNkksa0JBQXpDLEVBQTZELEtBQUtaLFNBQWxFO0FBQ0FqSSxNQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDMkksZ0JBQXBCLEVBQXNDM0ksRUFBRSxDQUFDOEksa0JBQXpDLEVBQTZELEtBQUtYLFNBQWxFO0FBQ0FuSSxNQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDMkksZ0JBQXBCLEVBQXNDM0ksRUFBRSxDQUFDK0ksY0FBekMsRUFBeUQsS0FBS1gsS0FBOUQ7QUFDQXBJLE1BQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUMySSxnQkFBcEIsRUFBc0MzSSxFQUFFLENBQUNnSixjQUF6QyxFQUF5RCxLQUFLVixLQUE5RDtBQUVBLFVBQU1XLE9BQU8sR0FBRyxDQUNmakosRUFBRSxDQUFDa0osMkJBRFksRUFDaUJsSixFQUFFLENBQUNtSiwyQkFEcEIsRUFFZm5KLEVBQUUsQ0FBQ29KLDJCQUZZLEVBRWlCcEosRUFBRSxDQUFDcUosMkJBRnBCLEVBR2ZySixFQUFFLENBQUNzSiwyQkFIWSxFQUdpQnRKLEVBQUUsQ0FBQ3VKLDJCQUhwQixDQUFoQjs7QUFNQSxTQUFJLElBQUl0SixDQUFDLEdBQUcsQ0FBWixFQUFlQSxDQUFDLEdBQUdnSixPQUFPLENBQUM3SyxNQUEzQixFQUFtQzZCLENBQUMsRUFBcEMsRUFBd0M7QUFDdkNELFFBQUUsQ0FBQ3dKLFdBQUgsQ0FBZXhKLEVBQUUsQ0FBQ3lKLG1CQUFsQixFQUF1QyxLQUF2QztBQUNBekosUUFBRSxDQUFDMEosVUFBSCxDQUFjVCxPQUFPLENBQUNoSixDQUFELENBQXJCLEVBQTBCLENBQTFCLEVBQTZCRCxFQUFFLENBQUMySixJQUFoQyxFQUFzQyxLQUFLQyxLQUEzQyxFQUFrRCxLQUFLQyxNQUF2RCxFQUErRCxDQUEvRCxFQUFrRTdKLEVBQUUsQ0FBQzJKLElBQXJFLEVBQTJFM0osRUFBRSxDQUFDOEosS0FBOUUsRUFBcUYsSUFBckY7QUFDQTs7QUFHRCxTQUFLQyxhQUFMLEdBQXFCLEVBQXJCOztBQUNBLFNBQUksSUFBSTlKLENBQUMsR0FBRyxDQUFaLEVBQWVBLENBQUMsR0FBR2dKLE9BQU8sQ0FBQzdLLE1BQTNCLEVBQW1DNkIsQ0FBQyxFQUFwQyxFQUF3QztBQUN2QyxZQUFNK0osV0FBVyxHQUFHaEssRUFBRSxDQUFDaUssaUJBQUgsRUFBcEI7QUFDQWpLLFFBQUUsQ0FBQ2tLLGVBQUgsQ0FBbUJsSyxFQUFFLENBQUNtSyxXQUF0QixFQUFtQ0gsV0FBbkM7QUFDQWhLLFFBQUUsQ0FBQ29LLG9CQUFILENBQXdCcEssRUFBRSxDQUFDbUssV0FBM0IsRUFBd0NuSyxFQUFFLENBQUNxSyxpQkFBM0MsRUFBOERwQixPQUFPLENBQUNoSixDQUFELENBQXJFLEVBQTBFLEtBQUtwQixPQUEvRSxFQUF3RixDQUF4RjtBQUVBLFlBQU15TCxNQUFNLEdBQUd0SyxFQUFFLENBQUN1SyxzQkFBSCxDQUEwQnZLLEVBQUUsQ0FBQ21LLFdBQTdCLENBQWY7O0FBQ0EsVUFBSUcsTUFBTSxLQUFLdEssRUFBRSxDQUFDd0ssb0JBQWxCLEVBQXdDO0FBQ3ZDL0ssZUFBTyxDQUFDQyxHQUFSLENBQWEsMENBQXlDNEssTUFBTyxFQUE3RDtBQUNBOztBQUVELFdBQUtQLGFBQUwsQ0FBbUJoTCxJQUFuQixDQUF3QmlMLFdBQXhCO0FBQ0EsS0FsQ00sQ0FvQ1A7OztBQUNBaEssTUFBRSxDQUFDa0ssZUFBSCxDQUFtQmxLLEVBQUUsQ0FBQ21LLFdBQXRCLEVBQW1DLElBQW5DO0FBQ0FuSyxNQUFFLENBQUN5SyxnQkFBSCxDQUFvQnpLLEVBQUUsQ0FBQzBLLFlBQXZCLEVBQXFDLElBQXJDO0FBQ0ExSyxNQUFFLENBQUMwSSxXQUFILENBQWUxSSxFQUFFLENBQUMySSxnQkFBbEIsRUFBb0MsSUFBcEM7QUFDQTs7QUFHRGYsTUFBSSxDQUFDK0MsWUFBRCxFQUFlO0FBRWxCO0FBQ0FoRyxtREFBRSxDQUFDaUcsUUFBSCxDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLEtBQUtoQixLQUF2QixFQUE4QixLQUFLQyxNQUFuQztBQUNBN0osTUFBRSxDQUFDa0ssZUFBSCxDQUFtQmxLLEVBQUUsQ0FBQ21LLFdBQXRCLEVBQW1DLEtBQUtKLGFBQUwsQ0FBbUJZLFlBQW5CLENBQW5DO0FBQ0E7O0FBRURFLFFBQU0sR0FBRztBQUNSN0ssTUFBRSxDQUFDa0ssZUFBSCxDQUFtQmxLLEVBQUUsQ0FBQ21LLFdBQXRCLEVBQW1DLElBQW5DO0FBQ0F4RixtREFBRSxDQUFDaUcsUUFBSCxDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCakcsK0NBQUUsQ0FBQ2lGLEtBQXJCLEVBQTRCakYsK0NBQUUsQ0FBQ2tGLE1BQS9CO0FBQ0EsR0FuRW9CLENBcUVyQjs7O0FBRUFpQixZQUFVLEdBQUc7QUFDWixXQUFPLEtBQUtyQyxTQUFaO0FBQ0EsR0F6RW9CLENBMkVyQjs7O0FBRUEsTUFBSW1CLEtBQUosR0FBWTtBQUNYLFdBQU8sS0FBSzVCLEtBQVo7QUFDQTs7QUFFRCxNQUFJNkIsTUFBSixHQUFhO0FBQ1osV0FBTyxLQUFLN0IsS0FBWjtBQUNBOztBQW5Gb0I7O0FBdUZQOUMsOEVBQWYsRTs7Ozs7Ozs7Ozs7O0FDakdBO0FBQUE7QUFBQTtBQUVBOztBQUVBLE1BQU02QixRQUFOLENBQWU7QUFFZDlFLGFBQVcsQ0FBQzhJLElBQUQsRUFBT25CLEtBQVAsRUFBY0MsTUFBZCxFQUFzQm1CLE1BQU0sR0FBQyxFQUE3QixFQUFpQ0MsV0FBVyxHQUFDLENBQTdDLEVBQWdEO0FBQzFELFNBQUtDLEtBQUwsR0FBYSxFQUFiOztBQUdBLFNBQUksSUFBSWpMLENBQUMsR0FBQyxDQUFWLEVBQWFBLENBQUMsR0FBQzhLLElBQWYsRUFBcUI5SyxDQUFDLEVBQXRCLEVBQTBCO0FBQ3pCLFlBQU1rTCxHQUFHLEdBQUcsSUFBSWxHLG9EQUFKLENBQWdCMkUsS0FBaEIsRUFBdUJDLE1BQXZCLEVBQStCbUIsTUFBL0IsRUFBdUNDLFdBQXZDLENBQVo7O0FBQ0EsV0FBS0MsS0FBTCxDQUFXbk0sSUFBWCxDQUFnQm9NLEdBQWhCO0FBQ0E7QUFFRDs7QUFHREMsTUFBSSxHQUFHO0FBQ04sVUFBTXROLENBQUMsR0FBRyxLQUFLb04sS0FBTCxDQUFXRyxLQUFYLEVBQVY7O0FBQ0EsU0FBS0gsS0FBTCxDQUFXbk0sSUFBWCxDQUFnQmpCLENBQWhCO0FBQ0E7O0FBR0QsTUFBSXdOLElBQUosR0FBVztBQUNWLFdBQU8sS0FBS0osS0FBTCxDQUFXLEtBQUtBLEtBQUwsQ0FBVzlNLE1BQVgsR0FBb0IsQ0FBL0IsQ0FBUDtBQUNBOztBQUdELE1BQUltTixLQUFKLEdBQVk7QUFDWCxXQUFPLEtBQUtMLEtBQUwsQ0FBVyxDQUFYLENBQVA7QUFDQTs7QUFHRCxNQUFJTSxHQUFKLEdBQVU7QUFDVCxXQUFPLEtBQUtOLEtBQVo7QUFDQTs7QUFoQ2E7O0FBcUNBbkUsdUVBQWYsRTs7Ozs7Ozs7Ozs7O0FDekNBO0FBQUE7QUFBQTtBQUVBOztBQUVBLE1BQU1DLFdBQU4sU0FBMEJ5RSxpREFBMUIsQ0FBb0M7QUFFbkN4SixhQUFXLENBQUMySCxLQUFELEVBQVFDLE1BQVIsRUFBZ0JtQixNQUFNLEdBQUMsRUFBdkIsRUFBMkJDLFdBQVcsR0FBQyxDQUF2QyxFQUEwQztBQUNwRCxVQUFNLENBQU4sRUFBU3JCLEtBQVQsRUFBZ0JDLE1BQWhCLEVBQXdCbUIsTUFBeEIsRUFBZ0NDLFdBQWhDO0FBQ0E7O0FBSmtDOztBQVFyQmpFLDBFQUFmLEU7Ozs7Ozs7Ozs7OztBQ1pBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBLElBQUloSCxFQUFKO0FBQ0EsSUFBSTBMLGlCQUFKO0FBQ0EsSUFBSUMsNEJBQTRCLEdBQUcsS0FBbkM7QUFDQSxJQUFJQyxhQUFKOztBQUVBLE1BQU1DLGdCQUFnQixHQUFHLFlBQVk7QUFDbkMsTUFBSWxILCtDQUFFLENBQUNtSCxNQUFQLEVBQWU7QUFDYixXQUFPLElBQVA7QUFDRCxHQUZELE1BRU87QUFDTEYsaUJBQWEsR0FBR2pILCtDQUFFLENBQUMzRyxZQUFILENBQWdCLG9CQUFoQixDQUFoQjtBQUNBLFdBQU8sQ0FBQyxDQUFDNE4sYUFBVDtBQUNEOztBQUVERCw4QkFBNEIsR0FBRyxJQUEvQjtBQUNELENBVEQ7O0FBV0EsTUFBTTFHLFdBQU4sQ0FBa0I7QUFDaEJoRCxhQUFXLENBQUU4SixNQUFGLEVBQVVDLE9BQVYsRUFBbUJqRSxXQUFXLEdBQUcsRUFBakMsRUFBcUNrRCxXQUFXLEdBQUcsQ0FBbkQsRUFBc0Q7QUFDL0RqTCxNQUFFLEdBQUcyRSwrQ0FBRSxDQUFDM0UsRUFBUjtBQUNBMEwscUJBQWlCLEdBQUcvRywrQ0FBRSxDQUFDc0gsY0FBSCxDQUFrQixxQkFBbEIsS0FBNEN0SCwrQ0FBRSxDQUFDbUgsTUFBbkU7QUFFQSxTQUFLbEMsS0FBTCxHQUFhbUMsTUFBYjtBQUNBLFNBQUtsQyxNQUFMLEdBQWNtQyxPQUFkO0FBQ0EsU0FBS0UsV0FBTCxHQUFtQmpCLFdBQW5CO0FBQ0EsU0FBS2tCLGdCQUFMLEdBQXdCbEIsV0FBVyxHQUFHLENBQXRDO0FBQ0EsU0FBS21CLFdBQUwsR0FBbUJyRSxXQUFuQjs7QUFFQSxRQUFJLENBQUM0RCw0QkFBTCxFQUFtQztBQUNqQ0Usc0JBQWdCO0FBQ2pCOztBQUVELFFBQUksS0FBS00sZ0JBQVQsRUFBMkI7QUFDekIsV0FBS0Usd0JBQUw7QUFDRDs7QUFFRCxTQUFLOUQsS0FBTDtBQUNEOztBQUVEQSxPQUFLLEdBQUk7QUFDUCxTQUFLK0QsYUFBTDs7QUFFQSxTQUFLdEMsV0FBTCxHQUFtQmhLLEVBQUUsQ0FBQ2lLLGlCQUFILEVBQW5CO0FBQ0FqSyxNQUFFLENBQUNrSyxlQUFILENBQW1CbEssRUFBRSxDQUFDbUssV0FBdEIsRUFBbUMsS0FBS0gsV0FBeEM7O0FBRUEsUUFBSXJGLCtDQUFFLENBQUNtSCxNQUFQLEVBQWU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUVBLFlBQU1TLE9BQU8sR0FBRyxFQUFoQjs7QUFDQSxXQUFLLElBQUl0TSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtpTSxXQUF6QixFQUFzQ2pNLENBQUMsRUFBdkMsRUFBMkM7QUFDekNELFVBQUUsQ0FBQ29LLG9CQUFILENBQXdCcEssRUFBRSxDQUFDd00sZ0JBQTNCLEVBQTZDeE0sRUFBRSxDQUFDcUssaUJBQUgsR0FBdUJwSyxDQUFwRSxFQUF1RUQsRUFBRSxDQUFDeU0sVUFBMUUsRUFBc0YsS0FBS0MsU0FBTCxDQUFlek0sQ0FBZixFQUFrQnBCLE9BQXhHLEVBQWlILENBQWpIO0FBQ0EwTixlQUFPLENBQUN4TixJQUFSLENBQWFpQixFQUFFLENBQUUsbUJBQWtCQyxDQUFFLEVBQXRCLENBQWY7QUFDRDs7QUFFREQsUUFBRSxDQUFDMk0sV0FBSCxDQUFlSixPQUFmO0FBRUF2TSxRQUFFLENBQUNvSyxvQkFBSCxDQUF3QnBLLEVBQUUsQ0FBQ3dNLGdCQUEzQixFQUE2Q3hNLEVBQUUsQ0FBQzRNLGdCQUFoRCxFQUFrRTVNLEVBQUUsQ0FBQ3lNLFVBQXJFLEVBQWlGLEtBQUtJLGNBQUwsQ0FBb0JoTyxPQUFyRyxFQUE4RyxDQUE5RztBQUNELEtBZkQsTUFlTztBQUNMLFdBQUssSUFBSW9CLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS2lNLFdBQXpCLEVBQXNDak0sQ0FBQyxFQUF2QyxFQUEyQztBQUN6Q0QsVUFBRSxDQUFDb0ssb0JBQUgsQ0FBd0JwSyxFQUFFLENBQUNtSyxXQUEzQixFQUF3Q25LLEVBQUUsQ0FBQ3FLLGlCQUFILEdBQXVCcEssQ0FBL0QsRUFBa0VELEVBQUUsQ0FBQ3lNLFVBQXJFLEVBQWlGLEtBQUtDLFNBQUwsQ0FBZXpNLENBQWYsRUFBa0JwQixPQUFuRyxFQUE0RyxDQUE1RztBQUNEOztBQUVELFVBQUksS0FBS3NOLGdCQUFULEVBQTJCO0FBQ3pCLGNBQU1RLFdBQVcsR0FBRyxFQUFwQjs7QUFDQSxhQUFLLElBQUkxTSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtpTSxXQUF6QixFQUFzQ2pNLENBQUMsRUFBdkMsRUFBMkM7QUFDekMwTSxxQkFBVyxDQUFDNU4sSUFBWixDQUFpQjZNLGFBQWEsQ0FBRSxtQkFBa0IzTCxDQUFFLFFBQXRCLENBQTlCO0FBQ0Q7O0FBRUQyTCxxQkFBYSxDQUFDa0IsZ0JBQWQsQ0FBK0JILFdBQS9CO0FBQ0Q7O0FBRUQsVUFBSWpCLGlCQUFKLEVBQXVCO0FBQ3JCMUwsVUFBRSxDQUFDb0ssb0JBQUgsQ0FBd0JwSyxFQUFFLENBQUNtSyxXQUEzQixFQUF3Q25LLEVBQUUsQ0FBQzRNLGdCQUEzQyxFQUE2RDVNLEVBQUUsQ0FBQ3lNLFVBQWhFLEVBQTRFLEtBQUtJLGNBQUwsQ0FBb0JoTyxPQUFoRyxFQUF5RyxDQUF6RztBQUNEO0FBQ0YsS0F0Q00sQ0F3Q1A7OztBQUNBLFVBQU1rTyxTQUFTLEdBQUcvTSxFQUFFLENBQUN1SyxzQkFBSCxDQUEwQnZLLEVBQUUsQ0FBQ21LLFdBQTdCLENBQWxCOztBQUNBLFFBQUk0QyxTQUFTLElBQUkvTSxFQUFFLENBQUN3SyxvQkFBcEIsRUFBMEM7QUFDeEMvSyxhQUFPLENBQUN1TixLQUFSLENBQWMsV0FBZCxFQUEyQkQsU0FBM0I7QUFDQXROLGFBQU8sQ0FBQ3VOLEtBQVIsQ0FBYyx3REFBZDtBQUNELEtBN0NNLENBK0NQOzs7QUFFQWhOLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLElBQTlCO0FBQ0F6TSxNQUFFLENBQUN5SyxnQkFBSCxDQUFvQnpLLEVBQUUsQ0FBQzBLLFlBQXZCLEVBQXFDLElBQXJDO0FBQ0ExSyxNQUFFLENBQUNrSyxlQUFILENBQW1CbEssRUFBRSxDQUFDbUssV0FBdEIsRUFBbUMsSUFBbkMsRUFuRE8sQ0FxRFA7O0FBRUEsU0FBSzhDLEtBQUw7QUFDRDs7QUFFRFosMEJBQXdCLEdBQUk7QUFDMUIsVUFBTWEsaUJBQWlCLEdBQUd2SSwrQ0FBRSxDQUFDM0UsRUFBSCxDQUFNbU4sWUFBTixDQUFtQnZCLGFBQWEsQ0FBQ3dCLHNCQUFqQyxDQUExQjs7QUFDQSxRQUFJLEtBQUtsQixXQUFMLEdBQW1CZ0IsaUJBQXZCLEVBQTBDO0FBQ3hDek4sYUFBTyxDQUFDdU4sS0FBUixDQUFjLDhDQUFkLEVBQThERSxpQkFBOUQ7QUFDQSxXQUFLaEIsV0FBTCxHQUFtQmdCLGlCQUFuQjtBQUNEO0FBQ0Y7O0FBRURaLGVBQWEsR0FBSTtBQUNmLFNBQUtJLFNBQUwsR0FBaUIsRUFBakI7O0FBQ0EsU0FBSyxJQUFJek0sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLaU0sV0FBekIsRUFBc0NqTSxDQUFDLEVBQXZDLEVBQTJDO0FBQ3pDLFlBQU1vTixHQUFHLEdBQUcsS0FBS0MsY0FBTCxFQUFaOztBQUNBLFdBQUtaLFNBQUwsQ0FBZTNOLElBQWYsQ0FBb0JzTyxHQUFwQjtBQUNEOztBQUVELFFBQUkxSSwrQ0FBRSxDQUFDbUgsTUFBUCxFQUFlO0FBQ2IsV0FBS2UsY0FBTCxHQUFzQixLQUFLUyxjQUFMLENBQW9CdE4sRUFBRSxDQUFDdU4saUJBQXZCLEVBQTBDdk4sRUFBRSxDQUFDd04sY0FBN0MsRUFBNkR4TixFQUFFLENBQUN5TixlQUFoRSxFQUFpRjtBQUFFdEYsaUJBQVMsRUFBRXhELCtDQUFFLENBQUMrSSxPQUFoQjtBQUF5QnpGLGlCQUFTLEVBQUV0RCwrQ0FBRSxDQUFDK0ksT0FBdkM7QUFBZ0RDLGNBQU0sRUFBRTtBQUF4RCxPQUFqRixDQUF0QjtBQUNELEtBRkQsTUFFTztBQUNMLFdBQUtkLGNBQUwsR0FBc0IsS0FBS1MsY0FBTCxDQUFvQnROLEVBQUUsQ0FBQ3lOLGVBQXZCLEVBQXdDek4sRUFBRSxDQUFDd04sY0FBM0MsRUFBMkR4TixFQUFFLENBQUN5TixlQUE5RCxFQUErRTtBQUFFdEYsaUJBQVMsRUFBRXhELCtDQUFFLENBQUN1RDtBQUFoQixPQUEvRSxDQUF0QjtBQUNEO0FBQ0Y7O0FBRURvRixnQkFBYyxDQUFFTSxlQUFGLEVBQW1CQyxVQUFuQixFQUErQkMsT0FBL0IsRUFBd0MvRixXQUFXLEdBQUcsRUFBdEQsRUFBMEQ7QUFDdEUsVUFBTWdHLFVBQVUsR0FBR0MsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLN0IsV0FBdkIsQ0FBbkI7O0FBQ0EsUUFBSSxDQUFDMEIsT0FBTCxFQUFjO0FBQUVBLGFBQU8sR0FBR0YsZUFBVjtBQUEyQjs7QUFFM0NHLGNBQVUsQ0FBQ0csY0FBWCxHQUE0Qk4sZUFBZSxJQUFJNU4sRUFBRSxDQUFDMkosSUFBbEQ7QUFDQW9FLGNBQVUsQ0FBQ0ksTUFBWCxHQUFvQkwsT0FBcEI7QUFFQUMsY0FBVSxDQUFDSyxJQUFYLEdBQWtCTCxVQUFVLENBQUNLLElBQVgsSUFBbUJQLFVBQW5CLElBQWlDbEosK0NBQUUsQ0FBQzBKLGFBQXREOztBQUNBLFFBQUlSLFVBQVUsS0FBSzdOLEVBQUUsQ0FBQ3dOLGNBQXRCLEVBQXNDO0FBQUU7QUFDdENPLGdCQUFVLENBQUNLLElBQVgsR0FBa0JQLFVBQWxCO0FBQ0Q7O0FBRUQsU0FBSyxNQUFNbE8sQ0FBWCxJQUFnQm9JLFdBQWhCLEVBQTZCO0FBQzNCZ0csZ0JBQVUsQ0FBQ3BPLENBQUQsQ0FBVixHQUFnQm9JLFdBQVcsQ0FBQ3BJLENBQUQsQ0FBM0I7QUFDRDs7QUFFRCxVQUFNZCxPQUFPLEdBQUcsSUFBSXlQLG1EQUFKLENBQWUsSUFBZixFQUFxQlAsVUFBckIsRUFBaUMsS0FBS25FLEtBQXRDLEVBQTZDLEtBQUtDLE1BQWxELENBQWhCO0FBQ0EsV0FBT2hMLE9BQVA7QUFDRCxHQXhIZSxDQTBIaEI7OztBQUVBK0ksTUFBSSxDQUFFMkcsZ0JBQWdCLEdBQUcsSUFBckIsRUFBMkI7QUFDN0IsUUFBSUEsZ0JBQUosRUFBc0I7QUFDcEI1SixxREFBRSxDQUFDaUcsUUFBSCxDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLEtBQUtoQixLQUF2QixFQUE4QixLQUFLQyxNQUFuQztBQUNEOztBQUNEN0osTUFBRSxDQUFDa0ssZUFBSCxDQUFtQmxLLEVBQUUsQ0FBQ21LLFdBQXRCLEVBQW1DLEtBQUtILFdBQXhDO0FBQ0Q7O0FBRURhLFFBQU0sQ0FBRTBELGdCQUFnQixHQUFHLElBQXJCLEVBQTJCO0FBQy9CLFFBQUlBLGdCQUFKLEVBQXNCO0FBQ3BCNUoscURBQUUsQ0FBQ2lHLFFBQUgsQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQmpHLCtDQUFFLENBQUNpRixLQUFyQixFQUE0QmpGLCtDQUFFLENBQUNrRixNQUEvQjtBQUNEOztBQUNEN0osTUFBRSxDQUFDa0ssZUFBSCxDQUFtQmxLLEVBQUUsQ0FBQ21LLFdBQXRCLEVBQW1DLElBQW5DOztBQUVBLFNBQUt1QyxTQUFMLENBQWU3TCxPQUFmLENBQXVCaEMsT0FBTyxJQUFJO0FBQ2hDQSxhQUFPLENBQUMyUCxjQUFSO0FBQ0QsS0FGRDtBQUdEOztBQUVEdkIsT0FBSyxDQUFFd0IsQ0FBQyxHQUFHLENBQU4sRUFBU0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JDLENBQUMsR0FBRyxDQUFwQixFQUF1QjdRLENBQUMsR0FBRyxDQUEzQixFQUE4QjtBQUNqQyxTQUFLOEosSUFBTDtBQUNBakQsbURBQUUsQ0FBQ3NJLEtBQUgsQ0FBU3dCLENBQVQsRUFBWUMsQ0FBWixFQUFlQyxDQUFmLEVBQWtCN1EsQ0FBbEI7QUFDQSxTQUFLK00sTUFBTDtBQUNELEdBbEplLENBb0poQjs7O0FBRUFDLFlBQVUsQ0FBRThELE1BQU0sR0FBRyxDQUFYLEVBQWM7QUFDdEIsV0FBTyxLQUFLbEMsU0FBTCxDQUFla0MsTUFBZixDQUFQO0FBQ0Q7O0FBRURDLGlCQUFlLEdBQUk7QUFDakIsV0FBTyxLQUFLaEMsY0FBWjtBQUNEOztBQUVELE1BQUloTyxPQUFKLEdBQWU7QUFBRSxXQUFPLEtBQUs2TixTQUFMLENBQWUsQ0FBZixDQUFQO0FBQTBCOztBQUUzQyxNQUFJb0MsWUFBSixHQUFvQjtBQUFFLFdBQU8sS0FBS2pDLGNBQVo7QUFBNEIsR0FoS2xDLENBa0toQjtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQSxNQUFJMUUsU0FBSixHQUFpQjtBQUFFLFdBQU8sS0FBS3VFLFNBQUwsQ0FBZSxDQUFmLEVBQWtCdkUsU0FBekI7QUFBb0M7O0FBRXZELE1BQUlBLFNBQUosQ0FBZTdGLE1BQWYsRUFBdUI7QUFDckIsU0FBS29LLFNBQUwsQ0FBZTdMLE9BQWYsQ0FBdUJoQyxPQUFPLElBQUk7QUFDaENBLGFBQU8sQ0FBQ3NKLFNBQVIsR0FBb0I3RixNQUFwQjtBQUNELEtBRkQ7QUFHRDs7QUFFRCxNQUFJMkYsU0FBSixHQUFpQjtBQUFFLFdBQU8sS0FBS3lFLFNBQUwsQ0FBZSxDQUFmLEVBQWtCekUsU0FBekI7QUFBb0M7O0FBRXZELE1BQUlBLFNBQUosQ0FBZTNGLE1BQWYsRUFBdUI7QUFDckIsU0FBS29LLFNBQUwsQ0FBZTdMLE9BQWYsQ0FBdUJoQyxPQUFPLElBQUk7QUFDaENBLGFBQU8sQ0FBQ29KLFNBQVIsR0FBb0IzRixNQUFwQjtBQUNELEtBRkQ7QUFHRCxHQXZMZSxDQXlMaEI7OztBQUVBLE1BQUk4RixLQUFKLEdBQWE7QUFBRSxXQUFPLEtBQUtzRSxTQUFMLENBQWUsQ0FBZixFQUFrQnRFLEtBQXpCO0FBQWdDOztBQUUvQyxNQUFJQSxLQUFKLENBQVc5RixNQUFYLEVBQW1CO0FBQ2pCLFNBQUtvSyxTQUFMLENBQWU3TCxPQUFmLENBQXVCaEMsT0FBTyxJQUFJO0FBQ2hDQSxhQUFPLENBQUN1SixLQUFSLEdBQWdCOUYsTUFBaEI7QUFDRCxLQUZEO0FBR0Q7O0FBRUQsTUFBSWdHLEtBQUosR0FBYTtBQUFFLFdBQU8sS0FBS29FLFNBQUwsQ0FBZSxDQUFmLEVBQWtCcEUsS0FBekI7QUFBZ0M7O0FBRS9DLE1BQUlBLEtBQUosQ0FBV2hHLE1BQVgsRUFBbUI7QUFDakIsU0FBS29LLFNBQUwsQ0FBZTdMLE9BQWYsQ0FBdUJoQyxPQUFPLElBQUk7QUFDaENBLGFBQU8sQ0FBQ3lKLEtBQVIsR0FBZ0JoRyxNQUFoQjtBQUNELEtBRkQ7QUFHRCxHQXpNZSxDQTJNaEI7OztBQUVBeU0sZ0JBQWMsR0FBSTtBQUNoQixTQUFLckMsU0FBTCxDQUFlLENBQWYsRUFBa0JxQyxjQUFsQjtBQUNEOztBQUVELE1BQUlDLFVBQUosR0FBa0I7QUFBRSxXQUFPLEtBQUs5QyxXQUFaO0FBQXlCOztBQWpON0I7O0FBb05IakgsMEVBQWYsRTs7Ozs7Ozs7Ozs7O0FDMU9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFYTs7QUFFYjtBQUNBO0FBQ0EsSUFBSWpGLEVBQUo7QUFDQSxNQUFNaVAsZ0JBQWdCLEdBQUcsT0FBekI7QUFDQSxNQUFNQyxlQUFlLEdBQUcsQ0FBeEI7QUFDQSxNQUFNQyxlQUFlLEdBQUcsRUFBeEI7O0FBRUEsTUFBTTlQLGFBQU4sQ0FBb0I7QUFDbkI0QyxhQUFXLENBQUNtTixPQUFELEVBQVVySCxXQUFXLEdBQUcsRUFBeEIsRUFBNEJzSCxhQUFhLEdBQUcsS0FBNUMsRUFBbUQ7QUFDN0RyUCxNQUFFLEdBQUcyRSwrQ0FBRSxDQUFDM0UsRUFBUjs7QUFFQSxRQUFHcVAsYUFBSCxFQUFrQjtBQUNqQixXQUFLeFEsT0FBTCxHQUFldVEsT0FBZjtBQUNBO0FBQ0E7O0FBRUQsUUFBSUUsVUFBVSxHQUFHRixPQUFPLENBQUNoUixNQUFSLEdBQWlCLENBQWxDOztBQUNBLFFBQUdnUixPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVdHLFdBQWQsRUFBMkI7QUFDMUJELGdCQUFVLEdBQUdGLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBV0csV0FBWCxHQUF5QixDQUF0QztBQUNBOztBQUVELFNBQUsxUSxPQUFMLEdBQWlCbUIsRUFBRSxDQUFDd0ksYUFBSCxFQUFqQjtBQUNBLFNBQUtQLFNBQUwsR0FBaUJGLFdBQVcsQ0FBQ0UsU0FBWixJQUF5QmpJLEVBQUUsQ0FBQ2tJLE1BQTdDO0FBQ0EsU0FBS0MsU0FBTCxHQUFpQkosV0FBVyxDQUFDSSxTQUFaLElBQXlCbkksRUFBRSxDQUFDd1Asb0JBQTdDO0FBQ0EsU0FBS3BILEtBQUwsR0FBaUJMLFdBQVcsQ0FBQ0ssS0FBWixJQUFxQnBJLEVBQUUsQ0FBQ3FJLGFBQXpDO0FBQ0EsU0FBS0MsS0FBTCxHQUFpQlAsV0FBVyxDQUFDTyxLQUFaLElBQXFCdEksRUFBRSxDQUFDcUksYUFBekM7O0FBRUEsUUFBRyxDQUFDaUgsVUFBRCxJQUFlLEtBQUtuSCxTQUFMLElBQWtCbkksRUFBRSxDQUFDd1Asb0JBQXZDLEVBQTZEO0FBQzVELFdBQUtySCxTQUFMLEdBQWlCbkksRUFBRSxDQUFDa0ksTUFBcEI7QUFDQTs7QUFFRGxJLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQzJJLGdCQUFsQixFQUFvQyxLQUFLOUosT0FBekM7QUFDQSxVQUFNb0ssT0FBTyxHQUFHLENBQ2ZqSixFQUFFLENBQUNrSiwyQkFEWSxFQUNpQmxKLEVBQUUsQ0FBQ21KLDJCQURwQixFQUVmbkosRUFBRSxDQUFDb0osMkJBRlksRUFFaUJwSixFQUFFLENBQUNxSiwyQkFGcEIsRUFHZnJKLEVBQUUsQ0FBQ3NKLDJCQUhZLEVBR2lCdEosRUFBRSxDQUFDdUosMkJBSHBCLENBQWhCO0FBT0EsUUFBSWtHLFNBQVMsR0FBRyxDQUFoQjtBQUNBLFFBQUlDLEtBQUssR0FBRyxDQUFaO0FBQ0FELGFBQVMsR0FBR0wsT0FBTyxDQUFDaFIsTUFBUixHQUFpQixDQUE3QjtBQUNBLFNBQUtxUixTQUFMLEdBQWlCQSxTQUFqQjs7QUFFQSxRQUFJSCxVQUFKLEVBQWdCO0FBQ2YsV0FBSyxJQUFJSyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLENBQXBCLEVBQXVCQSxDQUFDLEVBQXhCLEVBQTRCO0FBQzNCLGFBQUssSUFBSTFQLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd3UCxTQUFwQixFQUErQnhQLENBQUMsRUFBaEMsRUFBb0M7QUFDbkNELFlBQUUsQ0FBQ3dKLFdBQUgsQ0FBZXhKLEVBQUUsQ0FBQ3lKLG1CQUFsQixFQUF1QyxLQUF2QztBQUVBaUcsZUFBSyxHQUFHQyxDQUFDLEdBQUdGLFNBQUosR0FBZ0J4UCxDQUF4Qjs7QUFDQSxjQUFHbVAsT0FBTyxDQUFDTSxLQUFELENBQVAsQ0FBZUUsS0FBbEIsRUFBeUI7QUFDeEI1UCxjQUFFLENBQUMwSixVQUFILENBQWNULE9BQU8sQ0FBQzBHLENBQUQsQ0FBckIsRUFBMEIxUCxDQUExQixFQUE2QkQsRUFBRSxDQUFDMkosSUFBaEMsRUFBc0N5RixPQUFPLENBQUNNLEtBQUQsQ0FBUCxDQUFlRSxLQUFmLENBQXFCLENBQXJCLENBQXRDLEVBQStEUixPQUFPLENBQUNNLEtBQUQsQ0FBUCxDQUFlRSxLQUFmLENBQXFCLENBQXJCLENBQS9ELEVBQXdGLENBQXhGLEVBQTJGNVAsRUFBRSxDQUFDMkosSUFBOUYsRUFBb0czSixFQUFFLENBQUM4SixLQUF2RyxFQUE4R3NGLE9BQU8sQ0FBQ00sS0FBRCxDQUFQLENBQWVHLElBQTdIO0FBQ0EsV0FGRCxNQUVPO0FBQ043UCxjQUFFLENBQUMwSixVQUFILENBQWNULE9BQU8sQ0FBQzBHLENBQUQsQ0FBckIsRUFBMEIxUCxDQUExQixFQUE2QkQsRUFBRSxDQUFDMkosSUFBaEMsRUFBc0MzSixFQUFFLENBQUMySixJQUF6QyxFQUErQzNKLEVBQUUsQ0FBQ3FPLGFBQWxELEVBQWlFZSxPQUFPLENBQUNNLEtBQUQsQ0FBeEU7QUFDQTs7QUFFRDFQLFlBQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUMySSxnQkFBcEIsRUFBc0MzSSxFQUFFLENBQUMrSSxjQUF6QyxFQUF5RCxLQUFLWCxLQUE5RDtBQUNBcEksWUFBRSxDQUFDNEksYUFBSCxDQUFpQjVJLEVBQUUsQ0FBQzJJLGdCQUFwQixFQUFzQzNJLEVBQUUsQ0FBQ2dKLGNBQXpDLEVBQXlELEtBQUtWLEtBQTlEO0FBQ0F0SSxZQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDMkksZ0JBQXBCLEVBQXNDM0ksRUFBRSxDQUFDNkksa0JBQXpDLEVBQTZELEtBQUtaLFNBQWxFO0FBQ0FqSSxZQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDMkksZ0JBQXBCLEVBQXNDM0ksRUFBRSxDQUFDOEksa0JBQXpDLEVBQTZELEtBQUtYLFNBQWxFO0FBQ0E7QUFDRDtBQUNELEtBbEJELE1Ba0JPO0FBQ04sVUFBSXVILEtBQUssR0FBRyxDQUFaOztBQUNBLFdBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxDQUFwQixFQUF1QkEsQ0FBQyxFQUF4QixFQUE0QjtBQUMzQkQsYUFBSyxHQUFHQyxDQUFDLEdBQUdGLFNBQVo7QUFDQXpQLFVBQUUsQ0FBQ3dKLFdBQUgsQ0FBZXhKLEVBQUUsQ0FBQ3lKLG1CQUFsQixFQUF1QyxLQUF2Qzs7QUFDQSxZQUFHMkYsT0FBTyxDQUFDTSxLQUFELENBQVAsQ0FBZUUsS0FBbEIsRUFBeUI7QUFDeEI1UCxZQUFFLENBQUMwSixVQUFILENBQWNULE9BQU8sQ0FBQzBHLENBQUQsQ0FBckIsRUFBMEIsQ0FBMUIsRUFBNkIzUCxFQUFFLENBQUMySixJQUFoQyxFQUFzQ3lGLE9BQU8sQ0FBQ00sS0FBRCxDQUFQLENBQWVFLEtBQWYsQ0FBcUIsQ0FBckIsQ0FBdEMsRUFBK0RSLE9BQU8sQ0FBQ00sS0FBRCxDQUFQLENBQWVFLEtBQWYsQ0FBcUIsQ0FBckIsQ0FBL0QsRUFBd0YsQ0FBeEYsRUFBMkY1UCxFQUFFLENBQUMySixJQUE5RixFQUFvRzNKLEVBQUUsQ0FBQzhKLEtBQXZHLEVBQThHc0YsT0FBTyxDQUFDTSxLQUFELENBQVAsQ0FBZUcsSUFBN0g7QUFDQSxTQUZELE1BRU87QUFDTjdQLFlBQUUsQ0FBQzBKLFVBQUgsQ0FBY1QsT0FBTyxDQUFDMEcsQ0FBRCxDQUFyQixFQUEwQixDQUExQixFQUE2QjNQLEVBQUUsQ0FBQzJKLElBQWhDLEVBQXNDM0osRUFBRSxDQUFDMkosSUFBekMsRUFBK0MzSixFQUFFLENBQUNxTyxhQUFsRCxFQUFpRWUsT0FBTyxDQUFDTSxLQUFELENBQXhFO0FBQ0E7O0FBQ0QxUCxVQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDMkksZ0JBQXBCLEVBQXNDM0ksRUFBRSxDQUFDK0ksY0FBekMsRUFBeUQsS0FBS1gsS0FBOUQ7QUFDQXBJLFVBQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUMySSxnQkFBcEIsRUFBc0MzSSxFQUFFLENBQUNnSixjQUF6QyxFQUF5RCxLQUFLVixLQUE5RDtBQUNBdEksVUFBRSxDQUFDNEksYUFBSCxDQUFpQjVJLEVBQUUsQ0FBQzJJLGdCQUFwQixFQUFzQzNJLEVBQUUsQ0FBQzZJLGtCQUF6QyxFQUE2RCxLQUFLWixTQUFsRTtBQUNBakksVUFBRSxDQUFDNEksYUFBSCxDQUFpQjVJLEVBQUUsQ0FBQzJJLGdCQUFwQixFQUFzQzNJLEVBQUUsQ0FBQzhJLGtCQUF6QyxFQUE2RCxLQUFLWCxTQUFsRTtBQUNBOztBQUVEbkksUUFBRSxDQUFDd08sY0FBSCxDQUFrQnhPLEVBQUUsQ0FBQzJJLGdCQUFyQjtBQUNBOztBQUVEM0ksTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDMkksZ0JBQWxCLEVBQW9DLElBQXBDO0FBQ0EsR0EzRWtCLENBK0VuQjs7O0FBRUFmLE1BQUksQ0FBQzhILEtBQUssR0FBRyxDQUFULEVBQVk7QUFDZixRQUFHLENBQUMvSywrQ0FBRSxDQUFDa0QsTUFBUCxFQUFlO0FBQUU7QUFBUzs7QUFFMUI3SCxNQUFFLENBQUM4UCxhQUFILENBQWlCOVAsRUFBRSxDQUFDK1AsUUFBSCxHQUFjTCxLQUEvQjtBQUNBMVAsTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDMkksZ0JBQWxCLEVBQW9DLEtBQUs5SixPQUF6QztBQUNBbUIsTUFBRSxDQUFDZ1EsU0FBSCxDQUFhckwsK0NBQUUsQ0FBQ2tELE1BQUgsQ0FBVW9JLGVBQVYsQ0FBMEJQLEtBQTFCLENBQWIsRUFBK0NBLEtBQS9DO0FBQ0EsU0FBS1EsVUFBTCxHQUFrQlIsS0FBbEI7QUFDQTs7QUFFRDdFLFFBQU0sR0FBRztBQUNSN0ssTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDMkksZ0JBQWxCLEVBQW9DLElBQXBDO0FBQ0E7O0FBNUZrQjs7QUFnR3BCdEosYUFBYSxDQUFDQyxRQUFkLEdBQXlCLFNBQVNBLFFBQVQsQ0FBa0I2USxZQUFsQixFQUFnQztBQUV4RCxXQUFTQyxLQUFULENBQWU1TixLQUFmLEVBQXNCNk4sR0FBdEIsRUFBMkJDLEdBQTNCLEVBQWdDO0FBQy9CLFFBQUlELEdBQUcsR0FBR0MsR0FBVixFQUFlO0FBQ2QsYUFBT0YsS0FBSyxDQUFDNU4sS0FBRCxFQUFROE4sR0FBUixFQUFhRCxHQUFiLENBQVo7QUFDQTs7QUFFRCxRQUFJN04sS0FBSyxHQUFHNk4sR0FBWixFQUFpQixPQUFPQSxHQUFQLENBQWpCLEtBQ0ssSUFBSTdOLEtBQUssR0FBRzhOLEdBQVosRUFBaUIsT0FBT0EsR0FBUCxDQUFqQixLQUNBLE9BQU85TixLQUFQO0FBQ0wsR0FWdUQsQ0FZeEQ7OztBQUNBLFFBQU0rTixRQUFRLEdBQUdwUixnREFBSyxDQUFDZ1IsWUFBRCxDQUF0QjtBQUNBLFFBQU07QUFBRUs7QUFBRixNQUFZRCxRQUFsQjtBQUNBLFFBQU1FLE1BQU0sR0FBRyxJQUFJQyxVQUFKLENBQWVQLFlBQWYsRUFBNkIsQ0FBN0IsRUFBZ0NoQixlQUFoQyxDQUFmO0FBQ0EsTUFBSUksV0FBVyxHQUFHLENBQWxCOztBQUNBLE1BQUlpQixLQUFLLEdBQUd2QixnQkFBWixFQUE4QjtBQUM3Qk0sZUFBVyxHQUFHb0IsSUFBSSxDQUFDTCxHQUFMLENBQVMsQ0FBVCxFQUFZRyxNQUFNLENBQUN2QixlQUFELENBQWxCLENBQWQ7QUFDQTs7QUFDRCxRQUFNMEIsT0FBTyxHQUFHTCxRQUFRLENBQUNNLE1BQVQsQ0FBZ0JwUyxHQUFoQixDQUFxQitDLEdBQUQsSUFBUztBQUM1QyxVQUFNc1AsUUFBUSxHQUFHLElBQUlDLFlBQUosQ0FBaUJaLFlBQVksQ0FBQ2EsS0FBYixDQUFtQnhQLEdBQUcsQ0FBQ3lQLE1BQXZCLEVBQStCelAsR0FBRyxDQUFDeVAsTUFBSixHQUFhelAsR0FBRyxDQUFDcEQsTUFBaEQsQ0FBakIsQ0FBakI7QUFDQSxXQUFPO0FBQ055UixVQUFJLEVBQUVpQixRQURBO0FBRU5sQixXQUFLLEVBQUVwTyxHQUFHLENBQUNvTyxLQUZMO0FBR05MO0FBSE0sS0FBUDtBQUtBLEdBUGUsQ0FBaEI7QUFTQSxTQUFPLElBQUlsUSxhQUFKLENBQWtCdVIsT0FBbEIsQ0FBUDtBQUNBLENBOUJEOztBQWlDZXZSLDRFQUFmLEU7Ozs7Ozs7Ozs7OztBQzVJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU02UixNQUFNLEdBQUcsQ0FBQ0MsTUFBRCxFQUFTQyxNQUFULEtBQW9CO0FBQ2xDLE1BQUdELE1BQU0sQ0FBQy9TLE1BQVAsS0FBa0JnVCxNQUFNLENBQUNoVCxNQUE1QixFQUFvQztBQUNuQyxXQUFPLEtBQVA7QUFDQTs7QUFFRCxPQUFJLElBQUk2QixDQUFDLEdBQUcsQ0FBWixFQUFlQSxDQUFDLEdBQUdrUixNQUFNLENBQUMvUyxNQUExQixFQUFrQzZCLENBQUMsRUFBbkMsRUFBdUM7QUFDdEMsUUFBR2tSLE1BQU0sQ0FBQ2xSLENBQUQsQ0FBTixLQUFjbVIsTUFBTSxDQUFDblIsQ0FBRCxDQUF2QixFQUE0QjtBQUMzQixhQUFPLEtBQVA7QUFDQTtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNBLENBWkQ7O0FBY0EsTUFBTW9SLGNBQWMsR0FBSUMsTUFBRCxJQUFZO0FBQ2xDLFFBQU1DLEtBQUssR0FBR0QsTUFBTSxDQUFDblQsS0FBUCxDQUFhLElBQWIsQ0FBZDs7QUFDQSxPQUFLLElBQUk4QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc1IsS0FBSyxDQUFDblQsTUFBMUIsRUFBa0M2QixDQUFDLEVBQW5DLEVBQXdDO0FBQ3ZDc1IsU0FBSyxDQUFDdFIsQ0FBRCxDQUFMLEdBQVksR0FBR0EsQ0FBQyxHQUFHLENBQUcsS0FBSXNSLEtBQUssQ0FBQ3RSLENBQUQsQ0FBSSxFQUFuQztBQUNBOztBQUNELFNBQU9zUixLQUFLLENBQUNDLElBQU4sQ0FBVyxJQUFYLENBQVA7QUFDQSxDQU5EOztBQVNBLE1BQU1DLFVBQVUsR0FBSUMsTUFBRCxJQUFZO0FBQzlCLE1BQUdBLE1BQU0sQ0FBQ1YsS0FBVixFQUFpQjtBQUNoQixXQUFPVSxNQUFNLENBQUNWLEtBQVAsQ0FBYSxDQUFiLENBQVA7QUFDQSxHQUZELE1BRU87QUFDTixXQUFPLElBQUlELFlBQUosQ0FBaUJXLE1BQWpCLENBQVA7QUFDQTtBQUNELENBTkQ7O0FBUUEsSUFBSTFSLEVBQUo7QUFFQSxNQUFNMlIsY0FBYyxHQUFHO0FBQ3RCQyxPQUFLLEVBQUUsV0FEZTtBQUV0QkMsTUFBSSxFQUFFLFlBRmdCO0FBR3RCQyxNQUFJLEVBQUUsWUFIZ0I7QUFJdEJDLE1BQUksRUFBRSxZQUpnQjtBQUt0QkMsS0FBRyxFQUFFLFdBTGlCO0FBTXRCQyxNQUFJLEVBQUUsa0JBTmdCO0FBT3RCQyxNQUFJLEVBQUU7QUFQZ0IsQ0FBdkI7O0FBVUEsTUFBTXJOLFFBQU4sQ0FBZTtBQUNkNUMsYUFBVyxDQUFDa1EsZUFBZSxHQUFHQywyREFBbkIsRUFBd0NDLGlCQUFpQixHQUFHQywyREFBNUQsRUFBbUZDLFNBQW5GLEVBQThGO0FBRXhHdlMsTUFBRSxHQUFxQjJFLCtDQUFFLENBQUMzRSxFQUExQjtBQUNBLFNBQUsrTixVQUFMLEdBQXVCLEVBQXZCO0FBQ0EsU0FBS2tDLGVBQUwsR0FBdUIsRUFBdkI7QUFDQSxTQUFLdUMsU0FBTCxHQUFvQkQsU0FBcEI7O0FBRUEsUUFBRyxDQUFDSixlQUFKLEVBQXFCO0FBQUVBLHFCQUFlLEdBQUdDLDJEQUFsQjtBQUF3Qzs7QUFDL0QsUUFBRyxDQUFDQyxpQkFBSixFQUF1QjtBQUFFQSx1QkFBaUIsR0FBR0QsMkRBQXBCO0FBQTBDOztBQUVuRSxVQUFNSyxRQUFRLEdBQUcsS0FBS0Msb0JBQUwsQ0FBMEJQLGVBQTFCLEVBQTJDLElBQTNDLENBQWpCOztBQUNBLFVBQU1RLFFBQVEsR0FBRyxLQUFLRCxvQkFBTCxDQUEwQkwsaUJBQTFCLEVBQTZDLEtBQTdDLENBQWpCOztBQUNBLFNBQUtPLG9CQUFMLENBQTBCSCxRQUExQixFQUFvQ0UsUUFBcEM7QUFFQTs7QUFHRC9LLE1BQUksR0FBRztBQUVOLFFBQUdqRCwrQ0FBRSxDQUFDa0QsTUFBSCxLQUFjLElBQWpCLEVBQXVCO0FBQ3RCO0FBQ0E7O0FBQ0Q3SCxNQUFFLENBQUM2UyxVQUFILENBQWMsS0FBS0MsYUFBbkI7QUFDQW5PLG1EQUFFLENBQUNvTyxTQUFILENBQWEsSUFBYjtBQUNBLFNBQUs5QyxlQUFMLEdBQXVCLEVBQXZCO0FBRUE7O0FBR0QrQyxTQUFPLENBQUNDLEtBQUQsRUFBUUMsS0FBUixFQUFlNVEsTUFBZixFQUF1QjtBQUM3QixRQUFHLE9BQU8yUSxLQUFQLEtBQWlCLFFBQXBCLEVBQThCO0FBQzdCLFdBQUtFLGFBQUwsQ0FBbUJGLEtBQW5CO0FBQ0E7QUFDQTtBQUNEOzs7Ozs7OztBQU1BLFVBQU1HLFdBQVcsR0FBR3pCLGNBQWMsQ0FBQ3VCLEtBQUQsQ0FBZCxJQUF5QkEsS0FBN0M7QUFFQSxRQUFJRyxVQUFVLEdBQUcsS0FBakI7QUFDQSxRQUFJQyxRQUFKO0FBQ0EsUUFBSUMsY0FBYyxHQUFHLENBQUMsQ0FBdEI7O0FBR0EsU0FBSSxJQUFJdFQsQ0FBQyxHQUFHLENBQVosRUFBZUEsQ0FBQyxHQUFHLEtBQUs4TixVQUFMLENBQWdCM1AsTUFBbkMsRUFBMkM2QixDQUFDLEVBQTVDLEVBQWdEO0FBQy9DcVQsY0FBUSxHQUFHLEtBQUt2RixVQUFMLENBQWdCOU4sQ0FBaEIsQ0FBWDs7QUFDQSxVQUFHcVQsUUFBUSxDQUFDRSxJQUFULEtBQWtCUCxLQUFyQixFQUE0QjtBQUMzQkksa0JBQVUsR0FBRyxJQUFiO0FBQ0FFLHNCQUFjLEdBQUd0VCxDQUFqQjtBQUNBO0FBQ0E7QUFDRDs7QUFFRCxRQUFJd1QsUUFBUSxHQUFHLEtBQWY7O0FBRUEsUUFBRyxDQUFDSixVQUFKLEVBQWdCO0FBQ2ZJLGNBQVEsR0FBR0wsV0FBVyxLQUFLLFdBQWhCLElBQStCQSxXQUFXLEtBQUssV0FBMUQ7QUFDQSxXQUFLTixhQUFMLENBQW1CRyxLQUFuQixJQUE0QmpULEVBQUUsQ0FBQzBULGtCQUFILENBQXNCLEtBQUtaLGFBQTNCLEVBQTBDRyxLQUExQyxDQUE1Qjs7QUFDQSxVQUFHUSxRQUFILEVBQWE7QUFDWixhQUFLMUYsVUFBTCxDQUFnQmhQLElBQWhCLENBQXFCO0FBQUV5VSxjQUFJLEVBQUdQLEtBQVQ7QUFBZ0I3RSxjQUFJLEVBQUVnRixXQUF0QjtBQUFtQzVRLGVBQUssRUFBRUYsTUFBMUM7QUFBa0RxUixvQkFBVSxFQUFFLEtBQUtiLGFBQUwsQ0FBbUJHLEtBQW5CLENBQTlEO0FBQXlGUTtBQUF6RixTQUFyQjtBQUNBLE9BRkQsTUFFTztBQUNOLGFBQUsxRixVQUFMLENBQWdCaFAsSUFBaEIsQ0FBcUI7QUFBRXlVLGNBQUksRUFBR1AsS0FBVDtBQUFnQjdFLGNBQUksRUFBRWdGLFdBQXRCO0FBQW1DNVEsZUFBSyxFQUFFaVAsVUFBVSxDQUFDblAsTUFBRCxDQUFwRDtBQUE4RHFSLG9CQUFVLEVBQUUsS0FBS2IsYUFBTCxDQUFtQkcsS0FBbkIsQ0FBMUU7QUFBcUdRO0FBQXJHLFNBQXJCO0FBQ0E7O0FBRURGLG9CQUFjLEdBQUcsS0FBS3hGLFVBQUwsQ0FBZ0IzUCxNQUFoQixHQUF5QixDQUExQztBQUNBLEtBVkQsTUFVTztBQUNOLFdBQUswVSxhQUFMLENBQW1CRyxLQUFuQixJQUE0QkssUUFBUSxDQUFDSyxVQUFyQztBQUNBRixjQUFRLEdBQUdILFFBQVEsQ0FBQ0csUUFBcEI7QUFDQTs7QUFHRCxRQUFHLENBQUMsS0FBSzFGLFVBQUwsQ0FBZ0J3RixjQUFoQixFQUFnQ0ksVUFBcEMsRUFBZ0Q7QUFDL0M7QUFDQTs7QUFHRCxRQUFHUCxXQUFXLENBQUMvTCxPQUFaLENBQW9CLFFBQXBCLE1BQWtDLENBQUMsQ0FBdEMsRUFBeUM7QUFDeEMsVUFBRyxDQUFDb00sUUFBSixFQUFjO0FBQ2IsWUFBRyxDQUFDdkMsTUFBTSxDQUFDLEtBQUtuRCxVQUFMLENBQWdCd0YsY0FBaEIsRUFBZ0MvUSxLQUFqQyxFQUF3Q0YsTUFBeEMsQ0FBUCxJQUEwRCxDQUFDK1EsVUFBOUQsRUFBMEU7QUFDekVyVCxZQUFFLENBQUNvVCxXQUFELENBQUYsQ0FBZ0IsS0FBS04sYUFBTCxDQUFtQkcsS0FBbkIsQ0FBaEIsRUFBMkMzUSxNQUEzQztBQUNBLGVBQUt5TCxVQUFMLENBQWdCd0YsY0FBaEIsRUFBZ0MvUSxLQUFoQyxHQUF3Q2lQLFVBQVUsQ0FBQ25QLE1BQUQsQ0FBbEQ7QUFDQTtBQUNELE9BTEQsTUFLTztBQUNOLGNBQU1zUixVQUFVLEdBQUksS0FBSzdGLFVBQUwsQ0FBZ0J3RixjQUFoQixFQUFnQy9RLEtBQWhDLEtBQTBDRixNQUExQyxJQUFvRCxDQUFDK1EsVUFBekU7O0FBQ0EsWUFBR08sVUFBSCxFQUFlO0FBQ2Q1VCxZQUFFLENBQUNvVCxXQUFELENBQUYsQ0FBZ0IsS0FBS04sYUFBTCxDQUFtQkcsS0FBbkIsQ0FBaEIsRUFBMkMzUSxNQUEzQztBQUNBLGVBQUt5TCxVQUFMLENBQWdCd0YsY0FBaEIsRUFBZ0MvUSxLQUFoQyxHQUF3Q0YsTUFBeEM7QUFDQTtBQUNEO0FBRUQsS0FkRCxNQWNPO0FBQ04sVUFBRyxDQUFDNE8sTUFBTSxDQUFDLEtBQUtuRCxVQUFMLENBQWdCd0YsY0FBaEIsRUFBZ0MvUSxLQUFqQyxFQUF3Q0YsTUFBeEMsQ0FBUCxJQUEwRCxDQUFDK1EsVUFBOUQsRUFBMEU7QUFDekVyVCxVQUFFLENBQUNvVCxXQUFELENBQUYsQ0FBZ0IsS0FBS04sYUFBTCxDQUFtQkcsS0FBbkIsQ0FBaEIsRUFBMkMsS0FBM0MsRUFBa0QzUSxNQUFsRDtBQUNBLGFBQUt5TCxVQUFMLENBQWdCd0YsY0FBaEIsRUFBZ0MvUSxLQUFoQyxHQUF3Q2lQLFVBQVUsQ0FBQ25QLE1BQUQsQ0FBbEQ7QUFFQTtBQUNEO0FBRUQ7O0FBRUQ2USxlQUFhLENBQUNVLFdBQUQsRUFBYztBQUMxQixTQUFJLE1BQU1DLFdBQVYsSUFBeUJELFdBQXpCLEVBQXNDO0FBQ3JDLFVBQUlFLFlBQVksR0FBR0YsV0FBVyxDQUFDQyxXQUFELENBQTlCO0FBQ0EsWUFBTVYsV0FBVyxHQUFHdk8sUUFBUSxDQUFDbVAsY0FBVCxDQUF3QkQsWUFBeEIsQ0FBcEI7O0FBRUEsVUFBR0EsWUFBWSxDQUFDRSxNQUFiLElBQXVCRixZQUFZLENBQUMsQ0FBRCxDQUFaLENBQWdCRSxNQUExQyxFQUFrRDtBQUNqRCxZQUFJQyxHQUFHLEdBQUcsRUFBVjs7QUFDQSxhQUFJLElBQUlqVSxDQUFDLEdBQUMsQ0FBVixFQUFhQSxDQUFDLEdBQUM4VCxZQUFZLENBQUMzVixNQUE1QixFQUFvQzZCLENBQUMsRUFBckMsRUFBeUM7QUFDeENpVSxhQUFHLEdBQUdBLEdBQUcsQ0FBQ0QsTUFBSixDQUFXRixZQUFZLENBQUM5VCxDQUFELENBQXZCLENBQU47QUFDQTs7QUFDRDhULG9CQUFZLEdBQUdHLEdBQWY7QUFDQTs7QUFFRCxXQUFLbEIsT0FBTCxDQUFhYyxXQUFiLEVBQTBCVixXQUExQixFQUF1Q1csWUFBdkM7QUFDQTtBQUVEOztBQUdEckIsc0JBQW9CLENBQUN5QixVQUFELEVBQWFDLGNBQWIsRUFBNkI7QUFFaEQsVUFBTUMsVUFBVSxHQUFHRCxjQUFjLEdBQUd6UCwrQ0FBRSxDQUFDMlAsYUFBTixHQUFzQjNQLCtDQUFFLENBQUM0UCxlQUExRDtBQUNBLFVBQU0xTSxNQUFNLEdBQUc3SCxFQUFFLENBQUN3VSxZQUFILENBQWdCSCxVQUFoQixDQUFmO0FBRUFyVSxNQUFFLENBQUN5VSxZQUFILENBQWdCNU0sTUFBaEIsRUFBd0JzTSxVQUF4QjtBQUNBblUsTUFBRSxDQUFDMFUsYUFBSCxDQUFpQjdNLE1BQWpCOztBQUVBLFFBQUcsQ0FBQzdILEVBQUUsQ0FBQzJVLGtCQUFILENBQXNCOU0sTUFBdEIsRUFBOEI3SCxFQUFFLENBQUM0VSxjQUFqQyxDQUFKLEVBQXNEO0FBQ3JEblYsYUFBTyxDQUFDb1YsSUFBUixDQUFhLG9CQUFiLEVBQW1DN1UsRUFBRSxDQUFDOFUsZ0JBQUgsQ0FBb0JqTixNQUFwQixDQUFuQztBQUNBcEksYUFBTyxDQUFDQyxHQUFSLENBQVkyUixjQUFjLENBQUM4QyxVQUFELENBQTFCO0FBQ0EsYUFBTyxJQUFQO0FBQ0E7O0FBRUQsV0FBT3RNLE1BQVA7QUFDQTs7QUFFRCtLLHNCQUFvQixDQUFDbUMsYUFBRCxFQUFnQkMsZUFBaEIsRUFBaUM7QUFFcEQsU0FBS2xDLGFBQUwsR0FBcUI5UyxFQUFFLENBQUNpVixhQUFILEVBQXJCO0FBQ0FqVixNQUFFLENBQUNrVixZQUFILENBQWdCLEtBQUtwQyxhQUFyQixFQUFvQ2lDLGFBQXBDO0FBQ0EvVSxNQUFFLENBQUNrVixZQUFILENBQWdCLEtBQUtwQyxhQUFyQixFQUFvQ2tDLGVBQXBDO0FBRUFoVixNQUFFLENBQUNtVixZQUFILENBQWdCSixhQUFoQjtBQUNBL1UsTUFBRSxDQUFDbVYsWUFBSCxDQUFnQkgsZUFBaEI7O0FBRUEsUUFBRyxLQUFLeEMsU0FBUixFQUFtQjtBQUNsQi9TLGFBQU8sQ0FBQ0MsR0FBUixDQUFZLDZCQUFaLEVBQTJDLEtBQUs4UyxTQUFoRDtBQUNBeFMsUUFBRSxDQUFDb1YseUJBQUgsQ0FBNkIsS0FBS3RDLGFBQWxDLEVBQWlELEtBQUtOLFNBQXRELEVBQWlFeFMsRUFBRSxDQUFDcVYsZ0JBQXBFO0FBQ0E7O0FBRURyVixNQUFFLENBQUNzVixXQUFILENBQWUsS0FBS3hDLGFBQXBCO0FBRUE7O0FBNUphOztBQWdLZmpPLFFBQVEsQ0FBQ21QLGNBQVQsR0FBMEIsVUFBVTFSLE1BQVYsRUFBa0I7QUFDM0MsUUFBTWlULE9BQU8sR0FBRyxDQUFDLENBQUNqVCxNQUFNLENBQUMyUixNQUF6Qjs7QUFFQSxRQUFNdUIsbUJBQW1CLEdBQUcsVUFBVWxULE1BQVYsRUFBa0I7QUFDN0MsUUFBR0EsTUFBTSxDQUFDbEUsTUFBUCxLQUFrQixDQUFyQixFQUF3QjtBQUN2QixhQUFPLGtCQUFQO0FBQ0EsS0FGRCxNQUVPLElBQUdrRSxNQUFNLENBQUNsRSxNQUFQLEtBQWtCLEVBQXJCLEVBQXlCO0FBQy9CLGFBQU8sa0JBQVA7QUFDQSxLQUZNLE1BRUE7QUFDTixhQUFRLE1BQUtrRSxNQUFNLENBQUNsRSxNQUFPLEVBQTNCO0FBQ0E7QUFDRCxHQVJEOztBQVVBLE1BQUcsQ0FBQ21YLE9BQUosRUFBYTtBQUNaLFdBQU8sT0FBUDtBQUNBLEdBRkQsTUFFTztBQUNOLFFBQUksQ0FBQ2pULE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVTJSLE1BQWYsRUFBdUI7QUFDdEIsYUFBT3VCLG1CQUFtQixDQUFDbFQsTUFBRCxDQUExQjtBQUNBLEtBRkQsTUFFTztBQUNOLGFBQU9rVCxtQkFBbUIsQ0FBQ2xULE1BQU0sQ0FBQyxDQUFELENBQVAsQ0FBMUI7QUFDQTtBQUNEO0FBQ0QsQ0F0QkQ7O0FBeUJldUMsdUVBQWYsRTs7Ozs7Ozs7Ozs7O0FDN09BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQUVBLFNBQVM0USxZQUFULENBQXNCQyxDQUF0QixFQUF5QjtBQUN4QixTQUFRQSxDQUFDLEtBQUssQ0FBUCxJQUFjLEVBQUVBLENBQUMsR0FBSUEsQ0FBQyxHQUFHLENBQVgsQ0FBckI7QUFDQTs7QUFBQTs7QUFFRCxTQUFTQyxrQkFBVCxDQUE0QkMsR0FBNUIsRUFBaUM7QUFDaEMsUUFBTUMsQ0FBQyxHQUFHRCxHQUFHLENBQUNoTSxLQUFKLElBQWFnTSxHQUFHLENBQUNFLFVBQTNCO0FBQ0EsUUFBTUMsQ0FBQyxHQUFHSCxHQUFHLENBQUMvTCxNQUFKLElBQWMrTCxHQUFHLENBQUNJLFdBQTVCOztBQUVBLE1BQUcsQ0FBQ0gsQ0FBRCxJQUFNLENBQUNFLENBQVYsRUFBYTtBQUFFLFdBQU8sS0FBUDtBQUFlOztBQUU5QixTQUFPTixZQUFZLENBQUNJLENBQUQsQ0FBWixJQUFtQkosWUFBWSxDQUFDTSxDQUFELENBQXRDO0FBQ0E7O0FBQUE7QUFFRCxJQUFJL1YsRUFBSjs7QUFFQSxNQUFNbEIsU0FBTixDQUFnQjtBQUVmbUQsYUFBVyxDQUFDbU4sT0FBRCxFQUFVNkcsU0FBUyxHQUFHLEtBQXRCLEVBQTZCbE8sV0FBVyxHQUFHLEVBQTNDLEVBQStDO0FBQ3pEL0gsTUFBRSxHQUFHMkUsK0NBQUUsQ0FBQzNFLEVBQVI7O0FBRUEsUUFBR2lXLFNBQUgsRUFBYztBQUNiLFdBQUs5VixRQUFMLEdBQWdCaVAsT0FBaEI7QUFDQSxLQUZELE1BRU87QUFDTixXQUFLOEcsUUFBTCxHQUFpQjlHLE9BQWpCO0FBQ0EsV0FBS2pQLFFBQUwsR0FBaUJILEVBQUUsQ0FBQ3dJLGFBQUgsRUFBakI7QUFDQSxXQUFLMk4sUUFBTCxHQUFrQi9HLE9BQU8sQ0FBQ2dILE9BQVIsS0FBb0IsT0FBdEM7QUFDQSxXQUFLQyxpQkFBTCxHQUF5QixJQUF6QjtBQUNBLFdBQUtDLFVBQUwsR0FBa0J2TyxXQUFXLENBQUNFLFNBQVosSUFBeUJqSSxFQUFFLENBQUNrSSxNQUE5QztBQUNBLFdBQUtxTyxVQUFMLEdBQWtCeE8sV0FBVyxDQUFDSSxTQUFaLElBQXlCbkksRUFBRSxDQUFDd1cscUJBQTlDO0FBRUEsV0FBS0MsTUFBTCxHQUFrQjFPLFdBQVcsQ0FBQ0ssS0FBWixJQUFxQnBJLEVBQUUsQ0FBQzBXLGVBQTFDO0FBQ0EsV0FBS0MsTUFBTCxHQUFrQjVPLFdBQVcsQ0FBQ08sS0FBWixJQUFxQnRJLEVBQUUsQ0FBQzBXLGVBQTFDO0FBQ0EsWUFBTTlNLEtBQUssR0FBTXdGLE9BQU8sQ0FBQ3hGLEtBQVIsSUFBaUJ3RixPQUFPLENBQUMwRyxVQUExQzs7QUFFQSxVQUFHbE0sS0FBSCxFQUFVO0FBQ1QsWUFBRyxDQUFDK0wsa0JBQWtCLENBQUN2RyxPQUFELENBQXRCLEVBQWlDO0FBQ2hDLGVBQUtxSCxNQUFMLEdBQWMsS0FBS0UsTUFBTCxHQUFjM1csRUFBRSxDQUFDcUksYUFBL0I7O0FBQ0EsY0FBRyxLQUFLa08sVUFBTCxLQUFvQnZXLEVBQUUsQ0FBQ3dXLHFCQUExQixFQUFpRDtBQUNoRCxpQkFBS0QsVUFBTCxHQUFrQnZXLEVBQUUsQ0FBQ2tJLE1BQXJCO0FBQ0E7QUFDRDtBQUNELE9BUEQsTUFPTztBQUNOLGFBQUt1TyxNQUFMLEdBQWMsS0FBS0UsTUFBTCxHQUFjM1csRUFBRSxDQUFDcUksYUFBL0I7O0FBQ0EsWUFBRyxLQUFLa08sVUFBTCxLQUFvQnZXLEVBQUUsQ0FBQ3dXLHFCQUExQixFQUFpRDtBQUNoRCxlQUFLRCxVQUFMLEdBQWtCdlcsRUFBRSxDQUFDa0ksTUFBckI7QUFDQTtBQUNEOztBQUVEbEksUUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEIsS0FBS3RNLFFBQW5DO0FBQ0FILFFBQUUsQ0FBQ3dKLFdBQUgsQ0FBZXhKLEVBQUUsQ0FBQ3lKLG1CQUFsQixFQUF1QyxJQUF2Qzs7QUFFQSxVQUFHMkYsT0FBTyxDQUFDd0gsUUFBWCxFQUFxQjtBQUNwQjVXLFVBQUUsQ0FBQzBKLFVBQUgsQ0FBYzFKLEVBQUUsQ0FBQ3lNLFVBQWpCLEVBQTZCLENBQTdCLEVBQWdDek0sRUFBRSxDQUFDMkosSUFBbkMsRUFBeUN5RixPQUFPLENBQUNRLEtBQVIsQ0FBYyxDQUFkLENBQXpDLEVBQTJEUixPQUFPLENBQUNRLEtBQVIsQ0FBYyxDQUFkLENBQTNELEVBQTZFLENBQTdFLEVBQWdGNVAsRUFBRSxDQUFDMkosSUFBbkYsRUFBeUYzSixFQUFFLENBQUM4SixLQUE1RixFQUFtR3NGLE9BQU8sQ0FBQ1MsSUFBM0c7QUFDQSxPQUZELE1BRU87QUFDTjdQLFVBQUUsQ0FBQzBKLFVBQUgsQ0FBYzFKLEVBQUUsQ0FBQ3lNLFVBQWpCLEVBQTZCLENBQTdCLEVBQWdDek0sRUFBRSxDQUFDMkosSUFBbkMsRUFBeUMzSixFQUFFLENBQUMySixJQUE1QyxFQUFrRDNKLEVBQUUsQ0FBQ3FPLGFBQXJELEVBQW9FZSxPQUFwRSxFQURNLENBRU47QUFDQTs7QUFFRHBQLFFBQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUN5TSxVQUFwQixFQUFnQ3pNLEVBQUUsQ0FBQzZJLGtCQUFuQyxFQUF1RCxLQUFLeU4sVUFBNUQ7QUFDQXRXLFFBQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUN5TSxVQUFwQixFQUFnQ3pNLEVBQUUsQ0FBQzhJLGtCQUFuQyxFQUF1RCxLQUFLeU4sVUFBNUQ7QUFDQXZXLFFBQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUN5TSxVQUFwQixFQUFnQ3pNLEVBQUUsQ0FBQytJLGNBQW5DLEVBQW1ELEtBQUswTixNQUF4RDtBQUNBelcsUUFBRSxDQUFDNEksYUFBSCxDQUFpQjVJLEVBQUUsQ0FBQ3lNLFVBQXBCLEVBQWdDek0sRUFBRSxDQUFDZ0osY0FBbkMsRUFBbUQsS0FBSzJOLE1BQXhELEVBdkNNLENBeUNOO0FBQ0E7O0FBRUEsWUFBTWhZLEdBQUcsR0FBR2dHLCtDQUFFLENBQUMzRyxZQUFILENBQWdCLGdDQUFoQixDQUFaOztBQUNBLFVBQUdXLEdBQUgsRUFBUTtBQUNQLGNBQU0yUixHQUFHLEdBQUd0USxFQUFFLENBQUNtTixZQUFILENBQWdCeE8sR0FBRyxDQUFDa1ksOEJBQXBCLENBQVo7QUFDQTdXLFVBQUUsQ0FBQzhXLGFBQUgsQ0FBaUI5VyxFQUFFLENBQUN5TSxVQUFwQixFQUFnQzlOLEdBQUcsQ0FBQ29ZLDBCQUFwQyxFQUFnRXpHLEdBQWhFO0FBQ0E7O0FBRUQsVUFBRyxLQUFLMEcsa0JBQUwsRUFBSCxFQUE4QjtBQUM3QmhYLFVBQUUsQ0FBQ3dPLGNBQUgsQ0FBa0J4TyxFQUFFLENBQUN5TSxVQUFyQjtBQUNBOztBQUVEek0sUUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEIsSUFBOUI7QUFDQTtBQUNEOztBQUVEK0IsZ0JBQWMsR0FBRztBQUNoQixRQUFJLENBQUMsS0FBS3dJLGtCQUFMLEVBQUwsRUFBZ0M7QUFBRTtBQUFTOztBQUMzQ2hYLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLEtBQUt0TSxRQUFuQztBQUNBSCxNQUFFLENBQUN3TyxjQUFILENBQWtCeE8sRUFBRSxDQUFDeU0sVUFBckI7QUFDQXpNLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLElBQTlCO0FBQ0EsR0F0RWMsQ0F5RWY7OztBQUVBLE1BQUl0RSxTQUFKLENBQWM3RixNQUFkLEVBQXNCO0FBQ3JCLFFBQUdBLE1BQU0sS0FBS3RDLEVBQUUsQ0FBQ2tJLE1BQWQsSUFDQzVGLE1BQU0sS0FBS3RDLEVBQUUsQ0FBQzBOLE9BRGYsSUFFQ3BMLE1BQU0sS0FBS3RDLEVBQUUsQ0FBQ3dXLHFCQUZmLElBR0NsVSxNQUFNLEtBQUt0QyxFQUFFLENBQUN3VyxxQkFIZixJQUlDbFUsTUFBTSxLQUFLdEMsRUFBRSxDQUFDd1Asb0JBSmYsSUFLQ2xOLE1BQU0sS0FBS3RDLEVBQUUsQ0FBQ2lYLHNCQUxsQixFQU1FO0FBQUUsYUFBTyxJQUFQO0FBQWM7O0FBQ2xCLFNBQUtWLFVBQUwsR0FBa0JqVSxNQUFsQjtBQUNBdEMsTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEIsS0FBS3RNLFFBQW5DO0FBQ0FILE1BQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUN5TSxVQUFwQixFQUFnQ3pNLEVBQUUsQ0FBQzhJLGtCQUFuQyxFQUF1RCxLQUFLeU4sVUFBNUQ7QUFDQXZXLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLElBQTlCO0FBQ0E7O0FBRUQsTUFBSXRFLFNBQUosR0FBZ0I7QUFDZixXQUFPLEtBQUtvTyxVQUFaO0FBQ0E7O0FBRUQsTUFBSXRPLFNBQUosQ0FBYzNGLE1BQWQsRUFBc0I7QUFDckIsUUFBR0EsTUFBTSxLQUFLdEMsRUFBRSxDQUFDa0ksTUFBZCxJQUF3QjVGLE1BQU0sS0FBS3RDLEVBQUUsQ0FBQzBOLE9BQXpDLEVBQWtEO0FBQUUsYUFBTyxJQUFQO0FBQWM7O0FBQ2xFLFNBQUs0SSxVQUFMLEdBQWtCaFUsTUFBbEI7QUFDQXRDLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLEtBQUt0TSxRQUFuQztBQUNBSCxNQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDeU0sVUFBcEIsRUFBZ0N6TSxFQUFFLENBQUM2SSxrQkFBbkMsRUFBdUQsS0FBS3lOLFVBQTVEO0FBQ0F0VyxNQUFFLENBQUMwSSxXQUFILENBQWUxSSxFQUFFLENBQUN5TSxVQUFsQixFQUE4QixJQUE5QjtBQUNBOztBQUVELE1BQUl4RSxTQUFKLEdBQWdCO0FBQ2YsV0FBTyxLQUFLcU8sVUFBWjtBQUNBLEdBdkdjLENBMEdmOzs7QUFFQSxNQUFJbE8sS0FBSixDQUFVOUYsTUFBVixFQUFrQjtBQUNqQixRQUFHQSxNQUFNLEtBQUt0QyxFQUFFLENBQUNxSSxhQUFkLElBQStCL0YsTUFBTSxLQUFLdEMsRUFBRSxDQUFDa1gsTUFBN0MsSUFBdUQ1VSxNQUFNLEtBQUt0QyxFQUFFLENBQUMwVyxlQUF4RSxFQUF5RjtBQUFFLGFBQU8sSUFBUDtBQUFjOztBQUN6RyxTQUFLRCxNQUFMLEdBQWNuVSxNQUFkO0FBQ0F0QyxNQUFFLENBQUMwSSxXQUFILENBQWUxSSxFQUFFLENBQUN5TSxVQUFsQixFQUE4QixLQUFLdE0sUUFBbkM7QUFDQUgsTUFBRSxDQUFDNEksYUFBSCxDQUFpQjVJLEVBQUUsQ0FBQ3lNLFVBQXBCLEVBQWdDek0sRUFBRSxDQUFDK0ksY0FBbkMsRUFBbUQsS0FBSzBOLE1BQXhEO0FBQ0F6VyxNQUFFLENBQUMwSSxXQUFILENBQWUxSSxFQUFFLENBQUN5TSxVQUFsQixFQUE4QixJQUE5QjtBQUNBOztBQUVELE1BQUlyRSxLQUFKLEdBQVk7QUFDWCxXQUFPLEtBQUtxTyxNQUFaO0FBQ0E7O0FBRUQsTUFBSW5PLEtBQUosQ0FBVWhHLE1BQVYsRUFBa0I7QUFDakIsUUFBR0EsTUFBTSxLQUFLdEMsRUFBRSxDQUFDcUksYUFBZCxJQUErQi9GLE1BQU0sS0FBS3RDLEVBQUUsQ0FBQ2tYLE1BQTdDLElBQXVENVUsTUFBTSxLQUFLdEMsRUFBRSxDQUFDMFcsZUFBeEUsRUFBeUY7QUFBRSxhQUFPLElBQVA7QUFBYzs7QUFDekcsU0FBS0MsTUFBTCxHQUFjclUsTUFBZDtBQUNBdEMsTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEIsS0FBS3RNLFFBQW5DO0FBQ0FILE1BQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUN5TSxVQUFwQixFQUFnQ3pNLEVBQUUsQ0FBQ2dKLGNBQW5DLEVBQW1ELEtBQUsyTixNQUF4RDtBQUNBM1csTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEIsSUFBOUI7QUFDQTs7QUFFRCxNQUFJbkUsS0FBSixHQUFZO0FBQ1gsV0FBTyxLQUFLcU8sTUFBWjtBQUNBLEdBbEljLENBcUlmOzs7QUFFQSxNQUFJUSxnQkFBSixDQUFxQjdVLE1BQXJCLEVBQTZCO0FBQzVCLFNBQUsrVCxpQkFBTCxHQUF5Qi9ULE1BQXpCO0FBQ0F0QyxNQUFFLENBQUMwSSxXQUFILENBQWUxSSxFQUFFLENBQUN5TSxVQUFsQixFQUE4QixLQUFLdE0sUUFBbkM7QUFDQVYsV0FBTyxDQUFDQyxHQUFSLENBQVksbUJBQVosRUFBaUM0QyxNQUFqQztBQUNBdEMsTUFBRSxDQUFDd0osV0FBSCxDQUFleEosRUFBRSxDQUFDb1gsOEJBQWxCLEVBQWtELEtBQUtmLGlCQUF2RDtBQUNBclcsTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEIsSUFBOUI7QUFFQTs7QUFFRCxNQUFJMEssZ0JBQUosR0FBdUI7QUFDdEIsV0FBTyxLQUFLZCxpQkFBWjtBQUNBLEdBbEpjLENBb0pmOzs7QUFFQWdCLGVBQWEsQ0FBQ2pJLE9BQUQsRUFBVTtBQUN0QixRQUFHQSxPQUFILEVBQVk7QUFBRSxXQUFLOEcsUUFBTCxHQUFnQjlHLE9BQWhCO0FBQTBCOztBQUN4Q3BQLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLEtBQUt0TSxRQUFuQztBQUNBSCxNQUFFLENBQUN3SixXQUFILENBQWV4SixFQUFFLENBQUN5SixtQkFBbEIsRUFBdUMsSUFBdkM7QUFDQXpKLE1BQUUsQ0FBQzBKLFVBQUgsQ0FBYzFKLEVBQUUsQ0FBQ3lNLFVBQWpCLEVBQTZCLENBQTdCLEVBQWdDek0sRUFBRSxDQUFDMkosSUFBbkMsRUFBeUMzSixFQUFFLENBQUMySixJQUE1QyxFQUFrRDNKLEVBQUUsQ0FBQ3FPLGFBQXJELEVBQW9FLEtBQUs2SCxRQUF6RTtBQUNBbFcsTUFBRSxDQUFDNEksYUFBSCxDQUFpQjVJLEVBQUUsQ0FBQ3lNLFVBQXBCLEVBQWdDek0sRUFBRSxDQUFDNkksa0JBQW5DLEVBQXVELEtBQUt5TixVQUE1RDtBQUNBdFcsTUFBRSxDQUFDNEksYUFBSCxDQUFpQjVJLEVBQUUsQ0FBQ3lNLFVBQXBCLEVBQWdDek0sRUFBRSxDQUFDOEksa0JBQW5DLEVBQXVELEtBQUt5TixVQUE1RDs7QUFDQSxRQUFHLEtBQUtTLGtCQUFMLEVBQUgsRUFBOEI7QUFDN0JoWCxRQUFFLENBQUN3TyxjQUFILENBQWtCeE8sRUFBRSxDQUFDeU0sVUFBckI7QUFDQTs7QUFFRHpNLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLElBQTlCO0FBQ0E7O0FBR0Q3RSxNQUFJLENBQUM4SCxLQUFELEVBQVE7QUFDWCxRQUFHQSxLQUFLLEtBQUt4TCxTQUFiLEVBQXdCO0FBQUV3TCxXQUFLLEdBQUcsQ0FBUjtBQUFZOztBQUN0QyxRQUFHLENBQUMvSywrQ0FBRSxDQUFDa0QsTUFBUCxFQUFlO0FBQUU7QUFBUzs7QUFFMUI3SCxNQUFFLENBQUM4UCxhQUFILENBQWlCOVAsRUFBRSxDQUFDK1AsUUFBSCxHQUFjTCxLQUEvQjtBQUNBMVAsTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEIsS0FBS3RNLFFBQW5DO0FBQ0EsU0FBSytQLFVBQUwsR0FBa0JSLEtBQWxCO0FBQ0E7O0FBRURzSCxvQkFBa0IsR0FBRztBQUNwQixXQUFPLEtBQUtULFVBQUwsS0FBb0J2VyxFQUFFLENBQUNzWCxxQkFBdkIsSUFDRixLQUFLZixVQUFMLEtBQW9CdlcsRUFBRSxDQUFDd1cscUJBRHJCLElBRUYsS0FBS0QsVUFBTCxLQUFvQnZXLEVBQUUsQ0FBQ3dQLG9CQUZyQixJQUdGLEtBQUsrRyxVQUFMLEtBQW9CdlcsRUFBRSxDQUFDaVgsc0JBSDVCO0FBSUEsR0FuTGMsQ0FxTGY7OztBQUVBLE1BQUlwWSxPQUFKLEdBQWM7QUFBRSxXQUFPLEtBQUtzQixRQUFaO0FBQXVCOztBQXZMeEI7O0FBMkxoQixJQUFJb1gsYUFBSixFQUFtQkMsWUFBbkIsRUFBaUNDLGFBQWpDOztBQUVBM1ksU0FBUyxDQUFDNFksWUFBVixHQUF5QixTQUFTQSxZQUFULEdBQXdCO0FBQ2hELE1BQUdILGFBQWEsS0FBS3JULFNBQXJCLEVBQWdDO0FBQy9CLFVBQU15VCxNQUFNLEdBQUdsVyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjtBQUNBaVcsVUFBTSxDQUFDL04sS0FBUCxHQUFlK04sTUFBTSxDQUFDOU4sTUFBUCxHQUFnQixDQUEvQjtBQUNBLFVBQU0rTixHQUFHLEdBQUdELE1BQU0sQ0FBQ0UsVUFBUCxDQUFrQixJQUFsQixDQUFaO0FBQ0FELE9BQUcsQ0FBQ0UsU0FBSixHQUFnQixNQUFoQjtBQUNBRixPQUFHLENBQUNHLFFBQUosQ0FBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCO0FBQ0FSLGlCQUFhLEdBQUcsSUFBSXpZLFNBQUosQ0FBYzZZLE1BQWQsQ0FBaEI7QUFDQTs7QUFFRCxTQUFPSixhQUFQO0FBQ0EsQ0FYRDs7QUFhQXpZLFNBQVMsQ0FBQ2taLFdBQVYsR0FBd0IsU0FBU0EsV0FBVCxHQUF1QjtBQUM5QyxNQUFHUixZQUFZLEtBQUt0VCxTQUFwQixFQUErQjtBQUM5QixVQUFNeVQsTUFBTSxHQUFHbFcsUUFBUSxDQUFDQyxhQUFULENBQXVCLFFBQXZCLENBQWY7QUFDQWlXLFVBQU0sQ0FBQy9OLEtBQVAsR0FBZStOLE1BQU0sQ0FBQzlOLE1BQVAsR0FBZ0IsQ0FBL0I7QUFDQSxVQUFNK04sR0FBRyxHQUFHRCxNQUFNLENBQUNFLFVBQVAsQ0FBa0IsSUFBbEIsQ0FBWjtBQUNBRCxPQUFHLENBQUNFLFNBQUosR0FBZ0Isb0JBQWhCO0FBQ0FGLE9BQUcsQ0FBQ0csUUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEI7QUFDQVAsZ0JBQVksR0FBRyxJQUFJMVksU0FBSixDQUFjNlksTUFBZCxDQUFmO0FBQ0E7O0FBQ0QsU0FBT0gsWUFBUDtBQUNBLENBVkQ7O0FBWUExWSxTQUFTLENBQUNtWixZQUFWLEdBQXlCLFNBQVNBLFlBQVQsR0FBd0I7QUFDaEQsTUFBR1IsYUFBYSxLQUFLdlQsU0FBckIsRUFBZ0M7QUFDL0IsVUFBTXlULE1BQU0sR0FBR2xXLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixRQUF2QixDQUFmO0FBQ0FpVyxVQUFNLENBQUMvTixLQUFQLEdBQWUrTixNQUFNLENBQUM5TixNQUFQLEdBQWdCLENBQS9CO0FBQ0EsVUFBTStOLEdBQUcsR0FBR0QsTUFBTSxDQUFDRSxVQUFQLENBQWtCLElBQWxCLENBQVo7QUFDQUQsT0FBRyxDQUFDRSxTQUFKLEdBQWdCLG9CQUFoQjtBQUNBRixPQUFHLENBQUNHLFFBQUosQ0FBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCO0FBQ0FOLGlCQUFhLEdBQUcsSUFBSTNZLFNBQUosQ0FBYzZZLE1BQWQsQ0FBaEI7QUFDQTs7QUFDRCxTQUFPRixhQUFQO0FBQ0EsQ0FWRDs7QUFZZTNZLHdFQUFmLEU7Ozs7Ozs7Ozs7OztBQ3RQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBSWtCLEVBQUo7O0FBRUEsTUFBTWxCLFNBQU4sQ0FBZ0I7QUFDZG1ELGFBQVcsQ0FBRW1OLE9BQUYsRUFBVzhJLE1BQU0sR0FBRyxFQUFwQixFQUF3Qm5NLE1BQU0sR0FBRyxDQUFqQyxFQUFvQ0MsT0FBTyxHQUFHLENBQTlDLEVBQWlEO0FBQzFEaE0sTUFBRSxHQUFHMkUsK0NBQUUsQ0FBQzNFLEVBQVI7QUFFQSxTQUFLbVksT0FBTCxHQUFlL0ksT0FBZjs7QUFDQSxTQUFLZ0osYUFBTCxDQUFtQmhKLE9BQW5CLEVBQTRCckQsTUFBNUIsRUFBb0NDLE9BQXBDOztBQUNBLFNBQUtxTSxXQUFMLEdBQW1CSCxNQUFNLENBQUM5SixJQUFQLElBQWVrSyxhQUFhLENBQUNsSixPQUFELENBQS9DOztBQUNBLFNBQUttSixZQUFMOztBQUNBLFNBQUtDLFVBQUwsR0FBa0IsS0FBS0MsYUFBTCxFQUFsQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUIsSUFBdkI7QUFFQSxTQUFLQyxPQUFMLEdBQWVDLDJFQUFvQixDQUFDVixNQUFELEVBQVM5SSxPQUFULEVBQWtCLEtBQUt5SixNQUF2QixFQUErQixLQUFLQyxPQUFwQyxDQUFuQzs7QUFDQSxTQUFLQyxZQUFMOztBQUNBLFNBQUtDLGNBQUwsR0FaMEQsQ0FjMUQ7OztBQUNBLFNBQUs3WSxRQUFMLEdBQWdCSCxFQUFFLENBQUN3SSxhQUFILEVBQWhCOztBQUVBLFFBQUksS0FBSzZQLFdBQUwsS0FBcUIsT0FBekIsRUFBa0M7QUFDaEMsV0FBS0ssZUFBTCxHQUF1QixLQUF2QjtBQUNBdlQsd0RBQVMsQ0FBQzhULEtBQVYsQ0FBZ0IsTUFBTSxLQUFLQyxLQUFMLEVBQXRCO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsV0FBS0MsY0FBTDtBQUNEO0FBQ0Y7O0FBRURELE9BQUssR0FBSTtBQUNQLFFBQUksS0FBS2YsT0FBTCxDQUFhaUIsVUFBYixLQUE0QixDQUFoQyxFQUFtQztBQUNqQyxXQUFLVixlQUFMLEdBQXVCLElBQXZCOztBQUNBLFdBQUtTLGNBQUw7QUFDRDtBQUNGOztBQUVEQSxnQkFBYyxHQUFJO0FBQ2hCblosTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEIsS0FBS3RNLFFBQW5DO0FBQ0FILE1BQUUsQ0FBQ3dKLFdBQUgsQ0FBZXhKLEVBQUUsQ0FBQ3lKLG1CQUFsQixFQUF1QyxJQUF2Qzs7QUFFQSxRQUFJLEtBQUs0UCxvQkFBTCxFQUFKLEVBQWlDO0FBQy9CclosUUFBRSxDQUFDMEosVUFBSCxDQUFjMUosRUFBRSxDQUFDeU0sVUFBakIsRUFBNkIsQ0FBN0IsRUFBZ0MsS0FBS2tNLE9BQUwsQ0FBYXpLLGNBQTdDLEVBQTZELEtBQUt5SyxPQUFMLENBQWF4SyxNQUExRSxFQUFrRixLQUFLcUssVUFBdkYsRUFBbUcsS0FBS0wsT0FBeEc7QUFDRCxLQUZELE1BRU87QUFDTG5ZLFFBQUUsQ0FBQzBKLFVBQUgsQ0FBYzFKLEVBQUUsQ0FBQ3lNLFVBQWpCLEVBQTZCLENBQTdCLEVBQWdDLEtBQUtrTSxPQUFMLENBQWF6SyxjQUE3QyxFQUE2RCxLQUFLMkssTUFBbEUsRUFBMEUsS0FBS0MsT0FBL0UsRUFBd0YsQ0FBeEYsRUFBMkYsS0FBS0gsT0FBTCxDQUFheEssTUFBeEcsRUFBZ0gsS0FBS3FLLFVBQXJILEVBQWlJLEtBQUtMLE9BQXRJO0FBQ0Q7O0FBRURuWSxNQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDeU0sVUFBcEIsRUFBZ0N6TSxFQUFFLENBQUM2SSxrQkFBbkMsRUFBdUQsS0FBSzhQLE9BQUwsQ0FBYTFRLFNBQXBFO0FBQ0FqSSxNQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDeU0sVUFBcEIsRUFBZ0N6TSxFQUFFLENBQUM4SSxrQkFBbkMsRUFBdUQsS0FBSzZQLE9BQUwsQ0FBYXhRLFNBQXBFO0FBQ0FuSSxNQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDeU0sVUFBcEIsRUFBZ0N6TSxFQUFFLENBQUMrSSxjQUFuQyxFQUFtRCxLQUFLNFAsT0FBTCxDQUFhdlEsS0FBaEU7QUFDQXBJLE1BQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUN5TSxVQUFwQixFQUFnQ3pNLEVBQUUsQ0FBQ2dKLGNBQW5DLEVBQW1ELEtBQUsyUCxPQUFMLENBQWFyUSxLQUFoRTtBQUNBdEksTUFBRSxDQUFDd0osV0FBSCxDQUFleEosRUFBRSxDQUFDb1gsOEJBQWxCLEVBQWtELEtBQUtmLGlCQUF2RCxFQWRnQixDQWdCaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQUksS0FBS2lELGVBQVQsRUFBMEI7QUFBRXRaLFFBQUUsQ0FBQ3dPLGNBQUgsQ0FBa0J4TyxFQUFFLENBQUN5TSxVQUFyQjtBQUFrQyxLQTFCOUMsQ0E0QmhCOzs7QUFDQXpNLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLElBQTlCO0FBQ0Q7O0FBRUQ3RSxNQUFJLENBQUU4SCxLQUFGLEVBQVM7QUFDWCxRQUFJQSxLQUFLLEtBQUt4TCxTQUFkLEVBQXlCO0FBQUV3TCxXQUFLLEdBQUcsQ0FBUjtBQUFXOztBQUN0QyxRQUFJLENBQUMvSywrQ0FBRSxDQUFDa0QsTUFBUixFQUFnQjtBQUFFO0FBQVE7O0FBRTFCN0gsTUFBRSxDQUFDOFAsYUFBSCxDQUFpQjlQLEVBQUUsQ0FBQytQLFFBQUgsR0FBY0wsS0FBL0I7O0FBQ0EsUUFBSSxLQUFLZ0osZUFBVCxFQUEwQjtBQUN4QjFZLFFBQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLEtBQUt0TSxRQUFuQztBQUNELEtBRkQsTUFFTztBQUNMSCxRQUFFLENBQUMwSSxXQUFILENBQWUxSSxFQUFFLENBQUN5TSxVQUFsQixFQUE4QjNOLFNBQVMsQ0FBQ21aLFlBQVYsR0FBeUJwWixPQUF2RDtBQUNEOztBQUVELFNBQUtxUixVQUFMLEdBQWtCUixLQUFsQjtBQUNEOztBQUVEMkgsZUFBYSxDQUFFakksT0FBRixFQUFXO0FBQ3RCLFNBQUsrSSxPQUFMLEdBQWUvSSxPQUFmOztBQUNBLFNBQUttSixZQUFMOztBQUNBLFNBQUtZLGNBQUw7QUFDRDs7QUFFRDNLLGdCQUFjLEdBQUk7QUFDaEIsUUFBSSxDQUFDLEtBQUs4SyxlQUFWLEVBQTJCO0FBQUU7QUFBUTs7QUFDckN0WixNQUFFLENBQUMwSSxXQUFILENBQWUxSSxFQUFFLENBQUN5TSxVQUFsQixFQUE4QixLQUFLdE0sUUFBbkM7QUFDQUgsTUFBRSxDQUFDd08sY0FBSCxDQUFrQnhPLEVBQUUsQ0FBQ3lNLFVBQXJCO0FBQ0F6TSxNQUFFLENBQUMwSSxXQUFILENBQWUxSSxFQUFFLENBQUN5TSxVQUFsQixFQUE4QixJQUE5QjtBQUNEOztBQUVEc0MsZ0JBQWMsR0FBSTtBQUNoQnRQLFdBQU8sQ0FBQ0MsR0FBUixDQUFZLGdCQUFaLEVBQThCb0gseURBQVcsQ0FBQyxLQUFLdVIsV0FBTixDQUFYLElBQWlDLEtBQUtBLFdBQXBFO0FBQ0E1WSxXQUFPLENBQUNDLEdBQVIsQ0FBWSxhQUFaLEVBQTJCb0gseURBQVcsQ0FBQyxLQUFLeVMsU0FBTixDQUF0QztBQUNBOVosV0FBTyxDQUFDQyxHQUFSLENBQVksYUFBWixFQUEyQixLQUFLbVosTUFBaEMsRUFBd0MsS0FBS0MsT0FBN0M7O0FBQ0EsU0FBSyxNQUFNblosQ0FBWCxJQUFnQixLQUFLZ1osT0FBckIsRUFBOEI7QUFDNUJsWixhQUFPLENBQUNDLEdBQVIsQ0FBWUMsQ0FBWixFQUFlbUgseURBQVcsQ0FBQyxLQUFLNlIsT0FBTCxDQUFhaFosQ0FBYixDQUFELENBQVgsSUFBZ0MsS0FBS2daLE9BQUwsQ0FBYWhaLENBQWIsQ0FBL0M7QUFDRDs7QUFFREYsV0FBTyxDQUFDQyxHQUFSLENBQVksY0FBWixFQUE0QixLQUFLNFosZUFBakM7QUFDRDs7QUFFRGxCLGVBQWEsQ0FBRWhKLE9BQUYsRUFBV3JELE1BQVgsRUFBbUJDLE9BQW5CLEVBQTRCO0FBQ3ZDLFFBQUlvRCxPQUFKLEVBQWE7QUFDWDtBQUNBLFdBQUt5SixNQUFMLEdBQWN6SixPQUFPLENBQUN4RixLQUFSLElBQWlCd0YsT0FBTyxDQUFDMEcsVUFBdkM7QUFDQSxXQUFLZ0QsT0FBTCxHQUFlMUosT0FBTyxDQUFDdkYsTUFBUixJQUFrQnVGLE9BQU8sQ0FBQzBHLFVBQXpDLENBSFcsQ0FLWDs7QUFDQSxXQUFLK0MsTUFBTCxHQUFjLEtBQUtBLE1BQUwsSUFBZTlNLE1BQTdCO0FBQ0EsV0FBSytNLE9BQUwsR0FBZSxLQUFLQSxPQUFMLElBQWdCOU0sT0FBL0IsQ0FQVyxDQVNYO0FBQ0E7O0FBQ0EsVUFBSSxDQUFDLEtBQUs2TSxNQUFOLElBQWdCLENBQUMsS0FBS0MsT0FBMUIsRUFBbUM7QUFDakMsYUFBS0QsTUFBTCxHQUFjLEtBQUtDLE9BQUwsR0FBZW5JLElBQUksQ0FBQzZJLElBQUwsQ0FBVXBLLE9BQU8sQ0FBQ2hSLE1BQVIsR0FBaUIsQ0FBM0IsQ0FBN0IsQ0FEaUMsQ0FFakM7QUFDRDtBQUNGLEtBZkQsTUFlTztBQUNMLFdBQUt5YSxNQUFMLEdBQWM5TSxNQUFkO0FBQ0EsV0FBSytNLE9BQUwsR0FBZTlNLE9BQWY7QUFDRDtBQUNGOztBQUVEdU0sY0FBWSxHQUFJO0FBQ2QsUUFBSSxDQUFDLEtBQUtKLE9BQVYsRUFBbUI7QUFBRTtBQUFROztBQUU3QixRQUFJLEtBQUtFLFdBQUwsS0FBcUIxVCwrQ0FBRSxDQUFDMEosYUFBNUIsRUFBMkM7QUFDekMsVUFBSSxFQUFFLEtBQUs4SixPQUFMLFlBQXdCc0IsVUFBMUIsQ0FBSixFQUEyQztBQUN6QztBQUNBLGFBQUt0QixPQUFMLEdBQWUsSUFBSXNCLFVBQUosQ0FBZSxLQUFLdEIsT0FBcEIsQ0FBZjtBQUNEO0FBQ0YsS0FMRCxNQUtPLElBQUksS0FBS0UsV0FBTCxLQUFxQjFULCtDQUFFLENBQUNtRixLQUE1QixFQUFtQztBQUN4QyxVQUFJLEVBQUUsS0FBS3FPLE9BQUwsWUFBd0JwSCxZQUExQixDQUFKLEVBQTZDO0FBQzNDO0FBQ0EsYUFBS29ILE9BQUwsR0FBZSxJQUFJcEgsWUFBSixDQUFpQixLQUFLb0gsT0FBdEIsQ0FBZjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRE0sZUFBYSxHQUFJO0FBQ2YsUUFBSSxLQUFLWSxvQkFBTCxFQUFKLEVBQWlDO0FBQy9CLGFBQU8xVSwrQ0FBRSxDQUFDMEosYUFBVjtBQUNEOztBQUVELFdBQU8xSiwrQ0FBRSxDQUFDbUMseURBQVcsQ0FBQyxLQUFLdVIsV0FBTixDQUFaLENBQVQ7QUFDRDs7QUFFRFUsY0FBWSxHQUFJO0FBQ2QsU0FBS08sZUFBTCxHQUF1QixLQUFLWCxPQUFMLENBQWFoTCxNQUFwQzs7QUFFQSxRQUFJLEVBQUU4SCxZQUFZLENBQUMsS0FBS29ELE1BQU4sQ0FBWixJQUE2QnBELFlBQVksQ0FBQyxLQUFLcUQsT0FBTixDQUEzQyxDQUFKLEVBQWdFO0FBQzlELFdBQUtRLGVBQUwsR0FBdUIsS0FBdkI7QUFDRDs7QUFFRCxVQUFNblIsU0FBUyxHQUFHckIseURBQVcsQ0FBQyxLQUFLNlIsT0FBTCxDQUFheFEsU0FBZCxDQUE3Qjs7QUFDQSxRQUFJQSxTQUFTLENBQUNkLE9BQVYsQ0FBa0IsUUFBbEIsTUFBZ0MsQ0FBQyxDQUFyQyxFQUF3QztBQUN0QyxXQUFLaVMsZUFBTCxHQUF1QixLQUF2QjtBQUNEO0FBQ0Y7O0FBRUROLGdCQUFjLEdBQUk7QUFDaEIsUUFBSSxDQUFDLEtBQUtNLGVBQVYsRUFBMkI7QUFDekIsV0FBS1gsT0FBTCxDQUFhdlEsS0FBYixHQUFxQnpELCtDQUFFLENBQUMwRCxhQUF4QjtBQUNBLFdBQUtzUSxPQUFMLENBQWFyUSxLQUFiLEdBQXFCM0QsK0NBQUUsQ0FBQzBELGFBQXhCO0FBQ0Q7QUFDRjs7QUFFRGdSLHNCQUFvQixHQUFJO0FBQ3RCLFdBQU8sS0FBS2hCLFdBQUwsS0FBcUIsT0FBckIsSUFBZ0MsS0FBS0EsV0FBTCxLQUFxQixPQUFyRCxJQUFnRSxLQUFLQSxXQUFMLEtBQXFCLFFBQTVGO0FBQ0Q7O0FBRUQsTUFBSWxRLFNBQUosR0FBaUI7QUFBRSxXQUFPLEtBQUt3USxPQUFMLENBQWF4USxTQUFwQjtBQUErQjs7QUFFbEQsTUFBSUEsU0FBSixDQUFlN0YsTUFBZixFQUF1QjtBQUNyQixTQUFLcVcsT0FBTCxDQUFheFEsU0FBYixHQUF5QjdGLE1BQXpCOztBQUNBLFNBQUt5VyxZQUFMOztBQUVBL1ksTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEIsS0FBS3RNLFFBQW5DO0FBQ0FILE1BQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUN5TSxVQUFwQixFQUFnQ3pNLEVBQUUsQ0FBQzhJLGtCQUFuQyxFQUF1RCxLQUFLNlAsT0FBTCxDQUFheFEsU0FBcEU7QUFDQW5JLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLElBQTlCO0FBRUEsU0FBSytCLGNBQUw7QUFDRDs7QUFFRCxNQUFJdkcsU0FBSixHQUFpQjtBQUFFLFdBQU8sS0FBSzBRLE9BQUwsQ0FBYXhRLFNBQXBCO0FBQStCOztBQUVsRCxNQUFJRixTQUFKLENBQWUzRixNQUFmLEVBQXVCO0FBQ3JCLFNBQUtxVyxPQUFMLENBQWExUSxTQUFiLEdBQXlCM0YsTUFBekI7QUFFQXRDLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLEtBQUt0TSxRQUFuQztBQUNBSCxNQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDeU0sVUFBcEIsRUFBZ0N6TSxFQUFFLENBQUM2SSxrQkFBbkMsRUFBdUQsS0FBSzhQLE9BQUwsQ0FBYTFRLFNBQXBFO0FBQ0FqSSxNQUFFLENBQUMwSSxXQUFILENBQWUxSSxFQUFFLENBQUN5TSxVQUFsQixFQUE4QixJQUE5QjtBQUNEOztBQUVELE1BQUlyRSxLQUFKLEdBQWE7QUFBRSxXQUFPLEtBQUt1USxPQUFMLENBQWF2USxLQUFwQjtBQUEyQjs7QUFFMUMsTUFBSUEsS0FBSixDQUFXOUYsTUFBWCxFQUFtQjtBQUNqQixTQUFLcVcsT0FBTCxDQUFhdlEsS0FBYixHQUFxQjlGLE1BQXJCOztBQUNBLFNBQUswVyxjQUFMOztBQUVBaFosTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEIsS0FBS3RNLFFBQW5DO0FBQ0FILE1BQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUN5TSxVQUFwQixFQUFnQ3pNLEVBQUUsQ0FBQytJLGNBQW5DLEVBQW1ELEtBQUs0UCxPQUFMLENBQWF2USxLQUFoRTtBQUNBcEksTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEIsSUFBOUI7QUFDRDs7QUFFRCxNQUFJbkUsS0FBSixHQUFhO0FBQUUsV0FBTyxLQUFLcVEsT0FBTCxDQUFhclEsS0FBcEI7QUFBMkI7O0FBRTFDLE1BQUlBLEtBQUosQ0FBV2hHLE1BQVgsRUFBbUI7QUFDakIsU0FBS3FXLE9BQUwsQ0FBYXJRLEtBQWIsR0FBcUJoRyxNQUFyQjs7QUFDQSxTQUFLMFcsY0FBTDs7QUFFQWhaLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLEtBQUt0TSxRQUFuQztBQUNBSCxNQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDeU0sVUFBcEIsRUFBZ0N6TSxFQUFFLENBQUNnSixjQUFuQyxFQUFtRCxLQUFLMlAsT0FBTCxDQUFhclEsS0FBaEU7QUFDQXRJLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLElBQTlCO0FBQ0Q7O0FBRUQsTUFBSThNLFNBQUosR0FBaUI7QUFBRSxXQUFPLEtBQUtmLFVBQVo7QUFBd0I7O0FBRTNDLE1BQUk1TyxLQUFKLEdBQWE7QUFBRSxXQUFPLEtBQUtpUCxNQUFaO0FBQW9COztBQUVuQyxNQUFJaFAsTUFBSixHQUFjO0FBQUUsV0FBTyxLQUFLaVAsT0FBWjtBQUFxQjs7QUFFckMsTUFBSWphLE9BQUosR0FBZTtBQUFFLFdBQU8sS0FBS3NCLFFBQVo7QUFBc0I7O0FBRXZDLE1BQUl1WixjQUFKLEdBQXNCO0FBQUUsV0FBTyxLQUFLaEIsZUFBWjtBQUE2Qjs7QUFsT3ZDOztBQXFPaEIsU0FBU2pELFlBQVQsQ0FBdUJDLENBQXZCLEVBQTBCO0FBQ3hCLFNBQVFBLENBQUMsS0FBSyxDQUFQLElBQWMsRUFBRUEsQ0FBQyxHQUFJQSxDQUFDLEdBQUcsQ0FBWCxDQUFyQjtBQUNEOztBQUFBOztBQUVELFNBQVM0QyxhQUFULENBQXdCbEosT0FBeEIsRUFBaUM7QUFDL0I7QUFDQTtBQUVBLE1BQUloQixJQUFJLEdBQUd6SiwrQ0FBRSxDQUFDMEosYUFBZDs7QUFFQSxNQUFJZSxPQUFPLFlBQVl1SyxLQUF2QixFQUE4QjtBQUM1QnZMLFFBQUksR0FBR3pKLCtDQUFFLENBQUMwSixhQUFWO0FBQ0QsR0FGRCxNQUVPLElBQUllLE9BQU8sWUFBWXFLLFVBQXZCLEVBQW1DO0FBQ3hDckwsUUFBSSxHQUFHekosK0NBQUUsQ0FBQzBKLGFBQVY7QUFDRCxHQUZNLE1BRUEsSUFBSWUsT0FBTyxZQUFZMkIsWUFBdkIsRUFBcUM7QUFDMUMzQyxRQUFJLEdBQUd6SiwrQ0FBRSxDQUFDbUYsS0FBVjtBQUNELEdBRk0sTUFFQSxJQUFJc0YsT0FBTyxZQUFZd0ssZ0JBQXZCLEVBQXlDO0FBQzlDeEwsUUFBSSxHQUFHLE9BQVA7QUFDRCxHQUZNLE1BRUEsSUFBSWdCLE9BQU8sWUFBWXlLLGlCQUF2QixFQUEwQztBQUMvQ3pMLFFBQUksR0FBRyxRQUFQO0FBQ0QsR0FGTSxNQUVBLElBQUlnQixPQUFPLFlBQVkwSyxnQkFBdkIsRUFBeUM7QUFDOUMxTCxRQUFJLEdBQUcsT0FBUDtBQUNEOztBQUNELFNBQU9BLElBQVA7QUFDRDs7QUFFRCxJQUFJbUosYUFBSixFQUFtQkMsWUFBbkIsRUFBaUNDLGFBQWpDOztBQUVBM1ksU0FBUyxDQUFDNFksWUFBVixHQUF5QixTQUFTQSxZQUFULEdBQXlCO0FBQ2hELE1BQUlILGFBQWEsS0FBS3JULFNBQXRCLEVBQWlDO0FBQy9CLFVBQU15VCxNQUFNLEdBQUdsVyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjtBQUNBaVcsVUFBTSxDQUFDL04sS0FBUCxHQUFlK04sTUFBTSxDQUFDOU4sTUFBUCxHQUFnQixDQUEvQjtBQUNBLFVBQU0rTixHQUFHLEdBQUdELE1BQU0sQ0FBQ0UsVUFBUCxDQUFrQixJQUFsQixDQUFaO0FBQ0FELE9BQUcsQ0FBQ0UsU0FBSixHQUFnQixNQUFoQjtBQUNBRixPQUFHLENBQUNHLFFBQUosQ0FBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCO0FBQ0FSLGlCQUFhLEdBQUcsSUFBSXpZLFNBQUosQ0FBYzZZLE1BQWQsQ0FBaEI7QUFDRDs7QUFFRCxTQUFPSixhQUFQO0FBQ0QsQ0FYRDs7QUFhQXpZLFNBQVMsQ0FBQ2taLFdBQVYsR0FBd0IsU0FBU0EsV0FBVCxHQUF3QjtBQUM5QyxNQUFJUixZQUFZLEtBQUt0VCxTQUFyQixFQUFnQztBQUM5QixVQUFNeVQsTUFBTSxHQUFHbFcsUUFBUSxDQUFDQyxhQUFULENBQXVCLFFBQXZCLENBQWY7QUFDQWlXLFVBQU0sQ0FBQy9OLEtBQVAsR0FBZStOLE1BQU0sQ0FBQzlOLE1BQVAsR0FBZ0IsQ0FBL0I7QUFDQSxVQUFNK04sR0FBRyxHQUFHRCxNQUFNLENBQUNFLFVBQVAsQ0FBa0IsSUFBbEIsQ0FBWjtBQUNBRCxPQUFHLENBQUNFLFNBQUosR0FBZ0Isb0JBQWhCO0FBQ0FGLE9BQUcsQ0FBQ0csUUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEI7QUFDQVAsZ0JBQVksR0FBRyxJQUFJMVksU0FBSixDQUFjNlksTUFBZCxDQUFmO0FBQ0Q7O0FBQ0QsU0FBT0gsWUFBUDtBQUNELENBVkQ7O0FBWUExWSxTQUFTLENBQUNtWixZQUFWLEdBQXlCLFNBQVNBLFlBQVQsR0FBeUI7QUFDaEQsTUFBSVIsYUFBYSxLQUFLdlQsU0FBdEIsRUFBaUM7QUFDL0IsVUFBTXlULE1BQU0sR0FBR2xXLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixRQUF2QixDQUFmO0FBQ0FpVyxVQUFNLENBQUMvTixLQUFQLEdBQWUrTixNQUFNLENBQUM5TixNQUFQLEdBQWdCLENBQS9CO0FBQ0EsVUFBTStOLEdBQUcsR0FBR0QsTUFBTSxDQUFDRSxVQUFQLENBQWtCLElBQWxCLENBQVo7QUFDQUQsT0FBRyxDQUFDRSxTQUFKLEdBQWdCLGNBQWhCO0FBQ0FGLE9BQUcsQ0FBQ0csUUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEI7QUFDQU4saUJBQWEsR0FBRyxJQUFJM1ksU0FBSixDQUFjNlksTUFBZCxDQUFoQjtBQUNEOztBQUNELFNBQU9GLGFBQVA7QUFDRCxDQVZEOztBQVllM1ksd0VBQWYsRTs7Ozs7Ozs7Ozs7O0FDL1NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBSWtCLEVBQUo7O0FBRUEsTUFBTTRFLE1BQU4sQ0FBYTtBQUNYM0MsYUFBVyxHQUFJO0FBQ2IsU0FBSzhYLFNBQUwsR0FBaUIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQWpCO0FBQ0EsU0FBS0MsdUJBQUwsR0FBK0IsRUFBL0I7QUFDQSxTQUFLQyxjQUFMLEdBQXNCL0gsOENBQUksQ0FBQ2dJLE1BQUwsRUFBdEI7QUFDQSxTQUFLQyxhQUFMLEdBQXFCbEksOENBQUksQ0FBQ2lJLE1BQUwsRUFBckI7QUFDQSxTQUFLRSx1QkFBTCxHQUErQm5JLDhDQUFJLENBQUNpSSxNQUFMLEVBQS9CO0FBQ0EsU0FBS0csWUFBTCxHQUFvQm5JLDhDQUFJLENBQUNnSSxNQUFMLEVBQXBCO0FBQ0EsU0FBS0ksT0FBTCxHQUFlcEksOENBQUksQ0FBQ2dJLE1BQUwsRUFBZjtBQUNBLFNBQUtLLGFBQUwsR0FBcUIsRUFBckI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixLQUFsQjtBQUNBLFNBQUtDLGlCQUFMLEdBQXlCLEtBQXpCO0FBQ0EsU0FBS0MsaUJBQUwsR0FBeUIsS0FBekI7QUFDQSxTQUFLQyxjQUFMLEdBQXNCLEtBQXRCO0FBQ0ExSSxrREFBSSxDQUFDMkksUUFBTCxDQUFjLEtBQUtaLGNBQW5CLEVBQW1DLEtBQUtBLGNBQXhDO0FBRUEsU0FBS2EsUUFBTCxHQUFnQixLQUFoQjs7QUFDQSxRQUFJLGlFQUFpRUMsSUFBakUsQ0FBc0U1VCxTQUFTLENBQUNDLFNBQWhGLENBQUosRUFBZ0c7QUFDOUYsV0FBSzBULFFBQUwsR0FBZ0IsSUFBaEI7QUFDRDtBQUNGLEdBckJVLENBdUJYOzs7QUFFQXpjLE1BQUksQ0FBRTJjLE9BQUYsRUFBV2pULFdBQVcsR0FBRyxFQUF6QixFQUE2QjtBQUMvQixRQUFJaVQsT0FBTyxLQUFLLElBQVosSUFBb0JBLE9BQU8sS0FBSzlXLFNBQXBDLEVBQStDO0FBQzdDekUsYUFBTyxDQUFDdU4sS0FBUixDQUFjLGtCQUFkO0FBQ0E7QUFDRDs7QUFFRCxRQUFJLEtBQUsySyxNQUFMLEtBQWdCelQsU0FBaEIsSUFBNkIsS0FBS3lULE1BQUwsS0FBZ0IsSUFBakQsRUFBdUQ7QUFDckQsV0FBSzVYLE9BQUw7QUFDRDs7QUFFRCxTQUFLNFgsTUFBTCxHQUFjcUQsT0FBZDtBQUNBLFNBQUtDLE9BQUwsQ0FBYXphLE1BQU0sQ0FBQzBhLFVBQXBCLEVBQWdDMWEsTUFBTSxDQUFDMmEsV0FBdkM7QUFFQXBULGVBQVcsQ0FBQ3FULFNBQVosR0FBd0JyVCxXQUFXLENBQUNxVCxTQUFaLElBQXlCLEtBQWpEO0FBRUEsUUFBSXhELEdBQUo7O0FBQ0EsUUFBSTdQLFdBQVcsQ0FBQ3FULFNBQWhCLEVBQTJCO0FBQ3pCeEQsU0FBRyxHQUFHLEtBQUtELE1BQUwsQ0FBWUUsVUFBWixDQUF1QixxQkFBdkIsRUFBOEM5UCxXQUE5QyxLQUE4RCxLQUFLNFAsTUFBTCxDQUFZRSxVQUFaLENBQXVCLFFBQXZCLEVBQWlDOVAsV0FBakMsQ0FBcEU7O0FBRUEsVUFBSSxDQUFDNlAsR0FBTCxFQUFVO0FBQ1JBLFdBQUcsR0FBRyxLQUFLRCxNQUFMLENBQVlFLFVBQVosQ0FBdUIsT0FBdkIsRUFBZ0M5UCxXQUFoQyxLQUFnRCxLQUFLNFAsTUFBTCxDQUFZRSxVQUFaLENBQXVCLG9CQUF2QixFQUE2QzlQLFdBQTdDLENBQXREO0FBQ0EsYUFBSzBTLFVBQUwsR0FBa0IsS0FBbEI7QUFDRCxPQUhELE1BR087QUFDTCxhQUFLQSxVQUFMLEdBQWtCLElBQWxCO0FBQ0FoYixlQUFPLENBQUNDLEdBQVIsQ0FBWSxrQkFBWixFQUFnQ2tZLEdBQWhDO0FBQ0Q7QUFDRixLQVZELE1BVU87QUFDTEEsU0FBRyxHQUFHLEtBQUtELE1BQUwsQ0FBWUUsVUFBWixDQUF1QixPQUF2QixFQUFnQzlQLFdBQWhDLEtBQWdELEtBQUs0UCxNQUFMLENBQVlFLFVBQVosQ0FBdUIsb0JBQXZCLEVBQTZDOVAsV0FBN0MsQ0FBdEQ7QUFDQSxXQUFLMFMsVUFBTCxHQUFrQixLQUFsQjtBQUNELEtBN0I4QixDQStCL0I7OztBQUNBLFNBQUtZLFVBQUwsQ0FBZ0J6RCxHQUFoQjtBQUNEOztBQUVEeUQsWUFBVSxDQUFFekQsR0FBRixFQUFPO0FBQ2YsUUFBSSxDQUFDLEtBQUtELE1BQVYsRUFBa0I7QUFBRSxXQUFLQSxNQUFMLEdBQWNDLEdBQUcsQ0FBQ0QsTUFBbEI7QUFBMEI7O0FBQzlDM1gsTUFBRSxHQUFHLEtBQUtBLEVBQUwsR0FBVTRYLEdBQWY7QUFFQSxTQUFLMEQsVUFBTCxHQUFrQixFQUFsQjs7QUFDQSxTQUFLLElBQUlyYixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc2IsNkRBQWMsQ0FBQ25kLE1BQW5DLEVBQTJDNkIsQ0FBQyxFQUE1QyxFQUFnRDtBQUM5QyxXQUFLcWIsVUFBTCxDQUFnQkMsNkRBQWMsQ0FBQ3RiLENBQUQsQ0FBOUIsSUFBcUNELEVBQUUsQ0FBQ2hDLFlBQUgsQ0FBZ0J1ZCw2REFBYyxDQUFDdGIsQ0FBRCxDQUE5QixDQUFyQztBQUNELEtBUGMsQ0FTZjs7O0FBQ0F1YiwyRUFBZ0I7QUFDaEJDLCtFQUFvQixDQUFDemIsRUFBRCxFQUFLLHlCQUFMLENBQXBCO0FBQ0F5YiwrRUFBb0IsQ0FBQ3piLEVBQUQsRUFBSyx3QkFBTCxDQUFwQjtBQUNBeWIsK0VBQW9CLENBQUN6YixFQUFELEVBQUssb0JBQUwsQ0FBcEI7QUFFQSxTQUFLMGIsTUFBTCxDQUFZLEtBQUtDLFVBQWpCO0FBQ0EsU0FBS0QsTUFBTCxDQUFZLEtBQUtFLFNBQWpCO0FBQ0EsU0FBS0YsTUFBTCxDQUFZLEtBQUtHLEtBQWpCO0FBQ0EsU0FBS0MsbUJBQUw7QUFDRCxHQS9FVSxDQWlGWDs7O0FBRUFDLGFBQVcsQ0FBRXJHLENBQUYsRUFBS3NHLENBQUwsRUFBUW5HLENBQVIsRUFBV0UsQ0FBWCxFQUFjO0FBQ3ZCLFFBQUlrRyxVQUFVLEdBQUcsS0FBakI7O0FBQ0EsUUFBSXZHLENBQUMsS0FBSyxLQUFLcUUsU0FBTCxDQUFlLENBQWYsQ0FBVixFQUE2QjtBQUFFa0MsZ0JBQVUsR0FBRyxJQUFiO0FBQW1COztBQUNsRCxRQUFJRCxDQUFDLEtBQUssS0FBS2pDLFNBQUwsQ0FBZSxDQUFmLENBQVYsRUFBNkI7QUFBRWtDLGdCQUFVLEdBQUcsSUFBYjtBQUFtQjs7QUFDbEQsUUFBSXBHLENBQUMsS0FBSyxLQUFLa0UsU0FBTCxDQUFlLENBQWYsQ0FBVixFQUE2QjtBQUFFa0MsZ0JBQVUsR0FBRyxJQUFiO0FBQW1COztBQUNsRCxRQUFJbEcsQ0FBQyxLQUFLLEtBQUtnRSxTQUFMLENBQWUsQ0FBZixDQUFWLEVBQTZCO0FBQUVrQyxnQkFBVSxHQUFHLElBQWI7QUFBbUI7O0FBRWxELFFBQUlBLFVBQUosRUFBZ0I7QUFDZGpjLFFBQUUsQ0FBQzRLLFFBQUgsQ0FBWThLLENBQVosRUFBZXNHLENBQWYsRUFBa0JuRyxDQUFsQixFQUFxQkUsQ0FBckI7QUFDQSxXQUFLZ0UsU0FBTCxHQUFpQixDQUFDckUsQ0FBRCxFQUFJc0csQ0FBSixFQUFPbkcsQ0FBUCxFQUFVRSxDQUFWLENBQWpCO0FBQ0Q7QUFDRjs7QUFFRG1HLFNBQU8sQ0FBRXhHLENBQUYsRUFBS3NHLENBQUwsRUFBUW5HLENBQVIsRUFBV0UsQ0FBWCxFQUFjO0FBQ25CL1YsTUFBRSxDQUFDa2MsT0FBSCxDQUFXeEcsQ0FBWCxFQUFjc0csQ0FBZCxFQUFpQm5HLENBQWpCLEVBQW9CRSxDQUFwQjtBQUNEOztBQUVEOUksT0FBSyxDQUFFd0IsQ0FBRixFQUFLQyxDQUFMLEVBQVFDLENBQVIsRUFBVzdRLENBQVgsRUFBYztBQUNqQmtDLE1BQUUsQ0FBQ21jLFVBQUgsQ0FBYzFOLENBQWQsRUFBaUJDLENBQWpCLEVBQW9CQyxDQUFwQixFQUF1QjdRLENBQXZCO0FBQ0FrQyxNQUFFLENBQUNpTixLQUFILENBQVNqTixFQUFFLENBQUNvYyxnQkFBSCxHQUFzQnBjLEVBQUUsQ0FBQ3FjLGdCQUFsQztBQUNEOztBQUVEQyxVQUFRLENBQUVoYSxNQUFGLEVBQVU7QUFDaEJ0QyxNQUFFLENBQUNzYyxRQUFILENBQVloYSxNQUFaO0FBQ0Q7O0FBRURpYSxhQUFXLENBQUVDLE9BQUYsRUFBVztBQUNwQixTQUFLQyxNQUFMLEdBQWNELE9BQWQ7QUFDQSxTQUFLRSxNQUFMLENBQVksS0FBS3pDLGNBQWpCO0FBQ0Q7O0FBRURsSCxXQUFTLENBQUV2TCxPQUFGLEVBQVc7QUFDbEIsU0FBS0ssTUFBTCxHQUFjTCxPQUFkO0FBQ0EsU0FBS3NMLGFBQUwsR0FBcUIsS0FBS2pMLE1BQUwsQ0FBWWlMLGFBQWpDO0FBQ0Q7O0FBRUQ0SixRQUFNLENBQUVDLFNBQUYsRUFBYTtBQUNqQnpLLGtEQUFJLENBQUMwSyxJQUFMLENBQVUsS0FBS3ZDLFlBQWYsRUFBNkJzQyxTQUE3QjtBQUNBekssa0RBQUksQ0FBQzJLLFFBQUwsQ0FBYyxLQUFLdkMsT0FBbkIsRUFBNEIsS0FBS21DLE1BQUwsQ0FBWUssTUFBeEMsRUFBZ0QsS0FBS3pDLFlBQXJEO0FBQ0FwSSxrREFBSSxDQUFDOEssUUFBTCxDQUFjLEtBQUs1QyxhQUFuQixFQUFrQyxLQUFLRyxPQUF2QztBQUNBckksa0RBQUksQ0FBQytLLE1BQUwsQ0FBWSxLQUFLN0MsYUFBakIsRUFBZ0MsS0FBS0EsYUFBckM7QUFDQWxJLGtEQUFJLENBQUNnTCxTQUFMLENBQWUsS0FBSzlDLGFBQXBCLEVBQW1DLEtBQUtBLGFBQXhDO0FBRUFsSSxrREFBSSxDQUFDOEssUUFBTCxDQUFjLEtBQUszQyx1QkFBbkIsRUFBNEMsS0FBS0UsT0FBakQ7QUFDQXJJLGtEQUFJLENBQUMrSyxNQUFMLENBQVksS0FBSzVDLHVCQUFqQixFQUEwQyxLQUFLQSx1QkFBL0M7QUFDRDs7QUFFRHpTLE1BQUksQ0FBRUosS0FBRixFQUFTMlYsWUFBVCxFQUF1QjtBQUN6QixRQUFJM1YsS0FBSyxDQUFDbkosTUFBVixFQUFrQjtBQUNoQixXQUFLLElBQUk2QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc0gsS0FBSyxDQUFDbkosTUFBMUIsRUFBa0M2QixDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLGFBQUswSCxJQUFMLENBQVVKLEtBQUssQ0FBQ3RILENBQUQsQ0FBZjtBQUNEOztBQUNEO0FBQ0Q7O0FBRURzSCxTQUFLLENBQUNLLElBQU4sQ0FBVyxLQUFLa0wsYUFBaEIsRUFSeUIsQ0FVekI7O0FBQ0EsUUFBSSxLQUFLMkosTUFBTCxLQUFnQnZZLFNBQXBCLEVBQStCO0FBQzdCLFdBQUsyRCxNQUFMLENBQVltTCxPQUFaLENBQW9CLG1CQUFwQixFQUF5QyxNQUF6QyxFQUFpRCxLQUFLeUosTUFBTCxDQUFZVSxVQUE3RDtBQUNBLFdBQUt0VixNQUFMLENBQVltTCxPQUFaLENBQW9CLGFBQXBCLEVBQW1DLE1BQW5DLEVBQTJDLEtBQUt5SixNQUFMLENBQVlLLE1BQXZEO0FBQ0Q7O0FBRUQsU0FBS2pWLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IsY0FBcEIsRUFBb0MsTUFBcEMsRUFBNEMsS0FBS3FILFlBQWpEO0FBQ0EsU0FBS3hTLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IsZUFBcEIsRUFBcUMsTUFBckMsRUFBNkMsS0FBS21ILGFBQWxEO0FBQ0EsU0FBS3RTLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IseUJBQXBCLEVBQStDLE1BQS9DLEVBQXVELEtBQUtvSCx1QkFBNUQ7QUFFQSxRQUFJZ0QsUUFBUSxHQUFHN1YsS0FBSyxDQUFDNlYsUUFBckI7O0FBQ0EsUUFBSUYsWUFBWSxLQUFLaFosU0FBckIsRUFBZ0M7QUFDOUJrWixjQUFRLEdBQUdGLFlBQVg7QUFDRDs7QUFFRCxRQUFJM1YsS0FBSyxDQUFDOFYsV0FBVixFQUF1QjtBQUNyQjtBQUNBcmQsUUFBRSxDQUFDc2QscUJBQUgsQ0FBeUIvVixLQUFLLENBQUM2VixRQUEvQixFQUF5QzdWLEtBQUssQ0FBQ2dXLE9BQU4sQ0FBY0MsUUFBdkQsRUFBaUV4ZCxFQUFFLENBQUN3TixjQUFwRSxFQUFvRixDQUFwRixFQUF1RmpHLEtBQUssQ0FBQ2tXLFdBQTdGO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsVUFBSUwsUUFBUSxLQUFLcGQsRUFBRSxDQUFDMGQsTUFBcEIsRUFBNEI7QUFDMUIxZCxVQUFFLENBQUMyZCxVQUFILENBQWNQLFFBQWQsRUFBd0IsQ0FBeEIsRUFBMkI3VixLQUFLLENBQUNxVyxVQUFqQztBQUNELE9BRkQsTUFFTztBQUNMNWQsVUFBRSxDQUFDNmQsWUFBSCxDQUFnQlQsUUFBaEIsRUFBMEI3VixLQUFLLENBQUNnVyxPQUFOLENBQWNDLFFBQXhDLEVBQWtEeGQsRUFBRSxDQUFDd04sY0FBckQsRUFBcUUsQ0FBckU7QUFDRDtBQUNGOztBQUVEakcsU0FBSyxDQUFDc0QsTUFBTjtBQUNEOztBQUVEaVQsdUJBQXFCLENBQUVDLGdCQUFGLEVBQW9CO0FBQ3ZDLFVBQU07QUFBRUMsZ0JBQUY7QUFBY0MscUJBQWQ7QUFBK0JDLGVBQS9CO0FBQTBDQztBQUExQyxRQUFnRUosZ0JBQXRFLENBRHVDLENBR3ZDOztBQUNBQyxjQUFVLENBQUNwVyxJQUFYLENBQWdCLEtBQUtrTCxhQUFyQjtBQUNBbUwsbUJBQWUsQ0FBQ0csZUFBaEIsQ0FBZ0MsS0FBS3RMLGFBQXJDLEVBTHVDLENBT3ZDOztBQUNBOVMsTUFBRSxDQUFDcWUscUJBQUgsQ0FBeUJyZSxFQUFFLENBQUNzZSxrQkFBNUIsRUFBZ0RILGlCQUFoRDtBQUVBRixtQkFBZSxDQUFDTSxVQUFoQixDQUEyQjFkLE9BQTNCLENBQW1DLENBQUMyZCxJQUFELEVBQU92ZSxDQUFQLEtBQWE7QUFDOUNELFFBQUUsQ0FBQ3llLGNBQUgsQ0FBa0J6ZSxFQUFFLENBQUMwZSx5QkFBckIsRUFBZ0R6ZSxDQUFoRCxFQUFtRHVlLElBQUksQ0FBQ0csTUFBeEQ7QUFDRCxLQUZEO0FBSUEzZSxNQUFFLENBQUMwYixNQUFILENBQVUxYixFQUFFLENBQUM0ZSxrQkFBYjtBQUVBNWUsTUFBRSxDQUFDNmUsc0JBQUgsQ0FBMEI3ZSxFQUFFLENBQUMwZCxNQUE3QjtBQUNBMWQsTUFBRSxDQUFDMmQsVUFBSCxDQUFjM2QsRUFBRSxDQUFDMGQsTUFBakIsRUFBeUIsQ0FBekIsRUFBNEJRLFNBQTVCO0FBQ0FsZSxNQUFFLENBQUM4ZSxvQkFBSCxHQWxCdUMsQ0FvQnZDOztBQUNBOWUsTUFBRSxDQUFDK2UsT0FBSCxDQUFXL2UsRUFBRSxDQUFDNGUsa0JBQWQ7QUFDQTVlLE1BQUUsQ0FBQzZTLFVBQUgsQ0FBYyxJQUFkO0FBQ0E3UyxNQUFFLENBQUNnZixVQUFILENBQWNoZixFQUFFLENBQUNpZixZQUFqQixFQUErQixJQUEvQjtBQUNBaEIsbUJBQWUsQ0FBQ00sVUFBaEIsQ0FBMkIxZCxPQUEzQixDQUFtQyxDQUFDMmQsSUFBRCxFQUFPdmUsQ0FBUCxLQUFhO0FBQzlDRCxRQUFFLENBQUN5ZSxjQUFILENBQWtCemUsRUFBRSxDQUFDMGUseUJBQXJCLEVBQWdEemUsQ0FBaEQsRUFBbUQsSUFBbkQ7QUFDRCxLQUZEO0FBR0FELE1BQUUsQ0FBQ3FlLHFCQUFILENBQXlCcmUsRUFBRSxDQUFDc2Usa0JBQTVCLEVBQWdELElBQWhEO0FBRUFOLGNBQVUsQ0FBQ25ULE1BQVg7QUFDRDs7QUFFRG9RLFNBQU8sQ0FBRWxQLE1BQUYsRUFBVUMsT0FBVixFQUFtQjtBQUN4QixTQUFLNk0sTUFBTCxHQUFjOU0sTUFBZDtBQUNBLFNBQUsrTSxPQUFMLEdBQWU5TSxPQUFmO0FBQ0EsU0FBSzJMLE1BQUwsQ0FBWS9OLEtBQVosR0FBb0IsS0FBS2lQLE1BQXpCO0FBQ0EsU0FBS2xCLE1BQUwsQ0FBWTlOLE1BQVosR0FBcUIsS0FBS2lQLE9BQTFCO0FBQ0EsU0FBS29HLFlBQUwsR0FBb0IsS0FBS3JHLE1BQUwsR0FBYyxLQUFLQyxPQUF2Qzs7QUFFQSxRQUFJOVksRUFBSixFQUFRO0FBQ04sV0FBSzRLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CLEtBQUtpTyxNQUF6QixFQUFpQyxLQUFLQyxPQUF0QztBQUNEO0FBQ0Y7O0FBRURxRyxnQkFBYyxHQUFJO0FBQ2hCMWYsV0FBTyxDQUFDQyxHQUFSLENBQVksZUFBWixFQUE2QixLQUFLNGIsVUFBbEM7O0FBQ0EsU0FBSyxNQUFNM2MsR0FBWCxJQUFrQixLQUFLMmMsVUFBdkIsRUFBbUM7QUFDakMsVUFBSSxLQUFLQSxVQUFMLENBQWdCM2MsR0FBaEIsQ0FBSixFQUEwQjtBQUN4QmMsZUFBTyxDQUFDQyxHQUFSLENBQVlmLEdBQVosRUFBaUIsR0FBakIsRUFBc0IsS0FBSzJjLFVBQUwsQ0FBZ0IzYyxHQUFoQixDQUF0QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRHNOLGdCQUFjLENBQUVtVCxVQUFGLEVBQWM7QUFDMUIsV0FBTyxDQUFDLENBQUMsS0FBSzlELFVBQUwsQ0FBZ0I4RCxVQUFoQixDQUFUO0FBQ0Q7O0FBRURwaEIsY0FBWSxDQUFFb2hCLFVBQUYsRUFBYztBQUN4QixXQUFPLEtBQUs5RCxVQUFMLENBQWdCOEQsVUFBaEIsQ0FBUDtBQUNELEdBcE9VLENBc09YOzs7QUFFQXRELHFCQUFtQixHQUFJO0FBQ3JCOWIsTUFBRSxDQUFDcWYsU0FBSCxDQUFhcmYsRUFBRSxDQUFDc2YsU0FBaEIsRUFBMkJ0ZixFQUFFLENBQUN1ZixtQkFBOUI7QUFDRDs7QUFFREMsd0JBQXNCLEdBQUk7QUFDeEJ4ZixNQUFFLENBQUNxZixTQUFILENBQWFyZixFQUFFLENBQUN5ZixHQUFoQixFQUFxQnpmLEVBQUUsQ0FBQ3lmLEdBQXhCO0FBQ0QsR0E5T1UsQ0FnUFg7OztBQUVBQyxZQUFVLEdBQUk7QUFDWixVQUFNQyxHQUFHLEdBQUd6Tiw4Q0FBSSxDQUFDME4sS0FBTCxDQUFXLEtBQUt2RixZQUFoQixDQUFaOztBQUNBLFNBQUtFLGFBQUwsQ0FBbUJ4YixJQUFuQixDQUF3QjRnQixHQUF4QjtBQUNEOztBQUVERSxXQUFTLEdBQUk7QUFDWCxRQUFJLEtBQUt0RixhQUFMLENBQW1CbmMsTUFBbkIsSUFBNkIsQ0FBakMsRUFBb0M7QUFDbEMsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsVUFBTXVoQixHQUFHLEdBQUcsS0FBS3BGLGFBQUwsQ0FBbUJ1RixHQUFuQixFQUFaOztBQUNBLFNBQUtwRCxNQUFMLENBQVlpRCxHQUFaO0FBQ0QsR0E3UFUsQ0ErUFg7OztBQUVBakUsUUFBTSxDQUFFcUUsVUFBRixFQUFjO0FBQUUvZixNQUFFLENBQUMwYixNQUFILENBQVVxRSxVQUFWO0FBQXdCOztBQUU5Q2hCLFNBQU8sQ0FBRWdCLFVBQUYsRUFBYztBQUFFL2YsTUFBRSxDQUFDK2UsT0FBSCxDQUFXZ0IsVUFBWDtBQUF3Qjs7QUFFL0NuVixVQUFRLENBQUU4SyxDQUFGLEVBQUtzRyxDQUFMLEVBQVFuRyxDQUFSLEVBQVdFLENBQVgsRUFBYztBQUFFLFNBQUtnRyxXQUFMLENBQWlCckcsQ0FBakIsRUFBb0JzRyxDQUFwQixFQUF1Qm5HLENBQXZCLEVBQTBCRSxDQUExQjtBQUE4QixHQXJRM0MsQ0F1UVg7OztBQUVBLE1BQUlqTSxLQUFKLEdBQWE7QUFBRSxXQUFPa1csK0RBQVEsRUFBZjtBQUFtQjs7QUFFbEMsTUFBSUMsVUFBSixHQUFrQjtBQUFFLFdBQU9DLG1FQUFZLEVBQW5CO0FBQXVCOztBQUUzQyxNQUFJdFcsS0FBSixHQUFhO0FBQUUsV0FBTyxLQUFLaVAsTUFBWjtBQUFxQjs7QUFFcEMsTUFBSWhQLE1BQUosR0FBYztBQUFFLFdBQU8sS0FBS2lQLE9BQVo7QUFBcUI7O0FBRXJDLE1BQUlxSCxXQUFKLEdBQW1CO0FBQUUsV0FBTyxLQUFLakIsWUFBWjtBQUEwQjs7QUFFL0MsTUFBSXBULE1BQUosR0FBYztBQUFFLFdBQU8sS0FBSzJPLFVBQVo7QUFBd0IsR0FuUjdCLENBcVJYOzs7QUFFQTFhLFNBQU8sR0FBSTtBQUNULFFBQUksS0FBSzRYLE1BQUwsQ0FBWXlJLFVBQWhCLEVBQTRCO0FBQzFCLFVBQUk7QUFDRixhQUFLekksTUFBTCxDQUFZeUksVUFBWixDQUF1QkMsV0FBdkIsQ0FBbUMsS0FBSzFJLE1BQXhDO0FBQ0QsT0FGRCxDQUVFLE9BQU9qWCxDQUFQLEVBQVU7QUFDVmpCLGVBQU8sQ0FBQ0MsR0FBUixDQUFZLFVBQVosRUFBd0JnQixDQUF4QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBS2lYLE1BQUwsR0FBYyxJQUFkO0FBQ0Q7O0FBalNVOztBQW9TYixNQUFNaFQsRUFBRSxHQUFHLElBQUlDLE1BQUosRUFBWDtBQUVlRCxpRUFBZixFOzs7Ozs7Ozs7Ozs7QUNuVEE7QUFBQTtBQUFBO0FBRWE7O0FBRWI7QUFFQSxNQUFNSSxJQUFJLEdBQUcsRUFBYjtBQUNBLElBQUl1YixPQUFKOztBQUVBdmIsSUFBSSxDQUFDd2IsS0FBTCxHQUFhLFNBQVNBLEtBQVQsQ0FBZTNXLEtBQWYsRUFBc0JDLE1BQXRCLEVBQThCMlcsV0FBOUIsRUFBMkNDLElBQUksR0FBRyxJQUFsRCxFQUF3RHJELFFBQVEsR0FBRyxDQUFuRSxFQUFzRTtBQUNsRixRQUFNc0QsU0FBUyxHQUFHLEVBQWxCO0FBQ0EsUUFBTUMsTUFBTSxHQUFNLEVBQWxCO0FBQ0EsUUFBTUMsT0FBTyxHQUFLLEVBQWxCO0FBQ0EsUUFBTUMsT0FBTyxHQUFLLEVBQWxCO0FBRUEsUUFBTUMsSUFBSSxHQUFJbFgsS0FBSyxHQUFHNFcsV0FBdEI7QUFDQSxRQUFNTyxJQUFJLEdBQUlsWCxNQUFNLEdBQUcyVyxXQUF2QjtBQUNBLFFBQU1RLEtBQUssR0FBRyxJQUFJUixXQUFsQjtBQUNBLFFBQU1TLEVBQUUsR0FBTSxDQUFDclgsS0FBRCxHQUFTLEdBQXZCO0FBQ0EsUUFBTXNYLEVBQUUsR0FBTSxDQUFDclgsTUFBRCxHQUFVLEdBQXhCO0FBQ0EsTUFBSTZGLEtBQUssR0FBRyxDQUFaOztBQUVBLE9BQUksSUFBSXpQLENBQUMsR0FBRyxDQUFaLEVBQWVBLENBQUMsR0FBR3VnQixXQUFuQixFQUFnQ3ZnQixDQUFDLEVBQWpDLEVBQXFDO0FBQ3BDLFNBQUssSUFBSTBQLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2USxXQUFwQixFQUFpQzdRLENBQUMsRUFBbEMsRUFBc0M7QUFDckMsWUFBTXdSLEVBQUUsR0FBR0wsSUFBSSxHQUFHN2dCLENBQVAsR0FBV2doQixFQUF0QjtBQUNBLFlBQU1HLEVBQUUsR0FBR0wsSUFBSSxHQUFHcFIsQ0FBUCxHQUFXdVIsRUFBdEI7QUFFQSxZQUFNRyxDQUFDLEdBQUdwaEIsQ0FBQyxHQUFHdWdCLFdBQWQ7QUFDQSxZQUFNYyxDQUFDLEdBQUczUixDQUFDLEdBQUc2USxXQUFkOztBQUVBLFVBQUdDLElBQUksS0FBSyxJQUFaLEVBQWtCO0FBQ2pCQyxpQkFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDb2lCLEVBQUQsRUFBTyxDQUFQLEVBQVlDLEVBQUUsR0FBR0wsSUFBakIsQ0FBZjtBQUNBTCxpQkFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDb2lCLEVBQUUsR0FBR0wsSUFBTixFQUFhLENBQWIsRUFBa0JNLEVBQUUsR0FBR0wsSUFBdkIsQ0FBZjtBQUNBTCxpQkFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDb2lCLEVBQUUsR0FBR0wsSUFBTixFQUFhLENBQWIsRUFBa0JNLEVBQWxCLENBQWY7QUFDQVYsaUJBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQ29pQixFQUFELEVBQU8sQ0FBUCxFQUFZQyxFQUFaLENBQWY7QUFFQVQsY0FBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDc2lCLENBQUQsRUFBSSxPQUFPQyxDQUFDLEdBQUdOLEtBQVgsQ0FBSixDQUFaO0FBQ0FMLGNBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQ3NpQixDQUFDLEdBQUdMLEtBQUwsRUFBWSxPQUFPTSxDQUFDLEdBQUdOLEtBQVgsQ0FBWixDQUFaO0FBQ0FMLGNBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQ3NpQixDQUFDLEdBQUdMLEtBQUwsRUFBWSxNQUFNTSxDQUFsQixDQUFaO0FBQ0FYLGNBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQ3NpQixDQUFELEVBQUksTUFBTUMsQ0FBVixDQUFaO0FBRUFULGVBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLGVBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLGVBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLGVBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBLE9BZkQsTUFlTyxJQUFHMGhCLElBQUksS0FBSyxJQUFaLEVBQWtCO0FBQ3hCQyxpQkFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUQsRUFBSXFpQixFQUFKLEVBQVFELEVBQVIsQ0FBZjtBQUNBVCxpQkFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUQsRUFBSXFpQixFQUFKLEVBQVFELEVBQUUsR0FBR0wsSUFBYixDQUFmO0FBQ0FKLGlCQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMsQ0FBRCxFQUFJcWlCLEVBQUUsR0FBR0wsSUFBVCxFQUFlSSxFQUFFLEdBQUdMLElBQXBCLENBQWY7QUFDQUosaUJBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQyxDQUFELEVBQUlxaUIsRUFBRSxHQUFHTCxJQUFULEVBQWVJLEVBQWYsQ0FBZjtBQUVBUixjQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUNzaUIsQ0FBRCxFQUFJQyxDQUFKLENBQVo7QUFDQVgsY0FBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDc2lCLENBQUMsR0FBR0wsS0FBTCxFQUFZTSxDQUFaLENBQVo7QUFDQVgsY0FBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDc2lCLENBQUMsR0FBR0wsS0FBTCxFQUFZTSxDQUFDLEdBQUdOLEtBQWhCLENBQVo7QUFDQUwsY0FBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDc2lCLENBQUQsRUFBSUMsQ0FBQyxHQUFHTixLQUFSLENBQVo7QUFFQUgsZUFBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBQ0E4aEIsZUFBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBQ0E4aEIsZUFBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBQ0E4aEIsZUFBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBQ0EsT0FmTSxNQWVBO0FBQ04yaEIsaUJBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQ29pQixFQUFELEVBQU9DLEVBQVAsRUFBWSxDQUFaLENBQWY7QUFDQVYsaUJBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQ29pQixFQUFFLEdBQUdMLElBQU4sRUFBYU0sRUFBYixFQUFrQixDQUFsQixDQUFmO0FBQ0FWLGlCQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUNvaUIsRUFBRSxHQUFHTCxJQUFOLEVBQWFNLEVBQUUsR0FBR0wsSUFBbEIsRUFBeUIsQ0FBekIsQ0FBZjtBQUNBTCxpQkFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDb2lCLEVBQUQsRUFBT0MsRUFBRSxHQUFHTCxJQUFaLEVBQW1CLENBQW5CLENBQWY7QUFFQUosY0FBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDc2lCLENBQUQsRUFBSUMsQ0FBSixDQUFaO0FBQ0FYLGNBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQ3NpQixDQUFDLEdBQUdMLEtBQUwsRUFBWU0sQ0FBWixDQUFaO0FBQ0FYLGNBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQ3NpQixDQUFDLEdBQUdMLEtBQUwsRUFBWU0sQ0FBQyxHQUFHTixLQUFoQixDQUFaO0FBQ0FMLGNBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQ3NpQixDQUFELEVBQUlDLENBQUMsR0FBR04sS0FBUixDQUFaO0FBRUFILGVBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLGVBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLGVBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLGVBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOztBQUdENmhCLGFBQU8sQ0FBQzdoQixJQUFSLENBQWEyUSxLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0FrUixhQUFPLENBQUM3aEIsSUFBUixDQUFhMlEsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBa1IsYUFBTyxDQUFDN2hCLElBQVIsQ0FBYTJRLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQWtSLGFBQU8sQ0FBQzdoQixJQUFSLENBQWEyUSxLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0FrUixhQUFPLENBQUM3aEIsSUFBUixDQUFhMlEsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBa1IsYUFBTyxDQUFDN2hCLElBQVIsQ0FBYTJRLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFFQUEsV0FBSztBQUNMO0FBQ0Q7O0FBRUQsUUFBTW5RLElBQUksR0FBRyxJQUFJdUYsNkNBQUosQ0FBU3NZLFFBQVQsQ0FBYjtBQUNBN2QsTUFBSSxDQUFDZ2lCLFlBQUwsQ0FBa0JiLFNBQWxCO0FBQ0FuaEIsTUFBSSxDQUFDaWlCLGNBQUwsQ0FBb0JiLE1BQXBCO0FBQ0FwaEIsTUFBSSxDQUFDa2lCLFdBQUwsQ0FBaUJiLE9BQWpCO0FBQ0FyaEIsTUFBSSxDQUFDbWlCLFlBQUwsQ0FBa0JiLE9BQWxCO0FBRUEsU0FBT3RoQixJQUFQO0FBQ0EsQ0F2RkQ7O0FBeUZBd0YsSUFBSSxDQUFDNGMsTUFBTCxHQUFjLFNBQVNBLE1BQVQsQ0FBZ0I3WixJQUFoQixFQUFzQjBZLFdBQXRCLEVBQW1Db0IsUUFBUSxHQUFHLEtBQTlDLEVBQXFEeEUsUUFBUSxHQUFHLENBQWhFLEVBQW1FO0FBQ2hGLFFBQU1zRCxTQUFTLEdBQUcsRUFBbEI7QUFDQSxRQUFNQyxNQUFNLEdBQU0sRUFBbEI7QUFDQSxRQUFNQyxPQUFPLEdBQUssRUFBbEI7QUFDQSxRQUFNQyxPQUFPLEdBQUssRUFBbEI7QUFDQSxRQUFNRyxLQUFLLEdBQU8sSUFBSVIsV0FBdEI7QUFDQSxNQUFJOVEsS0FBSyxHQUFRLENBQWpCOztBQUdBLFdBQVNtUyxXQUFULENBQXFCNWhCLENBQXJCLEVBQXdCMFAsQ0FBeEIsRUFBMkJtUyxRQUFRLEdBQUcsS0FBdEMsRUFBNkM7QUFBRTtBQUM5QyxVQUFNNWUsRUFBRSxHQUFVakQsQ0FBQyxHQUFHdWdCLFdBQUosR0FBa0I3UCxJQUFJLENBQUNvUixFQUF2QixHQUE0QnBSLElBQUksQ0FBQ29SLEVBQUwsR0FBVSxHQUF4RDtBQUNBLFVBQU01ZSxFQUFFLEdBQVV3TSxDQUFDLEdBQUc2USxXQUFKLEdBQWtCN1AsSUFBSSxDQUFDb1IsRUFBdkIsR0FBNEIsQ0FBOUM7QUFDQSxVQUFNdFQsQ0FBQyxHQUFXcVQsUUFBUSxHQUFHLENBQUgsR0FBT2hhLElBQWpDO0FBQ0EsVUFBTWthLEdBQUcsR0FBUyxFQUFsQjtBQUNBQSxPQUFHLENBQUMsQ0FBRCxDQUFILEdBQWlCclIsSUFBSSxDQUFDc1IsR0FBTCxDQUFTL2UsRUFBVCxJQUFldUwsQ0FBaEM7QUFDQSxVQUFNeVQsQ0FBQyxHQUFXdlIsSUFBSSxDQUFDd1IsR0FBTCxDQUFTamYsRUFBVCxJQUFldUwsQ0FBakM7QUFDQXVULE9BQUcsQ0FBQyxDQUFELENBQUgsR0FBaUJyUixJQUFJLENBQUN3UixHQUFMLENBQVNoZixFQUFULElBQWUrZSxDQUFoQztBQUNBRixPQUFHLENBQUMsQ0FBRCxDQUFILEdBQWlCclIsSUFBSSxDQUFDc1IsR0FBTCxDQUFTOWUsRUFBVCxJQUFlK2UsQ0FBaEM7QUFFQSxVQUFNRSxTQUFTLEdBQUcsS0FBbEI7QUFDQUosT0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFnQnJSLElBQUksQ0FBQzBSLEtBQUwsQ0FBV0wsR0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTSSxTQUFwQixJQUFpQ0EsU0FBakQ7QUFDQUosT0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFnQnJSLElBQUksQ0FBQzBSLEtBQUwsQ0FBV0wsR0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTSSxTQUFwQixJQUFpQ0EsU0FBakQ7QUFDQUosT0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFnQnJSLElBQUksQ0FBQzBSLEtBQUwsQ0FBV0wsR0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTSSxTQUFwQixJQUFpQ0EsU0FBakQ7QUFFQSxXQUFPSixHQUFQO0FBQ0E7O0FBQUE7O0FBR0QsT0FBSSxJQUFJL2hCLENBQUMsR0FBRyxDQUFaLEVBQWVBLENBQUMsR0FBR3VnQixXQUFuQixFQUFnQ3ZnQixDQUFDLEVBQWpDLEVBQXFDO0FBQ3BDLFNBQUksSUFBSTBQLENBQUMsR0FBRyxDQUFaLEVBQWVBLENBQUMsR0FBRzZRLFdBQW5CLEVBQWdDN1EsQ0FBQyxFQUFqQyxFQUFxQztBQUNwQytRLGVBQVMsQ0FBQzNoQixJQUFWLENBQWU4aUIsV0FBVyxDQUFDNWhCLENBQUQsRUFBSTBQLENBQUosQ0FBMUI7QUFDQStRLGVBQVMsQ0FBQzNoQixJQUFWLENBQWU4aUIsV0FBVyxDQUFDNWhCLENBQUMsR0FBRyxDQUFMLEVBQVEwUCxDQUFSLENBQTFCO0FBQ0ErUSxlQUFTLENBQUMzaEIsSUFBVixDQUFlOGlCLFdBQVcsQ0FBQzVoQixDQUFDLEdBQUcsQ0FBTCxFQUFRMFAsQ0FBQyxHQUFHLENBQVosQ0FBMUI7QUFDQStRLGVBQVMsQ0FBQzNoQixJQUFWLENBQWU4aUIsV0FBVyxDQUFDNWhCLENBQUQsRUFBSTBQLENBQUMsR0FBRyxDQUFSLENBQTFCO0FBRUFrUixhQUFPLENBQUM5aEIsSUFBUixDQUFhOGlCLFdBQVcsQ0FBQzVoQixDQUFELEVBQUkwUCxDQUFKLEVBQU8sSUFBUCxDQUF4QjtBQUNBa1IsYUFBTyxDQUFDOWhCLElBQVIsQ0FBYThpQixXQUFXLENBQUM1aEIsQ0FBQyxHQUFHLENBQUwsRUFBUTBQLENBQVIsRUFBVyxJQUFYLENBQXhCO0FBQ0FrUixhQUFPLENBQUM5aEIsSUFBUixDQUFhOGlCLFdBQVcsQ0FBQzVoQixDQUFDLEdBQUcsQ0FBTCxFQUFRMFAsQ0FBQyxHQUFHLENBQVosRUFBZSxJQUFmLENBQXhCO0FBQ0FrUixhQUFPLENBQUM5aEIsSUFBUixDQUFhOGlCLFdBQVcsQ0FBQzVoQixDQUFELEVBQUkwUCxDQUFDLEdBQUcsQ0FBUixFQUFXLElBQVgsQ0FBeEI7QUFHQSxZQUFNMFIsQ0FBQyxHQUFHMVIsQ0FBQyxHQUFHNlEsV0FBZDtBQUNBLFlBQU1jLENBQUMsR0FBR3JoQixDQUFDLEdBQUd1Z0IsV0FBZDtBQUdBRyxZQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsTUFBTXNpQixDQUFQLEVBQVVDLENBQVYsQ0FBWjtBQUNBWCxZQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsTUFBTXNpQixDQUFQLEVBQVVDLENBQUMsR0FBR04sS0FBZCxDQUFaO0FBQ0FMLFlBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxNQUFNc2lCLENBQU4sR0FBVUwsS0FBWCxFQUFrQk0sQ0FBQyxHQUFHTixLQUF0QixDQUFaO0FBQ0FMLFlBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxNQUFNc2lCLENBQU4sR0FBVUwsS0FBWCxFQUFrQk0sQ0FBbEIsQ0FBWjtBQUVBVixhQUFPLENBQUM3aEIsSUFBUixDQUFhMlEsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBa1IsYUFBTyxDQUFDN2hCLElBQVIsQ0FBYTJRLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQWtSLGFBQU8sQ0FBQzdoQixJQUFSLENBQWEyUSxLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0FrUixhQUFPLENBQUM3aEIsSUFBUixDQUFhMlEsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBa1IsYUFBTyxDQUFDN2hCLElBQVIsQ0FBYTJRLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQWtSLGFBQU8sQ0FBQzdoQixJQUFSLENBQWEyUSxLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBRUFBLFdBQUs7QUFDTDtBQUNEOztBQUdELE1BQUdrUyxRQUFILEVBQWE7QUFDWmhCLFdBQU8sQ0FBQzBCLE9BQVI7QUFDQTs7QUFFRCxRQUFNL2lCLElBQUksR0FBRyxJQUFJdUYsNkNBQUosQ0FBU3NZLFFBQVQsQ0FBYjtBQUNBN2QsTUFBSSxDQUFDZ2lCLFlBQUwsQ0FBa0JiLFNBQWxCO0FBQ0FuaEIsTUFBSSxDQUFDaWlCLGNBQUwsQ0FBb0JiLE1BQXBCO0FBQ0FwaEIsTUFBSSxDQUFDa2lCLFdBQUwsQ0FBaUJiLE9BQWpCO0FBQ0FyaEIsTUFBSSxDQUFDbWlCLFlBQUwsQ0FBa0JiLE9BQWxCO0FBRUEsU0FBT3RoQixJQUFQO0FBQ0EsQ0F6RUQ7O0FBMkVBd0YsSUFBSSxDQUFDd2QsSUFBTCxHQUFZLFNBQVNBLElBQVQsQ0FBYzFNLENBQWQsRUFBaUJFLENBQWpCLEVBQW9CeU0sQ0FBcEIsRUFBdUJwRixRQUFRLEdBQUcsQ0FBbEMsRUFBcUM7QUFDaERySCxHQUFDLEdBQUdBLENBQUMsSUFBSUYsQ0FBVDtBQUNBMk0sR0FBQyxHQUFHQSxDQUFDLElBQUkzTSxDQUFUO0FBRUEsUUFBTUgsQ0FBQyxHQUFHRyxDQUFDLEdBQUcsQ0FBZDtBQUNBLFFBQU1tRyxDQUFDLEdBQUdqRyxDQUFDLEdBQUcsQ0FBZDtBQUNBLFFBQU0wTSxDQUFDLEdBQUdELENBQUMsR0FBRyxDQUFkO0FBRUEsUUFBTTlCLFNBQVMsR0FBRyxFQUFsQjtBQUNBLFFBQU1DLE1BQU0sR0FBTSxFQUFsQjtBQUNBLFFBQU1DLE9BQU8sR0FBSyxFQUFsQjtBQUNBLFFBQU1DLE9BQU8sR0FBSyxFQUFsQjtBQUNBLE1BQUk2QixLQUFLLEdBQU8sQ0FBaEIsQ0FaZ0QsQ0FlaEQ7O0FBQ0FoQyxXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMsQ0FBQzJXLENBQUYsRUFBTXNHLENBQU4sRUFBUyxDQUFDeUcsQ0FBVixDQUFmO0FBQ0EvQixXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMyVyxDQUFELEVBQUtzRyxDQUFMLEVBQVEsQ0FBQ3lHLENBQVQsQ0FBZjtBQUNBL0IsV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDMlcsQ0FBRCxFQUFJLENBQUNzRyxDQUFMLEVBQVEsQ0FBQ3lHLENBQVQsQ0FBZjtBQUNBL0IsV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMyVyxDQUFGLEVBQUssQ0FBQ3NHLENBQU4sRUFBUyxDQUFDeUcsQ0FBVixDQUFmO0FBRUE1QixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFDLENBQVIsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQUMsQ0FBUixDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQyxDQUFSLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFDLENBQVIsQ0FBYjtBQUVBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBRUE2aEIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUVBQSxPQUFLLEdBdEMyQyxDQXdDaEQ7O0FBQ0FoQyxXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMyVyxDQUFELEVBQUtzRyxDQUFMLEVBQVEsQ0FBQ3lHLENBQVQsQ0FBZjtBQUNBL0IsV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDMlcsQ0FBRCxFQUFLc0csQ0FBTCxFQUFTeUcsQ0FBVCxDQUFmO0FBQ0EvQixXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMyVyxDQUFELEVBQUksQ0FBQ3NHLENBQUwsRUFBU3lHLENBQVQsQ0FBZjtBQUNBL0IsV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDMlcsQ0FBRCxFQUFJLENBQUNzRyxDQUFMLEVBQVEsQ0FBQ3lHLENBQVQsQ0FBZjtBQUVBNUIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBRUE0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFFQTZoQixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBRUFBLE9BQUssR0EvRDJDLENBaUVoRDs7QUFDQWhDLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQzJXLENBQUQsRUFBS3NHLENBQUwsRUFBU3lHLENBQVQsQ0FBZjtBQUNBL0IsV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMyVyxDQUFGLEVBQU1zRyxDQUFOLEVBQVV5RyxDQUFWLENBQWY7QUFDQS9CLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQyxDQUFDMlcsQ0FBRixFQUFLLENBQUNzRyxDQUFOLEVBQVV5RyxDQUFWLENBQWY7QUFDQS9CLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQzJXLENBQUQsRUFBSSxDQUFDc0csQ0FBTCxFQUFTeUcsQ0FBVCxDQUFmO0FBRUE1QixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQWI7QUFFQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUVBNmhCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFFQUEsT0FBSyxHQXhGMkMsQ0EyRmhEOztBQUNBaEMsV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMyVyxDQUFGLEVBQU1zRyxDQUFOLEVBQVV5RyxDQUFWLENBQWY7QUFDQS9CLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQyxDQUFDMlcsQ0FBRixFQUFNc0csQ0FBTixFQUFTLENBQUN5RyxDQUFWLENBQWY7QUFDQS9CLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQyxDQUFDMlcsQ0FBRixFQUFLLENBQUNzRyxDQUFOLEVBQVMsQ0FBQ3lHLENBQVYsQ0FBZjtBQUNBL0IsV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMyVyxDQUFGLEVBQUssQ0FBQ3NHLENBQU4sRUFBVXlHLENBQVYsQ0FBZjtBQUVBNUIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUMsQ0FBRixFQUFLLENBQUwsRUFBUSxDQUFSLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBQyxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFDLENBQUYsRUFBSyxDQUFMLEVBQVEsQ0FBUixDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUMsQ0FBRixFQUFLLENBQUwsRUFBUSxDQUFSLENBQWI7QUFFQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUVBNmhCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFFQUEsT0FBSyxHQWxIMkMsQ0FvSGhEOztBQUNBaEMsV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDMlcsQ0FBRCxFQUFLc0csQ0FBTCxFQUFRLENBQUN5RyxDQUFULENBQWY7QUFDQS9CLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQyxDQUFDMlcsQ0FBRixFQUFNc0csQ0FBTixFQUFTLENBQUN5RyxDQUFWLENBQWY7QUFDQS9CLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQyxDQUFDMlcsQ0FBRixFQUFNc0csQ0FBTixFQUFVeUcsQ0FBVixDQUFmO0FBQ0EvQixXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMyVyxDQUFELEVBQUtzRyxDQUFMLEVBQVN5RyxDQUFULENBQWY7QUFFQTVCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUVBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBRUE2aEIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUVBQSxPQUFLLEdBM0kyQyxDQTZJaEQ7O0FBQ0FoQyxXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMyVyxDQUFELEVBQUksQ0FBQ3NHLENBQUwsRUFBU3lHLENBQVQsQ0FBZjtBQUNBL0IsV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMyVyxDQUFGLEVBQUssQ0FBQ3NHLENBQU4sRUFBVXlHLENBQVYsQ0FBZjtBQUNBL0IsV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMyVyxDQUFGLEVBQUssQ0FBQ3NHLENBQU4sRUFBUyxDQUFDeUcsQ0FBVixDQUFmO0FBQ0EvQixXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMyVyxDQUFELEVBQUksQ0FBQ3NHLENBQUwsRUFBUSxDQUFDeUcsQ0FBVCxDQUFmO0FBRUE1QixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUMsQ0FBTCxFQUFRLENBQVIsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBQyxDQUFMLEVBQVEsQ0FBUixDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFDLENBQUwsRUFBUSxDQUFSLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUMsQ0FBTCxFQUFRLENBQVIsQ0FBYjtBQUVBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBRUE2aEIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUVBQSxPQUFLO0FBR0wsUUFBTW5qQixJQUFJLEdBQUcsSUFBSXVGLDZDQUFKLENBQVNzWSxRQUFULENBQWI7QUFDQTdkLE1BQUksQ0FBQ2dpQixZQUFMLENBQWtCYixTQUFsQjtBQUNBbmhCLE1BQUksQ0FBQ2lpQixjQUFMLENBQW9CYixNQUFwQjtBQUNBcGhCLE1BQUksQ0FBQ2tpQixXQUFMLENBQWlCYixPQUFqQjtBQUNBcmhCLE1BQUksQ0FBQ21pQixZQUFMLENBQWtCYixPQUFsQjtBQUVBLFNBQU90aEIsSUFBUDtBQUNBLENBOUtEOztBQWdMQXdGLElBQUksQ0FBQzRkLE1BQUwsR0FBYyxTQUFTQSxNQUFULENBQWdCN2EsSUFBaEIsRUFBc0JzVixRQUFRLEdBQUcsQ0FBakMsRUFBb0M7QUFDakQsUUFBTXNELFNBQVMsR0FBRyxFQUFsQjtBQUNBLFFBQU1DLE1BQU0sR0FBTSxFQUFsQjtBQUNBLFFBQU1DLE9BQU8sR0FBSyxFQUFsQjtBQUNBLFFBQU1DLE9BQU8sR0FBSyxFQUFsQjtBQUNBLE1BQUk2QixLQUFLLEdBQU8sQ0FBaEIsQ0FMaUQsQ0FPakQ7O0FBQ0FoQyxXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMrSSxJQUFELEVBQVFBLElBQVIsRUFBYyxDQUFDQSxJQUFmLENBQWY7QUFDQTRZLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQyxDQUFDK0ksSUFBRixFQUFTQSxJQUFULEVBQWUsQ0FBQ0EsSUFBaEIsQ0FBZjtBQUNBNFksV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMrSSxJQUFGLEVBQVEsQ0FBQ0EsSUFBVCxFQUFlLENBQUNBLElBQWhCLENBQWY7QUFDQTRZLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQytJLElBQUQsRUFBTyxDQUFDQSxJQUFSLEVBQWMsQ0FBQ0EsSUFBZixDQUFmO0FBRUErWSxTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFDLENBQVIsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQUMsQ0FBUixDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQyxDQUFSLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFDLENBQVIsQ0FBYjtBQUVBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBRUE2aEIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUVBQSxPQUFLLEdBOUI0QyxDQWdDakQ7O0FBQ0FoQyxXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMrSSxJQUFELEVBQU8sQ0FBQ0EsSUFBUixFQUFjLENBQUNBLElBQWYsQ0FBZjtBQUNBNFksV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDK0ksSUFBRCxFQUFPLENBQUNBLElBQVIsRUFBZUEsSUFBZixDQUFmO0FBQ0E0WSxXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMrSSxJQUFELEVBQVFBLElBQVIsRUFBZUEsSUFBZixDQUFmO0FBQ0E0WSxXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMrSSxJQUFELEVBQVFBLElBQVIsRUFBYyxDQUFDQSxJQUFmLENBQWY7QUFFQStZLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUVBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBRUE2aEIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUVBQSxPQUFLLEdBdkQ0QyxDQXlEakQ7O0FBQ0FoQyxXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMsQ0FBQytJLElBQUYsRUFBU0EsSUFBVCxFQUFnQkEsSUFBaEIsQ0FBZjtBQUNBNFksV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDK0ksSUFBRCxFQUFRQSxJQUFSLEVBQWVBLElBQWYsQ0FBZjtBQUNBNFksV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDK0ksSUFBRCxFQUFPLENBQUNBLElBQVIsRUFBZUEsSUFBZixDQUFmO0FBQ0E0WSxXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMsQ0FBQytJLElBQUYsRUFBUSxDQUFDQSxJQUFULEVBQWdCQSxJQUFoQixDQUFmO0FBRUErWSxTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQWI7QUFFQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUVBNmhCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFFQUEsT0FBSyxHQWhGNEMsQ0FrRmpEOztBQUNBaEMsV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMrSSxJQUFGLEVBQVEsQ0FBQ0EsSUFBVCxFQUFnQkEsSUFBaEIsQ0FBZjtBQUNBNFksV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMrSSxJQUFGLEVBQVEsQ0FBQ0EsSUFBVCxFQUFlLENBQUNBLElBQWhCLENBQWY7QUFDQTRZLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQyxDQUFDK0ksSUFBRixFQUFTQSxJQUFULEVBQWUsQ0FBQ0EsSUFBaEIsQ0FBZjtBQUNBNFksV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMrSSxJQUFGLEVBQVNBLElBQVQsRUFBZ0JBLElBQWhCLENBQWY7QUFFQStZLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFDLENBQUYsRUFBSyxDQUFMLEVBQVEsQ0FBUixDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUMsQ0FBRixFQUFLLENBQUwsRUFBUSxDQUFSLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBQyxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFDLENBQUYsRUFBSyxDQUFMLEVBQVEsQ0FBUixDQUFiO0FBRUE0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFFQTZoQixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBRUFBLE9BQUssR0F6RzRDLENBMkdqRDs7QUFDQWhDLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQytJLElBQUQsRUFBUUEsSUFBUixFQUFlQSxJQUFmLENBQWY7QUFDQTRZLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQyxDQUFDK0ksSUFBRixFQUFTQSxJQUFULEVBQWdCQSxJQUFoQixDQUFmO0FBQ0E0WSxXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMsQ0FBQytJLElBQUYsRUFBU0EsSUFBVCxFQUFlLENBQUNBLElBQWhCLENBQWY7QUFDQTRZLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQytJLElBQUQsRUFBUUEsSUFBUixFQUFjLENBQUNBLElBQWYsQ0FBZjtBQUVBK1ksU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiO0FBRUE0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFFQTZoQixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBRUFBLE9BQUssR0FsSTRDLENBb0lqRDs7QUFDQWhDLFdBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQytJLElBQUQsRUFBTyxDQUFDQSxJQUFSLEVBQWMsQ0FBQ0EsSUFBZixDQUFmO0FBQ0E0WSxXQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMsQ0FBQytJLElBQUYsRUFBUSxDQUFDQSxJQUFULEVBQWUsQ0FBQ0EsSUFBaEIsQ0FBZjtBQUNBNFksV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMrSSxJQUFGLEVBQVEsQ0FBQ0EsSUFBVCxFQUFnQkEsSUFBaEIsQ0FBZjtBQUNBNFksV0FBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDK0ksSUFBRCxFQUFPLENBQUNBLElBQVIsRUFBZUEsSUFBZixDQUFmO0FBRUErWSxTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUMsQ0FBTCxFQUFRLENBQVIsQ0FBYjtBQUNBOGhCLFNBQU8sQ0FBQzloQixJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBQyxDQUFMLEVBQVEsQ0FBUixDQUFiO0FBQ0E4aEIsU0FBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFDLENBQUwsRUFBUSxDQUFSLENBQWI7QUFDQThoQixTQUFPLENBQUM5aEIsSUFBUixDQUFhLENBQUMsQ0FBRCxFQUFJLENBQUMsQ0FBTCxFQUFRLENBQVIsQ0FBYjtBQUVBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0E0aEIsUUFBTSxDQUFDNWhCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQTRoQixRQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBNGhCLFFBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBRUE2aEIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsU0FBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixTQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFDQTlCLFNBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUVBLFFBQU1uakIsSUFBSSxHQUFHLElBQUl1Riw2Q0FBSixDQUFTc1ksUUFBVCxDQUFiO0FBQ0E3ZCxNQUFJLENBQUNnaUIsWUFBTCxDQUFrQmIsU0FBbEI7QUFDQW5oQixNQUFJLENBQUNpaUIsY0FBTCxDQUFvQmIsTUFBcEI7QUFDQXBoQixNQUFJLENBQUNraUIsV0FBTCxDQUFpQmIsT0FBakI7QUFDQXJoQixNQUFJLENBQUNtaUIsWUFBTCxDQUFrQmIsT0FBbEI7QUFFQSxTQUFPdGhCLElBQVA7QUFDQSxDQWxLRDs7QUFvS0F3RixJQUFJLENBQUM2ZCxXQUFMLEdBQW1CLFNBQVNBLFdBQVQsR0FBdUI7QUFFekMsTUFBRyxDQUFDdEMsT0FBSixFQUFhO0FBQ1osVUFBTU0sT0FBTyxHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQWhCO0FBQ0EsVUFBTUYsU0FBUyxHQUFHLENBQ2pCLENBQUMsQ0FBQyxDQUFGLEVBQUssQ0FBQyxDQUFOLENBRGlCLEVBRWpCLENBQUMsQ0FBQyxDQUFGLEVBQUssQ0FBTCxDQUZpQixFQUdqQixDQUFDLENBQUQsRUFBSSxDQUFDLENBQUwsQ0FIaUIsQ0FBbEI7QUFNQUosV0FBTyxHQUFHLElBQUl4Yiw2Q0FBSixFQUFWO0FBQ0F3YixXQUFPLENBQUN1QyxVQUFSLENBQW1CbkMsU0FBbkIsRUFBOEIsV0FBOUIsRUFBMkMsQ0FBM0M7QUFDQUosV0FBTyxDQUFDbUIsV0FBUixDQUFvQmIsT0FBcEI7QUFDQTs7QUFHRCxTQUFPTixPQUFQO0FBQ0EsQ0FqQkQ7O0FBbUJldmIsbUVBQWYsRTs7Ozs7Ozs7Ozs7O0FDcGhCQTtBQUFBO0FBQUE7QUFBQTtBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUVBLElBQUkvRSxFQUFKO0FBQ0EsTUFBTThpQixXQUFXLEdBQUcsS0FBcEI7O0FBRUEsTUFBTUMsU0FBUyxHQUFHLFVBQVV2RSxJQUFWLEVBQWdCO0FBQ2pDLE1BQUlHLE1BQUo7O0FBRUEsTUFBR0gsSUFBSSxDQUFDRyxNQUFMLEtBQWdCemEsU0FBbkIsRUFBOEI7QUFDN0J5YSxVQUFNLEdBQUdILElBQUksQ0FBQ0csTUFBZDtBQUNBLEdBRkQsTUFFTztBQUNOQSxVQUFNLEdBQUczZSxFQUFFLENBQUNnakIsWUFBSCxFQUFUO0FBQ0F4RSxRQUFJLENBQUNHLE1BQUwsR0FBY0EsTUFBZDtBQUNBOztBQUVELFNBQU9BLE1BQVA7QUFDQSxDQVhEOztBQWNBLE1BQU1zRSxVQUFVLEdBQUcsVUFBVUMsS0FBVixFQUFpQm5ZLElBQWpCLEVBQXVCO0FBQ3pDLFFBQU03TSxHQUFHLEdBQUcsRUFBWjs7QUFFQSxPQUFJLElBQUkrQixDQUFDLEdBQUMsQ0FBVixFQUFhQSxDQUFDLEdBQUNpakIsS0FBSyxDQUFDOWtCLE1BQXJCLEVBQTZCNkIsQ0FBQyxJQUFHOEssSUFBakMsRUFBdUM7QUFDdEMsVUFBTXJNLENBQUMsR0FBRyxFQUFWOztBQUNBLFNBQUksSUFBSWlSLENBQUMsR0FBQyxDQUFWLEVBQWFBLENBQUMsR0FBQzVFLElBQWYsRUFBcUI0RSxDQUFDLEVBQXRCLEVBQTBCO0FBQ3pCalIsT0FBQyxDQUFDSyxJQUFGLENBQU9ta0IsS0FBSyxDQUFDampCLENBQUMsR0FBQzBQLENBQUgsQ0FBWjtBQUNBOztBQUVEelIsT0FBRyxDQUFDYSxJQUFKLENBQVNMLENBQVQ7QUFDQTs7QUFFRCxTQUFPUixHQUFQO0FBQ0EsQ0FiRDs7QUFlQSxNQUFNNEcsSUFBTixDQUFXO0FBQ1Y3QyxhQUFXLENBQUNpYixZQUFZLEdBQUcsQ0FBaEIsRUFBbUJpRyxPQUFPLEdBQUcsSUFBN0IsRUFBbUM7QUFDN0NuakIsTUFBRSxHQUE2QjJFLCtDQUFFLENBQUMzRSxFQUFsQztBQUNBLFNBQUtvZCxRQUFMLEdBQStCRixZQUEvQjtBQUNBLFNBQUtrRyxXQUFMLEdBQStCLEVBQS9CO0FBQ0EsU0FBS0MsWUFBTCxHQUF3QixDQUFDLENBQXpCO0FBQ0EsU0FBS3JKLHVCQUFMLEdBQStCLEVBQS9CO0FBRUEsU0FBS3NKLFFBQUwsR0FBK0IsRUFBL0I7QUFDQSxTQUFLQyxNQUFMLEdBQStCLEVBQS9CO0FBQ0EsU0FBS0MsY0FBTCxHQUErQixFQUEvQjtBQUNBLFNBQUtDLHNCQUFMLEdBQStCLEtBQS9CO0FBQ0EsU0FBS0MsT0FBTCxHQUErQixLQUEvQjtBQUNBLFNBQUtDLFlBQUwsR0FBd0IsS0FBeEI7QUFFQSxTQUFLQyxPQUFMLEdBQStCLENBQUMsQ0FBQ2pmLCtDQUFFLENBQUMzRSxFQUFILENBQU02akIsaUJBQXZDO0FBQ0EsU0FBS0MsT0FBTCxHQUE2QixDQUFDLENBQUMsS0FBS0YsT0FBUCxJQUFrQlQsT0FBL0MsQ0FmNkMsQ0FnQjdDO0FBQ0E7O0FBR0Q1QixjQUFZLENBQUN3QyxjQUFELEVBQWlCQyxTQUFTLEdBQUdsQixXQUE3QixFQUEwQztBQUVyRCxTQUFLRCxVQUFMLENBQWdCa0IsY0FBaEIsRUFBZ0MsaUJBQWhDLEVBQW1ELENBQW5ELEVBQXNEQyxTQUF0RDs7QUFFQSxRQUFJLEtBQUtuRCxPQUFMLENBQWF6aUIsTUFBYixHQUFzQixLQUFLNmxCLFFBQUwsQ0FBYzdsQixNQUF4QyxFQUFnRDtBQUMvQyxXQUFLc2pCLFlBQUwsQ0FBa0JxQyxjQUFsQixFQUFrQ0MsU0FBbEM7QUFDQTs7QUFFRCxXQUFPLElBQVA7QUFDQTs7QUFHRHhDLGdCQUFjLENBQUMwQyxlQUFELEVBQWtCRixTQUFTLEdBQUdsQixXQUE5QixFQUEyQztBQUV4RCxTQUFLRCxVQUFMLENBQWdCcUIsZUFBaEIsRUFBaUMsZUFBakMsRUFBa0QsQ0FBbEQsRUFBcURGLFNBQXJEO0FBQ0EsV0FBTyxJQUFQO0FBRUE7O0FBR0R0QyxjQUFZLENBQUN5QyxRQUFELEVBQVdILFNBQVMsR0FBR2xCLFdBQXZCLEVBQW9DO0FBRS9DLFNBQUtELFVBQUwsQ0FBZ0JzQixRQUFoQixFQUEwQixTQUExQixFQUFxQyxDQUFyQyxFQUF3Q0gsU0FBeEM7QUFDQSxXQUFPLElBQVA7QUFFQTs7QUFHRHZDLGFBQVcsQ0FBQzJDLGFBQUQsRUFBZ0JDLFNBQVMsR0FBRyxLQUE1QixFQUFtQztBQUU3QyxTQUFLQyxTQUFMLEdBQXdCRCxTQUFTLEdBQUdya0IsRUFBRSxDQUFDdWtCLFlBQU4sR0FBcUJ2a0IsRUFBRSxDQUFDOGlCLFdBQXpEO0FBQ0EsU0FBS1EsUUFBTCxHQUF3QixJQUFJa0IsV0FBSixDQUFnQkosYUFBaEIsQ0FBeEI7QUFDQSxTQUFLSyxTQUFMLEdBQXFCLEtBQUtuQixRQUFMLENBQWNsbEIsTUFBbkM7QUFDQSxXQUFPLElBQVA7QUFFQTs7QUFFRHNtQixtQkFBaUIsQ0FBQ3hCLEtBQUQsRUFBUWpRLEtBQVIsRUFBZTBSLFNBQWYsRUFBMEJYLFNBQVMsR0FBR2xCLFdBQXRDLEVBQW1EekYsV0FBVyxHQUFHLEtBQWpFLEVBQXdFO0FBRXhGLFVBQU14TixJQUFJLEdBQUdvVCxVQUFVLENBQUNDLEtBQUQsRUFBUXlCLFNBQVIsQ0FBdkI7QUFDQSxTQUFLOUIsVUFBTCxDQUFnQmhULElBQWhCLEVBQXNCb0QsS0FBdEIsRUFBNkIwUixTQUE3QixFQUF3Q1gsU0FBUyxHQUFHbEIsV0FBcEQsRUFBaUV6RixXQUFXLEdBQUcsS0FBL0U7QUFDQSxXQUFPLElBQVA7QUFFQTs7QUFFRHdGLFlBQVUsQ0FBQ0ssS0FBRCxFQUFRalEsS0FBUixFQUFlMFIsU0FBZixFQUEwQlgsU0FBUyxHQUFHbEIsV0FBdEMsRUFBbUR6RixXQUFXLEdBQUcsS0FBakUsRUFBd0U7QUFDakYsUUFBSXBkLENBQUMsR0FBRyxDQUFSO0FBQ0EsVUFBTW1kLFFBQVEsR0FBSzRHLFNBQW5CO0FBQ0EsUUFBRyxDQUFDNUcsUUFBSixFQUFjO0FBRWQsVUFBTXlGLFVBQVUsR0FBRyxFQUFuQjs7QUFDQSxRQUFJLENBQUM4QixTQUFMLEVBQWdCO0FBQUVBLGVBQVMsR0FBR3pCLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUzlrQixNQUFyQjtBQUE4Qjs7QUFDaEQsU0FBS3VsQixZQUFMLEdBQW9CdEcsV0FBVyxJQUFJLEtBQUtzRyxZQUF4QyxDQVBpRixDQVNqRjs7QUFDQSxTQUFJMWpCLENBQUMsR0FBRyxDQUFSLEVBQVdBLENBQUMsR0FBR2lqQixLQUFLLENBQUM5a0IsTUFBckIsRUFBNkI2QixDQUFDLEVBQTlCLEVBQWtDO0FBQ2pDLFdBQUksSUFBSTBQLENBQUMsR0FBRyxDQUFaLEVBQWVBLENBQUMsR0FBR3VULEtBQUssQ0FBQ2pqQixDQUFELENBQUwsQ0FBUzdCLE1BQTVCLEVBQW9DdVIsQ0FBQyxFQUFyQyxFQUF5QztBQUN4Q2tULGtCQUFVLENBQUM5akIsSUFBWCxDQUFnQm1rQixLQUFLLENBQUNqakIsQ0FBRCxDQUFMLENBQVMwUCxDQUFULENBQWhCO0FBQ0E7QUFDRDs7QUFDRCxVQUFNaVYsU0FBUyxHQUFHLElBQUk3VCxZQUFKLENBQWlCOFIsVUFBakIsQ0FBbEI7QUFDQSxVQUFNZ0MsU0FBUyxHQUFHLEtBQUtDLFlBQUwsQ0FBa0I3UixLQUFsQixDQUFsQjs7QUFHQSxRQUFHNFIsU0FBSCxFQUFjO0FBQ2I7QUFDQUEsZUFBUyxDQUFDRSxRQUFWLEdBQXFCSixTQUFyQjtBQUNBRSxlQUFTLENBQUNELFNBQVYsR0FBc0JBLFNBQXRCO0FBQ0FDLGVBQVMsQ0FBQ0csTUFBVixHQUFtQjlCLEtBQW5CO0FBQ0EsS0FMRCxNQUtPO0FBQ047QUFDQSxXQUFLRSxXQUFMLENBQWlCcmtCLElBQWpCLENBQXNCO0FBQUV5VSxZQUFJLEVBQUNQLEtBQVA7QUFBYytSLGNBQU0sRUFBQzlCLEtBQXJCO0FBQTRCNkIsZ0JBQVEsRUFBRUosU0FBdEM7QUFBaUR2SCxnQkFBakQ7QUFBMkR3SCxpQkFBM0Q7QUFBc0V2SDtBQUF0RSxPQUF0QjtBQUNBOztBQUVELFNBQUttRyxjQUFMLENBQW9CemtCLElBQXBCLENBQXlCa1UsS0FBekI7O0FBQ0EsV0FBTyxJQUFQO0FBQ0E7O0FBRURnUyxnQkFBYyxDQUFDL0IsS0FBRCxFQUFRalEsS0FBUixFQUFlO0FBQzVCLFFBQUksQ0FBQ3RPLCtDQUFFLENBQUMzRSxFQUFILENBQU1rbEIsbUJBQVgsRUFBZ0M7QUFDL0J6bEIsYUFBTyxDQUFDdU4sS0FBUixDQUFjLHdFQUFkO0FBQ0E7QUFDQTs7QUFFRCxVQUFNK1gsUUFBUSxHQUFHN0IsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTOWtCLE1BQTFCO0FBQ0EsU0FBS2lsQixZQUFMLEdBQW9CSCxLQUFLLENBQUM5a0IsTUFBMUI7QUFDQSxTQUFLeWtCLFVBQUwsQ0FBZ0JLLEtBQWhCLEVBQXVCalEsS0FBdkIsRUFBOEI4UixRQUE5QixFQUF3Q2pDLFdBQXhDLEVBQXFELElBQXJEO0FBQ0E7O0FBR0RsYixNQUFJLENBQUN1ZCxjQUFELEVBQWlCO0FBQ3BCLFNBQUsvRyxlQUFMLENBQXFCK0csY0FBckI7O0FBRUEsUUFBRyxLQUFLQyxNQUFSLEVBQWdCO0FBQ2ZwbEIsUUFBRSxDQUFDcWxCLGVBQUgsQ0FBbUIsS0FBS0MsR0FBeEI7QUFDQSxLQUZELE1BRU87QUFDTixXQUFLL0csVUFBTCxDQUFnQjFkLE9BQWhCLENBQXlCZ2tCLFNBQUQsSUFBYztBQUNyQzdrQixVQUFFLENBQUNnZixVQUFILENBQWNoZixFQUFFLENBQUNpZixZQUFqQixFQUErQjRGLFNBQVMsQ0FBQ2xHLE1BQXpDO0FBQ0EsY0FBTTRHLFlBQVksR0FBR1YsU0FBUyxDQUFDVSxZQUEvQjtBQUNBdmxCLFVBQUUsQ0FBQ3dsQixtQkFBSCxDQUF1QkQsWUFBdkIsRUFBcUNWLFNBQVMsQ0FBQ0UsUUFBL0MsRUFBeUQva0IsRUFBRSxDQUFDOEosS0FBNUQsRUFBbUUsS0FBbkUsRUFBMEUsQ0FBMUUsRUFBNkUsQ0FBN0U7O0FBRUEsWUFBRythLFNBQVMsQ0FBQ3hILFdBQWIsRUFBMEI7QUFDekJyZCxZQUFFLENBQUNrbEIsbUJBQUgsQ0FBdUJLLFlBQXZCLEVBQXFDLENBQXJDO0FBQ0E7QUFFRCxPQVRELEVBRE0sQ0FZTjs7QUFDQXZsQixRQUFFLENBQUNnZixVQUFILENBQWNoZixFQUFFLENBQUN5bEIsb0JBQWpCLEVBQXVDLEtBQUtsSSxPQUE1QztBQUNBO0FBQ0Q7O0FBRURhLGlCQUFlLENBQUMrRyxjQUFELEVBQWlCO0FBQy9CLFFBQUcsS0FBSzNCLGNBQUwsQ0FBb0JwbEIsTUFBcEIsSUFBOEIsQ0FBakMsRUFBb0M7QUFBRTtBQUFTOztBQUUvQyxRQUFHLEtBQUswbEIsT0FBUixFQUFpQjtBQUFFO0FBRWxCO0FBQ0EsVUFBRyxDQUFDLEtBQUs0QixJQUFULEVBQWU7QUFDZCxhQUFLQSxJQUFMLEdBQVkxbEIsRUFBRSxDQUFDNmpCLGlCQUFILEVBQVo7QUFDQTs7QUFFRDdqQixRQUFFLENBQUNxbEIsZUFBSCxDQUFtQixLQUFLSyxJQUF4QixFQVBnQixDQVNoQjs7QUFDQSxXQUFLdEMsV0FBTCxDQUFpQnZpQixPQUFqQixDQUEwQjhrQixPQUFELElBQWE7QUFFckMsWUFBRyxLQUFLbkMsY0FBTCxDQUFvQm5jLE9BQXBCLENBQTRCc2UsT0FBTyxDQUFDblMsSUFBcEMsTUFBOEMsQ0FBQyxDQUFsRCxFQUFxRDtBQUNwRCxnQkFBTW1MLE1BQU0sR0FBR29FLFNBQVMsQ0FBQzRDLE9BQUQsQ0FBeEI7QUFDQTNsQixZQUFFLENBQUNnZixVQUFILENBQWNoZixFQUFFLENBQUNpZixZQUFqQixFQUErQk4sTUFBL0I7QUFDQTNlLFlBQUUsQ0FBQzZpQixVQUFILENBQWM3aUIsRUFBRSxDQUFDaWYsWUFBakIsRUFBK0IwRyxPQUFPLENBQUNmLFNBQXZDLEVBQWtEZSxPQUFPLENBQUN2SSxRQUExRDtBQUVBLGdCQUFNbUksWUFBWSxHQUFHSyxtRUFBWSxDQUFDNWxCLEVBQUQsRUFBS21sQixjQUFMLEVBQXFCUSxPQUFPLENBQUNuUyxJQUE3QixDQUFqQztBQUNBeFQsWUFBRSxDQUFDNmxCLHVCQUFILENBQTJCTixZQUEzQjtBQUNBdmxCLFlBQUUsQ0FBQ3dsQixtQkFBSCxDQUF1QkQsWUFBdkIsRUFBcUNJLE9BQU8sQ0FBQ1osUUFBN0MsRUFBdUQva0IsRUFBRSxDQUFDOEosS0FBMUQsRUFBaUUsS0FBakUsRUFBd0UsQ0FBeEUsRUFBMkUsQ0FBM0U7QUFDQTZiLGlCQUFPLENBQUNKLFlBQVIsR0FBdUJBLFlBQXZCOztBQUVBLGNBQUdJLE9BQU8sQ0FBQ3RJLFdBQVgsRUFBd0I7QUFDdkJyZCxjQUFFLENBQUNrbEIsbUJBQUgsQ0FBdUJLLFlBQXZCLEVBQXFDLENBQXJDO0FBQ0E7QUFDRDtBQUVELE9BakJELEVBVmdCLENBNkJoQjs7O0FBQ0EsV0FBS08sa0JBQUwsR0E5QmdCLENBZ0NoQjs7O0FBQ0E5bEIsUUFBRSxDQUFDcWxCLGVBQUgsQ0FBbUIsSUFBbkI7QUFFQSxXQUFLM0IsT0FBTCxHQUFlLElBQWY7QUFFQSxLQXJDRCxNQXFDTztBQUFFO0FBRVIsV0FBS04sV0FBTCxDQUFpQnZpQixPQUFqQixDQUEwQjhrQixPQUFELElBQWE7QUFDckM7QUFDQSxZQUFHLEtBQUtuQyxjQUFMLENBQW9CbmMsT0FBcEIsQ0FBNEJzZSxPQUFPLENBQUNuUyxJQUFwQyxNQUE4QyxDQUFDLENBQWxELEVBQXFEO0FBQ3BELGdCQUFNbUwsTUFBTSxHQUFHb0UsU0FBUyxDQUFDNEMsT0FBRCxDQUF4QjtBQUNBM2xCLFlBQUUsQ0FBQ2dmLFVBQUgsQ0FBY2hmLEVBQUUsQ0FBQ2lmLFlBQWpCLEVBQStCTixNQUEvQjtBQUNBM2UsWUFBRSxDQUFDNmlCLFVBQUgsQ0FBYzdpQixFQUFFLENBQUNpZixZQUFqQixFQUErQjBHLE9BQU8sQ0FBQ2YsU0FBdkMsRUFBa0RlLE9BQU8sQ0FBQ3ZJLFFBQTFEO0FBRUEsZ0JBQU1tSSxZQUFZLEdBQUdLLG1FQUFZLENBQUM1bEIsRUFBRCxFQUFLbWxCLGNBQUwsRUFBcUJRLE9BQU8sQ0FBQ25TLElBQTdCLENBQWpDO0FBQ0F4VCxZQUFFLENBQUM2bEIsdUJBQUgsQ0FBMkJOLFlBQTNCO0FBQ0F2bEIsWUFBRSxDQUFDd2xCLG1CQUFILENBQXVCRCxZQUF2QixFQUFxQ0ksT0FBTyxDQUFDWixRQUE3QyxFQUF1RC9rQixFQUFFLENBQUM4SixLQUExRCxFQUFpRSxLQUFqRSxFQUF3RSxDQUF4RSxFQUEyRSxDQUEzRTtBQUNBNmIsaUJBQU8sQ0FBQ0osWUFBUixHQUF1QkEsWUFBdkI7O0FBRUEsY0FBR0ksT0FBTyxDQUFDdEksV0FBWCxFQUF3QjtBQUN2QnJkLGNBQUUsQ0FBQ2tsQixtQkFBSCxDQUF1QkssWUFBdkIsRUFBcUMsQ0FBckM7QUFDQTtBQUNEO0FBQ0QsT0FoQkQ7O0FBa0JBLFdBQUtPLGtCQUFMO0FBQ0E7O0FBRUQsU0FBS3JDLHNCQUFMLEdBQThCLEtBQTlCO0FBQ0EsU0FBS0QsY0FBTCxHQUFzQixFQUF0QjtBQUNBOztBQUdEM1ksUUFBTSxHQUFHO0FBQ1IsUUFBRyxLQUFLaVosT0FBUixFQUFpQjtBQUNoQjlqQixRQUFFLENBQUNxbEIsZUFBSCxDQUFtQixJQUFuQjtBQUNBOztBQUVELFNBQUtqQyxXQUFMLENBQWlCdmlCLE9BQWpCLENBQTBCZ2tCLFNBQUQsSUFBYztBQUN0QyxVQUFHQSxTQUFTLENBQUN4SCxXQUFiLEVBQTBCO0FBQ3pCcmQsVUFBRSxDQUFDa2xCLG1CQUFILENBQXVCTCxTQUFTLENBQUNVLFlBQWpDLEVBQStDLENBQS9DO0FBQ0E7QUFDRCxLQUpEO0FBS0E7O0FBR0RPLG9CQUFrQixHQUFHO0FBQ3BCLFFBQUcsQ0FBQyxLQUFLckMsc0JBQVQsRUFBaUM7QUFDaEMsVUFBSSxDQUFDLEtBQUtsRyxPQUFWLEVBQW1CO0FBQUUsYUFBS0EsT0FBTCxHQUFldmQsRUFBRSxDQUFDZ2pCLFlBQUgsRUFBZjtBQUFvQzs7QUFDekRoakIsUUFBRSxDQUFDZ2YsVUFBSCxDQUFjaGYsRUFBRSxDQUFDeWxCLG9CQUFqQixFQUF1QyxLQUFLbEksT0FBNUM7QUFDQXZkLFFBQUUsQ0FBQzZpQixVQUFILENBQWM3aUIsRUFBRSxDQUFDeWxCLG9CQUFqQixFQUF1QyxLQUFLbkMsUUFBNUMsRUFBc0QsS0FBS2dCLFNBQTNEO0FBQ0EsV0FBSy9HLE9BQUwsQ0FBYXdILFFBQWIsR0FBd0IsQ0FBeEI7QUFDQSxXQUFLeEgsT0FBTCxDQUFhQyxRQUFiLEdBQXdCLEtBQUtpSCxTQUE3QjtBQUNBO0FBQ0Q7O0FBR0RzQixnQkFBYyxDQUFDQyxnQkFBZ0IsR0FBRyxLQUFwQixFQUEyQjtBQUV4QyxTQUFLQyxhQUFMOztBQUVBLFFBQUdELGdCQUFILEVBQXFCO0FBQ3BCLFdBQUtFLG1CQUFMO0FBQ0EsS0FGRCxNQUVPO0FBQ04sV0FBS0MscUJBQUw7QUFDQTtBQUNELEdBMU9TLENBNE9WOzs7QUFFQUQscUJBQW1CLEdBQUc7QUFFckIsUUFBSUUsU0FBSjtBQUNBLFFBQUlDLElBQUo7QUFDQSxVQUFNeEYsT0FBTyxHQUFHLEVBQWhCOztBQUVBLFNBQUksSUFBSTVnQixDQUFDLEdBQUcsQ0FBWixFQUFlQSxDQUFDLEdBQUcsS0FBS3FqQixRQUFMLENBQWNsbEIsTUFBakMsRUFBeUM2QixDQUFDLElBQUksQ0FBOUMsRUFBaUQ7QUFDaERtbUIsZUFBUyxHQUFHbm1CLENBQUMsR0FBRyxDQUFoQjtBQUNBb21CLFVBQUksR0FBRyxLQUFLOUMsTUFBTCxDQUFZNkMsU0FBWixDQUFQO0FBQ0EsWUFBTUUsQ0FBQyxHQUFHRCxJQUFJLENBQUNFLE1BQWY7QUFFQTFGLGFBQU8sQ0FBQ3dGLElBQUksQ0FBQ3pGLE9BQUwsQ0FBYSxDQUFiLENBQUQsQ0FBUCxHQUEyQjBGLENBQTNCO0FBQ0F6RixhQUFPLENBQUN3RixJQUFJLENBQUN6RixPQUFMLENBQWEsQ0FBYixDQUFELENBQVAsR0FBMkIwRixDQUEzQjtBQUNBekYsYUFBTyxDQUFDd0YsSUFBSSxDQUFDekYsT0FBTCxDQUFhLENBQWIsQ0FBRCxDQUFQLEdBQTJCMEYsQ0FBM0I7QUFDQTs7QUFFRCxTQUFLNUUsWUFBTCxDQUFrQmIsT0FBbEI7QUFDQTs7QUFHRHNGLHVCQUFxQixHQUFHO0FBQ3ZCO0FBQ0EsUUFBSUUsSUFBSjtBQUNBLFVBQU1HLFNBQVMsR0FBRzFVLDhDQUFJLENBQUNvSSxNQUFMLEVBQWxCO0FBQ0EsVUFBTTJHLE9BQU8sR0FBRyxFQUFoQjtBQUNBLFVBQU07QUFBRW9EO0FBQUYsUUFBZSxJQUFyQjs7QUFFQSxTQUFJLElBQUloa0IsQ0FBQyxHQUFHLENBQVosRUFBZUEsQ0FBQyxHQUFHZ2tCLFFBQVEsQ0FBQzdsQixNQUE1QixFQUFvQzZCLENBQUMsRUFBckMsRUFBeUM7QUFFeEM2UixvREFBSSxDQUFDMVAsR0FBTCxDQUFTb2tCLFNBQVQsRUFBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsRUFBMEIsQ0FBMUI7O0FBRUEsV0FBSSxJQUFJN1csQ0FBQyxHQUFHLENBQVosRUFBZUEsQ0FBQyxHQUFHLEtBQUs0VCxNQUFMLENBQVlubEIsTUFBL0IsRUFBdUN1UixDQUFDLEVBQXhDLEVBQTRDO0FBQzNDMFcsWUFBSSxHQUFHLEtBQUs5QyxNQUFMLENBQVk1VCxDQUFaLENBQVAsQ0FEMkMsQ0FHM0M7O0FBQ0EsWUFBRzBXLElBQUksQ0FBQ3pGLE9BQUwsQ0FBYXZaLE9BQWIsQ0FBcUJwSCxDQUFyQixLQUEyQixDQUE5QixFQUFpQztBQUVoQ3VtQixtQkFBUyxDQUFDLENBQUQsQ0FBVCxJQUFnQkgsSUFBSSxDQUFDRSxNQUFMLENBQVksQ0FBWixDQUFoQjtBQUNBQyxtQkFBUyxDQUFDLENBQUQsQ0FBVCxJQUFnQkgsSUFBSSxDQUFDRSxNQUFMLENBQVksQ0FBWixDQUFoQjtBQUNBQyxtQkFBUyxDQUFDLENBQUQsQ0FBVCxJQUFnQkgsSUFBSSxDQUFDRSxNQUFMLENBQVksQ0FBWixDQUFoQjtBQUVBO0FBRUQ7O0FBRUR6VSxvREFBSSxDQUFDMlUsU0FBTCxDQUFlRCxTQUFmLEVBQTBCQSxTQUExQjtBQUNBM0YsYUFBTyxDQUFDOWhCLElBQVIsQ0FBYSxDQUFDeW5CLFNBQVMsQ0FBQyxDQUFELENBQVYsRUFBZUEsU0FBUyxDQUFDLENBQUQsQ0FBeEIsRUFBNkJBLFNBQVMsQ0FBQyxDQUFELENBQXRDLENBQWI7QUFDQTs7QUFFRCxTQUFLOUUsWUFBTCxDQUFrQmIsT0FBbEI7QUFFQTs7QUFHRG9GLGVBQWEsR0FBRztBQUNmLFFBQUlTLEVBQUosRUFBUUMsRUFBUixFQUFZQyxFQUFaO0FBQ0EsUUFBSTlvQixDQUFKLEVBQU82USxDQUFQLEVBQVVrWSxDQUFWO0FBQ0EsVUFBTUMsR0FBRyxHQUFHaFYsOENBQUksQ0FBQ29JLE1BQUwsRUFBWjtBQUFBLFVBQTJCNk0sR0FBRyxHQUFHalYsOENBQUksQ0FBQ29JLE1BQUwsRUFBakM7QUFBQSxVQUFnRDhNLE9BQU8sR0FBR2xWLDhDQUFJLENBQUNvSSxNQUFMLEVBQTFEO0FBQ0EsVUFBTTtBQUFFK0o7QUFBRixRQUFlLElBQXJCOztBQUVBLFNBQUksSUFBSWhrQixDQUFDLEdBQUcsQ0FBWixFQUFlQSxDQUFDLEdBQUcsS0FBS3FqQixRQUFMLENBQWNsbEIsTUFBakMsRUFBeUM2QixDQUFDLElBQUksQ0FBOUMsRUFBaUQ7QUFFaER5bUIsUUFBRSxHQUFHLEtBQUtwRCxRQUFMLENBQWNyakIsQ0FBZCxDQUFMO0FBQ0EwbUIsUUFBRSxHQUFHLEtBQUtyRCxRQUFMLENBQWNyakIsQ0FBQyxHQUFHLENBQWxCLENBQUw7QUFDQTJtQixRQUFFLEdBQUcsS0FBS3RELFFBQUwsQ0FBY3JqQixDQUFDLEdBQUcsQ0FBbEIsQ0FBTDtBQUVBbkMsT0FBQyxHQUFHbW1CLFFBQVEsQ0FBQ3lDLEVBQUQsQ0FBWjtBQUNBL1gsT0FBQyxHQUFHc1YsUUFBUSxDQUFDMEMsRUFBRCxDQUFaO0FBQ0FFLE9BQUMsR0FBRzVDLFFBQVEsQ0FBQzJDLEVBQUQsQ0FBWjtBQUVBLFlBQU1QLElBQUksR0FBRztBQUNaekYsZUFBTyxFQUFDLENBQUM4RixFQUFELEVBQUtDLEVBQUwsRUFBU0MsRUFBVCxDQURJO0FBRVozQyxnQkFBUSxFQUFDLENBQUNubUIsQ0FBRCxFQUFJNlEsQ0FBSixFQUFPa1ksQ0FBUDtBQUZHLE9BQWI7O0FBS0EsV0FBS3RELE1BQUwsQ0FBWXhrQixJQUFaLENBQWlCc25CLElBQWpCO0FBQ0E7QUFFRDs7QUFHRHZCLGNBQVksQ0FBQzdSLEtBQUQsRUFBUTtBQUFFLFdBQU8sS0FBS21RLFdBQUwsQ0FBaUJ2bEIsSUFBakIsQ0FBdUJDLENBQUQsSUFBT0EsQ0FBQyxDQUFDMFYsSUFBRixLQUFXUCxLQUF4QyxDQUFQO0FBQXdEOztBQUM5RWdVLFdBQVMsQ0FBQ2hVLEtBQUQsRUFBUTtBQUNoQixVQUFNdUwsSUFBSSxHQUFHLEtBQUtzRyxZQUFMLENBQWtCN1IsS0FBbEIsQ0FBYjtBQUNBLFdBQU91TCxJQUFJLEdBQUdBLElBQUksQ0FBQ3dHLE1BQVIsR0FBaUIsRUFBNUI7QUFDQSxHQW5VUyxDQXNVVjs7O0FBRUEsTUFBSWYsUUFBSixHQUFlO0FBQUUsV0FBTyxLQUFLZ0QsU0FBTCxDQUFlLGlCQUFmLENBQVA7QUFBMkM7O0FBRTVELE1BQUlwRyxPQUFKLEdBQWM7QUFBRyxXQUFPLEtBQUtvRyxTQUFMLENBQWUsU0FBZixDQUFQO0FBQW1DOztBQUVwRCxNQUFJdEcsTUFBSixHQUFhO0FBQUcsV0FBTyxLQUFLc0csU0FBTCxDQUFlLGVBQWYsQ0FBUDtBQUF5Qzs7QUFFekQsTUFBSXJHLE9BQUosR0FBYztBQUFHLFdBQU8sS0FBSzBDLFFBQVo7QUFBdUI7O0FBRXhDLE1BQUkxRixVQUFKLEdBQWlCO0FBQUUsV0FBTyxLQUFLcUcsUUFBTCxDQUFjN2xCLE1BQXJCO0FBQThCOztBQUVqRCxNQUFJOG9CLEtBQUosR0FBWTtBQUFFLFdBQU8sS0FBSzNELE1BQVo7QUFBcUI7O0FBRW5DLE1BQUloRixVQUFKLEdBQWlCO0FBQUUsV0FBTyxLQUFLNkUsV0FBWjtBQUEwQjs7QUFFN0MsTUFBSWdDLE1BQUosR0FBYTtBQUFFLFdBQU8sS0FBSzFCLE9BQVo7QUFBc0I7O0FBRXJDLE1BQUk0QixHQUFKLEdBQVU7QUFBRSxXQUFPLEtBQUtJLElBQVo7QUFBbUI7O0FBRS9CLE1BQUlqSSxXQUFKLEdBQWtCO0FBQUUsV0FBTyxLQUFLNEYsWUFBWjtBQUEyQjs7QUFFL0MsTUFBSWhHLFdBQUosR0FBa0I7QUFBRSxXQUFPLEtBQUtzRyxZQUFaO0FBQTJCOztBQTVWckM7O0FBaVdJN2UsbUVBQWYsRTs7Ozs7Ozs7Ozs7O0FDdllBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBLElBQUk5RSxFQUFKOztBQUVBLFNBQVN5VixZQUFULENBQXNCQyxDQUF0QixFQUF5QjtBQUN4QixTQUFRQSxDQUFDLEtBQUssQ0FBUCxJQUFjLEVBQUVBLENBQUMsR0FBSUEsQ0FBQyxHQUFHLENBQVgsQ0FBckI7QUFDQTs7QUFBQTs7QUFFRCxNQUFNek8sc0JBQU4sQ0FBNkI7QUFDNUJoRixhQUFXLENBQUM4SixNQUFELEVBQVNDLE9BQVQsRUFBa0JqRSxXQUFXLEdBQUcsRUFBaEMsRUFBb0M7QUFDOUMvSCxNQUFFLEdBQUcyRSwrQ0FBRSxDQUFDM0UsRUFBUjtBQUVBLFNBQUs0SixLQUFMLEdBQXdCbUMsTUFBeEI7QUFDQSxTQUFLbEMsTUFBTCxHQUF3Qm1DLE9BQXhCO0FBRUEsU0FBSy9ELFNBQUwsR0FBa0JGLFdBQVcsQ0FBQ0UsU0FBWixJQUEwQmpJLEVBQUUsQ0FBQ2tJLE1BQS9DO0FBQ0EsU0FBS0MsU0FBTCxHQUFrQkosV0FBVyxDQUFDSSxTQUFaLElBQTBCbkksRUFBRSxDQUFDa0ksTUFBL0M7QUFDQSxTQUFLRSxLQUFMLEdBQWtCTCxXQUFXLENBQUNLLEtBQVosSUFBdUJwSSxFQUFFLENBQUNxSSxhQUE1QztBQUNBLFNBQUtDLEtBQUwsR0FBa0JQLFdBQVcsQ0FBQ08sS0FBWixJQUF1QnRJLEVBQUUsQ0FBQ3FJLGFBQTVDO0FBQ0EsU0FBSzhlLFFBQUwsR0FBa0JwZixXQUFXLENBQUNvZixRQUFaLElBQTBCLElBQTVDO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQnJmLFdBQVcsQ0FBQ3FmLFVBQVosSUFBMkIsS0FBN0M7QUFDQSxTQUFLN04sU0FBTCxHQUFrQnhSLFdBQVcsQ0FBQ3FHLElBQTlCO0FBQ0EsU0FBS2laLFVBQUwsR0FBa0J0ZixXQUFXLENBQUN1ZixTQUFaLElBQTBCLENBQTVDOztBQUVBLFFBQUcsQ0FBQzdSLFlBQVksQ0FBQyxLQUFLN0wsS0FBTixDQUFiLElBQTZCLENBQUM2TCxZQUFZLENBQUMsS0FBSzVMLE1BQU4sQ0FBN0MsRUFBNEQ7QUFDM0QsV0FBS3pCLEtBQUwsR0FBYSxLQUFLRSxLQUFMLEdBQWF0SSxFQUFFLENBQUNxSSxhQUE3Qjs7QUFFQSxVQUFHLEtBQUtGLFNBQUwsS0FBbUJuSSxFQUFFLENBQUNzWCxxQkFBekIsRUFBZ0Q7QUFDL0MsYUFBS25QLFNBQUwsR0FBaUJuSSxFQUFFLENBQUNrSSxNQUFwQjtBQUNBO0FBQ0Q7O0FBRUQsU0FBS0ssS0FBTDtBQUNBOztBQUVEQSxPQUFLLEdBQUc7QUFDUCxRQUFJZ1IsU0FBUyxHQUFHdlosRUFBRSxDQUFDcU8sYUFBbkI7O0FBQ0EsUUFBSSxLQUFLa0wsU0FBVCxFQUFvQjtBQUNuQkEsZUFBUyxHQUFHLEtBQUtBLFNBQWpCO0FBQ0E7O0FBRUQsU0FBS0EsU0FBTCxHQUFpQkEsU0FBakI7QUFFQSxTQUFLdlAsV0FBTCxHQUEwQmhLLEVBQUUsQ0FBQ2lLLGlCQUFILEVBQTFCO0FBQ0EsU0FBS3NkLGdCQUFMLEdBQTBCdm5CLEVBQUUsQ0FBQ2lLLGlCQUFILEVBQTFCO0FBQ0EsU0FBS3VkLGlCQUFMLEdBQTBCeG5CLEVBQUUsQ0FBQ3luQixrQkFBSCxFQUExQjtBQUNBLFNBQUtDLGlCQUFMLEdBQTBCMW5CLEVBQUUsQ0FBQ3luQixrQkFBSCxFQUExQjtBQUNBLFNBQUtoZixTQUFMLEdBQW9CLEtBQUs2RSxjQUFMLEVBQXBCO0FBQ0EsU0FBS1QsY0FBTCxHQUF1QixLQUFLUyxjQUFMLENBQW9CdE4sRUFBRSxDQUFDdU4saUJBQXZCLEVBQTBDdk4sRUFBRSxDQUFDd04sY0FBN0MsRUFBNkR4TixFQUFFLENBQUN5TixlQUFoRSxFQUFpRixJQUFqRixDQUF2QjtBQUVBek4sTUFBRSxDQUFDeUssZ0JBQUgsQ0FBb0J6SyxFQUFFLENBQUMwSyxZQUF2QixFQUFxQyxLQUFLOGMsaUJBQTFDO0FBQ0F4bkIsTUFBRSxDQUFDMm5CLDhCQUFILENBQWtDM25CLEVBQUUsQ0FBQzBLLFlBQXJDLEVBQW1ELEtBQUsyYyxVQUF4RCxFQUFvRXJuQixFQUFFLENBQUM0bkIsS0FBdkUsRUFBOEUsS0FBS2hlLEtBQW5GLEVBQTBGLEtBQUtDLE1BQS9GO0FBRUE3SixNQUFFLENBQUN5SyxnQkFBSCxDQUFvQnpLLEVBQUUsQ0FBQzBLLFlBQXZCLEVBQXFDLEtBQUtnZCxpQkFBMUM7QUFDQTFuQixNQUFFLENBQUMybkIsOEJBQUgsQ0FBa0MzbkIsRUFBRSxDQUFDMEssWUFBckMsRUFBbUQsS0FBSzJjLFVBQXhELEVBQW9Fcm5CLEVBQUUsQ0FBQ3VOLGlCQUF2RSxFQUEwRixLQUFLM0QsS0FBL0YsRUFBc0csS0FBS0MsTUFBM0c7QUFFQTdKLE1BQUUsQ0FBQ2tLLGVBQUgsQ0FBbUJsSyxFQUFFLENBQUNtSyxXQUF0QixFQUFtQyxLQUFLSCxXQUF4QztBQUNBaEssTUFBRSxDQUFDNm5CLHVCQUFILENBQTJCN25CLEVBQUUsQ0FBQ21LLFdBQTlCLEVBQTJDbkssRUFBRSxDQUFDcUssaUJBQTlDLEVBQWlFckssRUFBRSxDQUFDMEssWUFBcEUsRUFBa0YsS0FBSzhjLGlCQUF2RjtBQUNBeG5CLE1BQUUsQ0FBQzZuQix1QkFBSCxDQUEyQjduQixFQUFFLENBQUNtSyxXQUE5QixFQUEyQ25LLEVBQUUsQ0FBQzRNLGdCQUE5QyxFQUFnRTVNLEVBQUUsQ0FBQzBLLFlBQW5FLEVBQWlGLEtBQUtnZCxpQkFBdEY7QUFDQTFuQixNQUFFLENBQUNrSyxlQUFILENBQW1CbEssRUFBRSxDQUFDbUssV0FBdEIsRUFBbUMsSUFBbkM7QUFFQW5LLE1BQUUsQ0FBQ2tLLGVBQUgsQ0FBbUJsSyxFQUFFLENBQUNtSyxXQUF0QixFQUFtQyxLQUFLb2QsZ0JBQXhDO0FBQ0F2bkIsTUFBRSxDQUFDb0ssb0JBQUgsQ0FBd0JwSyxFQUFFLENBQUNtSyxXQUEzQixFQUF3Q25LLEVBQUUsQ0FBQ3FLLGlCQUEzQyxFQUE4RHJLLEVBQUUsQ0FBQ3lNLFVBQWpFLEVBQTZFLEtBQUtoRSxTQUFMLENBQWU1SixPQUE1RixFQUFxRyxDQUFyRyxFQTNCTyxDQTRCUDs7QUFDQW1CLE1BQUUsQ0FBQ2tLLGVBQUgsQ0FBbUJsSyxFQUFFLENBQUNtSyxXQUF0QixFQUFtQyxJQUFuQyxFQTdCTyxDQStCUDtBQUNBO0FBQ0E7QUFDQTs7QUFFRG1ELGdCQUFjLENBQUNNLGVBQUQsRUFBa0JDLFVBQWxCLEVBQThCQyxPQUE5QixFQUF1Q2dhLFlBQVksR0FBRyxLQUF0RCxFQUE2RDtBQUMxRSxRQUFHbGEsZUFBZSxLQUFLMUosU0FBdkIsRUFBa0M7QUFBRTBKLHFCQUFlLEdBQUc1TixFQUFFLENBQUMySixJQUFyQjtBQUE0Qjs7QUFDaEUsUUFBR2tFLFVBQVUsS0FBSzNKLFNBQWxCLEVBQTZCO0FBQUUySixnQkFBVSxHQUFHLEtBQUswTCxTQUFsQjtBQUE4Qjs7QUFDN0QsUUFBRyxDQUFDekwsT0FBSixFQUFhO0FBQUVBLGFBQU8sR0FBR0YsZUFBVjtBQUE0Qjs7QUFFM0MsVUFBTXNVLENBQUMsR0FBR2xpQixFQUFFLENBQUN3SSxhQUFILEVBQVY7QUFDQSxVQUFNNkUsR0FBRyxHQUFHLElBQUl2TyxrREFBSixDQUFjb2pCLENBQWQsRUFBaUIsSUFBakIsQ0FBWjtBQUNBLFVBQU1qYSxTQUFTLEdBQUc2ZixZQUFZLEdBQUduakIsK0NBQUUsQ0FBQytJLE9BQU4sR0FBZ0IsS0FBS3pGLFNBQW5EO0FBQ0EsVUFBTUUsU0FBUyxHQUFHMmYsWUFBWSxHQUFHbmpCLCtDQUFFLENBQUMrSSxPQUFOLEdBQWdCLEtBQUt2RixTQUFuRDtBQUVBbkksTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDeU0sVUFBbEIsRUFBOEJ5VixDQUE5QjtBQUNBbGlCLE1BQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUN5TSxVQUFwQixFQUFnQ3pNLEVBQUUsQ0FBQzZJLGtCQUFuQyxFQUF1RFosU0FBdkQ7QUFDQWpJLE1BQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUN5TSxVQUFwQixFQUFnQ3pNLEVBQUUsQ0FBQzhJLGtCQUFuQyxFQUF1RFgsU0FBdkQ7QUFDQW5JLE1BQUUsQ0FBQzRJLGFBQUgsQ0FBaUI1SSxFQUFFLENBQUN5TSxVQUFwQixFQUFnQ3pNLEVBQUUsQ0FBQytJLGNBQW5DLEVBQW1ELEtBQUtYLEtBQXhEO0FBQ0FwSSxNQUFFLENBQUM0SSxhQUFILENBQWlCNUksRUFBRSxDQUFDeU0sVUFBcEIsRUFBZ0N6TSxFQUFFLENBQUNnSixjQUFuQyxFQUFtRCxLQUFLVixLQUF4RDtBQUNBdEksTUFBRSxDQUFDMEosVUFBSCxDQUFjMUosRUFBRSxDQUFDeU0sVUFBakIsRUFBNkIsQ0FBN0IsRUFBZ0NtQixlQUFoQyxFQUFpRCxLQUFLaEUsS0FBdEQsRUFBNkQsS0FBS0MsTUFBbEUsRUFBMEUsQ0FBMUUsRUFBNkVpRSxPQUE3RSxFQUFzRkQsVUFBdEYsRUFBa0csSUFBbEc7QUFDQTdOLE1BQUUsQ0FBQzBJLFdBQUgsQ0FBZTFJLEVBQUUsQ0FBQ3lNLFVBQWxCLEVBQThCLElBQTlCO0FBRUEsV0FBT1ksR0FBUDtBQUNBOztBQUdEekYsTUFBSSxDQUFDMkcsZ0JBQWdCLEdBQUMsSUFBbEIsRUFBd0I7QUFDM0IsUUFBR0EsZ0JBQUgsRUFBcUI7QUFDcEI1SixxREFBRSxDQUFDaUcsUUFBSCxDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLEtBQUtoQixLQUF2QixFQUE4QixLQUFLQyxNQUFuQztBQUNBOztBQUNEN0osTUFBRSxDQUFDa0ssZUFBSCxDQUFtQmxLLEVBQUUsQ0FBQ21LLFdBQXRCLEVBQW1DLEtBQUtILFdBQXhDO0FBQ0E7O0FBR0RhLFFBQU0sQ0FBQzBELGdCQUFnQixHQUFDLElBQWxCLEVBQXdCO0FBQzdCLFFBQUdBLGdCQUFILEVBQXFCO0FBQ3BCNUoscURBQUUsQ0FBQ2lHLFFBQUgsQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQmpHLCtDQUFFLENBQUNpRixLQUFyQixFQUE0QmpGLCtDQUFFLENBQUNrRixNQUEvQjtBQUNBOztBQUVELFVBQU07QUFBRUQsV0FBRjtBQUFTQztBQUFULFFBQW9CLElBQTFCO0FBRUE3SixNQUFFLENBQUNrSyxlQUFILENBQW1CbEssRUFBRSxDQUFDbUssV0FBdEIsRUFBbUMsSUFBbkM7QUFFQW5LLE1BQUUsQ0FBQ2tLLGVBQUgsQ0FBbUJsSyxFQUFFLENBQUMrbkIsZ0JBQXRCLEVBQXdDLEtBQUsvZCxXQUE3QztBQUNBaEssTUFBRSxDQUFDa0ssZUFBSCxDQUFtQmxLLEVBQUUsQ0FBQ3dNLGdCQUF0QixFQUF3QyxLQUFLK2EsZ0JBQTdDO0FBQ0F2bkIsTUFBRSxDQUFDZ29CLGFBQUgsQ0FBaUJob0IsRUFBRSxDQUFDaW9CLEtBQXBCLEVBQTJCLENBQTNCLEVBQThCLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLENBQTlCO0FBQ0Fqb0IsTUFBRSxDQUFDa29CLGVBQUgsQ0FDQyxDQURELEVBQ0ksQ0FESixFQUNPdGUsS0FEUCxFQUNjQyxNQURkLEVBRUMsQ0FGRCxFQUVJLENBRkosRUFFT0QsS0FGUCxFQUVjQyxNQUZkLEVBR0M3SixFQUFFLENBQUNvYyxnQkFISixFQUdzQnpYLCtDQUFFLENBQUMrSSxPQUh6QixFQVo2QixDQWlCN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUExTixNQUFFLENBQUNrSyxlQUFILENBQW1CbEssRUFBRSxDQUFDbUssV0FBdEIsRUFBbUMsSUFBbkM7QUFDQTs7QUFHRFcsWUFBVSxDQUFDOEQsTUFBTSxHQUFHLENBQVYsRUFBYTtBQUN0QixXQUFPLEtBQUtuRyxTQUFaO0FBQ0E7O0FBR0RvRyxpQkFBZSxHQUFHO0FBQ2pCLFdBQU8sS0FBS2hDLGNBQVo7QUFDQTs7QUF4STJCOztBQTZJZDVGLHFGQUFmLEU7Ozs7Ozs7Ozs7OztBQ3hKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUEsSUFBSWpILEVBQUo7O0FBRUEsTUFBTWtILHVCQUFOLENBQThCO0FBRzdCakYsYUFBVyxDQUFDa1EsZUFBRCxFQUFrQkUsaUJBQWxCLEVBQXFDO0FBQy9DclMsTUFBRSxHQUFHMkUsK0NBQUUsQ0FBQzNFLEVBQVI7QUFDQSxTQUFLbW9CLEdBQUwsR0FBV2hXLGVBQVg7QUFDQSxTQUFLaVcsR0FBTCxHQUFXL1YsaUJBQVg7O0FBRUEsU0FBSzlKLEtBQUw7QUFDQTs7QUFHREEsT0FBSyxHQUFHO0FBQ1AsU0FBSzhmLFlBQUwsR0FBb0IsSUFBSXZqQiw2Q0FBSixFQUFwQjtBQUNBLFNBQUt3akIsV0FBTCxHQUFtQixJQUFJeGpCLDZDQUFKLEVBQW5CO0FBQ0EsU0FBS3lqQixVQUFMLEdBQWtCLENBQUMsQ0FBbkI7QUFFQSxTQUFLL1YsU0FBTCxHQUFpQixFQUFqQjtBQUNBLFNBQUsyTCxpQkFBTCxHQUF5Qm5lLEVBQUUsQ0FBQ3dvQix1QkFBSCxFQUF6QjtBQUNBOztBQUdEM0YsWUFBVSxDQUFDSyxLQUFELEVBQVFqUSxLQUFSLEVBQWV3VixZQUFmLEVBQTZCO0FBQ3RDLFVBQU1DLG1CQUFtQixHQUFHLENBQUMsQ0FBQ0QsWUFBOUI7QUFDQWhwQixXQUFPLENBQUNDLEdBQVIsQ0FBWSx5QkFBWixFQUF1Q3VULEtBQXZDLEVBQThDeVYsbUJBQTlDOztBQUNBLFNBQUtMLFlBQUwsQ0FBa0J4RixVQUFsQixDQUE2QkssS0FBN0IsRUFBb0NqUSxLQUFwQyxFQUEyQyxJQUEzQyxFQUFpRGpULEVBQUUsQ0FBQzJvQixXQUFwRCxFQUFpRSxLQUFqRTs7QUFDQSxTQUFLTCxXQUFMLENBQWlCekYsVUFBakIsQ0FBNEJLLEtBQTVCLEVBQW1DalEsS0FBbkMsRUFBMEMsSUFBMUMsRUFBZ0RqVCxFQUFFLENBQUMyb0IsV0FBbkQsRUFBZ0UsS0FBaEU7O0FBRUEsUUFBR0QsbUJBQUgsRUFBd0I7QUFDdkIsV0FBS2xXLFNBQUwsQ0FBZXpULElBQWYsQ0FBb0IwcEIsWUFBcEI7O0FBRUEsVUFBRyxLQUFLRixVQUFMLEdBQWtCLENBQXJCLEVBQXdCO0FBQ3ZCLGFBQUtBLFVBQUwsR0FBa0JyRixLQUFLLENBQUM5a0IsTUFBeEI7QUFDQTtBQUNEO0FBQ0Q7O0FBRURxakIsYUFBVyxDQUFDMkMsYUFBRCxFQUFnQjtBQUMxQixTQUFLaUUsWUFBTCxDQUFrQjVHLFdBQWxCLENBQThCMkMsYUFBOUI7O0FBQ0EsU0FBS2tFLFdBQUwsQ0FBaUI3RyxXQUFqQixDQUE2QjJDLGFBQTdCO0FBQ0E7O0FBR0RwUixTQUFPLENBQUNDLEtBQUQsRUFBUUMsS0FBUixFQUFlNVEsTUFBZixFQUF1QjtBQUM3QixRQUFHLEtBQUt1RixNQUFSLEVBQWdCO0FBQ2YsV0FBS0EsTUFBTCxDQUFZbUwsT0FBWixDQUFvQkMsS0FBcEIsRUFBMkJDLEtBQTNCLEVBQWtDNVEsTUFBbEM7QUFDQTtBQUVEOztBQUVEc21CLFVBQVEsR0FBRztBQUNWLFNBQUsvZ0IsTUFBTCxHQUFjLElBQUloRCxpREFBSixDQUFhLEtBQUtzakIsR0FBbEIsRUFBdUIsS0FBS0MsR0FBNUIsRUFBaUMsS0FBSzVWLFNBQXRDLENBQWQ7QUFDQTs7QUFFRHFXLFFBQU0sR0FBRztBQUNSLFFBQUcsQ0FBQyxLQUFLaGhCLE1BQVQsRUFBaUI7QUFBRSxXQUFLK2dCLFFBQUw7QUFBa0I7O0FBRXJDLFNBQUsvZ0IsTUFBTCxDQUFZRCxJQUFaO0FBQ0FqRCxtREFBRSxDQUFDbVoscUJBQUgsQ0FBeUIsSUFBekI7O0FBRUEsU0FBS2dMLEtBQUw7QUFDQTs7QUFFREEsT0FBSyxHQUFHO0FBQ1AsVUFBTTVVLEdBQUcsR0FBWSxLQUFLbVUsWUFBMUI7QUFDQSxTQUFLQSxZQUFMLEdBQW9CLEtBQUtDLFdBQXpCO0FBQ0EsU0FBS0EsV0FBTCxHQUFvQnBVLEdBQXBCO0FBQ0E7O0FBRUQsTUFBSWdLLFNBQUosR0FBZ0I7QUFBRSxXQUFPLEtBQUtxSyxVQUFaO0FBQXlCOztBQUMzQyxNQUFJUSxXQUFKLEdBQWtCO0FBQUUsV0FBTyxLQUFLVixZQUFaO0FBQTJCOztBQUMvQyxNQUFJVyxVQUFKLEdBQWlCO0FBQUUsV0FBTyxLQUFLVixXQUFaO0FBQTBCOztBQUM3QyxNQUFJdEssVUFBSixHQUFpQjtBQUFFLFdBQU8sS0FBS3FLLFlBQVo7QUFBMkI7O0FBQzlDLE1BQUlwSyxlQUFKLEdBQXNCO0FBQUUsV0FBTyxLQUFLcUssV0FBWjtBQUEwQjs7QUF6RXJCOztBQTZFZnBoQixzRkFBZixFOzs7Ozs7Ozs7Ozs7QUNyRkE7QUFBQTtBQUFBO0FBRUE7O0FBRUEsTUFBTTFCLE1BQU4sQ0FBYTtBQUNadkQsYUFBVyxHQUFHO0FBQ2I7QUFDQSxTQUFLcVksT0FBTCxHQUFlcEksOENBQUksQ0FBQ2dJLE1BQUwsRUFBZixDQUZhLENBSWI7O0FBQ0EsU0FBSytPLEtBQUwsR0FBYUMsOENBQUksQ0FBQ2hQLE1BQUwsRUFBYjtBQUNBLFNBQUtpUCxZQUFMLEdBQW9CalgsOENBQUksQ0FBQ2dJLE1BQUwsRUFBcEIsQ0FOYSxDQVFiOztBQUNBLFNBQUtrUCxXQUFMLEdBQW1CbFgsOENBQUksQ0FBQ2dJLE1BQUwsRUFBbkIsQ0FUYSxDQVdiOztBQUNBLFNBQUttUCxRQUFMLEdBQWdCdlgsSUFBSSxDQUFDb0ksTUFBTCxFQUFoQjtBQUNBOztBQUdEb1AsUUFBTSxDQUFDQyxJQUFELEVBQU9DLE9BQVAsRUFBZ0JDLEdBQUcsR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUF0QixFQUFpQztBQUN0QyxTQUFLQyxJQUFMLEdBQVk1WCxJQUFJLENBQUM4TixLQUFMLENBQVcySixJQUFYLENBQVo7QUFDQSxTQUFLSSxPQUFMLEdBQWU3WCxJQUFJLENBQUM4TixLQUFMLENBQVc0SixPQUFYLENBQWY7QUFFQTFYLFFBQUksQ0FBQzhLLElBQUwsQ0FBVSxLQUFLeU0sUUFBZixFQUF5QkUsSUFBekI7QUFDQXJYLGtEQUFJLENBQUMySSxRQUFMLENBQWMsS0FBS1AsT0FBbkI7QUFDQXBJLGtEQUFJLENBQUNvWCxNQUFMLENBQVksS0FBS2hQLE9BQWpCLEVBQTBCaVAsSUFBMUIsRUFBZ0NDLE9BQWhDLEVBQXlDQyxHQUF6QztBQUNBOztBQUdERyxvQkFBa0IsQ0FBQ2xVLENBQUQsRUFBSXNHLENBQUosRUFBT3lHLENBQVAsRUFBVTVNLENBQVYsRUFBYTtBQUM5QnFULGtEQUFJLENBQUM5bUIsR0FBTCxDQUFTLEtBQUs2bUIsS0FBZCxFQUFxQnZULENBQXJCLEVBQXdCc0csQ0FBeEIsRUFBMkJ5RyxDQUEzQixFQUE4QjVNLENBQTlCO0FBQ0EzRCxrREFBSSxDQUFDMlgsUUFBTCxDQUFjLEtBQUtWLFlBQW5CLEVBQWlDLEtBQUtGLEtBQXRDO0FBQ0EvVyxrREFBSSxDQUFDNFgsU0FBTCxDQUFlLEtBQUt4UCxPQUFwQixFQUE2QixLQUFLNk8sWUFBbEMsRUFBZ0QsS0FBSzFsQixjQUFyRDtBQUNBOztBQUdEc21CLGVBQWEsQ0FBQ0MsS0FBRCxFQUFRO0FBQ3BCLFNBQUtaLFdBQUwsR0FBbUJsWCw4Q0FBSSxDQUFDME4sS0FBTCxDQUFXb0ssS0FBWCxDQUFuQjtBQUNBOztBQUdEQyxTQUFPLENBQUNDLEtBQUQsRUFBUTtBQUNkLFNBQUs1UCxPQUFMLEdBQWVwSSw4Q0FBSSxDQUFDME4sS0FBTCxDQUFXc0ssS0FBWCxDQUFmO0FBQ0E7O0FBR0RDLGlCQUFlLENBQUNELEtBQUQsRUFBUUYsS0FBUixFQUFlO0FBQzdCLFNBQUtDLE9BQUwsQ0FBYUMsS0FBYjtBQUNBLFNBQUtILGFBQUwsQ0FBbUJDLEtBQW5CO0FBQ0EsR0EvQ1csQ0FrRFo7OztBQUVBLE1BQUlsTixNQUFKLEdBQWE7QUFDWixXQUFPLEtBQUt4QyxPQUFaO0FBQ0E7O0FBRUQsTUFBSThQLFVBQUosR0FBaUI7QUFDaEIsV0FBTyxLQUFLOVAsT0FBWjtBQUNBOztBQUdELE1BQUk2QyxVQUFKLEdBQWlCO0FBQ2hCLFdBQU8sS0FBS2lNLFdBQVo7QUFDQTs7QUFFRCxNQUFJaUIsZ0JBQUosR0FBdUI7QUFDdEIsV0FBTyxLQUFLakIsV0FBWjtBQUNBOztBQUdELE1BQUlrQixHQUFKLEdBQVU7QUFBRSxXQUFPLEtBQUtaLElBQVo7QUFBbUI7O0FBRS9CLE1BQUlybUIsTUFBSixHQUFhO0FBQUUsV0FBTyxLQUFLc21CLE9BQVo7QUFBc0I7O0FBeEV6Qjs7QUE0RUVua0IscUVBQWYsRTs7Ozs7Ozs7Ozs7O0FDaEZBO0FBQUE7QUFBQTtBQUFBO0FBRWE7O0FBRWI7QUFDQTtBQUVBLE1BQU0ra0IsZUFBZSxHQUFHLENBQ3ZCLENBQUN6WSw4Q0FBSSxDQUFDMFksVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixDQUFELEVBQTJCMVksOENBQUksQ0FBQzBZLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBM0IsRUFBcUQxWSw4Q0FBSSxDQUFDMFksVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFDLENBQXBCLEVBQXVCLENBQXZCLENBQXJELENBRHVCLEVBRXZCLENBQUMxWSw4Q0FBSSxDQUFDMFksVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixDQUFELEVBQTJCMVksOENBQUksQ0FBQzBZLFVBQUwsQ0FBZ0IsQ0FBQyxDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixDQUEzQixFQUFzRDFZLDhDQUFJLENBQUMwWSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQUMsQ0FBcEIsRUFBdUIsQ0FBdkIsQ0FBdEQsQ0FGdUIsRUFHdkIsQ0FBQzFZLDhDQUFJLENBQUMwWSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLENBQUQsRUFBMkIxWSw4Q0FBSSxDQUFDMFksVUFBTCxDQUFnQixDQUFoQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixDQUEzQixFQUFzRDFZLDhDQUFJLENBQUMwWSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXVCLENBQXZCLENBQXRELENBSHVCLEVBSXZCLENBQUMxWSw4Q0FBSSxDQUFDMFksVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixDQUFELEVBQTJCMVksOENBQUksQ0FBQzBZLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBQyxDQUFwQixFQUF1QixDQUF2QixDQUEzQixFQUFzRDFZLDhDQUFJLENBQUMwWSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQUMsQ0FBdkIsQ0FBdEQsQ0FKdUIsRUFLdkIsQ0FBQzFZLDhDQUFJLENBQUMwWSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLENBQUQsRUFBMkIxWSw4Q0FBSSxDQUFDMFksVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUF1QixDQUF2QixDQUEzQixFQUFzRDFZLDhDQUFJLENBQUMwWSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQUMsQ0FBcEIsRUFBdUIsQ0FBdkIsQ0FBdEQsQ0FMdUIsRUFNdkIsQ0FBQzFZLDhDQUFJLENBQUMwWSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLENBQUQsRUFBMkIxWSw4Q0FBSSxDQUFDMFksVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUFDLENBQXZCLENBQTNCLEVBQXNEMVksOENBQUksQ0FBQzBZLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBQyxDQUFwQixFQUF1QixDQUF2QixDQUF0RCxDQU51QixDQUF4Qjs7QUFTQSxNQUFNNWtCLFVBQU4sU0FBeUJGLDBEQUF6QixDQUEyQztBQUUxQ3pELGFBQVcsR0FBRztBQUNiO0FBRUEsU0FBS3dvQixjQUFMLENBQW9COVosSUFBSSxDQUFDb1IsRUFBTCxHQUFVLENBQTlCLEVBQWlDLENBQWpDLEVBQW9DLEdBQXBDLEVBQXlDLElBQXpDO0FBQ0E7O0FBR0RzRSxNQUFJLENBQUN6WCxNQUFELEVBQVM7QUFDWixVQUFNbFEsQ0FBQyxHQUFHNnJCLGVBQWUsQ0FBQzNiLE1BQUQsQ0FBekI7QUFDQSxTQUFLMGEsTUFBTCxDQUFZNXFCLENBQUMsQ0FBQyxDQUFELENBQWIsRUFBa0JBLENBQUMsQ0FBQyxDQUFELENBQW5CLEVBQXdCQSxDQUFDLENBQUMsQ0FBRCxDQUF6QjtBQUNBOztBQVp5Qzs7QUFnQjVCa0gseUVBQWYsRTs7Ozs7Ozs7Ozs7O0FDaENBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTs7QUFFQSxNQUFNSCxXQUFOLFNBQTBCRCwrQ0FBMUIsQ0FBaUM7QUFDaEN2RCxhQUFXLEdBQUc7QUFDYjtBQUVBLFVBQU1xb0IsR0FBRyxHQUFNeFksOENBQUksQ0FBQzhOLEtBQUwsQ0FBVyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFYLENBQWY7QUFDQSxVQUFNdmMsTUFBTSxHQUFHeU8sOENBQUksQ0FBQ29JLE1BQUwsRUFBZjtBQUNBLFVBQU13USxFQUFFLEdBQU81WSw4Q0FBSSxDQUFDOE4sS0FBTCxDQUFXLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVgsQ0FBZjtBQUNBLFNBQUswSixNQUFMLENBQVlnQixHQUFaLEVBQWlCam5CLE1BQWpCLEVBQXlCcW5CLEVBQXpCO0FBQ0EsU0FBS0MsS0FBTCxDQUFXLENBQUMsQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEIsRUFBcUIsQ0FBQyxDQUF0QjtBQUNBOztBQUdEQyxhQUFXLENBQUNDLElBQUQsRUFBT0MsS0FBUCxFQUFjQyxHQUFkLEVBQW1CQyxNQUFuQixFQUEyQkMsSUFBSSxHQUFDLEdBQWhDLEVBQXFDQyxHQUFHLEdBQUMsR0FBekMsRUFBOEM7QUFDeEQsU0FBS1AsS0FBTCxDQUFXRSxJQUFYLEVBQWlCQyxLQUFqQixFQUF3QkMsR0FBeEIsRUFBNkJDLE1BQTdCLEVBQXFDQyxJQUFyQyxFQUEyQ0MsR0FBM0M7QUFDQTs7QUFHRFAsT0FBSyxDQUFDRSxJQUFELEVBQU9DLEtBQVAsRUFBY0MsR0FBZCxFQUFtQkMsTUFBbkIsRUFBMkJDLElBQUksR0FBQyxHQUFoQyxFQUFxQ0MsR0FBRyxHQUFDLEdBQXpDLEVBQThDO0FBQ2xELFNBQUtMLElBQUwsR0FBY0EsSUFBZDtBQUNBLFNBQUtDLEtBQUwsR0FBY0EsS0FBZDtBQUNBLFNBQUtDLEdBQUwsR0FBY0EsR0FBZDtBQUNBLFNBQUtDLE1BQUwsR0FBY0EsTUFBZDtBQUNBOVksUUFBSSxDQUFDeVksS0FBTCxDQUFXLEtBQUt2QixXQUFoQixFQUE2QnlCLElBQTdCLEVBQW1DQyxLQUFuQyxFQUEwQ0UsTUFBMUMsRUFBa0RELEdBQWxELEVBQXVERSxJQUF2RCxFQUE2REMsR0FBN0Q7QUFDQTs7QUF2QitCOztBQTRCbEJ6bEIsMEVBQWYsRTs7Ozs7Ozs7Ozs7O0FDakNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQSxNQUFNMGxCLGdCQUFnQixHQUFHalosOENBQUksQ0FBQ2dJLE1BQUwsRUFBekI7QUFDQSxNQUFNa1IsU0FBUyxHQUFHdFosOENBQUksQ0FBQ29JLE1BQUwsRUFBbEI7O0FBR0EsTUFBTXhVLGlCQUFOLFNBQWdDRiwrQ0FBaEMsQ0FBdUM7QUFFdEN2RCxhQUFXLENBQUNvcEIsSUFBRCxFQUFPQyxZQUFQLEVBQXFCQyxLQUFyQixFQUE0QkMsSUFBNUIsRUFBa0M7QUFDNUM7O0FBRUEsUUFBR0gsSUFBSCxFQUFTO0FBQ1IsV0FBS1osY0FBTCxDQUFvQlksSUFBcEIsRUFBMEJDLFlBQTFCLEVBQXdDQyxLQUF4QyxFQUErQ0MsSUFBL0M7QUFDQTtBQUNEOztBQUVEZixnQkFBYyxDQUFDWSxJQUFELEVBQU9DLFlBQVAsRUFBcUJDLEtBQXJCLEVBQTRCQyxJQUE1QixFQUFrQztBQUUvQyxTQUFLQyxJQUFMLEdBQW9CSixJQUFwQjtBQUNBLFNBQUtLLEtBQUwsR0FBb0JILEtBQXBCO0FBQ0EsU0FBS0ksSUFBTCxHQUFvQkgsSUFBcEI7QUFDQSxTQUFLdE0sWUFBTCxHQUFvQm9NLFlBQXBCO0FBQ0FwWixrREFBSSxDQUFDMFosV0FBTCxDQUFpQixLQUFLeEMsV0FBdEIsRUFBbUNpQyxJQUFuQyxFQUF5Q0MsWUFBekMsRUFBdURDLEtBQXZELEVBQThEQyxJQUE5RCxFQU4rQyxDQVEvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdESyxnQkFBYyxDQUFDUCxZQUFELEVBQWU7QUFDNUIsU0FBS3BNLFlBQUwsR0FBb0JvTSxZQUFwQjtBQUNBcFosa0RBQUksQ0FBQzBaLFdBQUwsQ0FBaUIsS0FBS3pPLFVBQXRCLEVBQWtDLEtBQUtzTyxJQUF2QyxFQUE2Q0gsWUFBN0MsRUFBMkQsS0FBS0ksS0FBaEUsRUFBdUUsS0FBS0MsSUFBNUU7QUFDQTs7QUFHREcsYUFBVyxDQUFDQyxlQUFELEVBQWtCQyxJQUFsQixFQUF3QjtBQUNsQyxVQUFNQyxJQUFJLEdBQUcsS0FBSzVCLGdCQUFsQjtBQUNBLFVBQU02QixJQUFJLEdBQUcsS0FBSzlCLFVBQWxCO0FBRUFsWSxrREFBSSxDQUFDMkssUUFBTCxDQUFjc08sZ0JBQWQsRUFBZ0NjLElBQWhDLEVBQXNDQyxJQUF0QztBQUNBaGEsa0RBQUksQ0FBQzhLLE1BQUwsQ0FBWW1PLGdCQUFaLEVBQThCQSxnQkFBOUI7QUFFQXJaLGtEQUFJLENBQUNxYSxhQUFMLENBQW1CZixTQUFuQixFQUE4QlcsZUFBOUIsRUFBK0NaLGdCQUEvQztBQUNBclosa0RBQUksQ0FBQ3NhLEdBQUwsQ0FBU2hCLFNBQVQsRUFBb0JBLFNBQXBCLEVBQStCLEtBQUsvQixRQUFwQztBQUNBdlgsa0RBQUksQ0FBQzJVLFNBQUwsQ0FBZTJFLFNBQWYsRUFBMEJBLFNBQTFCOztBQUVBLFFBQUksQ0FBQ1ksSUFBTCxFQUFXO0FBQ1ZBLFVBQUksR0FBRyxJQUFJcm1CLGlEQUFKLENBQVEsS0FBSzBqQixRQUFiLEVBQXVCK0IsU0FBdkIsQ0FBUDtBQUNBLEtBRkQsTUFFTztBQUNOWSxVQUFJLENBQUNLLE1BQUwsR0FBYyxLQUFLaEQsUUFBbkI7QUFDQTJDLFVBQUksQ0FBQ00sU0FBTCxHQUFpQmxCLFNBQWpCO0FBQ0E7O0FBR0QsV0FBT1ksSUFBUDtBQUNBOztBQW5EcUM7O0FBdUR4QnRtQixnRkFBZixFOzs7Ozs7Ozs7Ozs7QUNqRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFHQSxNQUFNUSxTQUFOLFNBQXdCbEIsOENBQXhCLENBQThCO0FBRTdCL0MsYUFBVyxHQUFHO0FBQ2IsVUFBTXllLFNBQVMsR0FBRyxFQUFsQjtBQUNBLFVBQU02TCxNQUFNLEdBQUcsRUFBZjtBQUNBLFVBQU0zTCxPQUFPLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUFoQjtBQUNBLFVBQU1uUyxDQUFDLEdBQUcsSUFBVjtBQUVBaVMsYUFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUMwUCxDQUFGLEVBQU0sQ0FBTixFQUFVLENBQVYsQ0FBZjtBQUNBaVMsYUFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDMFAsQ0FBRCxFQUFLLENBQUwsRUFBUyxDQUFULENBQWY7QUFDQWlTLGFBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQyxDQUFELEVBQUksQ0FBQzBQLENBQUwsRUFBUyxDQUFULENBQWY7QUFDQWlTLGFBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQyxDQUFELEVBQUswUCxDQUFMLEVBQVMsQ0FBVCxDQUFmO0FBQ0FpUyxhQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMsQ0FBRCxFQUFLLENBQUwsRUFBUSxDQUFDMFAsQ0FBVCxDQUFmO0FBQ0FpUyxhQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUMsQ0FBRCxFQUFLLENBQUwsRUFBUzBQLENBQVQsQ0FBZjtBQUdBOGQsVUFBTSxDQUFDeHRCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFaO0FBQ0F3dEIsVUFBTSxDQUFDeHRCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFaO0FBQ0F3dEIsVUFBTSxDQUFDeHRCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFaO0FBQ0F3dEIsVUFBTSxDQUFDeHRCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFaO0FBQ0F3dEIsVUFBTSxDQUFDeHRCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFaO0FBQ0F3dEIsVUFBTSxDQUFDeHRCLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFaO0FBRUEsVUFBTVEsSUFBSSxHQUFHLElBQUl1Riw2Q0FBSixDQUFTSCwrQ0FBRSxDQUFDNm5CLEtBQVosQ0FBYjtBQUNBanRCLFFBQUksQ0FBQ2dpQixZQUFMLENBQWtCYixTQUFsQjtBQUNBbmhCLFFBQUksQ0FBQ2tpQixXQUFMLENBQWlCYixPQUFqQjtBQUNBcmhCLFFBQUksQ0FBQ3NqQixVQUFMLENBQWdCMEosTUFBaEIsRUFBd0IsUUFBeEIsRUFBa0MsQ0FBbEM7QUFFQSxVQUFNMWtCLE1BQU0sR0FBRyxJQUFJaEQsaURBQUosQ0FBYTRuQiwwREFBYixFQUFpQkMsMERBQWpCLENBQWY7QUFFQSxVQUFNbnRCLElBQU4sRUFBWXNJLE1BQVo7QUFFQTs7QUFoQzRCOztBQXNDZjNCLHdFQUFmLEU7Ozs7Ozs7Ozs7OztBQ2pEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUEsTUFBTUMsU0FBTixTQUF3Qm5CLDhDQUF4QixDQUE4QjtBQUU3Qi9DLGFBQVcsR0FBRztBQUNiLFVBQU0xQyxJQUFJLEdBQUd3Riw2Q0FBSSxDQUFDNGMsTUFBTCxDQUFZLENBQVosRUFBZSxFQUFmLENBQWI7QUFDQSxVQUFNOVosTUFBTSxHQUFHLElBQUloRCxpREFBSixDQUFhNG5CLDZEQUFiLEVBQWlCQyxpRUFBakIsQ0FBZjtBQUNBLFVBQU1udEIsSUFBTixFQUFZc0ksTUFBWjtBQUNBOztBQUdERixNQUFJLENBQUMwaEIsUUFBUSxHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVosRUFBdUJzRCxLQUFLLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBL0IsRUFBMENDLEtBQUssR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFsRCxFQUE2REMsT0FBTyxHQUFHLENBQXZFLEVBQTBFO0FBQzdFLFNBQUtobEIsTUFBTCxDQUFZRCxJQUFaO0FBQ0EsU0FBS0MsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixVQUFwQixFQUFnQyxZQUFoQyxFQUE4Q3FXLFFBQTlDO0FBQ0EsU0FBS3hoQixNQUFMLENBQVltTCxPQUFaLENBQW9CLE9BQXBCLEVBQTZCLFlBQTdCLEVBQTJDMlosS0FBM0M7QUFDQSxTQUFLOWtCLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IsT0FBcEIsRUFBNkIsWUFBN0IsRUFBMkM0WixLQUEzQztBQUNBLFNBQUsva0IsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixTQUFwQixFQUErQixXQUEvQixFQUE0QzZaLE9BQTVDO0FBQ0EsVUFBTWxsQixJQUFOO0FBQ0E7O0FBaEI0Qjs7QUFvQmZ4Qix3RUFBZixFOzs7Ozs7Ozs7Ozs7QUM3QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBLE1BQU1GLFNBQU4sU0FBd0JqQiw4Q0FBeEIsQ0FBOEI7QUFFN0IvQyxhQUFXLEdBQUc7QUFDYixVQUFNMUMsSUFBSSxHQUFHd0YsNkNBQUksQ0FBQzZkLFdBQUwsRUFBYjtBQUNBLFVBQU0vYSxNQUFNLEdBQUcsSUFBSWhELGlEQUFKLENBQWE0bkIsaUVBQWIsRUFBaUJDLDBEQUFqQixDQUFmO0FBQ0EsVUFBTW50QixJQUFOLEVBQVlzSSxNQUFaO0FBRUFBLFVBQU0sQ0FBQ0QsSUFBUDtBQUNBQyxVQUFNLENBQUNtTCxPQUFQLENBQWUsU0FBZixFQUEwQixXQUExQixFQUF1QyxDQUF2QztBQUNBOztBQUdEckwsTUFBSSxDQUFDOUksT0FBRCxFQUFVO0FBQ2IsU0FBS2dKLE1BQUwsQ0FBWUQsSUFBWjtBQUNBL0ksV0FBTyxDQUFDK0ksSUFBUixDQUFhLENBQWI7QUFDQSxVQUFNRCxJQUFOO0FBQ0E7O0FBaEI0Qjs7QUFvQmYxQix3RUFBZixFOzs7Ozs7Ozs7Ozs7QUM3QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQSxNQUFNTSxjQUFOLFNBQTZCdkIsOENBQTdCLENBQW1DO0FBRWxDL0MsYUFBVyxHQUFHO0FBQ2IsVUFBTXllLFNBQVMsR0FBRyxFQUFsQjtBQUNBLFVBQU1FLE9BQU8sR0FBSyxFQUFsQjtBQUNBLFFBQUlsUixLQUFLLEdBQVMsQ0FBbEI7QUFDQSxVQUFNNUgsSUFBSSxHQUFRLEdBQWxCO0FBQ0EsUUFBSTdILENBQUosRUFBTzBQLENBQVA7O0FBRUEsU0FBSTFQLENBQUMsR0FBRyxDQUFDNkgsSUFBVCxFQUFlN0gsQ0FBQyxHQUFHNkgsSUFBbkIsRUFBeUI3SCxDQUFDLElBQUksQ0FBOUIsRUFBaUM7QUFDaEMsV0FBSTBQLENBQUMsR0FBRyxDQUFDN0gsSUFBVCxFQUFlNkgsQ0FBQyxHQUFHN0gsSUFBbkIsRUFBeUI2SCxDQUFDLElBQUksQ0FBOUIsRUFBaUM7QUFDaEMrUSxpQkFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDa0IsQ0FBRCxFQUFJMFAsQ0FBSixFQUFPLENBQVAsQ0FBZjtBQUNBaVIsZUFBTyxDQUFDN2hCLElBQVIsQ0FBYTJRLEtBQWI7QUFDQUEsYUFBSztBQUVMZ1IsaUJBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQ2tCLENBQUQsRUFBSSxDQUFKLEVBQU8wUCxDQUFQLENBQWY7QUFDQWlSLGVBQU8sQ0FBQzdoQixJQUFSLENBQWEyUSxLQUFiO0FBQ0FBLGFBQUs7QUFDTDtBQUNEOztBQUVELFVBQU1uUSxJQUFJLEdBQU8sSUFBSXVGLDZDQUFKLENBQVNILCtDQUFFLENBQUMrWSxNQUFaLENBQWpCO0FBQ0FuZSxRQUFJLENBQUNnaUIsWUFBTCxDQUFrQmIsU0FBbEI7QUFDQW5oQixRQUFJLENBQUNraUIsV0FBTCxDQUFpQmIsT0FBakI7QUFFQSxVQUFNL1ksTUFBTSxHQUFLLElBQUloRCxpREFBSixDQUFhNG5CLCtEQUFiLEVBQWlCQywrREFBakIsQ0FBakI7QUFFQSxVQUFNbnRCLElBQU4sRUFBWXNJLE1BQVo7QUFFQSxTQUFLK2tCLEtBQUwsR0FBZSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFmO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLElBQWY7QUFDQTs7QUFHRGxsQixNQUFJLEdBQUc7QUFDTixTQUFLRSxNQUFMLENBQVlELElBQVo7QUFDQSxTQUFLQyxNQUFMLENBQVltTCxPQUFaLENBQW9CLE9BQXBCLEVBQTZCLFlBQTdCLEVBQTJDLEtBQUs0WixLQUFoRDtBQUNBLFNBQUsva0IsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixTQUFwQixFQUErQixXQUEvQixFQUE0QyxLQUFLNlosT0FBakQ7QUFDQSxTQUFLaGxCLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IsVUFBcEIsRUFBZ0MsTUFBaEMsRUFBd0MsQ0FBQ3JPLCtDQUFFLENBQUNpRixLQUFKLEVBQVdqRiwrQ0FBRSxDQUFDa0YsTUFBZCxDQUF4QyxFQUpNLENBS047O0FBQ0EsVUFBTWxDLElBQU47QUFDQTs7QUF6Q2lDOztBQTRDcEJwQiw2RUFBZixFOzs7Ozs7Ozs7Ozs7QUN0REE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNTCxTQUFOLFNBQXdCbEIsOENBQXhCLENBQThCO0FBRTdCL0MsYUFBVyxHQUFHO0FBQ2IsVUFBTXllLFNBQVMsR0FBRyxFQUFsQjtBQUNBLFVBQU1FLE9BQU8sR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWhCO0FBQ0EsVUFBTUQsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFELEVBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFULENBQWY7QUFDQUQsYUFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUQsRUFBSyxDQUFMLEVBQVMsQ0FBVCxDQUFmO0FBQ0EyaEIsYUFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDLENBQUQsRUFBSyxDQUFMLEVBQVMsQ0FBVCxDQUFmO0FBRUEsVUFBTVEsSUFBSSxHQUFHLElBQUl1Riw2Q0FBSixDQUFTSCwrQ0FBRSxDQUFDNm5CLEtBQVosQ0FBYjtBQUNBanRCLFFBQUksQ0FBQ2dpQixZQUFMLENBQWtCYixTQUFsQjtBQUNBbmhCLFFBQUksQ0FBQ2lpQixjQUFMLENBQW9CYixNQUFwQjtBQUNBcGhCLFFBQUksQ0FBQ2tpQixXQUFMLENBQWlCYixPQUFqQjtBQUVBLFVBQU0vWSxNQUFNLEdBQUcsSUFBSWhELGlEQUFKLENBQWE0bkIsMkRBQWIsRUFBaUJDLGlFQUFqQixDQUFmO0FBRUEsVUFBTW50QixJQUFOLEVBQVlzSSxNQUFaO0FBQ0E7O0FBR0RGLE1BQUksQ0FBQ21sQixVQUFELEVBQWFDLFVBQWIsRUFBeUJILEtBQUssR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFqQyxFQUE0Q0MsT0FBTyxHQUFHLEdBQXRELEVBQTJEO0FBQzlELFNBQUtwbEIsS0FBTCxDQUFXOFosWUFBWCxDQUF3QixDQUFDdUwsVUFBRCxFQUFhQyxVQUFiLENBQXhCOztBQUVBLFNBQUtybEIsT0FBTCxDQUFhRSxJQUFiOztBQUNBLFNBQUtGLE9BQUwsQ0FBYXNMLE9BQWIsQ0FBcUIsT0FBckIsRUFBOEIsTUFBOUIsRUFBc0M0WixLQUF0Qzs7QUFDQSxTQUFLbGxCLE9BQUwsQ0FBYXNMLE9BQWIsQ0FBcUIsU0FBckIsRUFBZ0MsT0FBaEMsRUFBeUM2WixPQUF6Qzs7QUFDQSxVQUFNbGxCLElBQU47QUFDQTs7QUEzQjRCOztBQWlDZnpCLHdFQUFmLEU7Ozs7Ozs7Ozs7OztBQzFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTUksUUFBTixTQUF1QnRCLDhDQUF2QixDQUE2QjtBQUU1Qi9DLGFBQVcsQ0FBQzZGLElBQUksR0FBRyxFQUFSLEVBQVlrbEIsR0FBRyxHQUFHLEVBQWxCLEVBQXNCO0FBQ2hDLFVBQU16dEIsSUFBSSxHQUFHd0YsNkNBQUksQ0FBQzRjLE1BQUwsQ0FBWTdaLElBQVosRUFBa0JrbEIsR0FBbEIsRUFBdUIsSUFBdkIsQ0FBYjtBQUNBLFVBQU1ubEIsTUFBTSxHQUFHLElBQUloRCxpREFBSixDQUFhNG5CLHlEQUFiLEVBQWlCQywwREFBakIsQ0FBZjtBQUVBLFVBQU1udEIsSUFBTixFQUFZc0ksTUFBWjtBQUNBOztBQUVERixNQUFJLENBQUM5SSxPQUFELEVBQVU7QUFDYixTQUFLZ0osTUFBTCxDQUFZRCxJQUFaO0FBQ0EvSSxXQUFPLENBQUMrSSxJQUFSLENBQWEsQ0FBYjtBQUNBLFVBQU1ELElBQU47QUFDQTs7QUFiMkI7O0FBZ0JkckIsdUVBQWYsRTs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNRCxXQUFOLFNBQTBCckIsOENBQTFCLENBQWdDO0FBRS9CL0MsYUFBVyxDQUFDNkYsSUFBSSxHQUFHLEVBQVIsRUFBWTtBQUN0QixVQUFNdkksSUFBSSxHQUFHd0YsNkNBQUksQ0FBQzRkLE1BQUwsQ0FBWTdhLElBQVosQ0FBYjtBQUNBLFVBQU1ELE1BQU0sR0FBRyxJQUFJaEQsaURBQUosQ0FBYTRuQiw0REFBYixFQUFpQkMsNERBQWpCLENBQWY7QUFFQSxVQUFNbnRCLElBQU4sRUFBWXNJLE1BQVo7QUFDQTs7QUFFREYsTUFBSSxDQUFDOUksT0FBRCxFQUFVO0FBQ2IsU0FBS2dKLE1BQUwsQ0FBWUQsSUFBWjtBQUNBL0ksV0FBTyxDQUFDK0ksSUFBUixDQUFhLENBQWI7QUFDQSxVQUFNRCxJQUFOO0FBQ0E7O0FBYjhCOztBQW1CakJ0QiwwRUFBZixFOzs7Ozs7Ozs7Ozs7QUMzQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNTSxJQUFOLENBQVc7QUFFVjFFLGFBQVcsR0FBRztBQUNiLFNBQUtnckIsU0FBTCxHQUFpQixFQUFqQjtBQUNBLFNBQUtDLGdCQUFMLEdBQXdCLEVBQXhCO0FBQ0EsU0FBS0MsSUFBTDtBQUVBLFNBQUtDLFdBQUwsR0FBbUI7QUFBRTNlLE9BQUMsRUFBQyxDQUFKO0FBQU9DLE9BQUMsRUFBQyxDQUFUO0FBQVlDLE9BQUMsRUFBQyxDQUFkO0FBQWlCN1EsT0FBQyxFQUFDO0FBQW5CLEtBQW5CO0FBRUEsV0FBTyxJQUFQO0FBQ0E7O0FBR0R1dkIsZUFBYSxDQUFDNWUsQ0FBQyxHQUFDLENBQUgsRUFBTUMsQ0FBQyxHQUFDLENBQVIsRUFBV0MsQ0FBQyxHQUFDLENBQWIsRUFBZ0I3USxDQUFDLEdBQUMsQ0FBbEIsRUFBcUI7QUFDakMsU0FBS3N2QixXQUFMLENBQWlCM2UsQ0FBakIsR0FBcUJBLENBQXJCO0FBQ0EsU0FBSzJlLFdBQUwsQ0FBaUIxZSxDQUFqQixHQUFxQkEsQ0FBckI7QUFDQSxTQUFLMGUsV0FBTCxDQUFpQnplLENBQWpCLEdBQXFCQSxDQUFyQjtBQUNBLFNBQUt5ZSxXQUFMLENBQWlCdHZCLENBQWpCLEdBQXFCQSxDQUFyQjtBQUNBLFdBQU8sSUFBUDtBQUNBOztBQUdEK1UsWUFBVSxDQUFDNFosRUFBRCxFQUFLQyxFQUFMLEVBQVM7QUFDbEIsUUFBR0QsRUFBRSxZQUFZNW5CLGlEQUFqQixFQUEyQjtBQUMxQixXQUFLNkMsT0FBTCxHQUFlK2tCLEVBQWY7QUFDQSxLQUZELE1BRU87QUFDTixXQUFLL2tCLE9BQUwsR0FBZSxJQUFJN0MsaURBQUosQ0FBYTRuQixFQUFiLEVBQWlCQyxFQUFqQixDQUFmO0FBQ0E7O0FBRUQsV0FBTyxJQUFQO0FBQ0E7O0FBR0RZLFNBQU8sQ0FBQy9sQixLQUFELEVBQVE7QUFDZCxTQUFLRSxLQUFMLEdBQWFGLEtBQWI7QUFDQSxXQUFPLElBQVA7QUFDQTs7QUFHRGdtQixZQUFVLENBQUNyYSxLQUFELEVBQVE7QUFDakIsU0FBS3pMLEtBQUwsR0FBYSxJQUFJM0MsNkNBQUosQ0FBU29PLEtBQVQsQ0FBYjtBQUNBLFdBQU8sSUFBUDtBQUNBOztBQUdEcU8sY0FBWSxDQUFDd0MsY0FBRCxFQUFpQjtBQUM1QixRQUFHLENBQUMsS0FBS3RjLEtBQVQsRUFBZ0I7QUFDZixXQUFLQSxLQUFMLEdBQWEsSUFBSTNDLDZDQUFKLEVBQWI7QUFDQTs7QUFDRCxTQUFLMkMsS0FBTCxDQUFXOFosWUFBWCxDQUF3QndDLGNBQXhCOztBQUNBLFdBQU8sSUFBUDtBQUNBOztBQUdEdkMsZ0JBQWMsQ0FBQzBDLGVBQUQsRUFBa0I7QUFDL0IsUUFBRyxDQUFDLEtBQUt6YyxLQUFULEVBQWdCO0FBQ2YsV0FBS0EsS0FBTCxHQUFhLElBQUkzQyw2Q0FBSixFQUFiO0FBQ0E7O0FBQ0QsU0FBSzJDLEtBQUwsQ0FBVytaLGNBQVgsQ0FBMEIwQyxlQUExQjs7QUFDQSxXQUFPLElBQVA7QUFDQTs7QUFHRHhDLGNBQVksQ0FBQzhMLGFBQUQsRUFBZ0I7QUFDM0IsUUFBRyxDQUFDLEtBQUsvbEIsS0FBVCxFQUFnQjtBQUNmLFdBQUtBLEtBQUwsR0FBYSxJQUFJM0MsNkNBQUosRUFBYjtBQUNBOztBQUNELFNBQUsyQyxLQUFMLENBQVdpYSxZQUFYLENBQXdCOEwsYUFBeEI7O0FBQ0EsV0FBTyxJQUFQO0FBQ0E7O0FBR0QvTCxhQUFXLENBQUNnTSxRQUFELEVBQVc7QUFDckIsUUFBRyxDQUFDLEtBQUtobUIsS0FBVCxFQUFnQjtBQUNmLFdBQUtBLEtBQUwsR0FBYSxJQUFJM0MsNkNBQUosRUFBYjtBQUNBOztBQUNELFNBQUsyQyxLQUFMLENBQVdnYSxXQUFYLENBQXVCZ00sUUFBdkI7O0FBQ0EsV0FBTyxJQUFQO0FBQ0E7O0FBRUR4SSxnQkFBYyxDQUFDL0IsS0FBRCxFQUFRalEsS0FBUixFQUFlO0FBQzVCLFFBQUcsQ0FBQyxLQUFLeEwsS0FBVCxFQUFnQjtBQUNmaEksYUFBTyxDQUFDb1YsSUFBUixDQUFhLDJCQUFiO0FBQ0EsYUFBTyxJQUFQO0FBQ0E7O0FBRUQsU0FBS3BOLEtBQUwsQ0FBV3dkLGNBQVgsQ0FBMEIvQixLQUExQixFQUFpQ2pRLEtBQWpDOztBQUVBLFdBQU8sSUFBUDtBQUNBOztBQUdENFAsWUFBVSxDQUFDNkssVUFBRCxFQUFhemEsS0FBYixFQUFvQjtBQUM3QixRQUFHLENBQUMsS0FBS3hMLEtBQVQsRUFBZ0I7QUFDZixXQUFLQSxLQUFMLEdBQWEsSUFBSTNDLDZDQUFKLEVBQWI7QUFDQTs7QUFDRCxTQUFLMkMsS0FBTCxDQUFXb2IsVUFBWCxDQUFzQjZLLFVBQXRCLEVBQWtDemEsS0FBbEM7O0FBQ0EsV0FBTyxJQUFQO0FBQ0E7O0FBR0RELFNBQU8sQ0FBQ1EsSUFBRCxFQUFPcEYsSUFBUCxFQUFhNUwsS0FBYixFQUFvQjtBQUMxQixTQUFLeXFCLFNBQUwsQ0FBZXpaLElBQWYsSUFBdUI7QUFDdEJwRixVQURzQjtBQUV0QjVMO0FBRnNCLEtBQXZCO0FBS0EsV0FBTyxJQUFQO0FBQ0E7O0FBR0RtckIsZ0JBQWMsQ0FBQ25hLElBQUQsRUFBTzNVLE9BQVAsRUFBZ0I2USxLQUFoQixFQUF1QjtBQUNwQyxRQUFHQSxLQUFLLEtBQUt4TCxTQUFiLEVBQXdCO0FBQ3ZCLFdBQUtncEIsZ0JBQUwsQ0FBc0J4ZCxLQUF0QixJQUErQjtBQUM5QjhELFlBRDhCO0FBRTlCM1U7QUFGOEIsT0FBL0I7QUFJQSxLQUxELE1BS087QUFDTixXQUFLcXVCLGdCQUFMLENBQXNCbnVCLElBQXRCLENBQTJCO0FBQzFCeVUsWUFEMEI7QUFFMUIzVTtBQUYwQixPQUEzQjtBQUlBOztBQUdELFdBQU8sSUFBUDtBQUNBOztBQUdEK3VCLGlCQUFlLENBQUN6aUIsR0FBRCxFQUFNO0FBQ3BCLFNBQUtnaUIsSUFBTCxHQUFZaGlCLEdBQVo7QUFDQSxXQUFPLElBQVA7QUFDQTs7QUFHRHhELE1BQUksR0FBRztBQUNOLFFBQUcsQ0FBQyxLQUFLRCxPQUFULEVBQWtCO0FBQUU7QUFBUzs7QUFDN0IsUUFBRyxDQUFDLEtBQUtELEtBQVQsRUFBZ0I7QUFBRTtBQUFTOztBQUczQixRQUFHLEtBQUswbEIsSUFBUixFQUFjO0FBQ2IsWUFBTTtBQUFFMWUsU0FBRjtBQUFLQyxTQUFMO0FBQVFDLFNBQVI7QUFBVzdRO0FBQVgsVUFBaUIsS0FBS3N2QixXQUE1Qjs7QUFDQSxXQUFLRCxJQUFMLENBQVV2bEIsSUFBVjs7QUFDQWpELHFEQUFFLENBQUNzSSxLQUFILENBQVN3QixDQUFULEVBQVlDLENBQVosRUFBZUMsQ0FBZixFQUFrQjdRLENBQWxCO0FBQ0E7O0FBRUQsU0FBSzRKLE9BQUwsQ0FBYUUsSUFBYjs7QUFDQSxTQUFJLE1BQU1qSSxDQUFWLElBQWUsS0FBS3N0QixTQUFwQixFQUErQjtBQUM5QixZQUFNdnVCLENBQUMsR0FBRyxLQUFLdXVCLFNBQUwsQ0FBZXR0QixDQUFmLENBQVY7O0FBQ0EsV0FBSytILE9BQUwsQ0FBYXNMLE9BQWIsQ0FBcUJyVCxDQUFyQixFQUF3QmpCLENBQUMsQ0FBQzBQLElBQTFCLEVBQWdDMVAsQ0FBQyxDQUFDOEQsS0FBbEM7QUFDQTs7QUFFRCxTQUFLMHFCLGdCQUFMLENBQXNCcnNCLE9BQXRCLENBQThCLENBQUNuQyxDQUFELEVBQUl1QixDQUFKLEtBQVU7QUFDdkMsVUFBR3ZCLENBQUMsS0FBS3dGLFNBQVQsRUFBb0I7QUFDbkIsYUFBS3dELE9BQUwsQ0FBYXNMLE9BQWIsQ0FBcUJ0VSxDQUFDLENBQUM4VSxJQUF2QixFQUE2QixXQUE3QixFQUEwQ3ZULENBQTFDOztBQUNBdkIsU0FBQyxDQUFDRyxPQUFGLENBQVUrSSxJQUFWLENBQWUzSCxDQUFmO0FBQ0E7QUFDRCxLQUxEOztBQU9BMEUsbURBQUUsQ0FBQ2dELElBQUgsQ0FBUSxLQUFLRixLQUFiOztBQUVBLFFBQUcsS0FBSzBsQixJQUFSLEVBQWM7QUFDYixXQUFLQSxJQUFMLENBQVV0aUIsTUFBVjtBQUNBOztBQUVELFdBQU8sSUFBUDtBQUNBOztBQUdELE1BQUloRCxNQUFKLEdBQWE7QUFDWixXQUFPLEtBQUtILE9BQVo7QUFDQTs7QUFFRCxNQUFJbW1CLFdBQUosR0FBa0I7QUFDakIsV0FBTyxLQUFLVixJQUFaO0FBQ0E7O0FBL0tTOztBQWtMSXhtQixtRUFBZixFOzs7Ozs7Ozs7Ozs7QUN4TEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU1ILEtBQU4sQ0FBWTtBQUdYdkUsYUFBVyxDQUFDYyxPQUFPLEdBQUcsRUFBWCxFQUFlO0FBQ3pCLFNBQUsrcUIsU0FBTCxHQUFpQixFQUFqQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUI3YixJQUFJLENBQUNnSSxNQUFMLEVBQXZCO0FBQ0F2VixtREFBRSxDQUFDbVgsbUJBQUg7O0FBRUEsU0FBS3ZULEtBQUwsQ0FBV3hGLE9BQVg7O0FBQ0EsU0FBS3VKLGFBQUwsQ0FBbUJ2SixPQUFuQjs7QUFDQSxTQUFLaXJCLFVBQUwsQ0FBZ0JqckIsT0FBaEI7O0FBRUEsU0FBS2tyQixRQUFMLEdBQWdCOW9CLGtEQUFTLENBQUM4VCxLQUFWLENBQWdCLE1BQUksS0FBS0MsS0FBTCxFQUFwQixDQUFoQjtBQUVBLFNBQUtnVixlQUFMLEdBQXVCbnJCLE9BQU8sQ0FBQ29yQixTQUFSLElBQXFCM3RCLE1BQTVDO0FBQ0FBLFVBQU0sQ0FBQ08sZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0MsTUFBSSxLQUFLcXRCLE1BQUwsRUFBdEM7QUFDQSxHQWhCVSxDQW9CWDs7O0FBRUFDLFFBQU0sR0FBRyxDQUVSOztBQUVEeEYsUUFBTSxHQUFHLENBRVI7O0FBR0R5RixNQUFJLEdBQUc7QUFDTixRQUFHLEtBQUtMLFFBQUwsS0FBa0IsQ0FBQyxDQUF0QixFQUF5QjtBQUFFO0FBQVM7O0FBQ3BDLFNBQUtBLFFBQUwsR0FBZ0I5b0Isa0RBQVMsQ0FBQ29wQixRQUFWLENBQW1CLEtBQUtOLFFBQXhCLENBQWhCO0FBQ0E7O0FBR0RPLE9BQUssR0FBRztBQUNQLFFBQUcsS0FBS1AsUUFBTCxLQUFrQixDQUFDLENBQXRCLEVBQXlCO0FBQ3hCO0FBQ0E7O0FBRUQsU0FBS0EsUUFBTCxHQUFnQjlvQixrREFBUyxDQUFDOFQsS0FBVixDQUFnQixNQUFJLEtBQUtDLEtBQUwsRUFBcEIsQ0FBaEI7QUFDQTs7QUFHRGtWLFFBQU0sQ0FBQ3hrQixLQUFELEVBQVFDLE1BQVIsRUFBZ0I7QUFDckJsRixtREFBRSxDQUFDc1csT0FBSCxDQUFXclIsS0FBSyxJQUFJcEosTUFBTSxDQUFDMGEsVUFBM0IsRUFBdUNyUixNQUFNLElBQUlySixNQUFNLENBQUMyYSxXQUF4RDtBQUNBLFNBQUtzQixNQUFMLENBQVlvUCxjQUFaLENBQTJCbG5CLCtDQUFFLENBQUN3YixXQUE5QjtBQUNBOztBQUdEc08sVUFBUSxDQUFDQyxNQUFELEVBQVM7QUFDaEIsU0FBS1osU0FBTCxDQUFlL3VCLElBQWYsQ0FBb0IydkIsTUFBcEI7QUFDQTs7QUFFRHJPLGFBQVcsQ0FBQ3FPLE1BQUQsRUFBUztBQUNuQixVQUFNaGYsS0FBSyxHQUFHLEtBQUtvZSxTQUFMLENBQWV6bUIsT0FBZixDQUF1QnFuQixNQUF2QixDQUFkOztBQUNBLFFBQUdoZixLQUFLLElBQUksQ0FBQyxDQUFiLEVBQWdCO0FBQUVqUSxhQUFPLENBQUNvVixJQUFSLENBQWEsZ0JBQWI7QUFBZ0M7QUFBUzs7QUFFM0QsU0FBS2laLFNBQUwsQ0FBZWEsTUFBZixDQUFzQmpmLEtBQXRCLEVBQTZCLENBQTdCO0FBQ0EsR0E3RFUsQ0FnRVg7OztBQUVBcEQsZUFBYSxHQUFHLENBRWY7O0FBR0QwaEIsWUFBVSxHQUFHLENBRVo7O0FBR0RZLGlCQUFlLEdBQUc7QUFDakIsUUFBSUMsS0FBSjs7QUFDQSxTQUFJLElBQUk1dUIsQ0FBQyxHQUFDLENBQVYsRUFBYUEsQ0FBQyxHQUFDLEtBQUs2dEIsU0FBTCxDQUFlMXZCLE1BQTlCLEVBQXNDNkIsQ0FBQyxFQUF2QyxFQUEyQztBQUMxQzR1QixXQUFLLEdBQUcsS0FBS2YsU0FBTCxDQUFlN3RCLENBQWYsQ0FBUjtBQUNBNHVCLFdBQUssQ0FBQ0MsUUFBTjtBQUNBOztBQUVEbnFCLG1EQUFFLENBQUMrWCxNQUFILENBQVUsS0FBS3FSLGVBQWY7QUFDQSxHQXBGVSxDQXNGWDs7O0FBRUF4bEIsT0FBSyxDQUFDeEYsT0FBRCxFQUFVO0FBQ2QsU0FBSzBaLE1BQUwsR0FBOEIsSUFBSS9XLGtFQUFKLEVBQTlCO0FBQ0EsU0FBSytXLE1BQUwsQ0FBWWdPLGNBQVosQ0FBMkIsS0FBSzlaLElBQUksQ0FBQ29SLEVBQVYsR0FBZSxHQUExQyxFQUErQ3BkLCtDQUFFLENBQUN3YixXQUFsRCxFQUErRCxHQUEvRCxFQUFvRSxHQUFwRTtBQUNBLFNBQUt2ZCxjQUFMLEdBQStCLElBQUlpRCw2REFBSixDQUFtQixLQUFLNFcsTUFBeEIsRUFBZ0MsS0FBS3lSLGVBQXJDLEVBQXNELEVBQXRELENBQS9CO0FBRUF6dUIsV0FBTyxDQUFDQyxHQUFSLENBQVksU0FBWixFQUF1QnFELE9BQXZCOztBQUNBLFFBQUksQ0FBQ0EsT0FBTyxDQUFDZ3NCLFNBQWIsRUFBd0I7QUFDdkIsV0FBS25zQixjQUFMLENBQW9Cb3NCLE9BQXBCO0FBQ0E7O0FBQ0QsU0FBS3BzQixjQUFMLENBQW9CSyxNQUFwQixDQUEyQlQsS0FBM0IsR0FBbUMsRUFBbkM7QUFFQSxTQUFLeXNCLFdBQUwsR0FBOEIsSUFBSXhwQiw0REFBSixFQUE5QjtBQUNBOztBQUVEeVQsT0FBSyxHQUFHO0FBRVA7QUFDQXZVLG1EQUFFLENBQUNpRyxRQUFILENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0JqRywrQ0FBRSxDQUFDaUYsS0FBckIsRUFBNEJqRiwrQ0FBRSxDQUFDa0YsTUFBL0IsRUFITyxDQUtQOztBQUNBbEYsbURBQUUsQ0FBQzRYLFdBQUgsQ0FBZSxLQUFLRSxNQUFwQjtBQUVBLFNBQUs0UixNQUFMOztBQUNBLFNBQUtPLGVBQUw7O0FBQ0EsU0FBSy9GLE1BQUw7QUFDQTs7QUFFRDlvQixTQUFPLEdBQUc7QUFDVCxTQUFLNkMsY0FBTCxDQUFvQnNzQixVQUFwQjtBQUNBandCLFVBQU0sQ0FBQ2tHLFNBQVAsQ0FBaUJvcEIsUUFBakIsQ0FBMEIsS0FBS04sUUFBL0I7QUFDQXp0QixVQUFNLENBQUMydUIsbUJBQVAsQ0FBMkIsUUFBM0IsRUFBcUMsTUFBSSxLQUFLZixNQUFMLEVBQXpDO0FBQ0E7O0FBdkhVOztBQTRIRzVuQixvRUFBZixFOzs7Ozs7Ozs7Ozs7QUNwSUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBLE1BQU1DLElBQU4sQ0FBVztBQUNWeEUsYUFBVyxDQUFDbXRCLFVBQUQsRUFBYUMsUUFBYixFQUF1QjtBQUNqQyxTQUFLeG5CLE1BQUwsR0FBYyxJQUFJaEQsaURBQUosQ0FBYXVxQixVQUFiLEVBQXlCQyxRQUF6QixDQUFkOztBQUVBLFNBQUs5bUIsS0FBTDtBQUNBLEdBTFMsQ0FRVjs7O0FBRUFBLE9BQUssR0FBRyxDQUVQLENBWlMsQ0FjVjs7O0FBRUFzZ0IsUUFBTSxHQUFHLENBRVI7O0FBRUQ5b0IsU0FBTyxHQUFHO0FBQ1QsVUFBTUMsRUFBRSxHQUFHMkUsK0NBQUUsQ0FBQzNFLEVBQWQ7QUFFQUEsTUFBRSxDQUFDNlMsVUFBSCxDQUFjLElBQWQ7QUFDQTdTLE1BQUUsQ0FBQ3N2QixhQUFILENBQWlCLEtBQUt6bkIsTUFBTCxDQUFZaUwsYUFBN0I7QUFDQTs7QUF6QlM7O0FBNEJJck0sbUVBQWYsRTs7Ozs7Ozs7Ozs7O0FDaENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTUMsTUFBTixTQUFxQkUseURBQXJCLENBQThCO0FBQzdCM0UsYUFBVyxDQUFDbXRCLFVBQUQsRUFBYUMsUUFBYixFQUF1QjtBQUNqQztBQUVBLFNBQUt2QixTQUFMLEdBQWlCLEVBQWpCO0FBQ0EsU0FBS2ptQixNQUFMLEdBQWMsSUFBSWhELGlEQUFKLENBQWF1cUIsVUFBYixFQUF5QkMsUUFBekIsQ0FBZDs7QUFDQSxTQUFLOW1CLEtBQUw7QUFDQSxHQVA0QixDQVU3Qjs7O0FBRUFBLE9BQUssR0FBRyxDQUVQLENBZDRCLENBZ0I3Qjs7O0FBRUFzZ0IsUUFBTSxHQUFHLENBQ1I7O0FBRUQ5b0IsU0FBTyxHQUFHO0FBQ1QsVUFBTUMsRUFBRSxHQUFHMkUsK0NBQUUsQ0FBQzNFLEVBQWQ7QUFFQUEsTUFBRSxDQUFDNlMsVUFBSCxDQUFjLElBQWQ7QUFDQTdTLE1BQUUsQ0FBQ3N2QixhQUFILENBQWlCLEtBQUt6bkIsTUFBTCxDQUFZaUwsYUFBN0I7QUFDQTs7QUExQjRCOztBQStCZnBNLHFFQUFmLEU7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUFBO0FBRUEsTUFBTVgsWUFBTixDQUFtQjtBQUVsQjlELGFBQVcsQ0FBQ3N0QixhQUFhLEdBQUcsS0FBakIsRUFBd0I7QUFDbEMsU0FBS0MsSUFBTCxHQUFZLElBQUlDLGNBQUosRUFBWjs7QUFDQSxTQUFLRCxJQUFMLENBQVV6dUIsZ0JBQVYsQ0FBMkIsTUFBM0IsRUFBb0NMLENBQUQsSUFBSyxLQUFLZ3ZCLFNBQUwsQ0FBZWh2QixDQUFmLENBQXhDOztBQUNBLFNBQUs4dUIsSUFBTCxDQUFVenVCLGdCQUFWLENBQTJCLFVBQTNCLEVBQXdDTCxDQUFELElBQUssS0FBS2l2QixXQUFMLENBQWlCanZCLENBQWpCLENBQTVDOztBQUNBLFFBQUc2dUIsYUFBSCxFQUFrQjtBQUNqQixXQUFLQyxJQUFMLENBQVVJLFlBQVYsR0FBeUIsYUFBekI7QUFDQTtBQUNEOztBQUdEQyxNQUFJLENBQUNqeEIsR0FBRCxFQUFNa3hCLFFBQU4sRUFBZ0I7QUFDbkJyd0IsV0FBTyxDQUFDQyxHQUFSLENBQVksWUFBWixFQUEwQmQsR0FBMUI7QUFDQSxTQUFLbXhCLFNBQUwsR0FBaUJELFFBQWpCOztBQUVBLFNBQUtOLElBQUwsQ0FBVVEsSUFBVixDQUFlLEtBQWYsRUFBc0JweEIsR0FBdEI7O0FBQ0EsU0FBSzR3QixJQUFMLENBQVVTLElBQVY7QUFDQTs7QUFHRFAsV0FBUyxHQUFHO0FBQ1gsU0FBS0ssU0FBTCxDQUFlLEtBQUtQLElBQUwsQ0FBVVUsUUFBekI7QUFDQTs7QUFFRFAsYUFBVztBQUFDO0FBQVEsR0FDbkI7QUFDQTs7QUEzQmlCOztBQThCSjVwQiwyRUFBZixFOzs7Ozs7Ozs7Ozs7QUNoQ0E7QUFBQTtBQUFBO0FBRUE7QUFFQSxNQUFNb3FCLGNBQWMsR0FBRztBQUN0QixRQUFNQyxTQURnQjtBQUV0QixRQUFNM1csVUFGZ0I7QUFHdEIsUUFBTTRXLFVBSGdCO0FBSXRCLFFBQU03TCxXQUpnQjtBQUt0QixRQUFNOEwsV0FMZ0I7QUFNdEIsUUFBTXZmO0FBTmdCLENBQXZCO0FBU0EsTUFBTXdmLFFBQVEsR0FBRztBQUNoQkMsUUFBTSxFQUFFLENBRFE7QUFFaEJDLE1BQUksRUFBRSxDQUZVO0FBR2hCQyxNQUFJLEVBQUUsQ0FIVTtBQUloQkMsTUFBSSxFQUFFLENBSlU7QUFLaEJDLE1BQUksRUFBRSxDQUxVO0FBTWhCQyxNQUFJLEVBQUUsQ0FOVTtBQU9oQkMsTUFBSSxFQUFFO0FBUFUsQ0FBakI7QUFVQSxNQUFNQyxvQkFBb0IsR0FBRztBQUM1QkMsUUFBTSxFQUFFLFNBRG9CO0FBRTVCQyxVQUFRLEVBQUUsaUJBRmtCO0FBRzVCO0FBQ0FDLFlBQVUsRUFBRSxlQUpnQjtBQUs1QjtBQUNBQyxXQUFTLEVBQUUsU0FOaUI7QUFPNUJDLFVBQVEsRUFBRSxRQVBrQjtBQVE1Qm5KLE9BQUssRUFBRTtBQVJxQixDQUE3Qjs7QUFZQSxNQUFNOW9CLEtBQUssR0FBRyxDQUFDa3lCLElBQUQsRUFBT0MsR0FBUCxLQUFlLElBQUlDLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFFN0RKLE1BQUksQ0FBQ0ssTUFBTCxHQUFjO0FBQ2JDLFVBQU0sRUFBQyxFQURNO0FBRWJDLFVBQU0sRUFBQyxFQUZNO0FBR2JsMEIsWUFBUSxFQUFDO0FBSEksR0FBZDs7QUFNQW0wQixvQkFBa0IsQ0FBQ1IsSUFBRCxFQUFPQyxHQUFQLENBQWxCLENBQ0VRLElBREYsQ0FDT0MsVUFEUCxFQUVFRCxJQUZGLENBRVFFLFFBQUQsSUFBWTtBQUNqQlIsV0FBTyxDQUFDUSxRQUFELENBQVA7QUFDQSxHQUpGLEVBS0VDLEtBTEYsQ0FLUXZ4QixDQUFDLElBQUk7QUFDWGpCLFdBQU8sQ0FBQ0MsR0FBUixDQUFZLFFBQVosRUFBc0JnQixDQUF0QjtBQUNBLEdBUEYsRUFSNkQsQ0FnQjdEOztBQUNBLENBakI0QixDQUE3Qjs7QUFzQkEsTUFBTW14QixrQkFBa0IsR0FBRyxDQUFDRyxRQUFELEVBQVdWLEdBQVgsS0FBbUIsSUFBSUMsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUM5RSxRQUFNO0FBQUVTLGVBQUY7QUFBZTNsQjtBQUFmLE1BQTJCeWxCLFFBQWpDO0FBR0FFLGFBQVcsQ0FBQ3J4QixPQUFaLENBQW9CLENBQUNzeEIsY0FBRCxFQUFpQmx5QixDQUFqQixLQUF1QjtBQUMxQyxVQUFNMGUsTUFBTSxHQUFHMlMsR0FBZjtBQUNBYSxrQkFBYyxDQUFDdGlCLElBQWYsR0FBc0I4TyxNQUFNLENBQUMzTixLQUFQLENBQWFtaEIsY0FBYyxDQUFDQyxVQUFmLElBQTZCLENBQTFDLEVBQTZDLENBQUNELGNBQWMsQ0FBQ0MsVUFBZixJQUE2QixDQUE5QixLQUFvQ0QsY0FBYyxDQUFDRSxVQUFmLElBQTZCLENBQWpFLENBQTdDLENBQXRCO0FBQ0EsR0FIRDtBQUlBYixTQUFPLENBQUNRLFFBQUQsQ0FBUDtBQUNBLENBVDZDLENBQTlDOztBQVdBLE1BQU1ELFVBQVUsR0FBSVYsSUFBRCxJQUFVLElBQUlFLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDN0QsUUFBTTtBQUFFRTtBQUFGLE1BQWFOLElBQW5CO0FBQ0FBLE1BQUksQ0FBQ2lCLFVBQUwsR0FBa0IsRUFBbEI7QUFHQVgsUUFBTSxDQUFDOXdCLE9BQVAsQ0FBZSxDQUFDdEIsSUFBRCxFQUFPVSxDQUFQLEtBQWE7QUFDM0IsVUFBTTtBQUFFc3lCO0FBQUYsUUFBaUJoekIsSUFBdkI7QUFFQSxVQUFNaXpCLFFBQVEsR0FBRyxFQUFqQjtBQUVBRCxjQUFVLENBQUMxeEIsT0FBWCxDQUFtQixDQUFDNHhCLGFBQUQsRUFBZ0J4eUIsQ0FBaEIsS0FBc0I7QUFDeEMsWUFBTXl5QixTQUFTLEdBQUcxa0IsTUFBTSxDQUFDMmtCLElBQVAsQ0FBWUYsYUFBYSxDQUFDbFUsVUFBMUIsQ0FBbEI7QUFDQSxVQUFJcVUsT0FBTyxHQUFHLEVBQWQ7QUFFQUYsZUFBUyxDQUFDN3hCLE9BQVYsQ0FBa0IsQ0FBQ2d5QixRQUFELEVBQVc1eUIsQ0FBWCxLQUFpQjtBQUNsQyxjQUFNNnlCLFdBQVcsR0FBR0wsYUFBYSxDQUFDbFUsVUFBZCxDQUF5QnNVLFFBQXpCLENBQXBCO0FBQ0EsY0FBTUUsYUFBYSxHQUFHMUIsSUFBSSxDQUFDMkIsU0FBTCxDQUFlRixXQUFmLENBQXRCO0FBQ0EsY0FBTUcsYUFBYSxHQUFHbEMsb0JBQW9CLENBQUM4QixRQUFELENBQTFDOztBQUNBLFlBQUcsQ0FBQ0ksYUFBSixFQUFtQjtBQUNsQjtBQUNBOztBQUNELFlBQUdKLFFBQVEsS0FBSyxRQUFoQixFQUEwQjtBQUN6QkQsaUJBQU8sQ0FBQ00sV0FBUixHQUFzQixDQUF0QjtBQUNBOztBQUNELFlBQUdMLFFBQVEsQ0FBQ3hyQixPQUFULENBQWlCLFVBQWpCLElBQStCLENBQUMsQ0FBbkMsRUFBc0M7QUFDckN1ckIsaUJBQU8sQ0FBQ08sTUFBUixHQUFpQixDQUFqQjtBQUNBOztBQUdELGNBQU1yckIsSUFBSSxHQUFHeW9CLFFBQVEsQ0FBQ3dDLGFBQWEsQ0FBQzNrQixJQUFmLENBQXJCOztBQUNBLFlBQUlnbEIsY0FBYyxHQUFHQyxnQkFBZ0IsQ0FBQ2hDLElBQUQsRUFBT3lCLFdBQVAsQ0FBckM7O0FBQ0EsWUFBSU0sY0FBYyxZQUFZOUMsV0FBOUIsRUFBMkM7QUFDMUM4Qyx3QkFBYyxHQUFHLElBQUlyaUIsWUFBSixDQUFpQnFpQixjQUFqQixDQUFqQjtBQUNBOztBQUVELFlBQUdQLFFBQVEsS0FBSyxZQUFoQixFQUE4QjtBQUM3QnB6QixpQkFBTyxDQUFDQyxHQUFSLENBQVlvSSxJQUFaLEVBQWtCc3JCLGNBQWxCO0FBQ0E7O0FBRURaLGdCQUFRLENBQUNTLGFBQUQsQ0FBUixHQUEwQjtBQUN6Qnp3QixlQUFLLEVBQUM0d0IsY0FEbUI7QUFFekJ0ckI7QUFGeUIsU0FBMUIsQ0F6QmtDLENBNkJsQztBQUNBLE9BOUJELEVBSndDLENBb0N4Qzs7QUFDQSxVQUFJMnFCLGFBQWEsQ0FBQzdSLE9BQWQsSUFBeUIsSUFBN0IsRUFBbUM7QUFDbEMsY0FBTXdTLGNBQWMsR0FBR0MsZ0JBQWdCLENBQUNoQyxJQUFELEVBQU9vQixhQUFhLENBQUM3UixPQUFyQixFQUE4QixJQUE5QixDQUF2Qzs7QUFDQTRSLGdCQUFRLENBQUM1UixPQUFULEdBQW1CO0FBQ2xCcGUsZUFBSyxFQUFDNHdCLGNBRFk7QUFFbEJ0ckIsY0FBSSxFQUFDO0FBRmEsU0FBbkI7QUFJQTs7QUFFRCxZQUFNd3JCLENBQUMsR0FBRyxJQUFJeHVCLDZDQUFKLEVBQVY7O0FBRUEsV0FBSSxNQUFNbkYsQ0FBVixJQUFlNnlCLFFBQWYsRUFBeUI7QUFDeEIsY0FBTTNpQixJQUFJLEdBQUcyaUIsUUFBUSxDQUFDN3lCLENBQUQsQ0FBckI7O0FBQ0EsWUFBR0EsQ0FBQyxLQUFLLFNBQVQsRUFBb0I7QUFDbkIyekIsV0FBQyxDQUFDNU8saUJBQUYsQ0FBb0I3VSxJQUFJLENBQUNyTixLQUF6QixFQUFnQzdDLENBQWhDLEVBQW1Da1EsSUFBSSxDQUFDL0gsSUFBeEM7QUFDQSxTQUZELE1BRU87QUFDTndyQixXQUFDLENBQUM3UixXQUFGLENBQWM1UixJQUFJLENBQUNyTixLQUFuQjtBQUNBO0FBQ0Q7O0FBRUQ2dUIsVUFBSSxDQUFDSyxNQUFMLENBQVlDLE1BQVosQ0FBbUI1eUIsSUFBbkIsQ0FBd0J1MEIsQ0FBeEI7O0FBQ0EsVUFBSWIsYUFBYSxDQUFDYyxRQUFsQixFQUE0QjtBQUMzQjl6QixlQUFPLENBQUNDLEdBQVIsQ0FBWSxhQUFaLEVBQTJCMnhCLElBQUksQ0FBQ0ssTUFBaEMsRUFBd0NlLGFBQWEsQ0FBQ2MsUUFBdEQ7QUFDQSxjQUFNQSxRQUFRLEdBQUdsQyxJQUFJLENBQUNLLE1BQUwsQ0FBWThCLFNBQVosQ0FBc0JmLGFBQWEsQ0FBQ2MsUUFBcEMsQ0FBakI7QUFDQUQsU0FBQyxDQUFDQyxRQUFGLEdBQWFBLFFBQWI7QUFDQVgsZUFBTyxHQUFHYSxZQUFZLENBQUNiLE9BQUQsRUFBVVUsQ0FBQyxDQUFDQyxRQUFGLENBQVdYLE9BQXJCLENBQXRCO0FBRUFVLFNBQUMsQ0FBQ1YsT0FBRixHQUFZQSxPQUFaO0FBRUEsY0FBTS9xQixNQUFNLEdBQUc2ckIsT0FBTyxDQUFDOXpCLEdBQVIsQ0FBWWlILFVBQVUsQ0FBQzhzQixRQUF2QixFQUFpQzlzQixVQUFVLENBQUMrc0IsUUFBNUMsRUFBc0RoQixPQUF0RCxDQUFmO0FBRUEsY0FBTTtBQUNMaUIsd0JBREs7QUFFTEMsdUJBRks7QUFHTEMsMEJBSEs7QUFJTEM7QUFKSyxZQUtGVCxRQUxKO0FBT0EsY0FBTTtBQUNMVSwwQkFESztBQUVMQztBQUZLLFlBR0ZGLG9CQUhKO0FBS0EsY0FBTUcsUUFBUSxHQUFHO0FBQ2hCQyx5QkFBZSxFQUFDUCxjQUFjLElBQUksQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FEbEI7QUFFaEJRLG9CQUFVLEVBQUNMLG9CQUFvQixDQUFDTSxlQUFyQixJQUF3QyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FGbkM7QUFHaEJDLG9CQUFVLEVBQUNQLG9CQUFvQixDQUFDUSxlQUFyQixJQUF3QyxDQUhuQztBQUloQkMsbUJBQVMsRUFBQ1Qsb0JBQW9CLENBQUNVLGNBQXJCLElBQXVDLENBSmpDO0FBS2hCQywwQkFBZ0IsRUFBQyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FMRDtBQU1oQkMsdUJBQWEsRUFBQyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FORTtBQU9oQkMsMEJBQWdCLEVBQUMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBUEQ7QUFRaEJDLHlCQUFlLEVBQUMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FSQTtBQVNoQkMscUJBQVcsRUFBQyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQVRJO0FBVWhCQyxnQkFBTSxFQUFDO0FBVlMsU0FBakI7O0FBYUEsWUFBSWYsZ0JBQUosRUFBc0I7QUFDckJFLGtCQUFRLENBQUNjLFNBQVQsR0FBcUJoQixnQkFBZ0IsQ0FBQ3hyQixTQUF0QztBQUNBOztBQUVELFlBQUl5ckIsd0JBQUosRUFBOEI7QUFDN0JDLGtCQUFRLENBQUNlLHFCQUFULEdBQWlDaEIsd0JBQXdCLENBQUN6ckIsU0FBMUQ7QUFDQTs7QUFFRCxZQUFJcXJCLGFBQUosRUFBbUI7QUFDbEJLLGtCQUFRLENBQUNnQixZQUFULEdBQXdCckIsYUFBYSxDQUFDbkgsS0FBZCxJQUF1QixDQUEvQztBQUNBd0gsa0JBQVEsQ0FBQ2lCLFVBQVQsR0FBc0J0QixhQUFhLENBQUNyckIsU0FBcEM7QUFDQTs7QUFFRCxZQUFJc3JCLGdCQUFKLEVBQXNCO0FBQ3JCSSxrQkFBUSxDQUFDa0IsTUFBVCxHQUFrQnRCLGdCQUFnQixDQUFDdHJCLFNBQW5DO0FBQ0EwckIsa0JBQVEsQ0FBQ21CLGtCQUFULEdBQThCdkIsZ0JBQWdCLENBQUN3QixRQUFqQixJQUE2QixDQUEzRDtBQUNBOztBQUVEMXRCLGNBQU0sQ0FBQ0QsSUFBUDtBQUNBQyxjQUFNLENBQUNtTCxPQUFQLENBQWVtaEIsUUFBZjtBQUdBYixTQUFDLENBQUNDLFFBQUYsQ0FBVzFyQixNQUFYLEdBQW9CQSxNQUFwQjtBQUNBeXJCLFNBQUMsQ0FBQ0MsUUFBRixDQUFXWSxRQUFYLEdBQXNCQSxRQUF0QjtBQUNBOztBQUVEOUMsVUFBSSxDQUFDaUIsVUFBTCxDQUFnQnZ6QixJQUFoQixDQUFxQnl6QixRQUFyQjtBQUNBLEtBdkhEO0FBd0hBLEdBN0hEO0FBK0hBaEIsU0FBTyxDQUFDSCxJQUFELENBQVA7QUFDQSxDQXJJNEIsQ0FBN0I7O0FBdUlBLE1BQU1nQyxnQkFBZ0IsR0FBRyxDQUFDaEMsSUFBRCxFQUFPeUIsV0FBUCxFQUFvQjBDLFNBQVMsR0FBRyxLQUFoQyxLQUEwQztBQUNsRSxRQUFNQyxZQUFZLEdBQUdwRSxJQUFJLENBQUMyQixTQUFMLENBQWVGLFdBQWYsQ0FBckI7QUFDQSxRQUFNblUsTUFBTSxHQUFHMFMsSUFBSSxDQUFDYSxXQUFMLENBQWlCdUQsWUFBWSxDQUFDQyxVQUE5QixFQUEwQzdsQixJQUF6RDtBQUNBLFFBQU11aUIsVUFBVSxHQUFHcUQsWUFBWSxDQUFDckQsVUFBYixJQUEyQixDQUE5QztBQUNBLFFBQU11RCxTQUFTLEdBQUd4RixjQUFjLENBQUNzRixZQUFZLENBQUNHLGFBQWQsQ0FBZCxJQUE4QzdrQixZQUFoRTtBQUNBLE1BQUlqSixJQUFJLEdBQUd5b0IsUUFBUSxDQUFDa0YsWUFBWSxDQUFDcm5CLElBQWQsQ0FBbkI7O0FBQ0EsTUFBSXRHLElBQUksSUFBSSxJQUFSLElBQWdCMHRCLFNBQXBCLEVBQStCO0FBQzlCMXRCLFFBQUksR0FBRyxDQUFQO0FBQ0E7O0FBQ0QsTUFBSSt0QixHQUFHLEdBQUcsSUFBSUYsU0FBSixDQUFjaFgsTUFBZCxFQUFzQnlULFVBQXRCLEVBQWtDdHFCLElBQUksR0FBRzJ0QixZQUFZLENBQUMvUyxLQUF0RCxDQUFWO0FBQ0EsUUFBTW9ULGlCQUFpQixHQUFHTCxZQUFZLENBQUNuYSxVQUFiLElBQTJCbWEsWUFBWSxDQUFDbmEsVUFBYixDQUF3Qiw0QkFBeEIsQ0FBckQ7O0FBQ0EsTUFBSXdhLGlCQUFKLEVBQXVCO0FBQ3RCLFVBQU1DLFVBQVUsR0FBRyxJQUFJaGxCLFlBQUosQ0FBaUJqSixJQUFJLEdBQUcydEIsWUFBWSxDQUFDL1MsS0FBckMsQ0FBbkI7QUFDQSxVQUFNc1QsWUFBWSxHQUFHRixpQkFBaUIsQ0FBQ0UsWUFBdkM7QUFDQSxVQUFNQyxZQUFZLEdBQUcsSUFBSXRjLEtBQUosQ0FBVTdSLElBQVYsQ0FBckI7QUFDQSxVQUFNb3VCLFdBQVcsR0FBRyxJQUFJdmMsS0FBSixDQUFVN1IsSUFBVixDQUFwQjs7QUFDQSxTQUFLLElBQUlxdUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3J1QixJQUFwQixFQUEwQnF1QixDQUFDLEVBQTNCLEVBQStCO0FBQzlCRixrQkFBWSxDQUFDRSxDQUFELENBQVosR0FBa0JILFlBQVksQ0FBQ2x1QixJQUFJLElBQUlBLElBQUksR0FBRyxDQUFYLENBQUosR0FBb0JxdUIsQ0FBckIsQ0FBOUI7QUFDQUQsaUJBQVcsQ0FBQ0MsQ0FBRCxDQUFYLEdBQWlCSCxZQUFZLENBQUNHLENBQUMsSUFBSXJ1QixJQUFJLEdBQUcsQ0FBWCxDQUFELEdBQWlCcXVCLENBQWxCLENBQTdCO0FBQ0E7O0FBQ0QsU0FBSyxJQUFJbDJCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd3MUIsWUFBWSxDQUFDL1MsS0FBakMsRUFBd0N6aUIsQ0FBQyxFQUF6QyxFQUE2QztBQUM1QyxXQUFLLElBQUlrMkIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3J1QixJQUFwQixFQUEwQnF1QixDQUFDLEVBQTNCLEVBQStCO0FBQzlCSixrQkFBVSxDQUFDOTFCLENBQUMsR0FBRzZILElBQUosR0FBV3F1QixDQUFaLENBQVYsR0FBMkJOLEdBQUcsQ0FBQzUxQixDQUFDLEdBQUc2SCxJQUFKLEdBQVdxdUIsQ0FBWixDQUFILEdBQW9CRCxXQUFXLENBQUNDLENBQUQsQ0FBL0IsR0FBcUNGLFlBQVksQ0FBQ0UsQ0FBRCxDQUE1RTtBQUNBO0FBQ0Q7O0FBRUROLE9BQUcsR0FBR0UsVUFBTjtBQUNBLEdBM0JpRSxDQTZCbEU7OztBQUVBLFNBQU9GLEdBQVA7QUFDQSxDQWhDRDs7QUFrQ2U7QUFDZDEyQjtBQURjLENBQWYsRTs7Ozs7Ozs7Ozs7O0FDN09BO0FBQUE7QUFBQTtBQUFBO0FBRWE7O0FBRWI7QUFDQTs7QUFFQSxNQUFNRCxTQUFOLFNBQXdCNkcscURBQXhCLENBQXFDO0FBQ3BDOUQsYUFBVyxHQUFHO0FBQ2IsVUFBTSxJQUFOO0FBQ0E7O0FBRUQ5QyxPQUFLLENBQUNnUixZQUFELEVBQWU7QUFDbkIsV0FBT2ltQixnRUFBUyxDQUFDam1CLFlBQUQsQ0FBaEI7QUFDQTs7QUFFRHVmLFdBQVMsR0FBRztBQUNYLFVBQU1oeEIsQ0FBQyxHQUFHLEtBQUtTLEtBQUwsQ0FBVyxLQUFLcXdCLElBQUwsQ0FBVVUsUUFBckIsQ0FBVjs7QUFDQSxRQUFHLEtBQUtILFNBQVIsRUFBbUI7QUFDbEIsV0FBS0EsU0FBTCxDQUFlcnhCLENBQWY7QUFDQTtBQUNEOztBQWRtQzs7QUFtQnJDUSxTQUFTLENBQUNDLEtBQVYsR0FBa0IsVUFBVWdSLFlBQVYsRUFBd0I7QUFDekMsU0FBT2ltQixnRUFBUyxDQUFDam1CLFlBQUQsQ0FBaEI7QUFDQSxDQUZEOztBQUllalIsd0VBQWYsRTs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQUE7QUFBQTtBQUFBO0FBRWE7O0FBRWI7QUFDQTs7QUFFQSxNQUFNTSxTQUFOLFNBQXdCdUcscURBQXhCLENBQXFDO0FBRXBDOHBCLE1BQUksQ0FBQ2p4QixHQUFELEVBQU1reEIsUUFBTixFQUFnQjFTLFFBQVEsR0FBRyxDQUEzQixFQUE4QjtBQUNqQyxTQUFLa0gsU0FBTCxHQUFpQmxILFFBQWpCO0FBQ0EsVUFBTXlTLElBQU4sQ0FBV2p4QixHQUFYLEVBQWdCa3hCLFFBQWhCO0FBQ0E7O0FBRURKLFdBQVMsR0FBRztBQUNYLFNBQUsyRyxRQUFMLENBQWMsS0FBSzdHLElBQUwsQ0FBVVUsUUFBeEI7QUFDQTs7QUFFRG1HLFVBQVEsQ0FBQ0MsTUFBRCxFQUFTO0FBQ2hCLFVBQU0va0IsS0FBSyxHQUFHK2tCLE1BQU0sQ0FBQ240QixLQUFQLENBQWEsSUFBYixDQUFkO0FBRUEsVUFBTXVpQixTQUFTLEdBQU0sRUFBckI7QUFDQSxVQUFNQyxNQUFNLEdBQVMsRUFBckI7QUFDQSxVQUFNNFYsWUFBWSxHQUFHLEVBQXJCO0FBQ0EsVUFBTXRTLFFBQVEsR0FBTyxFQUFyQjtBQUNBLFVBQU1wRCxPQUFPLEdBQVEsRUFBckI7QUFDQSxVQUFNMlYsR0FBRyxHQUFZLEVBQXJCO0FBQ0EsVUFBTTVWLE9BQU8sR0FBUSxFQUFyQjtBQUNBLFFBQUk4QixLQUFLLEdBQVUsQ0FBbkI7QUFDQSxRQUFJN2dCLE1BQUosQ0FYZ0IsQ0FhaEI7O0FBQ0EsVUFBTTQwQixhQUFhLEdBQUcscUVBQXRCLENBZGdCLENBZ0JoQjs7QUFDQSxVQUFNQyxhQUFhLEdBQUcsc0VBQXRCLENBakJnQixDQW1CaEI7O0FBQ0EsVUFBTUMsU0FBUyxHQUFHLGdEQUFsQixDQXBCZ0IsQ0FzQmhCOztBQUNBLFVBQU1DLFlBQVksR0FBRyx3Q0FBckIsQ0F2QmdCLENBeUJoQjs7QUFDQSxVQUFNQyxZQUFZLEdBQUcsb0ZBQXJCLENBMUJnQixDQTRCaEI7O0FBQ0EsVUFBTUMsWUFBWSxHQUFHLHdIQUFyQixDQTdCZ0IsQ0ErQmhCOztBQUNBLFVBQU1DLFlBQVksR0FBRyw0RkFBckI7O0FBR0EsYUFBU0MsZ0JBQVQsQ0FBMEJ4MEIsS0FBMUIsRUFBaUM7QUFDaEMsWUFBTWtOLEtBQUssR0FBR3VuQixRQUFRLENBQUN6MEIsS0FBRCxDQUF0QjtBQUNBLGFBQU8sQ0FBQ2tOLEtBQUssSUFBSSxDQUFULEdBQWFBLEtBQUssR0FBRyxDQUFyQixHQUF5QkEsS0FBSyxHQUFHdVUsUUFBUSxDQUFDN2xCLE1BQVQsR0FBa0IsQ0FBcEQsSUFBeUQsQ0FBaEU7QUFDQTs7QUFFRCxhQUFTODRCLGdCQUFULENBQTBCMTBCLEtBQTFCLEVBQWlDO0FBQ2hDLFlBQU1rTixLQUFLLEdBQUd1bkIsUUFBUSxDQUFDejBCLEtBQUQsQ0FBdEI7QUFDQSxhQUFPLENBQUNrTixLQUFLLElBQUksQ0FBVCxHQUFhQSxLQUFLLEdBQUcsQ0FBckIsR0FBeUJBLEtBQUssR0FBR21SLE9BQU8sQ0FBQ3ppQixNQUFSLEdBQWlCLENBQW5ELElBQXdELENBQS9EO0FBQ0E7O0FBRUQsYUFBUys0QixZQUFULENBQXNCMzBCLEtBQXRCLEVBQTZCO0FBQzVCLFlBQU1rTixLQUFLLEdBQUd1bkIsUUFBUSxDQUFDejBCLEtBQUQsQ0FBdEI7QUFDQSxhQUFPLENBQUNrTixLQUFLLElBQUksQ0FBVCxHQUFhQSxLQUFLLEdBQUcsQ0FBckIsR0FBeUJBLEtBQUssR0FBRzhtQixHQUFHLENBQUNwNEIsTUFBSixHQUFhLENBQS9DLElBQW9ELENBQTNEO0FBQ0E7O0FBR0QsYUFBU2c1QixTQUFULENBQW1CdDVCLENBQW5CLEVBQXNCNlEsQ0FBdEIsRUFBeUJrWSxDQUF6QixFQUE0QjtBQUMzQm5HLGVBQVMsQ0FBQzNoQixJQUFWLENBQWUsQ0FBQ2tsQixRQUFRLENBQUNubUIsQ0FBRCxDQUFULEVBQWNtbUIsUUFBUSxDQUFDbm1CLENBQUMsR0FBRyxDQUFMLENBQXRCLEVBQStCbW1CLFFBQVEsQ0FBQ25tQixDQUFDLEdBQUcsQ0FBTCxDQUF2QyxDQUFmO0FBQ0E0aUIsZUFBUyxDQUFDM2hCLElBQVYsQ0FBZSxDQUFDa2xCLFFBQVEsQ0FBQ3RWLENBQUQsQ0FBVCxFQUFjc1YsUUFBUSxDQUFDdFYsQ0FBQyxHQUFHLENBQUwsQ0FBdEIsRUFBK0JzVixRQUFRLENBQUN0VixDQUFDLEdBQUcsQ0FBTCxDQUF2QyxDQUFmO0FBQ0ErUixlQUFTLENBQUMzaEIsSUFBVixDQUFlLENBQUNrbEIsUUFBUSxDQUFDNEMsQ0FBRCxDQUFULEVBQWM1QyxRQUFRLENBQUM0QyxDQUFDLEdBQUcsQ0FBTCxDQUF0QixFQUErQjVDLFFBQVEsQ0FBQzRDLENBQUMsR0FBRyxDQUFMLENBQXZDLENBQWY7QUFFQWpHLGFBQU8sQ0FBQzdoQixJQUFSLENBQWEyakIsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUF6QjtBQUNBOUIsYUFBTyxDQUFDN2hCLElBQVIsQ0FBYTJqQixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQXpCO0FBQ0E5QixhQUFPLENBQUM3aEIsSUFBUixDQUFhMmpCLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBekI7QUFFQUEsV0FBSztBQUNMOztBQUdELGFBQVMyVSxLQUFULENBQWV2NUIsQ0FBZixFQUFrQjZRLENBQWxCLEVBQXFCa1ksQ0FBckIsRUFBd0I7QUFDdkJsRyxZQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUN5M0IsR0FBRyxDQUFDMTRCLENBQUQsQ0FBSixFQUFTMDRCLEdBQUcsQ0FBQzE0QixDQUFDLEdBQUcsQ0FBTCxDQUFaLENBQVo7QUFDQTZpQixZQUFNLENBQUM1aEIsSUFBUCxDQUFZLENBQUN5M0IsR0FBRyxDQUFDN25CLENBQUQsQ0FBSixFQUFTNm5CLEdBQUcsQ0FBQzduQixDQUFDLEdBQUcsQ0FBTCxDQUFaLENBQVo7QUFDQWdTLFlBQU0sQ0FBQzVoQixJQUFQLENBQVksQ0FBQ3kzQixHQUFHLENBQUMzUCxDQUFELENBQUosRUFBUzJQLEdBQUcsQ0FBQzNQLENBQUMsR0FBRyxDQUFMLENBQVosQ0FBWjtBQUNBOztBQUdELGFBQVN5USxTQUFULENBQW1CeDVCLENBQW5CLEVBQXNCNlEsQ0FBdEIsRUFBeUJrWSxDQUF6QixFQUE0QjtBQUMzQjBQLGtCQUFZLENBQUN4M0IsSUFBYixDQUFrQixDQUFDOGhCLE9BQU8sQ0FBQy9pQixDQUFELENBQVIsRUFBYStpQixPQUFPLENBQUMvaUIsQ0FBQyxHQUFHLENBQUwsQ0FBcEIsRUFBNkIraUIsT0FBTyxDQUFDL2lCLENBQUMsR0FBRyxDQUFMLENBQXBDLENBQWxCO0FBQ0F5NEIsa0JBQVksQ0FBQ3gzQixJQUFiLENBQWtCLENBQUM4aEIsT0FBTyxDQUFDbFMsQ0FBRCxDQUFSLEVBQWFrUyxPQUFPLENBQUNsUyxDQUFDLEdBQUcsQ0FBTCxDQUFwQixFQUE2QmtTLE9BQU8sQ0FBQ2xTLENBQUMsR0FBRyxDQUFMLENBQXBDLENBQWxCO0FBQ0E0bkIsa0JBQVksQ0FBQ3gzQixJQUFiLENBQWtCLENBQUM4aEIsT0FBTyxDQUFDZ0csQ0FBRCxDQUFSLEVBQWFoRyxPQUFPLENBQUNnRyxDQUFDLEdBQUcsQ0FBTCxDQUFwQixFQUE2QmhHLE9BQU8sQ0FBQ2dHLENBQUMsR0FBRyxDQUFMLENBQXBDLENBQWxCO0FBQ0E7O0FBRUQsYUFBUzBRLE9BQVQsQ0FBaUJ6NUIsQ0FBakIsRUFBb0I2USxDQUFwQixFQUF1QmtZLENBQXZCLEVBQTBCckUsQ0FBMUIsRUFBOEJnVixFQUE5QixFQUFrQ0MsRUFBbEMsRUFBc0NDLEVBQXRDLEVBQTBDQyxFQUExQyxFQUErQ0MsRUFBL0MsRUFBbURDLEVBQW5ELEVBQXVEQyxFQUF2RCxFQUEyREMsRUFBM0QsRUFBK0Q7QUFDOUQsVUFBSXJSLEVBQUUsR0FBR3NRLGdCQUFnQixDQUFDbDVCLENBQUQsQ0FBekI7QUFDQSxVQUFJNm9CLEVBQUUsR0FBR3FRLGdCQUFnQixDQUFDcm9CLENBQUQsQ0FBekI7QUFDQSxVQUFJaVksRUFBRSxHQUFHb1EsZ0JBQWdCLENBQUNuUSxDQUFELENBQXpCO0FBQ0EsVUFBSWpwQixFQUFKOztBQUVBLFVBQUk0a0IsQ0FBQyxLQUFLdGUsU0FBVixFQUFxQjtBQUVwQmt6QixpQkFBUyxDQUFDMVEsRUFBRCxFQUFLQyxFQUFMLEVBQVNDLEVBQVQsQ0FBVDtBQUVBLE9BSkQsTUFJTztBQUVOaHBCLFVBQUUsR0FBR281QixnQkFBZ0IsQ0FBQ3hVLENBQUQsQ0FBckI7QUFFQTRVLGlCQUFTLENBQUMxUSxFQUFELEVBQUtDLEVBQUwsRUFBUy9vQixFQUFULENBQVQ7QUFDQXc1QixpQkFBUyxDQUFDelEsRUFBRCxFQUFLQyxFQUFMLEVBQVNocEIsRUFBVCxDQUFUO0FBRUE7O0FBR0QsVUFBSTQ1QixFQUFFLEtBQUt0ekIsU0FBWCxFQUFzQjtBQUVyQndpQixVQUFFLEdBQUd5USxZQUFZLENBQUNLLEVBQUQsQ0FBakI7QUFDQTdRLFVBQUUsR0FBR3dRLFlBQVksQ0FBQ00sRUFBRCxDQUFqQjtBQUNBN1EsVUFBRSxHQUFHdVEsWUFBWSxDQUFDTyxFQUFELENBQWpCOztBQUVBLFlBQUlsVixDQUFDLEtBQUt0ZSxTQUFWLEVBQXFCO0FBRXBCbXpCLGVBQUssQ0FBQzNRLEVBQUQsRUFBS0MsRUFBTCxFQUFTQyxFQUFULENBQUw7QUFFQSxTQUpELE1BSU87QUFFTmhwQixZQUFFLEdBQUd1NUIsWUFBWSxDQUFDUSxFQUFELENBQWpCO0FBRUFOLGVBQUssQ0FBQzNRLEVBQUQsRUFBS0MsRUFBTCxFQUFTL29CLEVBQVQsQ0FBTDtBQUNBeTVCLGVBQUssQ0FBQzFRLEVBQUQsRUFBS0MsRUFBTCxFQUFTaHBCLEVBQVQsQ0FBTDtBQUVBO0FBRUQ7O0FBRUQsVUFBSWc2QixFQUFFLEtBQUsxekIsU0FBWCxFQUFzQjtBQUVyQndpQixVQUFFLEdBQUd3USxnQkFBZ0IsQ0FBQ1UsRUFBRCxDQUFyQjtBQUNBalIsVUFBRSxHQUFHdVEsZ0JBQWdCLENBQUNXLEVBQUQsQ0FBckI7QUFDQWpSLFVBQUUsR0FBR3NRLGdCQUFnQixDQUFDWSxFQUFELENBQXJCOztBQUVBLFlBQUl0VixDQUFDLEtBQUt0ZSxTQUFWLEVBQXFCO0FBRXBCb3pCLG1CQUFTLENBQUM1USxFQUFELEVBQUtDLEVBQUwsRUFBU0MsRUFBVCxDQUFUO0FBRUEsU0FKRCxNQUlPO0FBRU5ocEIsWUFBRSxHQUFHczVCLGdCQUFnQixDQUFDYSxFQUFELENBQXJCO0FBRUFULG1CQUFTLENBQUM1USxFQUFELEVBQUtDLEVBQUwsRUFBUy9vQixFQUFULENBQVQ7QUFDQTA1QixtQkFBUyxDQUFDM1EsRUFBRCxFQUFLQyxFQUFMLEVBQVNocEIsRUFBVCxDQUFUO0FBRUE7QUFFRDtBQUNEOztBQUdELFNBQUssSUFBSXFDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdzUixLQUFLLENBQUNuVCxNQUExQixFQUFrQzZCLENBQUMsRUFBbkMsRUFBd0M7QUFDdkMsVUFBSSszQixJQUFJLEdBQUd6bUIsS0FBSyxDQUFDdFIsQ0FBRCxDQUFoQjtBQUNBKzNCLFVBQUksR0FBR0EsSUFBSSxDQUFDQyxJQUFMLEVBQVA7O0FBRUEsVUFBSUQsSUFBSSxDQUFDNTVCLE1BQUwsS0FBZ0IsQ0FBaEIsSUFBcUI0NUIsSUFBSSxDQUFDRSxNQUFMLENBQVksQ0FBWixNQUFtQixHQUE1QyxFQUFpRDtBQUVoRDtBQUVBLE9BSkQsTUFJTyxJQUFJLENBQUNyMkIsTUFBTSxHQUFHNDBCLGFBQWEsQ0FBQzBCLElBQWQsQ0FBbUJILElBQW5CLENBQVYsTUFBd0MsSUFBNUMsRUFBa0Q7QUFFeEQvVCxnQkFBUSxDQUFDbGxCLElBQVQsQ0FDQ3E1QixVQUFVLENBQUN2MkIsTUFBTSxDQUFDLENBQUQsQ0FBUCxDQURYLEVBRUN1MkIsVUFBVSxDQUFDdjJCLE1BQU0sQ0FBQyxDQUFELENBQVAsQ0FGWCxFQUdDdTJCLFVBQVUsQ0FBQ3YyQixNQUFNLENBQUMsQ0FBRCxDQUFQLENBSFg7QUFNQSxPQVJNLE1BUUEsSUFBSSxDQUFDQSxNQUFNLEdBQUc2MEIsYUFBYSxDQUFDeUIsSUFBZCxDQUFtQkgsSUFBbkIsQ0FBVixNQUF3QyxJQUE1QyxFQUFrRDtBQUV4RG5YLGVBQU8sQ0FBQzloQixJQUFSLENBQ0NxNUIsVUFBVSxDQUFDdjJCLE1BQU0sQ0FBQyxDQUFELENBQVAsQ0FEWCxFQUVDdTJCLFVBQVUsQ0FBQ3YyQixNQUFNLENBQUMsQ0FBRCxDQUFQLENBRlgsRUFHQ3UyQixVQUFVLENBQUN2MkIsTUFBTSxDQUFDLENBQUQsQ0FBUCxDQUhYO0FBTUEsT0FSTSxNQVFBLElBQUksQ0FBQ0EsTUFBTSxHQUFHODBCLFNBQVMsQ0FBQ3dCLElBQVYsQ0FBZUgsSUFBZixDQUFWLE1BQW9DLElBQXhDLEVBQThDO0FBRXBEeEIsV0FBRyxDQUFDejNCLElBQUosQ0FDQ3E1QixVQUFVLENBQUN2MkIsTUFBTSxDQUFDLENBQUQsQ0FBUCxDQURYLEVBRUN1MkIsVUFBVSxDQUFDdjJCLE1BQU0sQ0FBQyxDQUFELENBQVAsQ0FGWDtBQUtBLE9BUE0sTUFPQSxJQUFJLENBQUNBLE1BQU0sR0FBRyswQixZQUFZLENBQUN1QixJQUFiLENBQWtCSCxJQUFsQixDQUFWLE1BQXVDLElBQTNDLEVBQWlEO0FBRXZEVCxlQUFPLENBQ04xMUIsTUFBTSxDQUFDLENBQUQsQ0FEQSxFQUNLQSxNQUFNLENBQUMsQ0FBRCxDQURYLEVBQ2dCQSxNQUFNLENBQUMsQ0FBRCxDQUR0QixFQUMyQkEsTUFBTSxDQUFDLENBQUQsQ0FEakMsQ0FBUDtBQUlBLE9BTk0sTUFNQSxJQUFJLENBQUNBLE1BQU0sR0FBR2cxQixZQUFZLENBQUNzQixJQUFiLENBQWtCSCxJQUFsQixDQUFWLE1BQXVDLElBQTNDLEVBQWlEO0FBRXZEVCxlQUFPLENBQ04xMUIsTUFBTSxDQUFDLENBQUQsQ0FEQSxFQUNLQSxNQUFNLENBQUMsQ0FBRCxDQURYLEVBQ2dCQSxNQUFNLENBQUMsQ0FBRCxDQUR0QixFQUMyQkEsTUFBTSxDQUFDLEVBQUQsQ0FEakMsRUFFTkEsTUFBTSxDQUFDLENBQUQsQ0FGQSxFQUVLQSxNQUFNLENBQUMsQ0FBRCxDQUZYLEVBRWdCQSxNQUFNLENBQUMsQ0FBRCxDQUZ0QixFQUUyQkEsTUFBTSxDQUFDLEVBQUQsQ0FGakMsQ0FBUDtBQUtBLE9BUE0sTUFPQSxJQUFJLENBQUNBLE1BQU0sR0FBR2kxQixZQUFZLENBQUNxQixJQUFiLENBQWtCSCxJQUFsQixDQUFWLE1BQXVDLElBQTNDLEVBQWlEO0FBQ3ZEVCxlQUFPLENBQ04xMUIsTUFBTSxDQUFDLENBQUQsQ0FEQSxFQUNLQSxNQUFNLENBQUMsQ0FBRCxDQURYLEVBQ2dCQSxNQUFNLENBQUMsRUFBRCxDQUR0QixFQUM0QkEsTUFBTSxDQUFDLEVBQUQsQ0FEbEMsRUFFTkEsTUFBTSxDQUFDLENBQUQsQ0FGQSxFQUVLQSxNQUFNLENBQUMsQ0FBRCxDQUZYLEVBRWdCQSxNQUFNLENBQUMsRUFBRCxDQUZ0QixFQUU0QkEsTUFBTSxDQUFDLEVBQUQsQ0FGbEMsRUFHTkEsTUFBTSxDQUFDLENBQUQsQ0FIQSxFQUdLQSxNQUFNLENBQUMsQ0FBRCxDQUhYLEVBR2dCQSxNQUFNLENBQUMsRUFBRCxDQUh0QixFQUc0QkEsTUFBTSxDQUFDLEVBQUQsQ0FIbEMsQ0FBUDtBQU1BLE9BUE0sTUFPQSxJQUFJLENBQUNBLE1BQU0sR0FBR2sxQixZQUFZLENBQUNvQixJQUFiLENBQWtCSCxJQUFsQixDQUFWLE1BQXVDLElBQTNDLEVBQWlEO0FBQ3ZEVCxlQUFPLENBQ04xMUIsTUFBTSxDQUFDLENBQUQsQ0FEQSxFQUNLQSxNQUFNLENBQUMsQ0FBRCxDQURYLEVBQ2dCQSxNQUFNLENBQUMsQ0FBRCxDQUR0QixFQUMyQkEsTUFBTSxDQUFDLEVBQUQsQ0FEakMsRUFFTnFDLFNBRk0sRUFFS0EsU0FGTCxFQUVnQkEsU0FGaEIsRUFFMkJBLFNBRjNCLEVBR05yQyxNQUFNLENBQUMsQ0FBRCxDQUhBLEVBR0tBLE1BQU0sQ0FBQyxDQUFELENBSFgsRUFHZ0JBLE1BQU0sQ0FBQyxDQUFELENBSHRCLEVBRzJCQSxNQUFNLENBQUMsRUFBRCxDQUhqQyxDQUFQO0FBTUE7QUFDRDs7QUFFRCxXQUFPLEtBQUt3MkIsZUFBTCxDQUFxQjtBQUMzQjNYLGVBRDJCO0FBRTNCQyxZQUYyQjtBQUczQkUsYUFBTyxFQUFDMFYsWUFIbUI7QUFJM0IzVjtBQUoyQixLQUFyQixDQUFQO0FBT0E7O0FBRUR5WCxpQkFBZSxDQUFDMzVCLENBQUQsRUFBSTtBQUNsQixVQUFNNDVCLGNBQWMsR0FBRyxLQUF2QjtBQUNBLFVBQU1DLFVBQVUsR0FBRzc1QixDQUFDLENBQUNtaUIsT0FBRixDQUFVemlCLE1BQVYsR0FBbUIsQ0FBdEM7QUFDQSxVQUFNbzZCLE1BQU0sR0FBRzk1QixDQUFDLENBQUNpaUIsTUFBRixDQUFTdmlCLE1BQVQsR0FBa0IsQ0FBakM7QUFDQSxRQUFJbUIsSUFBSjs7QUFFQSxRQUFHYixDQUFDLENBQUNnaUIsU0FBRixDQUFZdGlCLE1BQVosR0FBcUJrNkIsY0FBeEIsRUFBd0M7QUFDdkMsWUFBTTNHLE1BQU0sR0FBRyxFQUFmO0FBQ0EsVUFBSThHLFNBQVMsR0FBRyxDQUFoQjtBQUVBLFlBQU1DLEtBQUssR0FBUyxFQUFwQjtBQUNBQSxXQUFLLENBQUNoWSxTQUFOLEdBQWtCaGlCLENBQUMsQ0FBQ2dpQixTQUFGLENBQVl6TSxNQUFaLEVBQWxCO0FBQ0F5a0IsV0FBSyxDQUFDL1gsTUFBTixHQUFrQmppQixDQUFDLENBQUNpaUIsTUFBRixDQUFTMU0sTUFBVCxFQUFsQjtBQUNBeWtCLFdBQUssQ0FBQzlYLE9BQU4sR0FBa0JsaUIsQ0FBQyxDQUFDa2lCLE9BQUYsQ0FBVTNNLE1BQVYsRUFBbEI7QUFDQXlrQixXQUFLLENBQUM3WCxPQUFOLEdBQWtCbmlCLENBQUMsQ0FBQ21pQixPQUFGLENBQVU1TSxNQUFWLEVBQWxCOztBQUVBLGFBQU12VixDQUFDLENBQUNraUIsT0FBRixDQUFVeGlCLE1BQVYsR0FBbUIsQ0FBekIsRUFBNEI7QUFFM0IsY0FBTXU2QixRQUFRLEdBQUlob0IsSUFBSSxDQUFDTixHQUFMLENBQVNpb0IsY0FBVCxFQUF5QjU1QixDQUFDLENBQUNnaUIsU0FBRixDQUFZdGlCLE1BQXJDLENBQWxCO0FBQ0EsY0FBTXdpQixPQUFPLEdBQUtsaUIsQ0FBQyxDQUFDa2lCLE9BQUYsQ0FBVStOLE1BQVYsQ0FBaUIsQ0FBakIsRUFBb0JnSyxRQUFwQixDQUFsQjtBQUNBLGNBQU1qWSxTQUFTLEdBQUcsRUFBbEI7QUFDQSxjQUFNQyxNQUFNLEdBQU0sRUFBbEI7QUFDQSxjQUFNRSxPQUFPLEdBQUssRUFBbEI7QUFDQSxZQUFJblIsS0FBSjtBQUFBLFlBQVdrcEIsUUFBUSxHQUFHLENBQXRCOztBQUVBLGFBQUksSUFBSTM0QixDQUFDLEdBQUcsQ0FBWixFQUFlQSxDQUFDLEdBQUcyZ0IsT0FBTyxDQUFDeGlCLE1BQTNCLEVBQW1DNkIsQ0FBQyxFQUFwQyxFQUF3QztBQUN2QyxjQUFHMmdCLE9BQU8sQ0FBQzNnQixDQUFELENBQVAsR0FBYTI0QixRQUFoQixFQUEwQjtBQUN6QkEsb0JBQVEsR0FBR2hZLE9BQU8sQ0FBQzNnQixDQUFELENBQWxCO0FBQ0E7O0FBRUR5UCxlQUFLLEdBQUdrUixPQUFPLENBQUMzZ0IsQ0FBRCxDQUFmO0FBRUF5Z0IsbUJBQVMsQ0FBQzNoQixJQUFWLENBQWUyNUIsS0FBSyxDQUFDaFksU0FBTixDQUFnQmhSLEtBQWhCLENBQWY7O0FBQ0EsY0FBRzhvQixNQUFILEVBQVc7QUFDVjdYLGtCQUFNLENBQUM1aEIsSUFBUCxDQUFZMjVCLEtBQUssQ0FBQy9YLE1BQU4sQ0FBYWpSLEtBQWIsQ0FBWjtBQUNBOztBQUNELGNBQUc2b0IsVUFBSCxFQUFlO0FBQ2QxWCxtQkFBTyxDQUFDOWhCLElBQVIsQ0FBYTI1QixLQUFLLENBQUM3WCxPQUFOLENBQWNuUixLQUFkLENBQWI7QUFDQTs7QUFFRGtSLGlCQUFPLENBQUMzZ0IsQ0FBRCxDQUFQLElBQWN3NEIsU0FBZDtBQUNBOztBQUVEQSxpQkFBUyxHQUFHRyxRQUFRLEdBQUcsQ0FBdkI7QUFFQXI1QixZQUFJLEdBQUcsSUFBSXVGLDZDQUFKLENBQVMsS0FBS3dmLFNBQWQsQ0FBUDtBQUNBL2tCLFlBQUksQ0FBQ2dpQixZQUFMLENBQWtCYixTQUFsQjs7QUFDQSxZQUFHOFgsTUFBSCxFQUFXO0FBQ1ZqNUIsY0FBSSxDQUFDaWlCLGNBQUwsQ0FBb0JiLE1BQXBCO0FBQ0E7O0FBRURwaEIsWUFBSSxDQUFDa2lCLFdBQUwsQ0FBaUJiLE9BQWpCOztBQUNBLFlBQUcyWCxVQUFILEVBQWU7QUFDZGg1QixjQUFJLENBQUNtaUIsWUFBTCxDQUFrQmIsT0FBbEI7QUFDQTs7QUFFRDhRLGNBQU0sQ0FBQzV5QixJQUFQLENBQVlRLElBQVo7QUFDQTs7QUFFRCxVQUFHLEtBQUt3d0IsU0FBUixFQUFtQjtBQUNsQixhQUFLQSxTQUFMLENBQWU0QixNQUFmLEVBQXVCK0csS0FBdkI7QUFDQTs7QUFFRCxhQUFPL0csTUFBUDtBQUNBLEtBMURELE1BMERPO0FBQ05weUIsVUFBSSxHQUFHLElBQUl1Riw2Q0FBSixDQUFTLEtBQUt3ZixTQUFkLENBQVA7QUFDQS9rQixVQUFJLENBQUNnaUIsWUFBTCxDQUFrQjdpQixDQUFDLENBQUNnaUIsU0FBcEI7O0FBQ0EsVUFBRzhYLE1BQUgsRUFBVztBQUNWajVCLFlBQUksQ0FBQ2lpQixjQUFMLENBQW9COWlCLENBQUMsQ0FBQ2lpQixNQUF0QjtBQUNBOztBQUNEcGhCLFVBQUksQ0FBQ2tpQixXQUFMLENBQWlCL2lCLENBQUMsQ0FBQ2tpQixPQUFuQjs7QUFDQSxVQUFHMlgsVUFBSCxFQUFlO0FBQ2RoNUIsWUFBSSxDQUFDbWlCLFlBQUwsQ0FBa0JoakIsQ0FBQyxDQUFDbWlCLE9BQXBCO0FBQ0E7O0FBRUQsVUFBRyxLQUFLa1AsU0FBUixFQUFtQjtBQUNsQixhQUFLQSxTQUFMLENBQWV4d0IsSUFBZixFQUFxQmIsQ0FBckI7QUFDQTs7QUFFRCxhQUFPYSxJQUFQO0FBQ0E7O0FBRUQsV0FBTyxJQUFQO0FBQ0E7O0FBalRtQzs7QUFxVHJDQyxTQUFTLENBQUNMLEtBQVYsR0FBa0IsVUFBVW0zQixNQUFWLEVBQWtCO0FBQ25DLFFBQU11QyxNQUFNLEdBQUcsSUFBSXI1QixTQUFKLEVBQWY7QUFDQSxTQUFPcTVCLE1BQU0sQ0FBQ3hDLFFBQVAsQ0FBZ0JDLE1BQWhCLENBQVA7QUFDQSxDQUhEOztBQUtlOTJCLHdFQUFmLEU7Ozs7Ozs7Ozs7OztBQ2pVQTtBQUFBO0FBQUE7QUFFQTtBQUdBLE1BQU0xQixDQUFDLEdBQUdnVSw4Q0FBSSxDQUFDb0ksTUFBTCxFQUFWO0FBQ0EsTUFBTXZMLENBQUMsR0FBR21ELDhDQUFJLENBQUNvSSxNQUFMLEVBQVY7QUFDQSxNQUFNMk0sQ0FBQyxHQUFHL1UsOENBQUksQ0FBQ29JLE1BQUwsRUFBVjtBQUNBLE1BQU00ZSxNQUFNLEdBQUdobkIsOENBQUksQ0FBQ29JLE1BQUwsRUFBZjtBQUNBLE1BQU02ZSxLQUFLLEdBQUdqbkIsOENBQUksQ0FBQ29JLE1BQUwsRUFBZDtBQUNBLE1BQU04ZSxLQUFLLEdBQUdsbkIsOENBQUksQ0FBQ29JLE1BQUwsRUFBZDtBQUNBLE1BQU1xTSxNQUFNLEdBQUd6VSw4Q0FBSSxDQUFDb0ksTUFBTCxFQUFmO0FBQ0EsTUFBTStlLElBQUksR0FBR25uQiw4Q0FBSSxDQUFDb0ksTUFBTCxFQUFiOztBQUVBLE1BQU12VSxHQUFOLENBQVU7QUFDVDFELGFBQVcsQ0FBQ2kzQixPQUFELEVBQVVDLFVBQVYsRUFBc0I7QUFDaEMsU0FBSzlNLE1BQUwsR0FBY3ZhLDhDQUFJLENBQUM4TixLQUFMLENBQVdzWixPQUFYLENBQWQ7QUFDQSxTQUFLNU0sU0FBTCxHQUFpQnhhLDhDQUFJLENBQUM4TixLQUFMLENBQVd1WixVQUFYLENBQWpCO0FBQ0E7O0FBRURDLElBQUUsQ0FBQ2xYLENBQUQsRUFBSTtBQUNMcFEsa0RBQUksQ0FBQzhLLElBQUwsQ0FBVWtjLE1BQVYsRUFBa0IsS0FBS3hNLFNBQXZCO0FBQ0F4YSxrREFBSSxDQUFDNmEsS0FBTCxDQUFXbU0sTUFBWCxFQUFtQkEsTUFBbkIsRUFBMkI1VyxDQUEzQjtBQUNBcFEsa0RBQUksQ0FBQy9QLEdBQUwsQ0FBUysyQixNQUFULEVBQWlCQSxNQUFqQixFQUF5QixLQUFLek0sTUFBOUI7QUFFQSxXQUFPeU0sTUFBUDtBQUNBOztBQUdEeFAsUUFBTSxDQUFDK1AsT0FBRCxFQUFVO0FBQ2Z2bkIsa0RBQUksQ0FBQ3NhLEdBQUwsQ0FBUyxLQUFLRSxTQUFkLEVBQXlCK00sT0FBekIsRUFBa0MsS0FBS2hOLE1BQXZDO0FBQ0F2YSxrREFBSSxDQUFDMlUsU0FBTCxDQUFlLEtBQUs0RixNQUFwQixFQUE0QixLQUFLQSxNQUFqQztBQUNBOztBQUVEaU4scUJBQW1CLENBQUNDLE1BQUQsRUFBUztBQUMzQixVQUFNMTNCLE1BQU0sR0FBR2lRLDhDQUFJLENBQUNvSSxNQUFMLEVBQWY7QUFDQXBJLGtEQUFJLENBQUNzYSxHQUFMLENBQVNtTixNQUFULEVBQWlCLEtBQUtsTixNQUF0QjtBQUNBLFVBQU1tTixpQkFBaUIsR0FBRzFuQiw4Q0FBSSxDQUFDMm5CLEdBQUwsQ0FBUzUzQixNQUFULEVBQWlCLEtBQUt5cUIsU0FBdEIsQ0FBMUI7O0FBRUEsUUFBSWtOLGlCQUFpQixHQUFHLENBQXhCLEVBQTJCO0FBQzFCLGFBQU8xbkIsOENBQUksQ0FBQzhOLEtBQUwsQ0FBVyxLQUFLeU0sTUFBaEIsQ0FBUDtBQUNBOztBQUVEdmEsa0RBQUksQ0FBQzhLLElBQUwsQ0FBVS9hLE1BQVYsRUFBa0IsS0FBS3lxQixTQUF2QjtBQUNBeGEsa0RBQUksQ0FBQzZhLEtBQUwsQ0FBVzlxQixNQUFYLEVBQW1CQSxNQUFuQixFQUEyQjIzQixpQkFBM0I7QUFDQTFuQixrREFBSSxDQUFDL1AsR0FBTCxDQUFTRixNQUFULEVBQWlCQSxNQUFqQixFQUF5QixLQUFLd3FCLE1BQTlCO0FBRUEsV0FBT3hxQixNQUFQO0FBQ0E7O0FBR0Q2M0IsaUJBQWUsQ0FBQ0gsTUFBRCxFQUFTO0FBQ3ZCLFdBQU81b0IsSUFBSSxDQUFDNkksSUFBTCxDQUFVLEtBQUttZ0IsaUJBQUwsQ0FBdUJKLE1BQXZCLENBQVYsQ0FBUDtBQUNBOztBQUdESSxtQkFBaUIsQ0FBQ0osTUFBRCxFQUFTO0FBQ3pCLFVBQU1LLEVBQUUsR0FBRzluQiw4Q0FBSSxDQUFDb0ksTUFBTCxFQUFYO0FBRUFwSSxrREFBSSxDQUFDc2EsR0FBTCxDQUFTd04sRUFBVCxFQUFhTCxNQUFiLEVBQXFCLEtBQUtsTixNQUExQjtBQUNBLFVBQU1tTixpQkFBaUIsR0FBRzFuQiw4Q0FBSSxDQUFDMm5CLEdBQUwsQ0FBU0csRUFBVCxFQUFhLEtBQUt0TixTQUFsQixDQUExQjs7QUFFQSxRQUFJa04saUJBQWlCLEdBQUcsQ0FBeEIsRUFBMkI7QUFDMUIsYUFBTzFuQiw4Q0FBSSxDQUFDK25CLGVBQUwsQ0FBcUIsS0FBS3hOLE1BQTFCLEVBQWtDa04sTUFBbEMsQ0FBUDtBQUNBOztBQUVEem5CLGtEQUFJLENBQUM4SyxJQUFMLENBQVVnZCxFQUFWLEVBQWMsS0FBS3ROLFNBQW5CO0FBQ0F4YSxrREFBSSxDQUFDNmEsS0FBTCxDQUFXaU4sRUFBWCxFQUFlQSxFQUFmLEVBQW1CSixpQkFBbkI7QUFDQTFuQixrREFBSSxDQUFDL1AsR0FBTCxDQUFTNjNCLEVBQVQsRUFBYUEsRUFBYixFQUFpQixLQUFLdk4sTUFBdEI7QUFDQSxXQUFPdmEsOENBQUksQ0FBQytuQixlQUFMLENBQXFCRCxFQUFyQixFQUF5QkwsTUFBekIsQ0FBUDtBQUNBOztBQUdETyxrQkFBZ0IsQ0FBQ0MsT0FBRCxFQUFVQyxPQUFWLEVBQW1CO0FBQ2xDLFdBQU8sS0FBS04sZUFBTCxDQUFxQkssT0FBckIsS0FBaUNDLE9BQXhDO0FBQ0E7O0FBR0RDLGlCQUFlLENBQUNGLE9BQUQsRUFBVUMsT0FBVixFQUFtQjtBQUNqQyxVQUFNSixFQUFFLEdBQUc5bkIsOENBQUksQ0FBQ29JLE1BQUwsRUFBWDtBQUNBcEksa0RBQUksQ0FBQ3NhLEdBQUwsQ0FBU3dOLEVBQVQsRUFBYUcsT0FBYixFQUFzQixLQUFLMU4sTUFBM0I7QUFDQSxVQUFNNk4sR0FBRyxHQUFHcG9CLDhDQUFJLENBQUMybkIsR0FBTCxDQUFTRyxFQUFULEVBQWEsS0FBS3ROLFNBQWxCLENBQVo7QUFDQSxVQUFNNk4sRUFBRSxHQUFHcm9CLDhDQUFJLENBQUMybkIsR0FBTCxDQUFTRyxFQUFULEVBQWFBLEVBQWIsSUFBbUJNLEdBQUcsR0FBR0EsR0FBcEM7QUFDQSxVQUFNRSxPQUFPLEdBQUdKLE9BQU8sR0FBR0EsT0FBMUI7QUFFQSxRQUFHRyxFQUFFLEdBQUdDLE9BQVIsRUFBaUIsT0FBTyxJQUFQO0FBRWpCLFVBQU1DLEdBQUcsR0FBRzFwQixJQUFJLENBQUM2SSxJQUFMLENBQVU0Z0IsT0FBTyxHQUFHRCxFQUFwQixDQUFaO0FBRUEsVUFBTUcsRUFBRSxHQUFHSixHQUFHLEdBQUdHLEdBQWpCO0FBRUEsVUFBTUUsRUFBRSxHQUFHTCxHQUFHLEdBQUdHLEdBQWpCO0FBRUEsUUFBR0MsRUFBRSxHQUFHLENBQUwsSUFBVUMsRUFBRSxHQUFHLENBQWxCLEVBQXFCLE9BQU8sSUFBUDtBQUVyQixRQUFHRCxFQUFFLEdBQUcsQ0FBUixFQUFXLE9BQU8sS0FBS2xCLEVBQUwsQ0FBUW1CLEVBQVIsQ0FBUDtBQUVYLFdBQU8sS0FBS25CLEVBQUwsQ0FBUWtCLEVBQVIsQ0FBUDtBQUNBOztBQUdERSxpQkFBZSxDQUFDQyxZQUFELEVBQWVDLE9BQWYsRUFBd0I7QUFDdEMsVUFBTUMsV0FBVyxHQUFHN29CLDhDQUFJLENBQUMybkIsR0FBTCxDQUFTaUIsT0FBVCxFQUFrQixLQUFLcE8sU0FBdkIsQ0FBcEI7O0FBRUEsUUFBR3FPLFdBQVcsS0FBSyxDQUFuQixFQUFzQixDQUNyQjtBQUNEOztBQUdEQyxtQkFBaUIsQ0FBQ0MsR0FBRCxFQUFNQyxHQUFOLEVBQVdDLEdBQVgsRUFBZ0JDLGVBQWUsR0FBRyxJQUFsQyxFQUF3QztBQUN4RGxwQixrREFBSSxDQUFDOEssSUFBTCxDQUFVOWUsQ0FBVixFQUFhKzhCLEdBQWI7QUFDQS9vQixrREFBSSxDQUFDOEssSUFBTCxDQUFVak8sQ0FBVixFQUFhbXNCLEdBQWI7QUFDQWhwQixrREFBSSxDQUFDOEssSUFBTCxDQUFVaUssQ0FBVixFQUFha1UsR0FBYixFQUh3RCxDQUt4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQWpwQixrREFBSSxDQUFDc2EsR0FBTCxDQUFTMk0sS0FBVCxFQUFnQnBxQixDQUFoQixFQUFtQjdRLENBQW5CO0FBQ0FnVSxrREFBSSxDQUFDc2EsR0FBTCxDQUFTNE0sS0FBVCxFQUFnQm5TLENBQWhCLEVBQW1CL29CLENBQW5CO0FBQ0FnVSxrREFBSSxDQUFDbXBCLEtBQUwsQ0FBVzFVLE1BQVgsRUFBbUJ3UyxLQUFuQixFQUEwQkMsS0FBMUI7QUFFQSxRQUFJa0MsR0FBRyxHQUFHcHBCLDhDQUFJLENBQUMybkIsR0FBTCxDQUFTLEtBQUtuTixTQUFkLEVBQXlCL0YsTUFBekIsQ0FBVjtBQUNBLFFBQUk0VSxJQUFKOztBQUVBLFFBQUlELEdBQUcsR0FBRyxDQUFWLEVBQWE7QUFDWixVQUFJRixlQUFKLEVBQXFCO0FBQUUsZUFBTyxJQUFQO0FBQWM7O0FBQ3JDRyxVQUFJLEdBQUcsQ0FBUDtBQUNBLEtBSEQsTUFHTyxJQUFJRCxHQUFHLEdBQUcsQ0FBVixFQUFhO0FBQ25CQyxVQUFJLEdBQUcsQ0FBQyxDQUFSO0FBQ0FELFNBQUcsR0FBRyxDQUFFQSxHQUFSO0FBQ0EsS0FITSxNQUdBO0FBQ04sYUFBTyxJQUFQO0FBQ0E7O0FBRURwcEIsa0RBQUksQ0FBQ3NhLEdBQUwsQ0FBUzZNLElBQVQsRUFBZSxLQUFLNU0sTUFBcEIsRUFBNEJ2dUIsQ0FBNUI7QUFFQWdVLGtEQUFJLENBQUNtcEIsS0FBTCxDQUFXakMsS0FBWCxFQUFrQkMsSUFBbEIsRUFBd0JELEtBQXhCO0FBQ0EsVUFBTW9DLE1BQU0sR0FBR0QsSUFBSSxHQUFHcnBCLDhDQUFJLENBQUMybkIsR0FBTCxDQUFTLEtBQUtuTixTQUFkLEVBQXlCME0sS0FBekIsQ0FBdEI7O0FBQ0EsUUFBSW9DLE1BQU0sR0FBRyxDQUFiLEVBQWdCO0FBQUcsYUFBTyxJQUFQO0FBQWU7O0FBRWxDdHBCLGtEQUFJLENBQUNtcEIsS0FBTCxDQUFXbEMsS0FBWCxFQUFrQkEsS0FBbEIsRUFBeUJFLElBQXpCO0FBQ0EsVUFBTW9DLE1BQU0sR0FBR0YsSUFBSSxHQUFHcnBCLDhDQUFJLENBQUMybkIsR0FBTCxDQUFTLEtBQUtuTixTQUFkLEVBQXlCeU0sS0FBekIsQ0FBdEI7O0FBQ0EsUUFBSXNDLE1BQU0sR0FBRyxDQUFiLEVBQWdCO0FBQUUsYUFBTyxJQUFQO0FBQWM7O0FBRWhDLFFBQUdELE1BQU0sR0FBR0MsTUFBVCxHQUFrQkgsR0FBckIsRUFBMEI7QUFBRSxhQUFPLElBQVA7QUFBYzs7QUFFMUMsVUFBTUksR0FBRyxHQUFHLENBQUVILElBQUYsR0FBU3JwQiw4Q0FBSSxDQUFDMm5CLEdBQUwsQ0FBU1IsSUFBVCxFQUFlMVMsTUFBZixDQUFyQjs7QUFDQSxRQUFHK1UsR0FBRyxHQUFHLENBQVQsRUFBWTtBQUFFLGFBQU8sSUFBUDtBQUFjOztBQUU1QixXQUFPLEtBQUtsQyxFQUFMLENBQVFrQyxHQUFHLEdBQUdKLEdBQWQsQ0FBUDtBQUNBOztBQTFJUTs7QUE4SUt2MUIsa0VBQWYsRTs7Ozs7Ozs7Ozs7O0FDNUpBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTs7QUFFQSxNQUFNaUIsUUFBTixDQUFlO0FBRWQzRSxhQUFXLEdBQUc7QUFDYixTQUFLczVCLFdBQUwsR0FBbUIsSUFBbkI7QUFFQSxTQUFLQyxFQUFMLEdBQVUsQ0FBVjtBQUNBLFNBQUtDLEVBQUwsR0FBVSxDQUFWO0FBQ0EsU0FBS0MsRUFBTCxHQUFVLENBQVY7QUFFQSxTQUFLQyxHQUFMLEdBQVcsQ0FBWDtBQUNBLFNBQUtDLEdBQUwsR0FBVyxDQUFYO0FBQ0EsU0FBS0MsR0FBTCxHQUFXLENBQVg7QUFFQSxTQUFLQyxHQUFMLEdBQVcsQ0FBWDtBQUNBLFNBQUtDLEdBQUwsR0FBVyxDQUFYO0FBQ0EsU0FBS0MsR0FBTCxHQUFXLENBQVg7QUFFQSxTQUFLQyxTQUFMLEdBQWlCbnFCLDhDQUFJLENBQUNvSSxNQUFMLEVBQWpCO0FBQ0EsU0FBS2dpQixNQUFMLEdBQWNwcUIsOENBQUksQ0FBQzBZLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBZDtBQUNBLFNBQUsyUixTQUFMLEdBQWlCcnFCLDhDQUFJLENBQUNvSSxNQUFMLEVBQWpCO0FBRUEsU0FBS0ksT0FBTCxHQUFlcEksOENBQUksQ0FBQ2dJLE1BQUwsRUFBZjtBQUNBLFNBQUtraUIsYUFBTCxHQUFxQmxxQiw4Q0FBSSxDQUFDZ0ksTUFBTCxFQUFyQjtBQUNBLFNBQUttaUIsZUFBTCxHQUF1Qm5xQiw4Q0FBSSxDQUFDZ0ksTUFBTCxFQUF2QjtBQUNBLFNBQUtvaUIsWUFBTCxHQUFvQnBxQiw4Q0FBSSxDQUFDZ0ksTUFBTCxFQUFwQjtBQUNBLFNBQUtxaUIsa0JBQUwsR0FBMEJycUIsOENBQUksQ0FBQ2dJLE1BQUwsRUFBMUI7QUFDQSxTQUFLc2lCLGlCQUFMLEdBQXlCdHFCLDhDQUFJLENBQUNnSSxNQUFMLEVBQXpCO0FBQ0EsU0FBSytPLEtBQUwsR0FBYUMsOENBQUksQ0FBQ2hQLE1BQUwsRUFBYjtBQUVBLFNBQUs0VCxTQUFMLEdBQWlCLEVBQWpCO0FBQ0E7O0FBR0RXLFVBQVEsQ0FBQ0MsTUFBRCxFQUFTO0FBQ2hCLFNBQUtaLFNBQUwsQ0FBZS91QixJQUFmLENBQW9CMnZCLE1BQXBCO0FBQ0E7O0FBR0RyTyxhQUFXLENBQUNxTyxNQUFELEVBQVM7QUFDbkIsVUFBTWhmLEtBQUssR0FBRyxLQUFLb2UsU0FBTCxDQUFlem1CLE9BQWYsQ0FBdUJxbkIsTUFBdkIsQ0FBZDs7QUFDQSxRQUFHaGYsS0FBSyxJQUFJLENBQUMsQ0FBYixFQUFnQjtBQUFFalEsYUFBTyxDQUFDb1YsSUFBUixDQUFhLGdCQUFiO0FBQWdDO0FBQVM7O0FBRTNELFNBQUtpWixTQUFMLENBQWVhLE1BQWYsQ0FBc0JqZixLQUF0QixFQUE2QixDQUE3QjtBQUNBOztBQUdEK3NCLFNBQU8sR0FBRztBQUNULFFBQUcsQ0FBQyxLQUFLbEIsV0FBVCxFQUFzQjtBQUFFO0FBQVM7O0FBRWpDenBCLGtEQUFJLENBQUMxUCxHQUFMLENBQVMsS0FBSzg1QixNQUFkLEVBQXNCLEtBQUtQLEdBQTNCLEVBQWdDLEtBQUtDLEdBQXJDLEVBQTBDLEtBQUtDLEdBQS9DO0FBQ0EvcEIsa0RBQUksQ0FBQzFQLEdBQUwsQ0FBUyxLQUFLKzVCLFNBQWQsRUFBeUIsS0FBS0wsR0FBOUIsRUFBbUMsS0FBS0MsR0FBeEMsRUFBNkMsS0FBS0MsR0FBbEQ7QUFDQWxxQixrREFBSSxDQUFDMVAsR0FBTCxDQUFTLEtBQUs2NUIsU0FBZCxFQUF5QixLQUFLVCxFQUE5QixFQUFrQyxLQUFLQyxFQUF2QyxFQUEyQyxLQUFLQyxFQUFoRDtBQUVBeHBCLGtEQUFJLENBQUMySSxRQUFMLENBQWMsS0FBSzBoQixrQkFBbkIsRUFBdUMsS0FBS0Esa0JBQTVDO0FBQ0FycUIsa0RBQUksQ0FBQzJJLFFBQUwsQ0FBYyxLQUFLeWhCLFlBQW5CLEVBQWlDLEtBQUtBLFlBQXRDO0FBQ0FwcUIsa0RBQUksQ0FBQzJJLFFBQUwsQ0FBYyxLQUFLd2hCLGVBQW5CLEVBQW9DLEtBQUtBLGVBQXpDO0FBRUFucUIsa0RBQUksQ0FBQ3dxQixPQUFMLENBQWEsS0FBS0wsZUFBbEIsRUFBbUMsS0FBS0EsZUFBeEMsRUFBeUQsS0FBS1AsR0FBOUQ7QUFDQTVwQixrREFBSSxDQUFDeXFCLE9BQUwsQ0FBYSxLQUFLTixlQUFsQixFQUFtQyxLQUFLQSxlQUF4QyxFQUF5RCxLQUFLTixHQUE5RDtBQUNBN3BCLGtEQUFJLENBQUMwcUIsT0FBTCxDQUFhLEtBQUtQLGVBQWxCLEVBQW1DLEtBQUtBLGVBQXhDLEVBQXlELEtBQUtMLEdBQTlEO0FBR0E5cEIsa0RBQUksQ0FBQzJYLFFBQUwsQ0FBYyxLQUFLMlMsaUJBQW5CLEVBQXNDLEtBQUt2VCxLQUEzQztBQUNBL1csa0RBQUksQ0FBQzJxQixHQUFMLENBQVMsS0FBS1IsZUFBZCxFQUErQixLQUFLRyxpQkFBcEMsRUFBdUQsS0FBS0gsZUFBNUQ7QUFFQW5xQixrREFBSSxDQUFDeWEsS0FBTCxDQUFXLEtBQUsyUCxZQUFoQixFQUE4QixLQUFLQSxZQUFuQyxFQUFpRCxLQUFLSixNQUF0RDtBQUNBaHFCLGtEQUFJLENBQUM0WCxTQUFMLENBQWUsS0FBS3lTLGtCQUFwQixFQUF3QyxLQUFLQSxrQkFBN0MsRUFBaUUsS0FBS04sU0FBdEU7QUFFQS9wQixrREFBSSxDQUFDMnFCLEdBQUwsQ0FBUyxLQUFLdmlCLE9BQWQsRUFBdUIsS0FBS2lpQixrQkFBNUIsRUFBZ0QsS0FBS0YsZUFBckQ7QUFDQW5xQixrREFBSSxDQUFDMnFCLEdBQUwsQ0FBUyxLQUFLdmlCLE9BQWQsRUFBdUIsS0FBS0EsT0FBNUIsRUFBcUMsS0FBS2dpQixZQUExQyxFQXZCUyxDQXdCVDs7QUFDQXBxQixrREFBSSxDQUFDMnFCLEdBQUwsQ0FBUyxLQUFLdmlCLE9BQWQsRUFBdUIsS0FBSzhoQixhQUE1QixFQUEyQyxLQUFLOWhCLE9BQWhEO0FBRUEsU0FBS3dpQixZQUFMO0FBRUEsU0FBS3ZCLFdBQUwsR0FBbUIsS0FBbkI7QUFDQTs7QUFHRHVCLGNBQVksQ0FBQ0MsYUFBRCxFQUFnQjtBQUMzQixRQUFHQSxhQUFILEVBQWtCO0FBQ2pCLFdBQUt4QixXQUFMLEdBQW1CLElBQW5CO0FBQ0FycEIsb0RBQUksQ0FBQzBLLElBQUwsQ0FBVSxLQUFLd2YsYUFBZixFQUE4QlcsYUFBOUI7QUFDQTs7QUFFRCxRQUFHLENBQUMsS0FBS3hCLFdBQVQsRUFBc0I7QUFBRTtBQUFTOztBQUVqQyxTQUFLek4sU0FBTCxDQUFlanRCLE9BQWYsQ0FBdUJndUIsS0FBSyxJQUFJO0FBQy9CQSxXQUFLLENBQUNpTyxZQUFOLENBQW1CLEtBQUt4aUIsT0FBeEI7QUFDQSxLQUZEO0FBR0E7O0FBRUQwaUIsMkJBQXlCLENBQUNDLEtBQUQsRUFBUTtBQUNoQy9ULGtEQUFJLENBQUN0TSxJQUFMLENBQVUsS0FBS3FNLEtBQWYsRUFBc0JnVSxLQUF0QjtBQUNBLFNBQUsxQixXQUFMLEdBQW1CLElBQW5CO0FBQ0FwMkIsc0RBQVMsQ0FBQyszQixJQUFWLENBQWUsTUFBSSxLQUFLVCxPQUFMLEVBQW5CO0FBQ0E7O0FBR0QsTUFBSTNmLE1BQUosR0FBYTtBQUNaLFFBQUcsS0FBS3llLFdBQVIsRUFBcUI7QUFDcEIsV0FBS2tCLE9BQUw7QUFDQTs7QUFDRCxXQUFPLEtBQUtuaUIsT0FBWjtBQUNBOztBQUVELE1BQUk1RSxDQUFKLEdBQVE7QUFBRSxXQUFPLEtBQUs4bEIsRUFBWjtBQUFpQjs7QUFDM0IsTUFBSTlsQixDQUFKLENBQU1wVCxNQUFOLEVBQWM7QUFDYixTQUFLaTVCLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxTQUFLQyxFQUFMLEdBQVVsNUIsTUFBVjtBQUNBNkMsc0RBQVMsQ0FBQyszQixJQUFWLENBQWUsTUFBSSxLQUFLVCxPQUFMLEVBQW5CO0FBQ0E7O0FBRUQsTUFBSXpnQixDQUFKLEdBQVE7QUFBRSxXQUFPLEtBQUt5ZixFQUFaO0FBQWlCOztBQUMzQixNQUFJemYsQ0FBSixDQUFNMVosTUFBTixFQUFjO0FBQ2IsU0FBS2k1QixXQUFMLEdBQW1CLElBQW5CO0FBQ0EsU0FBS0UsRUFBTCxHQUFVbjVCLE1BQVY7QUFDQTZDLHNEQUFTLENBQUMrM0IsSUFBVixDQUFlLE1BQUksS0FBS1QsT0FBTCxFQUFuQjtBQUNBOztBQUVELE1BQUloYSxDQUFKLEdBQVE7QUFBRSxXQUFPLEtBQUtpWixFQUFaO0FBQWlCOztBQUMzQixNQUFJalosQ0FBSixDQUFNbmdCLE1BQU4sRUFBYztBQUNiLFNBQUtpNUIsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFNBQUtHLEVBQUwsR0FBVXA1QixNQUFWO0FBQ0E2QyxzREFBUyxDQUFDKzNCLElBQVYsQ0FBZSxNQUFJLEtBQUtULE9BQUwsRUFBbkI7QUFDQTs7QUFHRCxNQUFJVSxNQUFKLEdBQWE7QUFBRSxXQUFPLEtBQUt4QixHQUFaO0FBQWtCOztBQUNqQyxNQUFJd0IsTUFBSixDQUFXNzZCLE1BQVgsRUFBbUI7QUFDbEIsU0FBS2k1QixXQUFMLEdBQW1CLElBQW5CO0FBQ0EsU0FBS0ksR0FBTCxHQUFXcjVCLE1BQVg7QUFDQTZDLHNEQUFTLENBQUMrM0IsSUFBVixDQUFlLE1BQUksS0FBS1QsT0FBTCxFQUFuQjtBQUNBOztBQUVELE1BQUlXLE1BQUosR0FBYTtBQUFFLFdBQU8sS0FBS3hCLEdBQVo7QUFBa0I7O0FBQ2pDLE1BQUl3QixNQUFKLENBQVc5NkIsTUFBWCxFQUFtQjtBQUNsQixTQUFLaTVCLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxTQUFLSyxHQUFMLEdBQVd0NUIsTUFBWDtBQUNBNkMsc0RBQVMsQ0FBQyszQixJQUFWLENBQWUsTUFBSSxLQUFLVCxPQUFMLEVBQW5CO0FBQ0E7O0FBRUQsTUFBSVksTUFBSixHQUFhO0FBQUUsV0FBTyxLQUFLeEIsR0FBWjtBQUFrQjs7QUFDakMsTUFBSXdCLE1BQUosQ0FBVy82QixNQUFYLEVBQW1CO0FBQ2xCLFNBQUtpNUIsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFNBQUtNLEdBQUwsR0FBV3Y1QixNQUFYO0FBQ0E2QyxzREFBUyxDQUFDKzNCLElBQVYsQ0FBZSxNQUFJLEtBQUtULE9BQUwsRUFBbkI7QUFDQTs7QUFHRCxNQUFJYSxTQUFKLEdBQWdCO0FBQUUsV0FBTyxLQUFLeEIsR0FBWjtBQUFrQjs7QUFDcEMsTUFBSXdCLFNBQUosQ0FBY2g3QixNQUFkLEVBQXNCO0FBQ3JCLFNBQUtpNUIsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFNBQUtPLEdBQUwsR0FBV3g1QixNQUFYO0FBQ0E2QyxzREFBUyxDQUFDKzNCLElBQVYsQ0FBZSxNQUFJLEtBQUtULE9BQUwsRUFBbkI7QUFDQTs7QUFFRCxNQUFJYyxTQUFKLEdBQWdCO0FBQUUsV0FBTyxLQUFLeEIsR0FBWjtBQUFrQjs7QUFDcEMsTUFBSXdCLFNBQUosQ0FBY2o3QixNQUFkLEVBQXNCO0FBQ3JCLFNBQUtpNUIsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFNBQUtRLEdBQUwsR0FBV3o1QixNQUFYO0FBQ0E2QyxzREFBUyxDQUFDKzNCLElBQVYsQ0FBZSxNQUFJLEtBQUtULE9BQUwsRUFBbkI7QUFDQTs7QUFFRCxNQUFJZSxTQUFKLEdBQWdCO0FBQUUsV0FBTyxLQUFLeEIsR0FBWjtBQUFrQjs7QUFDcEMsTUFBSXdCLFNBQUosQ0FBY2w3QixNQUFkLEVBQXNCO0FBQ3JCLFNBQUtpNUIsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFNBQUtTLEdBQUwsR0FBVzE1QixNQUFYO0FBQ0E2QyxzREFBUyxDQUFDKzNCLElBQVYsQ0FBZSxNQUFJLEtBQUtULE9BQUwsRUFBbkI7QUFDQTs7QUFFRCxNQUFJZ0IsUUFBSixHQUFlO0FBQUUsV0FBTyxLQUFLM1AsU0FBWjtBQUF3Qjs7QUEzSzNCOztBQStLQWxuQix1RUFBZixFOzs7Ozs7Ozs7Ozs7QUNwTEE7QUFBZSwySUFBNEUseUNBQXlDLHVCQUF1QixxQkFBcUIsNEJBQTRCLDJDQUEyQyxzQ0FBc0MsR0FBRyxDOzs7Ozs7Ozs7Ozs7QUNBaFM7QUFBZSwwSUFBMkUsb0RBQW9ELHdCQUF3Qix5QkFBeUIsOEJBQThCLDJCQUEyQixpQ0FBaUMsd0JBQXdCLHVCQUF1QixxQkFBcUIsZ0dBQWdHLHNCQUFzQix3QkFBd0IsR0FBRyxDOzs7Ozs7Ozs7Ozs7QUNBOWU7QUFBZSw0SUFBNkUsZ0RBQWdELHFCQUFxQiwrQkFBK0IscUJBQXFCLG1FQUFtRSxHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0EzUjtBQUFlLDJJQUE0RSxvREFBb0QsK0JBQStCLHlCQUF5Qiw4QkFBOEIsMkJBQTJCLGlDQUFpQywrQkFBK0IsdUJBQXVCLHFCQUFxQixnR0FBZ0csb0NBQW9DLHdCQUF3QixHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0EzZ0I7QUFBZSwwSkFBMkYsOENBQThDLDZCQUE2QixxQkFBcUIsOENBQThDLDBDQUEwQyxHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0FyUztBQUFlLDZJQUE4RSxrREFBa0QsNEJBQTRCLHFCQUFxQix1REFBdUQsR0FBRyxDOzs7Ozs7Ozs7Ozs7QUNBMVA7QUFBZSwyR0FBNEMsMENBQTBDLHdCQUF3QixxQkFBcUIsZ0RBQWdELGNBQWMsS0FBSywwQ0FBMEMsR0FBRyxDOzs7Ozs7Ozs7Ozs7QUNBbFE7QUFBZSxnSkFBaUYsb0RBQW9ELHlCQUF5Qiw4QkFBOEIsMkJBQTJCLGlDQUFpQyx3QkFBd0IseUJBQXlCLCtCQUErQixxQkFBcUIscUhBQXFILDRCQUE0Qix3QkFBd0IsdUZBQXVGLGdDQUFnQyxHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0Evb0I7QUFBZSx5SkFBMEYsb0RBQW9ELCtCQUErQix5QkFBeUIsOEJBQThCLDJCQUEyQixpQ0FBaUMsNkJBQTZCLDBCQUEwQixxQkFBcUIsK0JBQStCLHVCQUF1QixxQkFBcUIsNENBQTRDLDhCQUE4QixvRkFBb0Ysc0NBQXNDLHVEQUF1RCxHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0Fwc0I7QUFBZSxtSkFBb0YsMENBQTBDLHdCQUF3QixxQkFBcUIsMENBQTBDLEdBQUcsQzs7Ozs7Ozs7Ozs7O0FDQXZPO0FBQWUscUdBQXNDLG9EQUFvRCwrQkFBK0IseUJBQXlCLDhCQUE4QiwyQkFBMkIsaUNBQWlDLCtCQUErQix1QkFBdUIscUJBQXFCLCtCQUErQix3QkFBd0Isd0JBQXdCLHdCQUF3QixnR0FBZ0csb0NBQW9DLHdCQUF3QixHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0E1a0I7QUFBZSxnSkFBaUYsaURBQWlELDZCQUE2Qix1QkFBdUIscUJBQXFCLG1EQUFtRCxHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0FoUjtBQUFlLDRJQUE2RSxvREFBb0QsK0JBQStCLHlCQUF5Qiw4QkFBOEIsMkJBQTJCLGlDQUFpQywrQkFBK0IsdUJBQXVCLHVCQUF1QixxQkFBcUIsK0JBQStCLHdCQUF3Qix3QkFBd0Isd0JBQXdCLDhGQUE4RixrQ0FBa0Msa0NBQWtDLHNCQUFzQixHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0F0cUI7QUFBQTtBQUFBO0FBRUE7O0FBRUEsTUFBTXZCLFVBQU4sQ0FBaUI7QUFDaEJwRCxhQUFXLENBQUNLLE1BQUQsRUFBU283QixPQUFPLEdBQUcsR0FBbkIsRUFBd0I7QUFDbEMsU0FBS0MsTUFBTCxHQUFvQkQsT0FBcEI7QUFDQSxTQUFLdjdCLE1BQUwsR0FBb0JHLE1BQXBCO0FBQ0EsU0FBS3M3QixZQUFMLEdBQW9CdDdCLE1BQXBCO0FBQ0EsU0FBSzJyQixRQUFMLEdBQW9COW9CLGtEQUFTLENBQUM4VCxLQUFWLENBQWdCLE1BQUssS0FBS3dqQixPQUFMLEVBQXJCLENBQXBCO0FBQ0E7O0FBR0RBLFNBQU8sR0FBRztBQUNULFVBQU1vQixRQUFRLEdBQUcsTUFBakI7O0FBQ0EsU0FBS0MsV0FBTDs7QUFDQSxTQUFLMzdCLE1BQUwsSUFBZSxDQUFDLEtBQUt5N0IsWUFBTCxHQUFvQixLQUFLejdCLE1BQTFCLElBQW9DLEtBQUt3N0IsTUFBeEQ7O0FBQ0EsUUFBR2h0QixJQUFJLENBQUNvdEIsR0FBTCxDQUFTLEtBQUtILFlBQUwsR0FBb0IsS0FBS3o3QixNQUFsQyxJQUE0QzA3QixRQUEvQyxFQUF5RDtBQUN4RCxXQUFLMTdCLE1BQUwsR0FBYyxLQUFLeTdCLFlBQW5CO0FBQ0E7QUFDRDs7QUFFRHo1QixPQUFLLENBQUM3QixNQUFELEVBQVM7QUFDYixTQUFLczdCLFlBQUwsR0FBb0IsS0FBS3o3QixNQUFMLEdBQWNHLE1BQWxDO0FBQ0E7O0FBR0RQLEtBQUcsQ0FBQ2k4QixJQUFELEVBQU87QUFDVCxTQUFLSixZQUFMLElBQXFCSSxJQUFyQjtBQUNBOztBQUVEQyxPQUFLLENBQUNDLElBQUQsRUFBT0MsSUFBUCxFQUFhO0FBQ2pCLFFBQUdELElBQUksR0FBR0MsSUFBVixFQUFnQjtBQUNmLFdBQUtGLEtBQUwsQ0FBV0UsSUFBWCxFQUFpQkQsSUFBakI7QUFDQTtBQUNBOztBQUVELFNBQUtFLElBQUwsR0FBWUYsSUFBWjtBQUNBLFNBQUtHLElBQUwsR0FBWUYsSUFBWjs7QUFFQSxTQUFLTCxXQUFMO0FBQ0E7O0FBR0RBLGFBQVcsR0FBRztBQUNiLFFBQUcsS0FBS00sSUFBTCxLQUFjbDZCLFNBQWQsSUFBMkIsS0FBSzA1QixZQUFMLEdBQW9CLEtBQUtRLElBQXZELEVBQTZEO0FBQzVELFdBQUtSLFlBQUwsR0FBb0IsS0FBS1EsSUFBekI7QUFDQTs7QUFFRCxRQUFHLEtBQUtDLElBQUwsS0FBY242QixTQUFkLElBQTJCLEtBQUswNUIsWUFBTCxHQUFvQixLQUFLUyxJQUF2RCxFQUE2RDtBQUM1RCxXQUFLVCxZQUFMLEdBQW9CLEtBQUtTLElBQXpCO0FBQ0E7QUFDRDs7QUFHRHQrQixTQUFPLEdBQUc7QUFDVG9GLHNEQUFTLENBQUNvcEIsUUFBVixDQUFtQixLQUFLTixRQUF4QjtBQUNBLEdBckRlLENBd0RoQjs7O0FBRUEsTUFBSXpyQixLQUFKLENBQVVGLE1BQVYsRUFBa0I7QUFDakIsU0FBS3M3QixZQUFMLEdBQW9CdDdCLE1BQXBCO0FBQ0E7O0FBRUQsTUFBSUUsS0FBSixHQUFZO0FBQ1gsV0FBTyxLQUFLTCxNQUFaO0FBQ0E7O0FBRUQsTUFBSW04QixXQUFKLEdBQWtCO0FBQ2pCLFdBQU8sS0FBS1YsWUFBWjtBQUNBOztBQXBFZTs7QUF5RUZ2NEIseUVBQWYsRTs7Ozs7Ozs7Ozs7O0FDN0VBO0FBQUE7QUFFQSxJQUFJazVCLG9CQUFvQixHQUFHLElBQTNCOztBQUNBLElBQUk7QUFDSCxNQUFJQyxrQkFBa0IsR0FBRy84QixRQUFRLENBQUNnOUIsV0FBVCxDQUFxQixhQUFyQixDQUF6QjtBQUNBRCxvQkFBa0IsR0FBRyxJQUFyQjtBQUNBLENBSEQsQ0FHRSxPQUFNOTlCLENBQU4sRUFBUztBQUNWNjlCLHNCQUFvQixHQUFHLEtBQXZCO0FBQ0E7O0FBRUQsTUFBTW41QixlQUFOLENBQXNCO0FBRXJCbkQsYUFBVyxHQUFHO0FBQ2IsU0FBS3k4QixlQUFMLEdBQXVCLEVBQXZCO0FBQ0E7O0FBR0QzOUIsa0JBQWdCLENBQUM0OUIsVUFBRCxFQUFhQyxTQUFiLEVBQXdCO0FBRXZDLFFBQUcsS0FBS0YsZUFBTCxLQUF5QixJQUF6QixJQUFpQyxLQUFLQSxlQUFMLEtBQXlCeDZCLFNBQTdELEVBQXdFO0FBQ3ZFLFdBQUt3NkIsZUFBTCxHQUF1QixFQUF2QjtBQUNBOztBQUVELFFBQUcsQ0FBQyxLQUFLQSxlQUFMLENBQXFCQyxVQUFyQixDQUFKLEVBQXNDO0FBQ3JDLFdBQUtELGVBQUwsQ0FBcUJDLFVBQXJCLElBQW1DLEVBQW5DO0FBQ0E7O0FBQ0QsU0FBS0QsZUFBTCxDQUFxQkMsVUFBckIsRUFBaUM1L0IsSUFBakMsQ0FBc0M2L0IsU0FBdEM7O0FBRUEsV0FBTyxJQUFQO0FBRUE7O0FBRURDLElBQUUsQ0FBQ0YsVUFBRCxFQUFhQyxTQUFiLEVBQXdCO0FBQUUsV0FBTyxLQUFLNzlCLGdCQUFMLENBQXNCNDlCLFVBQXRCLEVBQWtDQyxTQUFsQyxDQUFQO0FBQXNEOztBQUVsRnpQLHFCQUFtQixDQUFDd1AsVUFBRCxFQUFhQyxTQUFiLEVBQXdCO0FBQzFDLFFBQUcsS0FBS0YsZUFBTCxLQUF5QixJQUF6QixJQUFpQyxLQUFLQSxlQUFMLEtBQXlCeDZCLFNBQTdELEVBQXdFO0FBQ3ZFLFdBQUt3NkIsZUFBTCxHQUF1QixFQUF2QjtBQUNBOztBQUNELFVBQU1JLFlBQVksR0FBRyxLQUFLSixlQUFMLENBQXFCQyxVQUFyQixDQUFyQjs7QUFFQSxRQUFJLE9BQU9HLFlBQVAsS0FBeUIsV0FBN0IsRUFBMEM7QUFDekMsYUFBTyxJQUFQO0FBQ0E7O0FBRUQsUUFBSUMsa0JBQWtCLEdBQUdELFlBQVksQ0FBQzFnQyxNQUF0Qzs7QUFDQSxTQUFJLElBQUk2QixDQUFDLEdBQUcsQ0FBWixFQUFlQSxDQUFDLEdBQUc4K0Isa0JBQW5CLEVBQXVDOStCLENBQUMsRUFBeEMsRUFBNEM7QUFDM0MsVUFBRzYrQixZQUFZLENBQUM3K0IsQ0FBRCxDQUFaLEtBQW9CMitCLFNBQXZCLEVBQWtDO0FBQ2pDRSxvQkFBWSxDQUFDblEsTUFBYixDQUFvQjF1QixDQUFwQixFQUF1QixDQUF2QjtBQUNBQSxTQUFDO0FBQ0Q4K0IsMEJBQWtCO0FBQ2xCO0FBQ0Q7O0FBQ0QsV0FBTyxJQUFQO0FBQ0E7O0FBRURDLEtBQUcsQ0FBQ0wsVUFBRCxFQUFhQyxTQUFiLEVBQXdCO0FBQUUsV0FBTyxLQUFLelAsbUJBQUwsQ0FBeUJ3UCxVQUF6QixFQUFxQ0MsU0FBckMsQ0FBUDtBQUF5RDs7QUFFdEZLLGVBQWEsQ0FBQ0MsTUFBRCxFQUFTO0FBQ3JCLFFBQUcsS0FBS1IsZUFBTCxLQUF5QixJQUF6QixJQUFpQyxLQUFLQSxlQUFMLEtBQXlCeDZCLFNBQTdELEVBQXdFO0FBQ3ZFLFdBQUt3NkIsZUFBTCxHQUF1QixFQUF2QjtBQUNBOztBQUNELFVBQU1TLFNBQVMsR0FBR0QsTUFBTSxDQUFDOXdCLElBQXpCOztBQUVBLFFBQUk7QUFDSCxVQUFHOHdCLE1BQU0sQ0FBQ3BHLE1BQVAsS0FBa0IsSUFBckIsRUFBMkI7QUFDMUJvRyxjQUFNLENBQUNwRyxNQUFQLEdBQWdCLElBQWhCO0FBQ0E7O0FBQ0RvRyxZQUFNLENBQUNFLGFBQVAsR0FBdUIsSUFBdkI7QUFDQSxLQUxELENBS0UsT0FBTUMsUUFBTixFQUFnQjtBQUNqQixZQUFNQyxRQUFRLEdBQUc7QUFBRWx4QixZQUFJLEVBQUUrd0IsU0FBUjtBQUFtQkksY0FBTSxFQUFFTCxNQUFNLENBQUNLLE1BQWxDO0FBQTBDQyxrQkFBVSxFQUFFO0FBQXRELE9BQWpCO0FBQ0EsYUFBTyxLQUFLUCxhQUFMLENBQW1CSyxRQUFuQixDQUFQO0FBQ0E7O0FBRUQsVUFBTUcscUJBQXFCLEdBQUcsS0FBS2YsZUFBTCxDQUFxQlMsU0FBckIsQ0FBOUI7O0FBQ0EsUUFBR00scUJBQXFCLEtBQUssSUFBMUIsSUFBa0NBLHFCQUFxQixLQUFLdjdCLFNBQS9ELEVBQTBFO0FBQ3pFLFlBQU00NkIsWUFBWSxHQUFHLEtBQUtZLFVBQUwsQ0FBZ0JELHFCQUFoQixDQUFyQjs7QUFDQSxZQUFNVixrQkFBa0IsR0FBR0QsWUFBWSxDQUFDMWdDLE1BQXhDOztBQUNBLFdBQUksSUFBSTZCLENBQUMsR0FBRyxDQUFaLEVBQWVBLENBQUMsR0FBRzgrQixrQkFBbkIsRUFBdUM5K0IsQ0FBQyxFQUF4QyxFQUE0QztBQUMzQyxjQUFNMC9CLGVBQWUsR0FBR2IsWUFBWSxDQUFDNytCLENBQUQsQ0FBcEM7QUFDQTAvQix1QkFBZSxDQUFDQyxJQUFoQixDQUFxQixJQUFyQixFQUEyQlYsTUFBM0I7QUFDQTtBQUNEOztBQUNELFdBQU8sSUFBUDtBQUNBOztBQUVEVyxxQkFBbUIsQ0FBQ2xCLFVBQUQsRUFBYW1CLE9BQWIsRUFBc0I7QUFDeEMsUUFBSVIsUUFBSjs7QUFDQSxRQUFJZixvQkFBSixFQUEwQjtBQUN6QmUsY0FBUSxHQUFHNzlCLFFBQVEsQ0FBQ2c5QixXQUFULENBQXFCLGFBQXJCLENBQVg7QUFDQWEsY0FBUSxDQUFDRSxVQUFULEdBQXNCLElBQXRCO0FBQ0FGLGNBQVEsQ0FBQ1MsZUFBVCxDQUF5QnBCLFVBQXpCLEVBQXFDLEtBQXJDLEVBQTRDLEtBQTVDLEVBQW1EbUIsT0FBbkQ7QUFDQSxLQUpELE1BSU87QUFDTlIsY0FBUSxHQUFHO0FBQUVseEIsWUFBSSxFQUFFdXdCLFVBQVI7QUFBb0JZLGNBQU0sRUFBRU8sT0FBNUI7QUFBcUNOLGtCQUFVLEVBQUU7QUFBakQsT0FBWDtBQUNBOztBQUNELFdBQU8sS0FBS1AsYUFBTCxDQUFtQkssUUFBbkIsQ0FBUDtBQUNBOztBQUVEVSxTQUFPLENBQUNyQixVQUFELEVBQWFtQixPQUFiLEVBQXNCO0FBQUUsV0FBTyxLQUFLRCxtQkFBTCxDQUF5QmxCLFVBQXpCLEVBQXFDbUIsT0FBckMsQ0FBUDtBQUF1RDs7QUFFdEZHLFVBQVEsR0FBRztBQUNWLFFBQUcsS0FBS3ZCLGVBQUwsS0FBeUIsSUFBNUIsRUFBa0M7QUFDakMsV0FBSSxNQUFNd0IsVUFBVixJQUF3QixLQUFLeEIsZUFBN0IsRUFBOEM7QUFDN0MsWUFBRyxLQUFLQSxlQUFMLENBQXFCeUIsY0FBckIsQ0FBb0NELFVBQXBDLENBQUgsRUFBb0Q7QUFDbkQsZ0JBQU1wQixZQUFZLEdBQUcsS0FBS0osZUFBTCxDQUFxQndCLFVBQXJCLENBQXJCO0FBQ0EsZ0JBQU1uQixrQkFBa0IsR0FBR0QsWUFBWSxDQUFDMWdDLE1BQXhDOztBQUNBLGVBQUksSUFBSTZCLENBQUMsR0FBRyxDQUFaLEVBQWVBLENBQUMsR0FBRzgrQixrQkFBbkIsRUFBdUM5K0IsQ0FBQyxFQUF4QyxFQUE0QztBQUMzQzYrQix3QkFBWSxDQUFDNytCLENBQUQsQ0FBWixHQUFrQixJQUFsQjtBQUNBOztBQUNELGlCQUFPLEtBQUt5K0IsZUFBTCxDQUFxQndCLFVBQXJCLENBQVA7QUFDQTtBQUNEOztBQUNELFdBQUt4QixlQUFMLEdBQXVCLElBQXZCO0FBQ0E7QUFDRDs7QUFFRGdCLFlBQVUsQ0FBQ1UsTUFBRCxFQUFTO0FBQ2xCLFVBQU10QixZQUFZLEdBQUcsSUFBSW5sQixLQUFKLENBQVV5bUIsTUFBTSxDQUFDaGlDLE1BQWpCLENBQXJCO0FBQ0EsVUFBTTJnQyxrQkFBa0IsR0FBR0QsWUFBWSxDQUFDMWdDLE1BQXhDOztBQUNBLFNBQUksSUFBSTZCLENBQUMsR0FBRyxDQUFaLEVBQWVBLENBQUMsR0FBRzgrQixrQkFBbkIsRUFBdUM5K0IsQ0FBQyxFQUF4QyxFQUE0QztBQUMzQzYrQixrQkFBWSxDQUFDNytCLENBQUQsQ0FBWixHQUFrQm1nQyxNQUFNLENBQUNuZ0MsQ0FBRCxDQUF4QjtBQUNBOztBQUNELFdBQU82K0IsWUFBUDtBQUNBOztBQWhIb0I7O0FBb0hQMTVCLDhFQUFmLEU7Ozs7Ozs7Ozs7OztBQzlIQTtBQUFBO0FBRWUsZ0VBQ2Qsd0JBRGMsRUFFZCxVQUZjLEVBR2QsZ0JBSGMsRUFJZCxtQkFKYyxFQUtkLHdCQUxjLEVBTWQsMEJBTmMsRUFPZCwrQkFQYyxFQVFkLDBCQVJjLEVBU2QscUJBVGMsRUFVZCxnQ0FWYyxFQVdkLHlCQVhjLEVBWWQsd0JBWmMsRUFhZCxvQkFiYyxDQUFmLEU7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQUE7Q0FJQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTWk3QixlQUFlLEdBQUcsY0FBeEI7QUFDQSxNQUFNQyxjQUFjLEdBQUcsS0FBdkIsQyxDQUNBOztBQUNBLE1BQU1DLGVBQWUsR0FBRyxnQ0FBeEI7QUFDQSxNQUFNQyxhQUFhLEdBQUcsd0JBQXRCO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUcsMkJBQTNCLEMsQ0FFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTQyxnQkFBVCxDQUEwQi9oQixNQUExQixFQUFrQzlPLElBQWxDLEVBQXdDb0IsTUFBeEMsRUFBZ0QwdkIsVUFBaEQsRUFBNERDLGFBQTVELEVBQTJFQyxZQUEzRSxFQUF5RjtBQUN4RixRQUFNQyxJQUFJLEdBQUcsSUFBSW5uQixLQUFKLENBQVUsQ0FBVixDQUFiO0FBQ0EsTUFBSW9uQixjQUFjLEdBQUcsSUFBckI7QUFDQSxNQUFJQyxHQUFKO0FBQ0EsTUFBSUMsTUFBSjtBQUNBLE1BQUl2ZSxLQUFKO0FBQ0EsUUFBTXdlLEdBQUcsR0FBRyxJQUFJdm5CLEtBQUosQ0FBVSxDQUFWLENBQVo7QUFDQSxRQUFNd25CLFlBQVksR0FBR3hpQixNQUFNLENBQUN2Z0IsTUFBNUI7O0FBRUEsV0FBU2dqQyxPQUFULENBQWlCRixHQUFqQixFQUFzQjtBQUNyQixRQUFJRyxTQUFTLEdBQUcsQ0FBaEI7O0FBQ0EsT0FBRztBQUNGSCxTQUFHLENBQUNHLFNBQVMsRUFBVixDQUFILEdBQW1CMWlCLE1BQU0sQ0FBQ2dpQixVQUFELENBQXpCO0FBQ0EsS0FGRCxRQUVRLEVBQUVBLFVBQUYsR0FBZVEsWUFBZixJQUErQkUsU0FBUyxHQUFHSCxHQUFHLENBQUM5aUMsTUFGdkQ7O0FBR0EsV0FBT2lqQyxTQUFQO0FBQ0E7O0FBRUQsV0FBU0MsYUFBVCxDQUF1QkosR0FBdkIsRUFBNEJqd0IsTUFBNUIsRUFBb0M3UyxNQUFwQyxFQUE0QztBQUMzQyxRQUFJaWpDLFNBQVMsR0FBRyxDQUFoQjs7QUFDQSxPQUFHO0FBQ0ZILFNBQUcsQ0FBQ2p3QixNQUFNLEdBQUdvd0IsU0FBUyxFQUFuQixDQUFILEdBQTRCMWlCLE1BQU0sQ0FBQ2dpQixVQUFELENBQWxDO0FBQ0EsS0FGRCxRQUVRLEVBQUVBLFVBQUYsR0FBZVEsWUFBZixJQUErQkUsU0FBUyxHQUFHampDLE1BRm5EOztBQUdBLFdBQU9pakMsU0FBUDtBQUNBOztBQUVELFdBQVNFLGFBQVQsQ0FBdUI1aUIsTUFBdkIsRUFBK0I5TyxJQUEvQixFQUFxQ29CLE1BQXJDLEVBQTZDdXdCLFNBQTdDLEVBQXdEO0FBQ3ZELFVBQU1DLFdBQVcsR0FBRyxJQUFJRCxTQUF4QjtBQUNBLFVBQU1FLE9BQU8sR0FBR0osYUFBYSxDQUFDenhCLElBQUQsRUFBT29CLE1BQVAsRUFBZXd3QixXQUFmLENBQTdCOztBQUNBLFFBQUlDLE9BQU8sR0FBR0QsV0FBZCxFQUEyQjtBQUMxQixZQUFNLElBQUlFLEtBQUosQ0FBVyxpQ0FBZ0NELE9BQVEsb0JBQW1CRCxXQUFZLEVBQWxGLENBQU47QUFDQTtBQUNEOztBQUVELFNBQU9aLFlBQVksR0FBRyxDQUF0QixFQUF5QjtBQUN4QixRQUFJTyxPQUFPLENBQUNOLElBQUQsQ0FBUCxHQUFnQkEsSUFBSSxDQUFDMWlDLE1BQXpCLEVBQWlDO0FBQ2hDLFlBQU0sSUFBSXVqQyxLQUFKLENBQVcsaUNBQWdDYixJQUFJLENBQUMxaUMsTUFBTyxFQUF2RCxDQUFOO0FBQ0E7O0FBRUQsUUFBSzBpQyxJQUFJLENBQUMsQ0FBRCxDQUFKLEtBQVksQ0FBYixJQUFvQkEsSUFBSSxDQUFDLENBQUQsQ0FBSixLQUFZLENBQWhDLElBQXVDLENBQUNBLElBQUksQ0FBQyxDQUFELENBQUosR0FBVSxJQUFYLE1BQXFCLENBQWhFLEVBQW9FO0FBQ25FO0FBQ0FqeEIsVUFBSSxDQUFDb0IsTUFBTSxFQUFQLENBQUosR0FBaUI2dkIsSUFBSSxDQUFDLENBQUQsQ0FBckI7QUFDQWp4QixVQUFJLENBQUNvQixNQUFNLEVBQVAsQ0FBSixHQUFpQjZ2QixJQUFJLENBQUMsQ0FBRCxDQUFyQjtBQUNBanhCLFVBQUksQ0FBQ29CLE1BQU0sRUFBUCxDQUFKLEdBQWlCNnZCLElBQUksQ0FBQyxDQUFELENBQXJCO0FBQ0FqeEIsVUFBSSxDQUFDb0IsTUFBTSxFQUFQLENBQUosR0FBaUI2dkIsSUFBSSxDQUFDLENBQUQsQ0FBckI7QUFDQVMsbUJBQWEsQ0FBQzVpQixNQUFELEVBQVM5TyxJQUFULEVBQWVvQixNQUFmLEVBQXVCMnZCLGFBQWEsR0FBR0MsWUFBaEIsR0FBK0IsQ0FBdEQsQ0FBYjtBQUNBO0FBQ0E7O0FBRUQsUUFBSSxDQUFFLENBQUNDLElBQUksQ0FBQyxDQUFELENBQUosR0FBVSxJQUFYLEtBQW9CLENBQXJCLEdBQTJCQSxJQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVUsSUFBdEMsTUFBaURGLGFBQXJELEVBQW9FO0FBQ25FLFlBQU0sSUFBSWUsS0FBSixDQUFXLHdCQUF5QixDQUFDYixJQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVUsSUFBWCxLQUFvQixDQUFyQixHQUEyQkEsSUFBSSxDQUFDLENBQUQsQ0FBSixHQUFVLElBQU8sY0FBYUYsYUFBYyxFQUExRyxDQUFOO0FBQ0E7O0FBRUQsUUFBSUcsY0FBYyxLQUFLLElBQXZCLEVBQTZCO0FBQzVCQSxvQkFBYyxHQUFHLElBQUlwbkIsS0FBSixDQUFVLElBQUlpbkIsYUFBZCxDQUFqQjtBQUNBOztBQUVESSxPQUFHLEdBQUcsQ0FBTjtBQUNBOztBQUNBLFNBQUssSUFBSS9nQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLENBQXBCLEVBQXVCQSxDQUFDLEVBQXhCLEVBQTRCO0FBQzNCZ2hDLFlBQU0sR0FBRyxDQUFDaGhDLENBQUMsR0FBRyxDQUFMLElBQVUyZ0MsYUFBbkI7O0FBQ0EsYUFBTUksR0FBRyxHQUFHQyxNQUFaLEVBQW9CO0FBQ25CLFlBQUlHLE9BQU8sQ0FBQ0YsR0FBRCxDQUFQLEdBQWVBLEdBQUcsQ0FBQzlpQyxNQUF2QixFQUErQjtBQUM5QixnQkFBTSxJQUFJdWpDLEtBQUosQ0FBVSw2QkFBVixDQUFOO0FBQ0E7O0FBQ0QsWUFBSSxDQUFDVCxHQUFHLENBQUMsQ0FBRCxDQUFILEdBQVMsSUFBVixJQUFrQixHQUF0QixFQUEyQjtBQUMxQjtBQUNBeGUsZUFBSyxHQUFHLENBQUN3ZSxHQUFHLENBQUMsQ0FBRCxDQUFILEdBQVMsSUFBVixJQUFrQixHQUExQjs7QUFDQSxjQUFLeGUsS0FBSyxLQUFLLENBQVgsSUFBa0JBLEtBQUssR0FBR3VlLE1BQU0sR0FBR0QsR0FBdkMsRUFBNkM7QUFDNUMsa0JBQU0sSUFBSVcsS0FBSixDQUFVLG1CQUFWLENBQU47QUFDQTs7QUFDRCxpQkFBTWpmLEtBQUssS0FBSyxDQUFoQixFQUFtQjtBQUNsQnFlLDBCQUFjLENBQUNDLEdBQUcsRUFBSixDQUFkLEdBQXdCRSxHQUFHLENBQUMsQ0FBRCxDQUEzQjtBQUNBO0FBQ0QsU0FURCxNQVNPO0FBQ047QUFDQXhlLGVBQUssR0FBR3dlLEdBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxJQUFqQjs7QUFDQSxjQUFLeGUsS0FBSyxLQUFLLENBQVgsSUFBa0JBLEtBQUssR0FBR3VlLE1BQU0sR0FBR0QsR0FBdkMsRUFBNkM7QUFDNUMsa0JBQU0sSUFBSVcsS0FBSixDQUFVLG1CQUFWLENBQU47QUFDQTs7QUFDRFosd0JBQWMsQ0FBQ0MsR0FBRyxFQUFKLENBQWQsR0FBd0JFLEdBQUcsQ0FBQyxDQUFELENBQTNCOztBQUNBLGNBQUksRUFBRXhlLEtBQUYsR0FBVSxDQUFkLEVBQWlCO0FBQ2hCLGdCQUFJNGUsYUFBYSxDQUFDUCxjQUFELEVBQWlCQyxHQUFqQixFQUFzQnRlLEtBQXRCLENBQWIsR0FBNENBLEtBQWhELEVBQXVEO0FBQ3RELG9CQUFNLElBQUlpZixLQUFKLENBQVUsNEJBQVYsQ0FBTjtBQUNBOztBQUNEWCxlQUFHLElBQUl0ZSxLQUFQO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFFRDs7O0FBQ0EsU0FBSSxJQUFJemlCLENBQUMsR0FBRyxDQUFaLEVBQWVBLENBQUMsR0FBRzJnQyxhQUFuQixFQUFrQzNnQyxDQUFDLEVBQW5DLEVBQXVDO0FBQ3RDNFAsVUFBSSxDQUFDb0IsTUFBTSxHQUFHLENBQVYsQ0FBSixHQUFtQjh2QixjQUFjLENBQUM5Z0MsQ0FBRCxDQUFqQztBQUNBNFAsVUFBSSxDQUFDb0IsTUFBTSxHQUFHLENBQVYsQ0FBSixHQUFtQjh2QixjQUFjLENBQUM5Z0MsQ0FBQyxHQUFHMmdDLGFBQUwsQ0FBakM7QUFDQS93QixVQUFJLENBQUNvQixNQUFNLEdBQUcsQ0FBVixDQUFKLEdBQW1COHZCLGNBQWMsQ0FBQzlnQyxDQUFDLEdBQUcsSUFBSTJnQyxhQUFULENBQWpDO0FBQ0Evd0IsVUFBSSxDQUFDb0IsTUFBTSxHQUFHLENBQVYsQ0FBSixHQUFtQjh2QixjQUFjLENBQUM5Z0MsQ0FBQyxHQUFHLElBQUkyZ0MsYUFBVCxDQUFqQztBQUNBM3ZCLFlBQU0sSUFBSSxDQUFWO0FBQ0E7O0FBRUQ0dkIsZ0JBQVk7QUFDWjtBQUVELEMsQ0FFRDs7O0FBQ0EsU0FBU2UsUUFBVCxDQUFrQmpqQixNQUFsQixFQUEwQjtBQUN6QixNQUFJQSxNQUFNLFlBQVlrakIsV0FBdEIsRUFBbUM7QUFDbENsakIsVUFBTSxHQUFHLElBQUlsRixVQUFKLENBQWVrRixNQUFmLENBQVQ7QUFDQTs7QUFFRCxNQUFJZ2lCLFVBQVUsR0FBRyxDQUFqQjtBQUNBLFFBQU1RLFlBQVksR0FBR3hpQixNQUFNLENBQUN2Z0IsTUFBNUI7QUFFQSxRQUFNMGpDLFFBQVEsR0FBRyxFQUFqQjs7QUFFQSxXQUFTQyxRQUFULEdBQW9CO0FBQ25CLFFBQUliLEdBQUcsR0FBRyxFQUFWOztBQUNBLE9BQUc7QUFDRixZQUFNdnlCLENBQUMsR0FBR2dRLE1BQU0sQ0FBQ2dpQixVQUFELENBQWhCOztBQUNBLFVBQUloeUIsQ0FBQyxLQUFLbXpCLFFBQVYsRUFBb0I7QUFDbkIsVUFBRW5CLFVBQUY7QUFDQTtBQUNBOztBQUNETyxTQUFHLElBQUljLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQnR6QixDQUFwQixDQUFQO0FBQ0EsS0FQRCxRQU9RLEVBQUVneUIsVUFBRixHQUFlUSxZQVB2Qjs7QUFRQSxXQUFPRCxHQUFQO0FBQ0E7O0FBRUQsTUFBSXQzQixLQUFLLEdBQUcsQ0FBWjtBQUNBLE1BQUlDLE1BQU0sR0FBRyxDQUFiO0FBQ0EsTUFBSStNLFFBQVEsR0FBRyxDQUFmO0FBQ0EsUUFBTXNyQixLQUFLLEdBQUcsQ0FBZDtBQUNBLE1BQUlDLEdBQUcsR0FBRyxLQUFWOztBQUVBLE9BQUksSUFBSWxpQyxDQUFDLEdBQUcsQ0FBWixFQUFlQSxDQUFDLEdBQUcsRUFBbkIsRUFBdUJBLENBQUMsRUFBeEIsRUFBNEI7QUFDM0IsVUFBTSszQixJQUFJLEdBQUcrSixRQUFRLEVBQXJCO0FBQ0EsUUFBSUssS0FBSjs7QUFDQSxRQUFJQSxLQUFLLEdBQUdwSyxJQUFJLENBQUNvSyxLQUFMLENBQVcvQixlQUFYLENBQVosRUFBeUMsQ0FDeEMsQ0FERCxNQUNPLElBQUkrQixLQUFLLEdBQUdwSyxJQUFJLENBQUNvSyxLQUFMLENBQVc1QixhQUFYLENBQVosRUFBdUM7QUFDN0MyQixTQUFHLEdBQUcsSUFBTjtBQUNBLEtBRk0sTUFFQSxJQUFJQyxLQUFLLEdBQUdwSyxJQUFJLENBQUNvSyxLQUFMLENBQVc3QixlQUFYLENBQVosRUFBeUM7QUFDL0MzcEIsY0FBUSxHQUFHeXJCLE1BQU0sQ0FBQ0QsS0FBSyxDQUFDLENBQUQsQ0FBTixDQUFqQjtBQUNBLEtBRk0sTUFFQSxJQUFJQSxLQUFLLEdBQUdwSyxJQUFJLENBQUNvSyxLQUFMLENBQVc5QixjQUFYLENBQVosRUFBd0MsQ0FDOUMsQ0FETSxNQUNBLElBQUk4QixLQUFLLEdBQUdwSyxJQUFJLENBQUNvSyxLQUFMLENBQVczQixrQkFBWCxDQUFaLEVBQTRDO0FBQ2xENTJCLFlBQU0sR0FBR3c0QixNQUFNLENBQUNELEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBZjtBQUNBeDRCLFdBQUssR0FBR3k0QixNQUFNLENBQUNELEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBZDtBQUNBO0FBQ0E7QUFDRDs7QUFFRCxNQUFJLENBQUNELEdBQUwsRUFBVTtBQUNULFVBQU0sSUFBSVIsS0FBSixDQUFVLGlDQUFWLENBQU47QUFDQTs7QUFFRCxRQUFNOXhCLElBQUksR0FBRyxJQUFJNEosVUFBSixDQUFlN1AsS0FBSyxHQUFHQyxNQUFSLEdBQWlCLENBQWhDLENBQWI7QUFDQSxRQUFNKzJCLGFBQWEsR0FBR2gzQixLQUF0QjtBQUNBLFFBQU1pM0IsWUFBWSxHQUFHaDNCLE1BQXJCO0FBRUE2MkIsa0JBQWdCLENBQUMvaEIsTUFBRCxFQUFTOU8sSUFBVCxFQUFlLENBQWYsRUFBa0I4d0IsVUFBbEIsRUFBOEJDLGFBQTlCLEVBQTZDQyxZQUE3QyxDQUFoQixDQXJEeUIsQ0F1RHpCOztBQUNBLFFBQU15QixTQUFTLEdBQUcsSUFBSXZ4QixZQUFKLENBQWlCbkgsS0FBSyxHQUFHQyxNQUFSLEdBQWlCLENBQWxDLENBQWxCOztBQUNBLE9BQUksSUFBSW9ILE1BQU0sR0FBRyxDQUFqQixFQUFvQkEsTUFBTSxHQUFHcEIsSUFBSSxDQUFDelIsTUFBbEMsRUFBMEM2UyxNQUFNLElBQUksQ0FBcEQsRUFBdUQ7QUFDdEQsUUFBSXhDLENBQUMsR0FBR29CLElBQUksQ0FBQ29CLE1BQU0sR0FBRyxDQUFWLENBQUosR0FBbUIsR0FBM0I7QUFDQSxRQUFJdkMsQ0FBQyxHQUFHbUIsSUFBSSxDQUFDb0IsTUFBTSxHQUFHLENBQVYsQ0FBSixHQUFtQixHQUEzQjtBQUNBLFFBQUl0QyxDQUFDLEdBQUdrQixJQUFJLENBQUNvQixNQUFNLEdBQUcsQ0FBVixDQUFKLEdBQW1CLEdBQTNCO0FBQ0EsVUFBTXZRLENBQUMsR0FBR21QLElBQUksQ0FBQ29CLE1BQU0sR0FBRyxDQUFWLENBQWQ7QUFDQSxVQUFNc3hCLENBQUMsR0FBRzV4QixJQUFJLENBQUM2eEIsR0FBTCxDQUFTLEdBQVQsRUFBYzloQyxDQUFDLEdBQUcsS0FBbEIsQ0FBVjtBQUVBK04sS0FBQyxJQUFJOHpCLENBQUw7QUFDQTd6QixLQUFDLElBQUk2ekIsQ0FBTDtBQUNBNXpCLEtBQUMsSUFBSTR6QixDQUFMO0FBRUEsVUFBTUUsV0FBVyxHQUFHeHhCLE1BQXBCO0FBRUFxeEIsYUFBUyxDQUFDRyxXQUFXLEdBQUcsQ0FBZixDQUFULEdBQTZCaDBCLENBQTdCO0FBQ0E2ekIsYUFBUyxDQUFDRyxXQUFXLEdBQUcsQ0FBZixDQUFULEdBQTZCL3pCLENBQTdCO0FBQ0E0ekIsYUFBUyxDQUFDRyxXQUFXLEdBQUcsQ0FBZixDQUFULEdBQTZCOXpCLENBQTdCO0FBQ0EyekIsYUFBUyxDQUFDRyxXQUFXLEdBQUcsQ0FBZixDQUFULEdBQTZCLEdBQTdCO0FBQ0E7O0FBRUQsU0FBTztBQUNON3lCLFNBQUssRUFBRSxDQUFDaEcsS0FBRCxFQUFRQyxNQUFSLENBREQ7QUFFTitNLFlBRk07QUFHTnNyQixTQUhNO0FBSU5yeUIsUUFBSSxFQUFFeXlCO0FBSkEsR0FBUDtBQU1BOztBQUdjVix1RUFBZixFOzs7Ozs7Ozs7Ozs7QUNqTkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBOztBQUVBLE1BQU1jLFFBQVEsR0FBRyxVQUFVQyxNQUFWLEVBQWtCdEosT0FBbEIsRUFBMkI7QUFFM0MsUUFBTTM2QixDQUFDLEdBQUcyNkIsT0FBTyxJQUFJLEVBQXJCOztBQUNBLE1BQUdzSixNQUFNLENBQUNDLE9BQVYsRUFBbUI7QUFDbEJsa0MsS0FBQyxDQUFDZ1gsQ0FBRixHQUFNaXRCLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlLENBQWYsRUFBa0JDLEtBQXhCO0FBQ0Fua0MsS0FBQyxDQUFDc2QsQ0FBRixHQUFNMm1CLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlLENBQWYsRUFBa0JFLEtBQXhCO0FBQ0EsR0FIRCxNQUdPO0FBQ05wa0MsS0FBQyxDQUFDZ1gsQ0FBRixHQUFNaXRCLE1BQU0sQ0FBQ0ksT0FBYjtBQUNBcmtDLEtBQUMsQ0FBQ3NkLENBQUYsR0FBTTJtQixNQUFNLENBQUNLLE9BQWI7QUFDQTs7QUFFRCxTQUFPdGtDLENBQVA7QUFDQSxDQVpEOztBQWNBLE1BQU1tSCxjQUFOLENBQXFCO0FBRXBCNUQsYUFBVyxDQUFDbzNCLE9BQUQsRUFBVTRKLGVBQWUsR0FBR3ppQyxNQUE1QixFQUFvQ3c1QixPQUFPLEdBQUcsR0FBOUMsRUFBbUQ7QUFDN0QsU0FBS2tKLE9BQUwsR0FBdUI3SixPQUF2QjtBQUNBLFNBQUs4SixlQUFMLEdBQXVCRixlQUF2QjtBQUNBLFNBQUtHLE1BQUwsR0FBdUIsRUFBdkI7QUFDQSxTQUFLQyxTQUFMLEdBQXVCLEVBQXZCO0FBQ0EsU0FBS2hnQyxNQUFMLEdBQXVCeU8sOENBQUksQ0FBQ29JLE1BQUwsRUFBdkI7QUFDQSxTQUFLb3BCLEdBQUwsR0FBdUJ4eEIsOENBQUksQ0FBQzBZLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBdkI7QUFDQSxTQUFLdm5CLE1BQUwsR0FBdUIsSUFBSW9DLGlEQUFKLENBQWUyMEIsT0FBZixDQUF2QjtBQUNBLFNBQUszUSxRQUFMLEdBQXVCdlgsOENBQUksQ0FBQzBZLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsS0FBS3ZuQixNQUFMLENBQVlULEtBQWxDLENBQXZCO0FBQ0EsU0FBS2lCLGNBQUwsR0FBdUJxTyw4Q0FBSSxDQUFDb0ksTUFBTCxFQUF2QjtBQUNBLFNBQUs0aEIsR0FBTCxHQUF1QixJQUFJejJCLGlEQUFKLENBQWUsQ0FBZixDQUF2Qjs7QUFDQSxTQUFLeTJCLEdBQUwsQ0FBU21DLEtBQVQsQ0FBZSxDQUFDdHRCLElBQUksQ0FBQ29SLEVBQU4sR0FBVyxDQUExQixFQUE2QnBSLElBQUksQ0FBQ29SLEVBQUwsR0FBVSxDQUF2Qzs7QUFDQSxTQUFLZ2EsR0FBTCxHQUF1QixJQUFJMTJCLGlEQUFKLENBQWUsQ0FBZixDQUF2QjtBQUNBLFNBQUtrK0IsTUFBTCxHQUF1QixDQUF2QjtBQUNBLFNBQUtDLE1BQUwsR0FBdUIsQ0FBdkI7QUFFQSxTQUFLQyxXQUFMLEdBQXVCLEtBQXZCO0FBQ0EsU0FBS0MsZUFBTCxHQUF1QixLQUF2QjtBQUNBLFNBQUtDLFNBQUwsR0FBdUIsS0FBdkI7QUFDQSxTQUFLQyxXQUFMLEdBQW9CLEdBQXBCOztBQUdBLFNBQUtDLFVBQUwsR0FBbUJuakMsQ0FBRCxJQUFPLEtBQUtvakMsUUFBTCxDQUFjcGpDLENBQWQsQ0FBekI7O0FBQ0EsU0FBS3FqQyxTQUFMLEdBQWtCcmpDLENBQUQsSUFBTyxLQUFLc2pDLE9BQUwsQ0FBYXRqQyxDQUFiLENBQXhCOztBQUNBLFNBQUt1akMsU0FBTCxHQUFrQnZqQyxDQUFELElBQU8sS0FBS3dqQyxPQUFMLENBQWF4akMsQ0FBYixDQUF4Qjs7QUFDQSxTQUFLeWpDLE9BQUwsR0FBZSxNQUFNLEtBQUtDLEtBQUwsRUFBckI7O0FBRUEsU0FBS25XLFFBQUwsR0FBZ0I5b0IsZ0RBQVMsQ0FBQzhULEtBQVYsQ0FBZ0IsTUFBTSxLQUFLQyxLQUFMLEVBQXRCLENBQWhCO0FBQ0E7O0FBRUQ4VixTQUFPLENBQUNpVSxlQUFELEVBQWtCO0FBQ3hCLFFBQUlBLGVBQUosRUFBcUIsS0FBS0UsZUFBTCxHQUF1QkYsZUFBdkI7QUFDckIsU0FBSy9ULFVBQUw7O0FBRUEsU0FBS2lVLGVBQUwsQ0FBcUJwaUMsZ0JBQXJCLENBQXNDLFlBQXRDLEVBQW9ELEtBQUs4aUMsVUFBekQ7O0FBQ0EsU0FBS1YsZUFBTCxDQUFxQnBpQyxnQkFBckIsQ0FBc0MsZ0JBQXRDLEVBQXdELEtBQUs4aUMsVUFBN0Q7O0FBRUEsU0FBS1YsZUFBTCxDQUFxQnBpQyxnQkFBckIsQ0FBc0MsV0FBdEMsRUFBbUQsS0FBS2dqQyxTQUF4RDs7QUFDQSxTQUFLWixlQUFMLENBQXFCcGlDLGdCQUFyQixDQUFzQyxZQUF0QyxFQUFvRCxLQUFLZ2pDLFNBQXpEOztBQUNBLFNBQUtaLGVBQUwsQ0FBcUJwaUMsZ0JBQXJCLENBQXNDLFdBQXRDLEVBQW1ELEtBQUtrakMsU0FBeEQ7O0FBQ0EsU0FBS2QsZUFBTCxDQUFxQnBpQyxnQkFBckIsQ0FBc0MsV0FBdEMsRUFBbUQsS0FBS2tqQyxTQUF4RDs7QUFDQXpqQyxVQUFNLENBQUNPLGdCQUFQLENBQXdCLFVBQXhCLEVBQW9DLEtBQUtvakMsT0FBekM7QUFDQTNqQyxVQUFNLENBQUNPLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DLEtBQUtvakMsT0FBeEM7QUFHQTs7QUFFRGpWLFlBQVUsR0FBRztBQUNaLFNBQUtpVSxlQUFMLENBQXFCaFUsbUJBQXJCLENBQXlDLFlBQXpDLEVBQXVELEtBQUswVSxVQUE1RDs7QUFDQSxTQUFLVixlQUFMLENBQXFCaFUsbUJBQXJCLENBQXlDLGdCQUF6QyxFQUEyRCxLQUFLMFUsVUFBaEU7O0FBRUEsU0FBS1YsZUFBTCxDQUFxQmhVLG1CQUFyQixDQUF5QyxXQUF6QyxFQUFzRCxLQUFLNFUsU0FBM0Q7O0FBQ0EsU0FBS1osZUFBTCxDQUFxQmhVLG1CQUFyQixDQUF5QyxZQUF6QyxFQUF1RCxLQUFLNFUsU0FBNUQ7O0FBQ0EsU0FBS1osZUFBTCxDQUFxQmhVLG1CQUFyQixDQUF5QyxXQUF6QyxFQUFzRCxLQUFLOFUsU0FBM0Q7O0FBQ0EsU0FBS2QsZUFBTCxDQUFxQmhVLG1CQUFyQixDQUF5QyxXQUF6QyxFQUFzRCxLQUFLOFUsU0FBM0Q7O0FBQ0F6akMsVUFBTSxDQUFDMnVCLG1CQUFQLENBQTJCLFVBQTNCLEVBQXVDLEtBQUtnVixPQUE1QztBQUNBM2pDLFVBQU0sQ0FBQzJ1QixtQkFBUCxDQUEyQixTQUEzQixFQUFzQyxLQUFLZ1YsT0FBM0M7QUFDQSxHQTNEbUIsQ0E4RHBCOzs7QUFFQUUsTUFBSSxDQUFDL2hDLE1BQU0sR0FBRyxJQUFWLEVBQWdCO0FBQ25CLFNBQUttaEMsV0FBTCxHQUFtQm5oQyxNQUFuQjtBQUNBLFNBQUtvaEMsZUFBTCxHQUF1QnBoQyxNQUF2QjtBQUNBLFNBQUtnaUMsWUFBTCxHQUFvQixLQUFwQjtBQUNBOztBQUVEQyxVQUFRLENBQUNqaUMsTUFBTSxHQUFHLElBQVYsRUFBZ0I7QUFDdkIsU0FBS21oQyxXQUFMLEdBQW1CbmhDLE1BQW5CO0FBQ0E7O0FBR0RraUMsY0FBWSxDQUFDbGlDLE1BQU0sR0FBRyxJQUFWLEVBQWdCO0FBQzNCLFNBQUtvaEMsZUFBTCxHQUF1QnBoQyxNQUF2QjtBQUNBOztBQUdEbWlDLGdCQUFjLENBQUM3aUIsUUFBUSxHQUFHLElBQVosRUFBa0I7QUFDL0IsU0FBSytoQixTQUFMLEdBQWlCL2hCLFFBQWpCO0FBQ0EsR0FsRm1CLENBcUZwQjs7O0FBQ0FvaUIsU0FBTyxDQUFDckIsTUFBRCxFQUFTO0FBQ2YsUUFBRyxLQUFLZSxlQUFSLEVBQXlCO0FBQUU7QUFBUzs7QUFDcEMsU0FBS1ksWUFBTCxHQUFvQixJQUFwQjtBQUNBNUIsWUFBUSxDQUFDQyxNQUFELEVBQVMsS0FBS1MsTUFBZCxDQUFSO0FBQ0FWLFlBQVEsQ0FBQ0MsTUFBRCxFQUFTLEtBQUtVLFNBQWQsQ0FBUjtBQUNBLFNBQUtFLE1BQUwsR0FBYyxLQUFLekgsR0FBTCxDQUFTd0MsV0FBdkI7QUFDQSxTQUFLa0YsTUFBTCxHQUFjLEtBQUt6SCxHQUFMLENBQVN1QyxXQUF2QjtBQUNBOztBQUdENEYsU0FBTyxDQUFDdkIsTUFBRCxFQUFTO0FBQ2YsUUFBRyxLQUFLZSxlQUFSLEVBQXlCO0FBQUU7QUFBUzs7QUFDcENoQixZQUFRLENBQUNDLE1BQUQsRUFBUyxLQUFLUyxNQUFkLENBQVI7O0FBQ0EsUUFBR1QsTUFBTSxDQUFDQyxPQUFWLEVBQW1CO0FBQUVELFlBQU0sQ0FBQ2hpQyxjQUFQO0FBQTBCOztBQUUvQyxRQUFHLEtBQUsyakMsWUFBUixFQUFzQjtBQUNyQixVQUFJSSxLQUFLLEdBQUcsRUFBRSxLQUFLdEIsTUFBTCxDQUFZMXRCLENBQVosR0FBZ0IsS0FBSzJ0QixTQUFMLENBQWUzdEIsQ0FBakMsQ0FBWjs7QUFDQSxVQUFHLEtBQUtpdUIsU0FBUixFQUFtQjtBQUFFZSxhQUFLLElBQUksQ0FBQyxDQUFWO0FBQWM7O0FBQ25DLFdBQUszSSxHQUFMLENBQVN2NUIsS0FBVCxHQUFpQixLQUFLZ2hDLE1BQUwsR0FBY2tCLEtBQUssR0FBRyxJQUFSLEdBQWUsS0FBS2QsV0FBbkQ7QUFFQSxVQUFJZSxLQUFLLEdBQUcsRUFBRSxLQUFLdkIsTUFBTCxDQUFZcG5CLENBQVosR0FBZ0IsS0FBS3FuQixTQUFMLENBQWVybkIsQ0FBakMsQ0FBWjs7QUFDQSxVQUFHLEtBQUsybkIsU0FBUixFQUFtQjtBQUFFZ0IsYUFBSyxJQUFJLENBQUMsQ0FBVjtBQUFjOztBQUNuQyxXQUFLN0ksR0FBTCxDQUFTdDVCLEtBQVQsR0FBaUIsS0FBSytnQyxNQUFMLEdBQWNvQixLQUFLLEdBQUcsSUFBUixHQUFlLEtBQUtmLFdBQW5EO0FBQ0E7QUFDRDs7QUFHRFEsT0FBSyxHQUFHO0FBQ1AsUUFBRyxLQUFLVixlQUFSLEVBQXlCO0FBQUU7QUFBUzs7QUFDcEMsU0FBS1ksWUFBTCxHQUFvQixLQUFwQjtBQUNBOztBQUdEUixVQUFRLENBQUNuQixNQUFELEVBQVM7QUFDaEIsUUFBRyxLQUFLYyxXQUFSLEVBQXFCO0FBQUU7QUFBUzs7QUFDaEMsVUFBTTV0QixDQUFDLEdBQUc4c0IsTUFBTSxDQUFDaUMsVUFBakI7QUFDQSxVQUFNcGlCLENBQUMsR0FBR21nQixNQUFNLENBQUNwRCxNQUFqQjtBQUNBLFFBQUkvOEIsS0FBSyxHQUFHLENBQVo7O0FBQ0EsUUFBSWdnQixDQUFKLEVBQU87QUFDTixVQUFJM00sQ0FBSixFQUFPO0FBQ05yVCxhQUFLLEdBQUdxVCxDQUFDLEdBQUcyTSxDQUFKLEdBQVEsRUFBUixHQUFhQSxDQUFiLEdBQWlCLENBQWpCLEdBQXFCLENBQXJCLEdBQXlCLENBQUMsQ0FBbEMsQ0FETSxDQUMrQjtBQUNyQyxPQUZELE1BRU87QUFDTmhnQixhQUFLLEdBQUcsQ0FBQ2dnQixDQUFELEdBQUssQ0FBYixDQURNLENBQ3VCO0FBQzdCO0FBQ0QsS0FORCxNQU1PO0FBQ05oZ0IsV0FBSyxHQUFHcVQsQ0FBQyxHQUFHLEdBQVo7QUFDQTs7QUFFRCxTQUFLNVMsTUFBTCxDQUFZbEIsR0FBWixDQUFnQixDQUFDUyxLQUFELEdBQVMsQ0FBekI7QUFDQSxHQXZJbUIsQ0EwSXBCOzs7QUFFQTBXLE9BQUssR0FBRztBQUVQLFNBQUsyckIsZUFBTDs7QUFFQSxRQUFHLEtBQUszQixPQUFSLEVBQWlCO0FBQ2hCLFdBQUs0QixhQUFMO0FBQ0E7QUFDRDs7QUFHREQsaUJBQWUsR0FBRztBQUNqQixTQUFLeGIsUUFBTCxDQUFjLENBQWQsSUFBbUIxWSxJQUFJLENBQUNzUixHQUFMLENBQVMsS0FBSzZaLEdBQUwsQ0FBU3Q1QixLQUFsQixJQUEyQixLQUFLUyxNQUFMLENBQVlULEtBQTFEO0FBQ0EsVUFBTXVpQyxFQUFFLEdBQUdwMEIsSUFBSSxDQUFDd1IsR0FBTCxDQUFTLEtBQUsyWixHQUFMLENBQVN0NUIsS0FBbEIsSUFBMkIsS0FBS1MsTUFBTCxDQUFZVCxLQUFsRDtBQUNBLFNBQUs2bUIsUUFBTCxDQUFjLENBQWQsSUFBbUIxWSxJQUFJLENBQUN3UixHQUFMLENBQVMsS0FBSzRaLEdBQUwsQ0FBU3Y1QixLQUFULEdBQWlCbU8sSUFBSSxDQUFDb1IsRUFBTCxHQUFVLEdBQXBDLElBQTJDZ2pCLEVBQTlEO0FBQ0EsU0FBSzFiLFFBQUwsQ0FBYyxDQUFkLElBQW1CMVksSUFBSSxDQUFDc1IsR0FBTCxDQUFTLEtBQUs4WixHQUFMLENBQVN2NUIsS0FBVCxHQUFpQm1PLElBQUksQ0FBQ29SLEVBQUwsR0FBVSxHQUFwQyxJQUEyQ2dqQixFQUE5RDtBQUNBanpCLGtEQUFJLENBQUMvUCxHQUFMLENBQVMsS0FBS3NuQixRQUFkLEVBQXdCLEtBQUtBLFFBQTdCLEVBQXVDLEtBQUs1bEIsY0FBNUM7QUFDQTs7QUFFRG9lLGFBQVcsQ0FBQzNlLEVBQUQsRUFBS0MsRUFBTCxFQUFTRixNQUFULEVBQWlCO0FBQzNCLFVBQU0rWSxDQUFDLEdBQUdyTCxJQUFJLENBQUNzUixHQUFMLENBQVMvZSxFQUFULElBQWVELE1BQXpCO0FBQ0EsVUFBTThoQyxFQUFFLEdBQUdwMEIsSUFBSSxDQUFDd1IsR0FBTCxDQUFTamYsRUFBVCxJQUFlRCxNQUExQjtBQUNBLFVBQU15UyxDQUFDLEdBQUcvRSxJQUFJLENBQUN3UixHQUFMLENBQVNoZixFQUFFLEdBQUd3TixJQUFJLENBQUNvUixFQUFMLEdBQVUsR0FBeEIsSUFBK0JnakIsRUFBekM7QUFDQSxVQUFNdGlCLENBQUMsR0FBRzlSLElBQUksQ0FBQ3NSLEdBQUwsQ0FBUzllLEVBQUUsR0FBR3dOLElBQUksQ0FBQ29SLEVBQUwsR0FBVSxHQUF4QixJQUErQmdqQixFQUF6QztBQUNBLFdBQU8sQ0FBQ3J2QixDQUFELEVBQUlzRyxDQUFKLEVBQU95RyxDQUFQLENBQVA7QUFDQTs7QUFHRHFpQixlQUFhLEdBQUc7QUFDZixTQUFLNUIsT0FBTCxDQUFhNVosTUFBYixDQUFvQixLQUFLRCxRQUF6QixFQUFtQyxLQUFLaG1CLE1BQXhDLEVBQWdELEtBQUtpZ0MsR0FBckQ7QUFDQTs7QUFFRHZqQyxTQUFPLEdBQUc7QUFDVCxTQUFLbXZCLFVBQUw7QUFDQS9wQixvREFBUyxDQUFDb3BCLFFBQVYsQ0FBbUIsS0FBS04sUUFBeEI7QUFDQSxHQTlLbUIsQ0FpTHBCOzs7QUFHQSxNQUFJL3FCLEVBQUosR0FBUztBQUNSLFdBQU8sS0FBSzQ0QixHQUFaO0FBQ0E7O0FBR0QsTUFBSTM0QixFQUFKLEdBQVM7QUFDUixXQUFPLEtBQUs0NEIsR0FBWjtBQUNBOztBQTNMbUI7O0FBK0xObDJCLDZFQUFmLEU7Ozs7Ozs7Ozs7OztBQ2xOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLE1BQU02OEIsUUFBUSxHQUFHLFVBQVVDLE1BQVYsRUFBa0J0SixPQUFsQixFQUEyQjtBQUUzQyxRQUFNMzZCLENBQUMsR0FBRzI2QixPQUFPLElBQUksRUFBckI7O0FBQ0EsTUFBR3NKLE1BQU0sQ0FBQ0MsT0FBVixFQUFtQjtBQUNsQmxrQyxLQUFDLENBQUNnWCxDQUFGLEdBQU1pdEIsTUFBTSxDQUFDQyxPQUFQLENBQWUsQ0FBZixFQUFrQkMsS0FBeEI7QUFDQW5rQyxLQUFDLENBQUNzZCxDQUFGLEdBQU0ybUIsTUFBTSxDQUFDQyxPQUFQLENBQWUsQ0FBZixFQUFrQkUsS0FBeEI7QUFDQSxHQUhELE1BR087QUFDTnBrQyxLQUFDLENBQUNnWCxDQUFGLEdBQU1pdEIsTUFBTSxDQUFDSSxPQUFiO0FBQ0Fya0MsS0FBQyxDQUFDc2QsQ0FBRixHQUFNMm1CLE1BQU0sQ0FBQ0ssT0FBYjtBQUNBOztBQUVELFNBQU90a0MsQ0FBUDtBQUNBLENBWkQ7O0FBY0EsTUFBTW9ILFlBQU4sQ0FBbUI7QUFDbEI3RCxhQUFXLENBQUNvM0IsT0FBRCxFQUFVNEosZUFBZSxHQUFHemlDLE1BQTVCLEVBQW9DazlCLE9BQU8sR0FBRyxHQUE5QyxFQUFtRDtBQUU3RCxTQUFLd0YsT0FBTCxHQUF1QjdKLE9BQXZCO0FBQ0EsU0FBSzhKLGVBQUwsR0FBdUJGLGVBQXZCO0FBRUEsU0FBS25tQixNQUFMLEdBQXVCNUssOENBQUksQ0FBQ2dJLE1BQUwsRUFBdkI7QUFDQSxTQUFLb1osQ0FBTCxHQUF1QnBoQiw4Q0FBSSxDQUFDZ0ksTUFBTCxFQUF2QjtBQUNBLFNBQUs4cUIsT0FBTCxHQUF1Qmx6Qiw4Q0FBSSxDQUFDOE4sS0FBTCxDQUFXLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVgsQ0FBdkI7QUFDQSxTQUFLcWxCLE1BQUwsR0FBdUJuekIsOENBQUksQ0FBQzhOLEtBQUwsQ0FBVyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFYLENBQXZCO0FBQ0EsU0FBS3NsQixRQUFMLEdBQXVCO0FBQUV4dkIsT0FBQyxFQUFDLENBQUo7QUFBT3NHLE9BQUMsRUFBQztBQUFULEtBQXZCO0FBQ0EsU0FBS21wQixLQUFMLEdBQXVCO0FBQUV6dkIsT0FBQyxFQUFDLENBQUo7QUFBT3NHLE9BQUMsRUFBQztBQUFULEtBQXZCO0FBQ0EsU0FBS3NvQixZQUFMLEdBQXVCLEtBQXZCO0FBQ0EsU0FBS25JLFNBQUwsR0FBdUJqVCw4Q0FBSSxDQUFDaFAsTUFBTCxFQUF2QjtBQUNBLFNBQUtrckIsWUFBTCxHQUF1QmxjLDhDQUFJLENBQUNoUCxNQUFMLEVBQXZCO0FBQ0EsU0FBS21yQixjQUFMLEdBQXVCLENBQXZCO0FBQ0EsU0FBS0MsT0FBTCxHQUF1QixLQUF2QjtBQUNBLFNBQUtDLE1BQUwsR0FBdUIsQ0FBQyxDQUF4QjtBQUNBLFNBQUtDLFNBQUwsR0FBdUIsS0FBdkI7QUFFQSxTQUFLQyxNQUFMLEdBQXVCLElBQUlwZ0MsbURBQUosQ0FBZSxDQUFmLEVBQWtCcTRCLE9BQWxCLENBQXZCO0FBQ0EsU0FBS2dJLE1BQUwsR0FBdUIsSUFBSXJnQyxtREFBSixDQUFlLENBQWYsRUFBa0JxNEIsT0FBbEIsQ0FBdkI7O0FBRUEsU0FBS3lGLGVBQUwsQ0FBcUJwaUMsZ0JBQXJCLENBQXNDLFdBQXRDLEVBQW9ETCxDQUFELElBQU8sS0FBS3NqQyxPQUFMLENBQWF0akMsQ0FBYixDQUExRDs7QUFDQSxTQUFLeWlDLGVBQUwsQ0FBcUJwaUMsZ0JBQXJCLENBQXNDLFlBQXRDLEVBQXFETCxDQUFELElBQU8sS0FBS3NqQyxPQUFMLENBQWF0akMsQ0FBYixDQUEzRDs7QUFDQSxTQUFLeWlDLGVBQUwsQ0FBcUJwaUMsZ0JBQXJCLENBQXNDLFdBQXRDLEVBQW9ETCxDQUFELElBQU8sS0FBS3dqQyxPQUFMLENBQWF4akMsQ0FBYixDQUExRDs7QUFDQSxTQUFLeWlDLGVBQUwsQ0FBcUJwaUMsZ0JBQXJCLENBQXNDLFdBQXRDLEVBQW9ETCxDQUFELElBQU8sS0FBS3dqQyxPQUFMLENBQWF4akMsQ0FBYixDQUExRDs7QUFDQUYsVUFBTSxDQUFDTyxnQkFBUCxDQUF3QixVQUF4QixFQUFvQyxNQUFNLEtBQUtxakMsS0FBTCxFQUExQztBQUNBNWpDLFVBQU0sQ0FBQ08sZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsTUFBTSxLQUFLcWpDLEtBQUwsRUFBekM7QUFFQWovQixzREFBUyxDQUFDOFQsS0FBVixDQUFnQixNQUFNLEtBQUtDLEtBQUwsRUFBdEI7QUFDQSxHQS9CaUIsQ0FpQ2xCOzs7QUFFQXVyQixnQkFBYyxDQUFDN2lCLFFBQVEsR0FBRyxJQUFaLEVBQWtCO0FBQy9CLFNBQUsraEIsU0FBTCxHQUFpQi9oQixRQUFqQjtBQUNBOztBQUVEeWlCLE1BQUksQ0FBQy9oQyxNQUFNLEdBQUcsSUFBVixFQUFnQjtBQUNuQixTQUFLa2pDLFNBQUwsR0FBaUJsakMsTUFBakI7QUFDQTs7QUFFRHFqQyxjQUFZLENBQUMxSSxLQUFELEVBQVEySSxLQUFLLEdBQUcsR0FBaEIsRUFBcUI7QUFDaEMsU0FBS2pJLE1BQUwsR0FBY2lJLEtBQWQ7O0FBQ0EsUUFBRyxLQUFLTCxNQUFMLEdBQWMsQ0FBakIsRUFBb0I7QUFBRTtBQUFTOztBQUUvQixVQUFNSCxZQUFZLEdBQUlsYyw4Q0FBSSxDQUFDdEosS0FBTCxDQUFXLEtBQUt1YyxTQUFoQixDQUF0Qjs7QUFDQSxTQUFLMEosZUFBTCxDQUFxQlQsWUFBckI7O0FBQ0EsU0FBS2pKLFNBQUwsR0FBb0JqVCw4Q0FBSSxDQUFDdEosS0FBTCxDQUFXd2xCLFlBQVgsQ0FBcEI7QUFDQSxTQUFLVSxVQUFMLEdBQW9CLEtBQUtwQixLQUFMLEdBQWEsQ0FBakM7QUFDQSxTQUFLcUIsVUFBTCxHQUFvQixLQUFLcEIsS0FBTCxHQUFhLENBQWpDO0FBRUEsU0FBS0wsWUFBTCxHQUFvQixLQUFwQjtBQUNBLFNBQUswQixVQUFMLEdBQW9CLENBQXBCO0FBRUEsU0FBS0MsV0FBTCxHQUFvQi9jLDhDQUFJLENBQUN0SixLQUFMLENBQVdxZCxLQUFYLENBQXBCO0FBQ0EsU0FBS3NJLE1BQUwsR0FBb0IsQ0FBcEI7QUFDQTs7QUFFRFcsV0FBUyxHQUFHO0FBQ1gsU0FBSy9KLFNBQUwsR0FBb0JqVCw4Q0FBSSxDQUFDdEosS0FBTCxDQUFXLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUFYLENBQXBCO0FBQ0EsU0FBS3dsQixZQUFMLEdBQW9CbGMsOENBQUksQ0FBQ3RKLEtBQUwsQ0FBVyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBWCxDQUFwQjtBQUNBLFNBQUtxbUIsV0FBTCxHQUFvQi9oQyxTQUFwQjtBQUNBLFNBQUtxaEMsTUFBTCxHQUFvQixDQUFDLENBQXJCO0FBQ0EsR0FqRWlCLENBbUVsQjs7O0FBRUF2QixTQUFPLENBQUNyQixNQUFELEVBQVM7QUFDZixRQUFHLEtBQUs2QyxTQUFSLEVBQW1CO0FBQUU7QUFBUzs7QUFFOUIsVUFBTUwsS0FBSyxHQUFHekMsUUFBUSxDQUFDQyxNQUFELENBQXRCO0FBQ0EsVUFBTXlDLFlBQVksR0FBR2xjLDhDQUFJLENBQUN0SixLQUFMLENBQVcsS0FBS3VjLFNBQWhCLENBQXJCOztBQUNBLFNBQUswSixlQUFMLENBQXFCVCxZQUFyQjs7QUFDQSxTQUFLakosU0FBTCxHQUFpQmlKLFlBQWpCO0FBRUEsU0FBS2QsWUFBTCxHQUFvQixJQUFwQjtBQUNBLFNBQUswQixVQUFMLEdBQWtCLENBQWxCO0FBQ0EsU0FBS2QsUUFBTCxHQUFnQjtBQUFFeHZCLE9BQUMsRUFBQ3l2QixLQUFLLENBQUN6dkIsQ0FBVjtBQUFhc0csT0FBQyxFQUFDbXBCLEtBQUssQ0FBQ25wQjtBQUFyQixLQUFoQjs7QUFFQSxRQUFHbXBCLEtBQUssQ0FBQ25wQixDQUFOLEdBQVUsS0FBS3FwQixjQUFmLElBQWlDRixLQUFLLENBQUNucEIsQ0FBTixHQUFXeGIsTUFBTSxDQUFDMmEsV0FBUCxHQUFxQixLQUFLa3FCLGNBQXpFLEVBQTBGO0FBQ3pGLFdBQUtXLFVBQUwsR0FBa0IsQ0FBbEI7QUFDQSxLQUZELE1BRU8sSUFBR2IsS0FBSyxDQUFDenZCLENBQU4sR0FBVSxLQUFLMnZCLGNBQWYsSUFBaUNGLEtBQUssQ0FBQ3p2QixDQUFOLEdBQVdsVixNQUFNLENBQUMwYSxVQUFQLEdBQW9CLEtBQUttcUIsY0FBeEUsRUFBeUY7QUFDL0YsV0FBS1csVUFBTCxHQUFrQixDQUFsQjtBQUNBOztBQUVELFNBQUtQLE1BQUwsQ0FBWXRoQyxLQUFaLENBQWtCLENBQWxCOztBQUNBLFNBQUt1aEMsTUFBTCxDQUFZdmhDLEtBQVosQ0FBa0IsQ0FBbEI7QUFDQTs7QUFHRCsvQixTQUFPLENBQUN2QixNQUFELEVBQVM7QUFDZixRQUFHLEtBQUs2QyxTQUFSLEVBQW1CO0FBQUU7QUFBUzs7QUFDOUI5QyxZQUFRLENBQUNDLE1BQUQsRUFBUyxLQUFLd0MsS0FBZCxDQUFSO0FBQ0E7O0FBR0RmLE9BQUssR0FBRztBQUNQLFFBQUcsS0FBS29CLFNBQVIsRUFBbUI7QUFBRTtBQUFTOztBQUM5QixTQUFLbEIsWUFBTCxHQUFvQixLQUFwQjtBQUNBLEdBckdpQixDQXdHbEI7OztBQUVBdUIsaUJBQWUsQ0FBQ00sYUFBRCxFQUFnQjtBQUM5QixRQUFHLEtBQUs3QixZQUFMLElBQXFCLENBQUMsS0FBS2tCLFNBQTlCLEVBQXlDO0FBQ3hDLFdBQUtDLE1BQUwsQ0FBWWpqQyxLQUFaLEdBQW9CLEVBQUUsS0FBSzJpQyxLQUFMLENBQVd6dkIsQ0FBWCxHQUFlLEtBQUt3dkIsUUFBTCxDQUFjeHZCLENBQS9CLENBQXBCO0FBQ0EsV0FBS2d3QixNQUFMLENBQVlsakMsS0FBWixHQUFzQixLQUFLMmlDLEtBQUwsQ0FBV25wQixDQUFYLEdBQWUsS0FBS2twQixRQUFMLENBQWNscEIsQ0FBbkQ7O0FBRUEsVUFBRyxLQUFLMm5CLFNBQVIsRUFBbUI7QUFDbEIsYUFBSzhCLE1BQUwsQ0FBWWpqQyxLQUFaLEdBQW9CLENBQUMsS0FBS2lqQyxNQUFMLENBQVluSCxXQUFqQztBQUNBLGFBQUtvSCxNQUFMLENBQVlsakMsS0FBWixHQUFvQixDQUFDLEtBQUtrakMsTUFBTCxDQUFZcEgsV0FBakM7QUFDQTtBQUNEOztBQUVELFFBQUk4SCxLQUFKLEVBQVduZCxLQUFYOztBQUVBLFFBQUcsS0FBSytjLFVBQUwsR0FBa0IsQ0FBckIsRUFBd0I7QUFDdkIsVUFBRyxLQUFLQSxVQUFMLEtBQW9CLENBQXZCLEVBQTBCO0FBQ3pCSSxhQUFLLEdBQUcsQ0FBQyxLQUFLWCxNQUFMLENBQVlqakMsS0FBYixHQUFxQixLQUFLOGlDLE9BQWxDO0FBQ0FjLGFBQUssSUFBSyxLQUFLbEIsUUFBTCxDQUFjbHBCLENBQWQsR0FBa0IsS0FBS3FwQixjQUF4QixHQUEwQyxDQUFDLENBQTNDLEdBQStDLENBQXhEO0FBQ0FwYyxhQUFLLEdBQUdDLDhDQUFJLENBQUN0SixLQUFMLENBQVcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPalAsSUFBSSxDQUFDc1IsR0FBTCxDQUFTbWtCLEtBQVQsQ0FBUCxFQUF3QnoxQixJQUFJLENBQUN3UixHQUFMLENBQVNpa0IsS0FBVCxDQUF4QixDQUFYLENBQVI7QUFDQWxkLHNEQUFJLENBQUNyTSxRQUFMLENBQWNvTSxLQUFkLEVBQXFCa2QsYUFBckIsRUFBb0NsZCxLQUFwQztBQUNBLE9BTEQsTUFLTztBQUNObWQsYUFBSyxHQUFHLENBQUMsS0FBS1YsTUFBTCxDQUFZbGpDLEtBQWIsR0FBcUIsS0FBSzhpQyxPQUFsQztBQUNBYyxhQUFLLElBQUssS0FBS2xCLFFBQUwsQ0FBY3h2QixDQUFkLEdBQWtCLEtBQUsydkIsY0FBeEIsR0FBMEMsQ0FBMUMsR0FBOEMsQ0FBQyxDQUF4RDtBQUNBcGMsYUFBSyxHQUFHQyw4Q0FBSSxDQUFDdEosS0FBTCxDQUFXLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBT2pQLElBQUksQ0FBQ3NSLEdBQUwsQ0FBU21rQixLQUFULENBQVAsRUFBd0J6MUIsSUFBSSxDQUFDd1IsR0FBTCxDQUFTaWtCLEtBQVQsQ0FBeEIsQ0FBWCxDQUFSO0FBQ0FsZCxzREFBSSxDQUFDck0sUUFBTCxDQUFjb00sS0FBZCxFQUFxQmtkLGFBQXJCLEVBQW9DbGQsS0FBcEM7QUFDQTtBQUNELEtBWkQsTUFZTztBQUNOLFlBQU0zSCxDQUFDLEdBQUd4UCw4Q0FBSSxDQUFDOE4sS0FBTCxDQUFXLENBQUMsS0FBSzZsQixNQUFMLENBQVlqakMsS0FBYixFQUFvQixLQUFLa2pDLE1BQUwsQ0FBWWxqQyxLQUFoQyxFQUF1QyxDQUF2QyxDQUFYLENBQVY7QUFDQSxZQUFNaWUsSUFBSSxHQUFHM08sOENBQUksQ0FBQ29JLE1BQUwsRUFBYjtBQUNBcEksb0RBQUksQ0FBQ21wQixLQUFMLENBQVd4YSxJQUFYLEVBQWlCYSxDQUFqQixFQUFvQixLQUFLMmpCLE1BQXpCO0FBQ0FuekIsb0RBQUksQ0FBQzJVLFNBQUwsQ0FBZWhHLElBQWYsRUFBcUJBLElBQXJCO0FBQ0EybEIsV0FBSyxHQUFHdDBCLDhDQUFJLENBQUMxVCxNQUFMLENBQVlrakIsQ0FBWixJQUFpQixLQUFLZ2tCLE9BQTlCO0FBQ0FyYyxXQUFLLEdBQUdDLDhDQUFJLENBQUN0SixLQUFMLENBQVcsQ0FBQ2pQLElBQUksQ0FBQ3NSLEdBQUwsQ0FBU21rQixLQUFULElBQWtCM2xCLElBQUksQ0FBQyxDQUFELENBQXZCLEVBQTRCOVAsSUFBSSxDQUFDc1IsR0FBTCxDQUFTbWtCLEtBQVQsSUFBa0IzbEIsSUFBSSxDQUFDLENBQUQsQ0FBbEQsRUFBdUQ5UCxJQUFJLENBQUNzUixHQUFMLENBQVNta0IsS0FBVCxJQUFrQjNsQixJQUFJLENBQUMsQ0FBRCxDQUE3RSxFQUFrRjlQLElBQUksQ0FBQ3dSLEdBQUwsQ0FBU2lrQixLQUFULENBQWxGLENBQVgsQ0FBUjtBQUNBbGQsb0RBQUksQ0FBQ3JNLFFBQUwsQ0FBY3NwQixhQUFkLEVBQTZCbGQsS0FBN0IsRUFBb0NrZCxhQUFwQztBQUNBO0FBQ0Q7O0FBRURqdEIsT0FBSyxHQUFHO0FBQ1BoSCxrREFBSSxDQUFDMkksUUFBTCxDQUFjLEtBQUt5WSxDQUFuQjs7QUFFQSxRQUFHLEtBQUsyUyxXQUFMLEtBQXFCL2hDLFNBQXhCLEVBQW1DO0FBQ2xDZ2xCLG9EQUFJLENBQUM5bUIsR0FBTCxDQUFTLEtBQUtnakMsWUFBZCxFQUE0QixLQUFLakosU0FBTCxDQUFlLENBQWYsQ0FBNUIsRUFBK0MsS0FBS0EsU0FBTCxDQUFlLENBQWYsQ0FBL0MsRUFBa0UsS0FBS0EsU0FBTCxDQUFlLENBQWYsQ0FBbEUsRUFBcUYsS0FBS0EsU0FBTCxDQUFlLENBQWYsQ0FBckY7O0FBQ0EsV0FBSzBKLGVBQUwsQ0FBcUIsS0FBS1QsWUFBMUI7QUFDQSxLQUhELE1BR087QUFDTixXQUFLRyxNQUFMLElBQWUsQ0FBQyxJQUFJLEtBQUtBLE1BQVYsSUFBb0IsR0FBbkM7O0FBRUEsVUFBRyxLQUFLQSxNQUFMLEdBQWMsTUFBakIsRUFBeUI7QUFDeEJyYyxzREFBSSxDQUFDdE0sSUFBTCxDQUFVLEtBQUt1ZixTQUFmLEVBQTBCLEtBQUs4SixXQUEvQjtBQUNBL2Msc0RBQUksQ0FBQ3RNLElBQUwsQ0FBVSxLQUFLd29CLFlBQWYsRUFBNkIsS0FBS2EsV0FBbEM7QUFDQSxhQUFLQSxXQUFMLEdBQW1CL2hDLFNBQW5COztBQUNBLGFBQUt1aEMsTUFBTCxDQUFZdGhDLEtBQVosQ0FBa0IsQ0FBbEI7O0FBQ0EsYUFBS3VoQyxNQUFMLENBQVl2aEMsS0FBWixDQUFrQixDQUFsQjs7QUFDQSxhQUFLb2hDLE1BQUwsR0FBYyxDQUFDLENBQWY7QUFDQSxPQVBELE1BT087QUFDTnJjLHNEQUFJLENBQUM5bUIsR0FBTCxDQUFTLEtBQUtnakMsWUFBZCxFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQztBQUNBbGMsc0RBQUksQ0FBQ21kLEtBQUwsQ0FBVyxLQUFLakIsWUFBaEIsRUFBOEIsS0FBS2EsV0FBbkMsRUFBZ0QsS0FBSzlKLFNBQXJELEVBQWdFLEtBQUtvSixNQUFyRTtBQUNBO0FBQ0Q7O0FBRUR6ekIsa0RBQUksQ0FBQ3cwQixhQUFMLENBQW1CLEtBQUt0QixPQUF4QixFQUFpQyxLQUFLQSxPQUF0QyxFQUErQyxLQUFLSSxZQUFwRDtBQUVBbHpCLGtEQUFJLENBQUMyWCxRQUFMLENBQWMsS0FBSy9NLE1BQW5CLEVBQTJCLEtBQUtzb0IsWUFBaEM7QUFDQSxHQXZLaUIsQ0EwS2xCOzs7QUFFQSxNQUFJekgsTUFBSixDQUFXcjdCLE1BQVgsRUFBbUI7QUFDbEIsU0FBS21qQyxNQUFMLENBQVk5SCxNQUFaLEdBQXFCcjdCLE1BQXJCO0FBQ0EsU0FBS29qQyxNQUFMLENBQVkvSCxNQUFaLEdBQXFCcjdCLE1BQXJCO0FBQ0E7O0FBRUQsTUFBSXE3QixNQUFKLEdBQWE7QUFDWixXQUFPLEtBQUs4SCxNQUFMLENBQVk5SCxNQUFuQjtBQUNBOztBQW5MaUI7O0FBc0xKNzNCLDJFQUFmLEU7Ozs7Ozs7Ozs7OztBQzVNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU1lLFVBQVUsR0FBRztBQUNqQjAvQixvRkFEaUI7QUFFakJDLG9GQUZpQjtBQUdqQkMsNEVBSGlCO0FBSWpCQyxzRUFKaUI7QUFLakJDLHdFQUxpQjtBQU1qQkMsMEVBTmlCO0FBT2pCQywwRUFBVUE7QUFQTyxDQUFuQjtBQVVlaGdDLHlFQUFmLEU7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUFBO0FBQUE7QUFFQTs7QUFFQSxNQUFNdkIsWUFBTixDQUFtQjtBQUVsQnJELGFBQVcsQ0FBQ0ssTUFBRCxFQUFTd2tDLE1BQU0sR0FBQyxHQUFoQixFQUFxQkMsYUFBYSxHQUFDLEdBQW5DLEVBQXdDO0FBQ2xELFNBQUs1a0MsTUFBTCxHQUFjRyxNQUFkO0FBQ0EsU0FBS3M3QixZQUFMLEdBQW9CdDdCLE1BQXBCO0FBQ0EsU0FBS3NqQyxLQUFMLEdBQWFrQixNQUFiO0FBQ0EsU0FBS0UsWUFBTCxHQUFvQkQsYUFBcEI7QUFFQSxTQUFLRSxTQUFMLEdBQWlCLENBQWpCO0FBRUEsU0FBS2haLFFBQUwsR0FBb0I5b0Isa0RBQVMsQ0FBQzhULEtBQVYsQ0FBZ0IsTUFBSyxLQUFLd2pCLE9BQUwsRUFBckIsQ0FBcEI7QUFDQTs7QUFHREEsU0FBTyxHQUFHO0FBQ1QsVUFBTW9CLFFBQVEsR0FBRyxNQUFqQjs7QUFDQSxTQUFLQyxXQUFMOztBQUNBLFFBQUdudEIsSUFBSSxDQUFDb3RCLEdBQUwsQ0FBUyxLQUFLSCxZQUFMLEdBQW9CLEtBQUt6N0IsTUFBbEMsSUFBNEMwN0IsUUFBL0MsRUFBeUQ7QUFDeEQsV0FBSzE3QixNQUFMLEdBQWMsS0FBS3k3QixZQUFuQjtBQUNBO0FBQ0E7O0FBRUQsU0FBS3FKLFNBQUwsSUFBa0IsQ0FBQyxLQUFLckosWUFBTCxHQUFvQixLQUFLejdCLE1BQTFCLElBQW9DLEtBQUt5akMsS0FBM0Q7QUFFQSxTQUFLempDLE1BQUwsSUFBZSxLQUFLOGtDLFNBQXBCO0FBQ0EsU0FBS0EsU0FBTCxJQUFrQixLQUFLRCxZQUF2Qjs7QUFFQSxRQUFHcjJCLElBQUksQ0FBQ290QixHQUFMLENBQVMsS0FBS0gsWUFBTCxHQUFvQixLQUFLejdCLE1BQWxDLElBQTRDMDdCLFFBQS9DLEVBQXlEO0FBQ3hELFdBQUsxN0IsTUFBTCxHQUFjLEtBQUt5N0IsWUFBbkI7QUFDQTtBQUNEOztBQUdESyxPQUFLLENBQUNDLElBQUQsRUFBT0MsSUFBUCxFQUFhO0FBQ2pCLFFBQUdELElBQUksR0FBR0MsSUFBVixFQUFnQjtBQUNmLFdBQUtGLEtBQUwsQ0FBV0UsSUFBWCxFQUFpQkQsSUFBakI7QUFDQTtBQUNBOztBQUVELFNBQUtFLElBQUwsR0FBWUYsSUFBWjtBQUNBLFNBQUtHLElBQUwsR0FBWUYsSUFBWjs7QUFFQSxTQUFLTCxXQUFMO0FBQ0E7O0FBR0RBLGFBQVcsR0FBRztBQUNiLFFBQUcsS0FBS00sSUFBTCxLQUFjbDZCLFNBQWQsSUFBMkIsS0FBSzA1QixZQUFMLEdBQW9CLEtBQUtRLElBQXZELEVBQTZEO0FBQzVELFdBQUtSLFlBQUwsR0FBb0IsS0FBS1EsSUFBekI7QUFDQTs7QUFFRCxRQUFHLEtBQUtDLElBQUwsS0FBY242QixTQUFkLElBQTJCLEtBQUswNUIsWUFBTCxHQUFvQixLQUFLUyxJQUF2RCxFQUE2RDtBQUM1RCxXQUFLVCxZQUFMLEdBQW9CLEtBQUtTLElBQXpCO0FBQ0E7QUFDRDs7QUFHRHQrQixTQUFPLEdBQUc7QUFDVG9GLHNEQUFTLENBQUNvcEIsUUFBVixDQUFtQixLQUFLTixRQUF4QjtBQUNBOztBQUdELE1BQUl6ckIsS0FBSixDQUFVRixNQUFWLEVBQWtCO0FBQ2pCLFNBQUtzN0IsWUFBTCxHQUFvQnQ3QixNQUFwQjtBQUNBOztBQUdELE1BQUlFLEtBQUosR0FBWTtBQUNYLFdBQU8sS0FBS0wsTUFBWjtBQUNBOztBQXJFaUI7O0FBMEVKbUQsMkVBQWYsRTs7Ozs7Ozs7Ozs7O0FDOUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM0aEMsUUFBVCxDQUFrQnBwQyxDQUFsQixFQUFxQjZRLENBQXJCLEVBQXdCO0FBQ3ZCLFFBQU13NEIsRUFBRSxHQUFHcnBDLENBQUMsQ0FBQzRYLENBQUYsR0FBTS9HLENBQUMsQ0FBQytHLENBQW5CO0FBQ0EsUUFBTTB4QixFQUFFLEdBQUd0cEMsQ0FBQyxDQUFDa2UsQ0FBRixHQUFNck4sQ0FBQyxDQUFDcU4sQ0FBbkI7QUFDQSxTQUFPckwsSUFBSSxDQUFDNkksSUFBTCxDQUFVMnRCLEVBQUUsR0FBR0EsRUFBTCxHQUFVQyxFQUFFLEdBQUdBLEVBQXpCLENBQVA7QUFDQTs7QUFFRCxNQUFNQyxhQUFOLFNBQTRCamlDLHdEQUE1QixDQUE0QztBQUMzQ25ELGFBQVcsQ0FBQ3NGLEtBQUQsRUFBUWlWLE9BQVIsRUFBaUI4cUIsY0FBYyxHQUFDLEtBQWhDLEVBQXVDckUsZUFBZSxHQUFDemlDLE1BQXZELEVBQStEO0FBQ3pFO0FBRUEsU0FBS2lILEtBQUwsR0FBYUYsS0FBYjs7QUFDQSxTQUFLRSxLQUFMLENBQVd3ZSxhQUFYOztBQUNBLFNBQUtzaEIsT0FBTCxHQUFlL3FCLE9BQWY7QUFDQSxTQUFLZ3JCLFlBQUwsR0FBb0JqZ0MsS0FBSyxDQUFDMmYsS0FBTixDQUFZem9CLEdBQVosQ0FBaUI0bkIsSUFBRCxJQUFTQSxJQUFJLENBQUNwQyxRQUE5QixDQUFwQjtBQUNBLFNBQUt3akIsY0FBTCxHQUFzQixDQUF0QjtBQUVBLFNBQUtDLElBQUwsR0FBWSxJQUFJL2hDLGlEQUFKLENBQVEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBUixFQUFtQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQyxDQUFSLENBQW5CLENBQVo7QUFDQSxTQUFLZ2lDLElBQUwsR0FBWTcxQixJQUFJLENBQUMwWSxVQUFMLENBQWdCLENBQUMsR0FBakIsRUFBc0IsQ0FBQyxHQUF2QixFQUE0QixDQUFDLEdBQTdCLENBQVo7QUFDQSxTQUFLb2QsUUFBTDtBQUNBLFNBQUtDLFNBQUw7QUFDQSxTQUFLQyxRQUFMLEdBQWdCNTFCLElBQUksQ0FBQ2dJLE1BQUwsRUFBaEI7QUFFQSxTQUFLaXBCLGVBQUwsR0FBdUJGLGVBQXZCO0FBQ0EsU0FBSzhFLGFBQUwsR0FBcUJULGNBQXJCOztBQUVBLFNBQUtVLFdBQUwsR0FBb0J0bkMsQ0FBRCxJQUFPLEtBQUt3akMsT0FBTCxDQUFheGpDLENBQWIsQ0FBMUI7O0FBQ0EsU0FBS3VuQyxXQUFMLEdBQW9Cdm5DLENBQUQsSUFBTyxLQUFLc2pDLE9BQUwsQ0FBYXRqQyxDQUFiLENBQTFCOztBQUNBLFNBQUt3bkMsU0FBTCxHQUFpQixNQUFNLEtBQUs5RCxLQUFMLEVBQXZCOztBQUVBLFNBQUtwVixPQUFMO0FBQ0E7O0FBRURBLFNBQU8sR0FBRztBQUNULFNBQUttVSxlQUFMLENBQXFCcGlDLGdCQUFyQixDQUFzQyxXQUF0QyxFQUFtRCxLQUFLa25DLFdBQXhEOztBQUNBLFNBQUs5RSxlQUFMLENBQXFCcGlDLGdCQUFyQixDQUFzQyxXQUF0QyxFQUFtRCxLQUFLaW5DLFdBQXhEOztBQUNBLFNBQUs3RSxlQUFMLENBQXFCcGlDLGdCQUFyQixDQUFzQyxTQUF0QyxFQUFpRCxLQUFLbW5DLFNBQXREO0FBQ0E7O0FBRURoWixZQUFVLEdBQUc7QUFDWixTQUFLaVUsZUFBTCxDQUFxQmhVLG1CQUFyQixDQUF5QyxXQUF6QyxFQUFzRCxLQUFLOFksV0FBM0Q7O0FBQ0EsU0FBSzlFLGVBQUwsQ0FBcUJoVSxtQkFBckIsQ0FBeUMsV0FBekMsRUFBc0QsS0FBSzZZLFdBQTNEOztBQUNBLFNBQUs3RSxlQUFMLENBQXFCaFUsbUJBQXJCLENBQXlDLFNBQXpDLEVBQW9ELEtBQUsrWSxTQUF6RDtBQUNBOztBQUdEQyxXQUFTLENBQUNqMUIsS0FBSyxHQUFDLE9BQVAsRUFBZ0I7QUFDeEIsVUFBTXVKLE1BQU0sR0FBRyxLQUFLOHFCLE9BQXBCOztBQUNBLFFBQUcsQ0FBQzlxQixNQUFKLEVBQVk7QUFDWDtBQUNBOztBQUdELFVBQU0yckIsRUFBRSxHQUFJLEtBQUtSLFFBQUwsQ0FBY2x5QixDQUFkLEdBQWtCL1EsK0NBQUUsQ0FBQ2lGLEtBQXRCLEdBQStCLEdBQS9CLEdBQXFDLEdBQWhEO0FBQ0EsVUFBTXkrQixFQUFFLEdBQUcsRUFBRyxLQUFLVCxRQUFMLENBQWM1ckIsQ0FBZCxHQUFrQnJYLCtDQUFFLENBQUNrRixNQUF4QixJQUFrQyxHQUFsQyxHQUF3QyxHQUFuRDtBQUVBNFMsVUFBTSxDQUFDcVAsV0FBUCxDQUFtQixDQUFDc2MsRUFBRCxFQUFLQyxFQUFMLEVBQVMsQ0FBVCxDQUFuQixFQUFnQyxLQUFLWCxJQUFyQztBQUVBLFFBQUlZLEdBQUo7QUFDQSxVQUFNQyxFQUFFLEdBQUd6MkIsSUFBSSxDQUFDb0ksTUFBTCxFQUFYO0FBQ0EsVUFBTTBmLEVBQUUsR0FBRzluQixJQUFJLENBQUNvSSxNQUFMLEVBQVg7QUFDQSxVQUFNc3VCLEVBQUUsR0FBRzEyQixJQUFJLENBQUNvSSxNQUFMLEVBQVg7QUFDQSxRQUFJdXVCLElBQUksR0FBRyxDQUFYOztBQUVBLFVBQU1DLFNBQVMsR0FBRyxDQUFDcG5CLENBQUQsRUFBSXdYLE1BQUosS0FBZTtBQUNoQ2huQixVQUFJLENBQUNxYSxhQUFMLENBQW1CMk0sTUFBbkIsRUFBMkJ4WCxDQUEzQixFQUE4QixLQUFLd21CLFFBQW5DO0FBQ0EsS0FGRDs7QUFJQSxTQUFJLElBQUk3bkMsQ0FBQyxHQUFHLENBQVosRUFBZUEsQ0FBQyxHQUFHLEtBQUt1bkMsWUFBTCxDQUFrQnBwQyxNQUFyQyxFQUE2QzZCLENBQUMsRUFBOUMsRUFBa0Q7QUFDakQsWUFBTWdrQixRQUFRLEdBQUcsS0FBS3VqQixZQUFMLENBQWtCdm5DLENBQWxCLENBQWpCO0FBQ0F5b0MsZUFBUyxDQUFDemtCLFFBQVEsQ0FBQyxDQUFELENBQVQsRUFBY3NrQixFQUFkLENBQVQ7QUFDQUcsZUFBUyxDQUFDemtCLFFBQVEsQ0FBQyxDQUFELENBQVQsRUFBYzJWLEVBQWQsQ0FBVDtBQUNBOE8sZUFBUyxDQUFDemtCLFFBQVEsQ0FBQyxDQUFELENBQVQsRUFBY3VrQixFQUFkLENBQVQ7O0FBQ0EsWUFBTXRtQixDQUFDLEdBQUcsS0FBS3dsQixJQUFMLENBQVU5TSxpQkFBVixDQUE0QjJOLEVBQTVCLEVBQWdDM08sRUFBaEMsRUFBb0M0TyxFQUFwQyxDQUFWOztBQUVBLFVBQUd0bUIsQ0FBSCxFQUFNO0FBQ0wsWUFBR29tQixHQUFILEVBQVE7QUFDUCxnQkFBTUssU0FBUyxHQUFHNzJCLElBQUksQ0FBQzIyQixJQUFMLENBQVV2bUIsQ0FBVixFQUFhekYsTUFBTSxDQUFDNE0sUUFBcEIsQ0FBbEI7O0FBQ0EsY0FBR3NmLFNBQVMsR0FBR0YsSUFBZixFQUFxQjtBQUNwQkgsZUFBRyxHQUFHeDJCLElBQUksQ0FBQzhOLEtBQUwsQ0FBV3NDLENBQVgsQ0FBTjtBQUNBdW1CLGdCQUFJLEdBQUdFLFNBQVA7QUFDQTtBQUNELFNBTkQsTUFNTztBQUNOTCxhQUFHLEdBQUd4MkIsSUFBSSxDQUFDOE4sS0FBTCxDQUFXc0MsQ0FBWCxDQUFOO0FBQ0F1bUIsY0FBSSxHQUFHMzJCLElBQUksQ0FBQzIyQixJQUFMLENBQVVILEdBQVYsRUFBZTdyQixNQUFNLENBQUM0TSxRQUF0QixDQUFQO0FBQ0E7QUFDRDtBQUNEOztBQUdELFFBQUdpZixHQUFILEVBQVE7QUFDUCxXQUFLWCxJQUFMLEdBQVk3MUIsSUFBSSxDQUFDOE4sS0FBTCxDQUFXMG9CLEdBQVgsQ0FBWjtBQUNBLFdBQUt6SSxtQkFBTCxDQUF5QjNzQixLQUF6QixFQUFnQztBQUFFbzFCO0FBQUYsT0FBaEM7QUFDQSxLQUhELE1BR087QUFDTixXQUFLekksbUJBQUwsQ0FBeUIsTUFBekI7QUFDQTtBQUNEOztBQUdEbUUsU0FBTyxDQUFDdGpDLENBQUQsRUFBSTtBQUNWLFNBQUttbkMsU0FBTCxHQUFpQm5GLHlEQUFRLENBQUNoaUMsQ0FBRCxDQUF6QjtBQUNBLFNBQUtrbkMsUUFBTCxHQUFnQmxGLHlEQUFRLENBQUNoaUMsQ0FBRCxDQUF4Qjs7QUFDQSxTQUFLeW5DLFNBQUwsQ0FBZSxRQUFmO0FBQ0E7O0FBRURqRSxTQUFPLENBQUN4akMsQ0FBRCxFQUFJO0FBQ1YsU0FBS2tuQyxRQUFMLEdBQWdCbEYseURBQVEsQ0FBQ2hpQyxDQUFELENBQXhCOztBQUNBLFFBQUcsQ0FBQyxLQUFLcW5DLGFBQVQsRUFBd0I7QUFDdkIsV0FBS0ksU0FBTDtBQUNBO0FBQ0Q7O0FBRUQvRCxPQUFLLEdBQUc7QUFDUCxVQUFNcUUsSUFBSSxHQUFHdkIsUUFBUSxDQUFDLEtBQUtXLFNBQU4sRUFBaUIsS0FBS0QsUUFBdEIsQ0FBckI7O0FBQ0EsUUFBR2EsSUFBSSxHQUFHLEtBQUtoQixjQUFmLEVBQStCO0FBQzlCLFdBQUtVLFNBQUw7QUFDQTtBQUVEOztBQS9HMEM7O0FBbUg3QmQsNEVBQWYsRTs7Ozs7Ozs7Ozs7O0FDL0hBO0FBQUE7QUFBQTtBQUVhOztBQUViO0FBRUEsTUFBTXVCLE1BQU0sR0FBRztBQUNkQyxRQUFNLEVBQUU7QUFDUEMsUUFBSSxDQUFDM1MsQ0FBRCxFQUFJO0FBQ1AsYUFBT0EsQ0FBUDtBQUNBOztBQUhNLEdBRE07QUFNZDRTLFdBQVMsRUFBRTtBQUNWQyxNQUFFLENBQUM3UyxDQUFELEVBQUk7QUFDTCxhQUFPQSxDQUFDLEdBQUdBLENBQVg7QUFDQSxLQUhTOztBQUlWOFMsT0FBRyxDQUFDOVMsQ0FBRCxFQUFJO0FBQ04sYUFBT0EsQ0FBQyxJQUFJLElBQUlBLENBQVIsQ0FBUjtBQUNBLEtBTlM7O0FBT1YrUyxTQUFLLENBQUMvUyxDQUFELEVBQUk7QUFDUixVQUFJLENBQUNBLENBQUMsSUFBSSxDQUFOLElBQVcsQ0FBZixFQUFrQjtBQUNqQixlQUFPLE1BQU1BLENBQU4sR0FBVUEsQ0FBakI7QUFDQTs7QUFDRCxhQUFPLENBQUUsR0FBRixJQUFTLEVBQUVBLENBQUYsSUFBT0EsQ0FBQyxHQUFHLENBQVgsSUFBZ0IsQ0FBekIsQ0FBUDtBQUNBOztBQVpTLEdBTkc7QUFvQmRnVCxPQUFLLEVBQUU7QUFDTkgsTUFBRSxDQUFDN1MsQ0FBRCxFQUFJO0FBQ0wsYUFBT0EsQ0FBQyxHQUFHQSxDQUFKLEdBQVFBLENBQWY7QUFDQSxLQUhLOztBQUlOOFMsT0FBRyxDQUFDOVMsQ0FBRCxFQUFJO0FBQ04sYUFBTyxFQUFFQSxDQUFGLEdBQU1BLENBQU4sR0FBVUEsQ0FBVixHQUFjLENBQXJCO0FBQ0EsS0FOSzs7QUFPTitTLFNBQUssQ0FBQy9TLENBQUQsRUFBSTtBQUNSLFVBQUksQ0FBQ0EsQ0FBQyxJQUFJLENBQU4sSUFBVyxDQUFmLEVBQWtCO0FBQ2pCLGVBQU8sTUFBTUEsQ0FBTixHQUFVQSxDQUFWLEdBQWNBLENBQXJCO0FBQ0E7O0FBQ0QsYUFBTyxPQUFPLENBQUNBLENBQUMsSUFBSSxDQUFOLElBQVdBLENBQVgsR0FBZUEsQ0FBZixHQUFtQixDQUExQixDQUFQO0FBQ0E7O0FBWkssR0FwQk87QUFrQ2RpVCxTQUFPLEVBQUU7QUFDUkosTUFBRSxDQUFDN1MsQ0FBRCxFQUFJO0FBQ0wsYUFBT0EsQ0FBQyxHQUFHQSxDQUFKLEdBQVFBLENBQVIsR0FBWUEsQ0FBbkI7QUFDQSxLQUhPOztBQUlSOFMsT0FBRyxDQUFDOVMsQ0FBRCxFQUFJO0FBQ04sYUFBTyxJQUFLLEVBQUVBLENBQUYsR0FBTUEsQ0FBTixHQUFVQSxDQUFWLEdBQWNBLENBQTFCO0FBQ0EsS0FOTzs7QUFPUitTLFNBQUssQ0FBQy9TLENBQUQsRUFBSTtBQUNSLFVBQUksQ0FBQ0EsQ0FBQyxJQUFJLENBQU4sSUFBVyxDQUFmLEVBQWtCO0FBQ2pCLGVBQU8sTUFBTUEsQ0FBTixHQUFVQSxDQUFWLEdBQWNBLENBQWQsR0FBa0JBLENBQXpCO0FBQ0E7O0FBQ0QsYUFBTyxDQUFFLEdBQUYsSUFBUyxDQUFDQSxDQUFDLElBQUksQ0FBTixJQUFXQSxDQUFYLEdBQWVBLENBQWYsR0FBbUJBLENBQW5CLEdBQXVCLENBQWhDLENBQVA7QUFDQTs7QUFaTyxHQWxDSztBQWdEZGtULFNBQU8sRUFBRTtBQUNSTCxNQUFFLENBQUM3UyxDQUFELEVBQUk7QUFDTCxhQUFPQSxDQUFDLEdBQUdBLENBQUosR0FBUUEsQ0FBUixHQUFZQSxDQUFaLEdBQWdCQSxDQUF2QjtBQUNBLEtBSE87O0FBSVI4UyxPQUFHLENBQUM5UyxDQUFELEVBQUk7QUFDTixhQUFPLEVBQUVBLENBQUYsR0FBTUEsQ0FBTixHQUFVQSxDQUFWLEdBQWNBLENBQWQsR0FBa0JBLENBQWxCLEdBQXNCLENBQTdCO0FBQ0EsS0FOTzs7QUFPUitTLFNBQUssQ0FBQy9TLENBQUQsRUFBSTtBQUNSLFVBQUksQ0FBQ0EsQ0FBQyxJQUFJLENBQU4sSUFBVyxDQUFmLEVBQWtCO0FBQ2pCLGVBQU8sTUFBTUEsQ0FBTixHQUFVQSxDQUFWLEdBQWNBLENBQWQsR0FBa0JBLENBQWxCLEdBQXNCQSxDQUE3QjtBQUNBOztBQUNELGFBQU8sT0FBTyxDQUFDQSxDQUFDLElBQUksQ0FBTixJQUFXQSxDQUFYLEdBQWVBLENBQWYsR0FBbUJBLENBQW5CLEdBQXVCQSxDQUF2QixHQUEyQixDQUFsQyxDQUFQO0FBQ0E7O0FBWk8sR0FoREs7QUE4RGRtVCxZQUFVLEVBQUU7QUFDWE4sTUFBRSxDQUFDN1MsQ0FBRCxFQUFJO0FBQ0wsYUFBTyxJQUFJeGxCLElBQUksQ0FBQ3dSLEdBQUwsQ0FBU2dVLENBQUMsR0FBR3hsQixJQUFJLENBQUNvUixFQUFULEdBQWMsQ0FBdkIsQ0FBWDtBQUNBLEtBSFU7O0FBSVhrbkIsT0FBRyxDQUFDOVMsQ0FBRCxFQUFJO0FBQ04sYUFBT3hsQixJQUFJLENBQUNzUixHQUFMLENBQVNrVSxDQUFDLEdBQUd4bEIsSUFBSSxDQUFDb1IsRUFBVCxHQUFjLENBQXZCLENBQVA7QUFDQSxLQU5VOztBQU9YbW5CLFNBQUssQ0FBQy9TLENBQUQsRUFBSTtBQUNSLGFBQU8sT0FBTyxJQUFJeGxCLElBQUksQ0FBQ3dSLEdBQUwsQ0FBU3hSLElBQUksQ0FBQ29SLEVBQUwsR0FBVW9VLENBQW5CLENBQVgsQ0FBUDtBQUNBOztBQVRVLEdBOURFO0FBeUVkb1QsYUFBVyxFQUFFO0FBQ1pQLE1BQUUsQ0FBQzdTLENBQUQsRUFBSTtBQUNMLGFBQU9BLENBQUMsS0FBSyxDQUFOLEdBQVUsQ0FBVixHQUFjeGxCLElBQUksQ0FBQzZ4QixHQUFMLENBQVMsSUFBVCxFQUFlck0sQ0FBQyxHQUFHLENBQW5CLENBQXJCO0FBQ0EsS0FIVzs7QUFJWjhTLE9BQUcsQ0FBQzlTLENBQUQsRUFBSTtBQUNOLGFBQU9BLENBQUMsS0FBSyxDQUFOLEdBQVUsQ0FBVixHQUFjLElBQUl4bEIsSUFBSSxDQUFDNnhCLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBRSxFQUFGLEdBQU9yTSxDQUFuQixDQUF6QjtBQUNBLEtBTlc7O0FBT1orUyxTQUFLLENBQUMvUyxDQUFELEVBQUk7QUFDUixVQUFJQSxDQUFDLEtBQUssQ0FBVixFQUFhO0FBQ1osZUFBTyxDQUFQO0FBQ0E7O0FBQ0QsVUFBSUEsQ0FBQyxLQUFLLENBQVYsRUFBYTtBQUNaLGVBQU8sQ0FBUDtBQUNBOztBQUNELFVBQUksQ0FBQ0EsQ0FBQyxJQUFJLENBQU4sSUFBVyxDQUFmLEVBQWtCO0FBQ2pCLGVBQU8sTUFBTXhsQixJQUFJLENBQUM2eEIsR0FBTCxDQUFTLElBQVQsRUFBZXJNLENBQUMsR0FBRyxDQUFuQixDQUFiO0FBQ0E7O0FBQ0QsYUFBTyxPQUFPLENBQUV4bEIsSUFBSSxDQUFDNnhCLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBRSxFQUFGLElBQVFyTSxDQUFDLEdBQUcsQ0FBWixDQUFaLENBQUYsR0FBZ0MsQ0FBdkMsQ0FBUDtBQUNBOztBQWxCVyxHQXpFQztBQTZGZHFULFVBQVEsRUFBRTtBQUNUUixNQUFFLENBQUM3UyxDQUFELEVBQUk7QUFDTCxhQUFPLElBQUl4bEIsSUFBSSxDQUFDNkksSUFBTCxDQUFVLElBQUkyYyxDQUFDLEdBQUdBLENBQWxCLENBQVg7QUFDQSxLQUhROztBQUlUOFMsT0FBRyxDQUFDOVMsQ0FBRCxFQUFJO0FBQ04sYUFBT3hsQixJQUFJLENBQUM2SSxJQUFMLENBQVUsSUFBSyxFQUFFMmMsQ0FBRixHQUFNQSxDQUFyQixDQUFQO0FBQ0EsS0FOUTs7QUFPVCtTLFNBQUssQ0FBQy9TLENBQUQsRUFBSTtBQUNSLFVBQUksQ0FBQ0EsQ0FBQyxJQUFJLENBQU4sSUFBVyxDQUFmLEVBQWtCO0FBQ2pCLGVBQU8sQ0FBRSxHQUFGLElBQVN4bEIsSUFBSSxDQUFDNkksSUFBTCxDQUFVLElBQUkyYyxDQUFDLEdBQUdBLENBQWxCLElBQXVCLENBQWhDLENBQVA7QUFDQTs7QUFDRCxhQUFPLE9BQU94bEIsSUFBSSxDQUFDNkksSUFBTCxDQUFVLElBQUksQ0FBQzJjLENBQUMsSUFBSSxDQUFOLElBQVdBLENBQXpCLElBQThCLENBQXJDLENBQVA7QUFDQTs7QUFaUSxHQTdGSTtBQTJHZHNULFNBQU8sRUFBRTtBQUNSVCxNQUFFLENBQUM3UyxDQUFELEVBQUk7QUFDTCxVQUFJeDJCLENBQUo7QUFDQSxVQUFJN0IsQ0FBQyxHQUFHLEdBQVI7QUFDQSxZQUFNNHJDLENBQUMsR0FBRyxHQUFWOztBQUNBLFVBQUl2VCxDQUFDLEtBQUssQ0FBVixFQUFhO0FBQ1osZUFBTyxDQUFQO0FBQ0E7O0FBQ0QsVUFBSUEsQ0FBQyxLQUFLLENBQVYsRUFBYTtBQUNaLGVBQU8sQ0FBUDtBQUNBOztBQUNELFVBQUksQ0FBQ3I0QixDQUFELElBQU1BLENBQUMsR0FBRyxDQUFkLEVBQWlCO0FBQ2hCQSxTQUFDLEdBQUcsQ0FBSjtBQUNBNkIsU0FBQyxHQUFHK3BDLENBQUMsR0FBRyxDQUFSO0FBQ0EsT0FIRCxNQUdPO0FBQ04vcEMsU0FBQyxHQUFHK3BDLENBQUMsR0FBRy80QixJQUFJLENBQUNnNUIsSUFBTCxDQUFVLElBQUk3ckMsQ0FBZCxDQUFKLElBQXdCLElBQUk2UyxJQUFJLENBQUNvUixFQUFqQyxDQUFKO0FBQ0E7O0FBQ0QsYUFBTyxFQUFHamtCLENBQUMsR0FBRzZTLElBQUksQ0FBQzZ4QixHQUFMLENBQVMsQ0FBVCxFQUFZLE1BQU1yTSxDQUFDLElBQUksQ0FBWCxDQUFaLENBQUosR0FBaUN4bEIsSUFBSSxDQUFDc1IsR0FBTCxDQUFTLENBQUNrVSxDQUFDLEdBQUd4MkIsQ0FBTCxLQUFXLElBQUlnUixJQUFJLENBQUNvUixFQUFwQixJQUEwQjJuQixDQUFuQyxDQUFwQyxDQUFQO0FBQ0EsS0FsQk87O0FBbUJSVCxPQUFHLENBQUM5UyxDQUFELEVBQUk7QUFDTixVQUFJeDJCLENBQUo7QUFDQSxVQUFJN0IsQ0FBQyxHQUFHLEdBQVI7QUFDQSxZQUFNNHJDLENBQUMsR0FBRyxHQUFWOztBQUNBLFVBQUl2VCxDQUFDLEtBQUssQ0FBVixFQUFhO0FBQ1osZUFBTyxDQUFQO0FBQ0E7O0FBQ0QsVUFBSUEsQ0FBQyxLQUFLLENBQVYsRUFBYTtBQUNaLGVBQU8sQ0FBUDtBQUNBOztBQUNELFVBQUksQ0FBQ3I0QixDQUFELElBQU1BLENBQUMsR0FBRyxDQUFkLEVBQWlCO0FBQ2hCQSxTQUFDLEdBQUcsQ0FBSjtBQUNBNkIsU0FBQyxHQUFHK3BDLENBQUMsR0FBRyxDQUFSO0FBQ0EsT0FIRCxNQUdPO0FBQ04vcEMsU0FBQyxHQUFHK3BDLENBQUMsR0FBRy80QixJQUFJLENBQUNnNUIsSUFBTCxDQUFVLElBQUk3ckMsQ0FBZCxDQUFKLElBQXdCLElBQUk2UyxJQUFJLENBQUNvUixFQUFqQyxDQUFKO0FBQ0E7O0FBQ0QsYUFBUWprQixDQUFDLEdBQUc2UyxJQUFJLENBQUM2eEIsR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFFLEVBQUYsR0FBT3JNLENBQW5CLENBQUosR0FBNEJ4bEIsSUFBSSxDQUFDc1IsR0FBTCxDQUFTLENBQUNrVSxDQUFDLEdBQUd4MkIsQ0FBTCxLQUFXLElBQUlnUixJQUFJLENBQUNvUixFQUFwQixJQUEwQjJuQixDQUFuQyxDQUE1QixHQUFvRSxDQUE1RTtBQUNBLEtBcENPOztBQXFDUlIsU0FBSyxDQUFDL1MsQ0FBRCxFQUFJO0FBQ1IsVUFBSXgyQixDQUFKO0FBQ0EsVUFBSTdCLENBQUMsR0FBRyxHQUFSO0FBQ0EsWUFBTTRyQyxDQUFDLEdBQUcsR0FBVjs7QUFDQSxVQUFJdlQsQ0FBQyxLQUFLLENBQVYsRUFBYTtBQUNaLGVBQU8sQ0FBUDtBQUNBOztBQUNELFVBQUlBLENBQUMsS0FBSyxDQUFWLEVBQWE7QUFDWixlQUFPLENBQVA7QUFDQTs7QUFDRCxVQUFJLENBQUNyNEIsQ0FBRCxJQUFNQSxDQUFDLEdBQUcsQ0FBZCxFQUFpQjtBQUNoQkEsU0FBQyxHQUFHLENBQUo7QUFDQTZCLFNBQUMsR0FBRytwQyxDQUFDLEdBQUcsQ0FBUjtBQUNBLE9BSEQsTUFHTztBQUNOL3BDLFNBQUMsR0FBRytwQyxDQUFDLEdBQUcvNEIsSUFBSSxDQUFDZzVCLElBQUwsQ0FBVSxJQUFJN3JDLENBQWQsQ0FBSixJQUF3QixJQUFJNlMsSUFBSSxDQUFDb1IsRUFBakMsQ0FBSjtBQUNBOztBQUNELFVBQUksQ0FBQ29VLENBQUMsSUFBSSxDQUFOLElBQVcsQ0FBZixFQUFrQjtBQUNqQixlQUFPLENBQUUsR0FBRixJQUFTcjRCLENBQUMsR0FBRzZTLElBQUksQ0FBQzZ4QixHQUFMLENBQVMsQ0FBVCxFQUFZLE1BQU1yTSxDQUFDLElBQUksQ0FBWCxDQUFaLENBQUosR0FBaUN4bEIsSUFBSSxDQUFDc1IsR0FBTCxDQUFTLENBQUNrVSxDQUFDLEdBQUd4MkIsQ0FBTCxLQUFXLElBQUlnUixJQUFJLENBQUNvUixFQUFwQixJQUEwQjJuQixDQUFuQyxDQUExQyxDQUFQO0FBQ0E7O0FBQ0QsYUFBTzVyQyxDQUFDLEdBQUc2UyxJQUFJLENBQUM2eEIsR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDLEVBQUQsSUFBT3JNLENBQUMsSUFBSSxDQUFaLENBQVosQ0FBSixHQUFrQ3hsQixJQUFJLENBQUNzUixHQUFMLENBQVMsQ0FBQ2tVLENBQUMsR0FBR3gyQixDQUFMLEtBQVcsSUFBSWdSLElBQUksQ0FBQ29SLEVBQXBCLElBQTBCMm5CLENBQW5DLENBQWxDLEdBQTBFLEdBQTFFLEdBQWdGLENBQXZGO0FBQ0E7O0FBekRPLEdBM0dLO0FBc0tkRSxNQUFJLEVBQUU7QUFDTFosTUFBRSxDQUFDN1MsQ0FBRCxFQUFJO0FBQ0wsWUFBTXgyQixDQUFDLEdBQUcsT0FBVjtBQUNBLGFBQU93MkIsQ0FBQyxHQUFHQSxDQUFKLElBQVMsQ0FBQ3gyQixDQUFDLEdBQUcsQ0FBTCxJQUFVdzJCLENBQVYsR0FBY3gyQixDQUF2QixDQUFQO0FBQ0EsS0FKSTs7QUFLTHNwQyxPQUFHLENBQUM5UyxDQUFELEVBQUk7QUFDTixZQUFNeDJCLENBQUMsR0FBRyxPQUFWO0FBQ0EsYUFBTyxFQUFFdzJCLENBQUYsR0FBTUEsQ0FBTixJQUFXLENBQUN4MkIsQ0FBQyxHQUFHLENBQUwsSUFBVXcyQixDQUFWLEdBQWN4MkIsQ0FBekIsSUFBOEIsQ0FBckM7QUFDQSxLQVJJOztBQVNMdXBDLFNBQUssQ0FBQy9TLENBQUQsRUFBSTtBQUNSLFlBQU14MkIsQ0FBQyxHQUFHLFVBQVUsS0FBcEI7O0FBQ0EsVUFBSSxDQUFDdzJCLENBQUMsSUFBSSxDQUFOLElBQVcsQ0FBZixFQUFrQjtBQUNqQixlQUFPLE9BQU9BLENBQUMsR0FBR0EsQ0FBSixJQUFTLENBQUN4MkIsQ0FBQyxHQUFHLENBQUwsSUFBVXcyQixDQUFWLEdBQWN4MkIsQ0FBdkIsQ0FBUCxDQUFQO0FBQ0E7O0FBQ0QsYUFBTyxPQUFPLENBQUN3MkIsQ0FBQyxJQUFJLENBQU4sSUFBV0EsQ0FBWCxJQUFnQixDQUFDeDJCLENBQUMsR0FBRyxDQUFMLElBQVV3MkIsQ0FBVixHQUFjeDJCLENBQTlCLElBQW1DLENBQTFDLENBQVA7QUFDQTs7QUFmSSxHQXRLUTtBQXVMZGtxQyxRQUFNLEVBQUU7QUFDUEMsTUFBRSxDQUFDM1QsQ0FBRCxFQUFJO0FBQ0wsYUFBTyxJQUFJeVMsTUFBTSxDQUFDaUIsTUFBUCxDQUFjRSxHQUFkLENBQWtCLElBQUk1VCxDQUF0QixDQUFYO0FBQ0EsS0FITTs7QUFJUDRULE9BQUcsQ0FBQzVULENBQUQsRUFBSTtBQUNOLFVBQUlBLENBQUMsR0FBSSxJQUFJLElBQWIsRUFBb0I7QUFDbkIsZUFBTyxTQUFTQSxDQUFULEdBQWFBLENBQXBCO0FBQ0EsT0FGRCxNQUVPLElBQUlBLENBQUMsR0FBSSxJQUFJLElBQWIsRUFBb0I7QUFDMUIsZUFBTyxVQUFVQSxDQUFDLElBQUssTUFBTSxJQUF0QixJQUErQkEsQ0FBL0IsR0FBbUMsSUFBMUM7QUFDQSxPQUZNLE1BRUEsSUFBSUEsQ0FBQyxHQUFJLE1BQU0sSUFBZixFQUFzQjtBQUM1QixlQUFPLFVBQVVBLENBQUMsSUFBSyxPQUFPLElBQXZCLElBQWdDQSxDQUFoQyxHQUFvQyxNQUEzQztBQUNBLE9BRk0sTUFFQTtBQUNOLGVBQU8sVUFBVUEsQ0FBQyxJQUFLLFFBQVEsSUFBeEIsSUFBaUNBLENBQWpDLEdBQXFDLFFBQTVDO0FBQ0E7QUFDRCxLQWRNOztBQWVQNlQsU0FBSyxDQUFDN1QsQ0FBRCxFQUFJO0FBQ1IsVUFBSUEsQ0FBQyxHQUFHLEdBQVIsRUFBYTtBQUNaLGVBQU95UyxNQUFNLENBQUNpQixNQUFQLENBQWNDLEVBQWQsQ0FBaUIzVCxDQUFDLEdBQUcsQ0FBckIsSUFBMEIsR0FBakM7QUFDQTs7QUFDRCxhQUFPeVMsTUFBTSxDQUFDaUIsTUFBUCxDQUFjRSxHQUFkLENBQWtCNVQsQ0FBQyxHQUFHLENBQUosR0FBUSxDQUExQixJQUErQixHQUEvQixHQUFxQyxHQUE1QztBQUNBOztBQXBCTTtBQXZMTSxDQUFmOztBQStNQSxTQUFTOFQsT0FBVCxDQUFpQnZNLE9BQWpCLEVBQTBCO0FBQ3pCLFVBQVFBLE9BQVI7QUFDQTtBQUNBLFNBQUssUUFBTDtBQUNDLGFBQU9rTCxNQUFNLENBQUNDLE1BQVAsQ0FBY0MsSUFBckI7O0FBQ0QsU0FBSyxPQUFMO0FBQ0MsYUFBT0YsTUFBTSxDQUFDVyxXQUFQLENBQW1CUCxFQUExQjs7QUFDRCxTQUFLLFFBQUw7QUFDQyxhQUFPSixNQUFNLENBQUNXLFdBQVAsQ0FBbUJOLEdBQTFCOztBQUNELFNBQUssVUFBTDtBQUNDLGFBQU9MLE1BQU0sQ0FBQ1csV0FBUCxDQUFtQkwsS0FBMUI7O0FBRUQsU0FBSyxTQUFMO0FBQ0MsYUFBT04sTUFBTSxDQUFDTyxLQUFQLENBQWFILEVBQXBCOztBQUNELFNBQUssVUFBTDtBQUNDLGFBQU9KLE1BQU0sQ0FBQ08sS0FBUCxDQUFhRixHQUFwQjs7QUFDRCxTQUFLLFlBQUw7QUFDQyxhQUFPTCxNQUFNLENBQUNPLEtBQVAsQ0FBYUQsS0FBcEI7O0FBRUQsU0FBSyxXQUFMO0FBQ0MsYUFBT04sTUFBTSxDQUFDUSxPQUFQLENBQWVKLEVBQXRCOztBQUNELFNBQUssWUFBTDtBQUNDLGFBQU9KLE1BQU0sQ0FBQ1EsT0FBUCxDQUFlSCxHQUF0Qjs7QUFDRCxTQUFLLGNBQUw7QUFDQyxhQUFPTCxNQUFNLENBQUNRLE9BQVAsQ0FBZUYsS0FBdEI7O0FBRUQsU0FBSyxXQUFMO0FBQ0MsYUFBT04sTUFBTSxDQUFDUyxPQUFQLENBQWVMLEVBQXRCOztBQUNELFNBQUssWUFBTDtBQUNDLGFBQU9KLE1BQU0sQ0FBQ1MsT0FBUCxDQUFlSixHQUF0Qjs7QUFDRCxTQUFLLGNBQUw7QUFDQyxhQUFPTCxNQUFNLENBQUNTLE9BQVAsQ0FBZUgsS0FBdEI7O0FBRUQsU0FBSyxjQUFMO0FBQ0MsYUFBT04sTUFBTSxDQUFDVSxVQUFQLENBQWtCTixFQUF6Qjs7QUFDRCxTQUFLLGVBQUw7QUFDQyxhQUFPSixNQUFNLENBQUNVLFVBQVAsQ0FBa0JMLEdBQXpCOztBQUNELFNBQUssaUJBQUw7QUFDQyxhQUFPTCxNQUFNLENBQUNVLFVBQVAsQ0FBa0JKLEtBQXpCOztBQUVELFNBQUssWUFBTDtBQUNDLGFBQU9OLE1BQU0sQ0FBQ1ksUUFBUCxDQUFnQlIsRUFBdkI7O0FBQ0QsU0FBSyxhQUFMO0FBQ0MsYUFBT0osTUFBTSxDQUFDWSxRQUFQLENBQWdCUCxHQUF2Qjs7QUFDRCxTQUFLLGVBQUw7QUFDQyxhQUFPTCxNQUFNLENBQUNZLFFBQVAsQ0FBZ0JOLEtBQXZCOztBQUVELFNBQUssV0FBTDtBQUNDLGFBQU9OLE1BQU0sQ0FBQ2EsT0FBUCxDQUFlVCxFQUF0Qjs7QUFDRCxTQUFLLFlBQUw7QUFDQyxhQUFPSixNQUFNLENBQUNhLE9BQVAsQ0FBZVIsR0FBdEI7O0FBQ0QsU0FBSyxjQUFMO0FBQ0MsYUFBT0wsTUFBTSxDQUFDYSxPQUFQLENBQWVQLEtBQXRCOztBQUVELFNBQUssUUFBTDtBQUNDLGFBQU9OLE1BQU0sQ0FBQ2dCLElBQVAsQ0FBWVosRUFBbkI7O0FBQ0QsU0FBSyxTQUFMO0FBQ0MsYUFBT0osTUFBTSxDQUFDZ0IsSUFBUCxDQUFZWCxHQUFuQjs7QUFDRCxTQUFLLFdBQUw7QUFDQyxhQUFPTCxNQUFNLENBQUNnQixJQUFQLENBQVlWLEtBQW5COztBQUVELFNBQUssVUFBTDtBQUNDLGFBQU9OLE1BQU0sQ0FBQ2lCLE1BQVAsQ0FBY0MsRUFBckI7O0FBQ0QsU0FBSyxXQUFMO0FBQ0MsYUFBT2xCLE1BQU0sQ0FBQ2lCLE1BQVAsQ0FBY0UsR0FBckI7O0FBQ0QsU0FBSyxhQUFMO0FBQ0MsYUFBT25CLE1BQU0sQ0FBQ2lCLE1BQVAsQ0FBY0csS0FBckI7QUFqRUQ7QUFtRUE7O0FBRUQsTUFBTXprQyxXQUFOLENBQWtCO0FBQ2pCdEQsYUFBVyxDQUFDSyxNQUFELEVBQVNvN0IsT0FBTyxHQUFHLFFBQW5CLEVBQTZCb0osTUFBTSxHQUFHLElBQXRDLEVBQTRDO0FBQ3RELFNBQUsza0MsTUFBTCxHQUFjRyxNQUFkO0FBQ0EsU0FBSzRuQyxXQUFMLEdBQW1CNW5DLE1BQW5CO0FBQ0EsU0FBS3M3QixZQUFMLEdBQW9CdDdCLE1BQXBCO0FBQ0EsU0FBSzZuQyxRQUFMLEdBQWdCLENBQWhCO0FBQ0EsU0FBS3ZFLEtBQUwsR0FBYWtCLE1BQWI7QUFDQSxTQUFLbkosTUFBTCxHQUFjRCxPQUFkO0FBQ0EsU0FBS25DLFdBQUwsR0FBbUIsSUFBbkI7QUFFQSxTQUFLdE4sUUFBTCxHQUFvQjlvQixrREFBUyxDQUFDOFQsS0FBVixDQUFnQixNQUFLLEtBQUt3akIsT0FBTCxFQUFyQixDQUFwQjtBQUNBOztBQUdEQSxTQUFPLEdBQUc7QUFDVCxRQUFJMk4sVUFBVSxHQUFHLEtBQUtELFFBQUwsR0FBZ0IsS0FBS3ZFLEtBQXRDOztBQUNBLFFBQUd3RSxVQUFVLEdBQUcsQ0FBaEIsRUFBbUI7QUFBRUEsZ0JBQVUsR0FBRyxDQUFiO0FBQWlCOztBQUN0QyxRQUFHLEtBQUtELFFBQUwsS0FBa0JDLFVBQXJCLEVBQWlDO0FBQ2hDLFdBQUs3TyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0E7QUFDQTs7QUFFRCxTQUFLNE8sUUFBTCxHQUFnQkMsVUFBaEI7QUFDQSxTQUFLN08sV0FBTCxHQUFtQixJQUFuQjtBQUNBOztBQUdEMEMsT0FBSyxDQUFDQyxJQUFELEVBQU9DLElBQVAsRUFBYTtBQUNqQixRQUFHRCxJQUFJLEdBQUdDLElBQVYsRUFBZ0I7QUFDZixXQUFLRixLQUFMLENBQVdFLElBQVgsRUFBaUJELElBQWpCO0FBQ0E7QUFDQTs7QUFFRCxTQUFLRSxJQUFMLEdBQVlGLElBQVo7QUFDQSxTQUFLRyxJQUFMLEdBQVlGLElBQVo7O0FBRUEsU0FBS0wsV0FBTDtBQUNBOztBQUVEMzVCLE9BQUssQ0FBQzdCLE1BQUQsRUFBUztBQUNiLFNBQUtILE1BQUwsR0FBY0csTUFBZDtBQUNBLFNBQUtzN0IsWUFBTCxHQUFvQnQ3QixNQUFwQjtBQUNBLFNBQUs2bkMsUUFBTCxHQUFnQixDQUFoQjtBQUNBOztBQUdEck0sYUFBVyxHQUFHO0FBQ2IsUUFBRyxLQUFLTSxJQUFMLEtBQWNsNkIsU0FBZCxJQUEyQixLQUFLMDVCLFlBQUwsR0FBb0IsS0FBS1EsSUFBdkQsRUFBNkQ7QUFDNUQsV0FBS1IsWUFBTCxHQUFvQixLQUFLUSxJQUF6QjtBQUNBOztBQUVELFFBQUcsS0FBS0MsSUFBTCxLQUFjbjZCLFNBQWQsSUFBMkIsS0FBSzA1QixZQUFMLEdBQW9CLEtBQUtTLElBQXZELEVBQTZEO0FBQzVELFdBQUtULFlBQUwsR0FBb0IsS0FBS1MsSUFBekI7QUFDQTtBQUNEOztBQUdEdCtCLFNBQU8sR0FBRztBQUNUb0Ysc0RBQVMsQ0FBQ29wQixRQUFWLENBQW1CLEtBQUtOLFFBQXhCO0FBQ0EsR0EzRGdCLENBNkRqQjs7O0FBRUEsTUFBSXpyQixLQUFKLENBQVVGLE1BQVYsRUFBa0I7QUFDakIsU0FBSzRuQyxXQUFMLEdBQW1CLEtBQUsvbkMsTUFBeEI7QUFDQSxTQUFLeTdCLFlBQUwsR0FBb0J0N0IsTUFBcEI7O0FBQ0EsU0FBS3c3QixXQUFMOztBQUNBLFNBQUtxTSxRQUFMLEdBQWdCLENBQWhCO0FBQ0E7O0FBRUQsTUFBSTNuQyxLQUFKLEdBQVk7QUFDWCxRQUFHLEtBQUsrNEIsV0FBUixFQUFxQjtBQUNwQixZQUFNZ0gsQ0FBQyxHQUFHMEgsT0FBTyxDQUFDLEtBQUt0TSxNQUFOLENBQWpCO0FBQ0EsWUFBTStMLENBQUMsR0FBR25ILENBQUMsQ0FBQyxLQUFLNEgsUUFBTixDQUFYO0FBQ0EsV0FBS2hvQyxNQUFMLEdBQWMsS0FBSytuQyxXQUFMLEdBQW1CUixDQUFDLElBQUksS0FBSzlMLFlBQUwsR0FBb0IsS0FBS3NNLFdBQTdCLENBQWxDO0FBQ0EsV0FBSzNPLFdBQUwsR0FBbUIsS0FBbkI7QUFDQTs7QUFDRCxXQUFPLEtBQUtwNUIsTUFBWjtBQUNBOztBQUVELE1BQUltOEIsV0FBSixHQUFrQjtBQUNqQixXQUFPLEtBQUtWLFlBQVo7QUFDQTs7QUFsRmdCOztBQXNGSHI0QiwwRUFBZixFOzs7Ozs7Ozs7OztBQ2pYQTtBQUVBO0FBRUE4a0MsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2hCQyxtQkFBaUIsRUFBRSxLQURIO0FBRWhCQyw2QkFBMkIsRUFBRSxLQUZiO0FBR2hCQyxnQkFBYyxFQUFFLEtBSEE7QUFJaEJDLGlCQUFlLEVBQUUsS0FKRDtBQUtoQkMsMkJBQXlCLEVBQUUsS0FMWDtBQU1oQkMsMEJBQXdCLEVBQUUsS0FOVjtBQU9oQkMsMEJBQXdCLEVBQUUsS0FQVjtBQVFoQkMsT0FBSyxFQUFFLElBUlM7QUFTaEJDLFlBQVUsRUFBRSxJQVRJO0FBVWhCQyxRQUFNLEVBQUUsR0FWUTtBQVdoQi9yQixjQUFZLEVBQUUsS0FYRTtBQVloQmdzQixzQkFBb0IsRUFBRSxLQVpOO0FBYWhCQyxrQkFBZ0IsRUFBRSxLQWJGO0FBY2hCQyxNQUFJLEVBQUUsSUFkVTtBQWVoQnR2QixPQUFLLEVBQUUsSUFmUztBQWdCaEJ1dkIsYUFBVyxFQUFFLEtBaEJHO0FBaUJoQkMsaUJBQWUsRUFBRSxLQWpCRDtBQWtCaEJDLGVBQWEsRUFBRSxLQWxCQztBQW1CaEJDLGdCQUFjLEVBQUUsS0FuQkE7QUFvQmhCQyxzQkFBb0IsRUFBRSxLQXBCTjtBQXFCaEJDLG9CQUFrQixFQUFFLEtBckJKO0FBc0JoQkMsaUJBQWUsRUFBRSxLQXRCRDtBQXVCaEJDLGVBQWEsRUFBRSxLQXZCQztBQXdCaEJDLFdBQVMsRUFBRSxJQXhCSztBQXlCaEJDLE1BQUksRUFBRSxLQXpCVTtBQTBCaEJDLFdBQVMsRUFBRSxLQTFCSztBQTJCaEJDLFdBQVMsRUFBRSxLQTNCSztBQTRCaEJDLFdBQVMsRUFBRSxLQTVCSztBQTZCaEJDLHVCQUFxQixFQUFFLEtBN0JQO0FBOEJoQkMsYUFBVyxFQUFFLEtBOUJHO0FBK0JoQkMsY0FBWSxFQUFFLEtBL0JFO0FBZ0NoQkMsTUFBSSxFQUFFLElBaENVO0FBaUNoQkMsS0FBRyxFQUFFLElBakNXO0FBa0NoQmhrQyxlQUFhLEVBQUUsS0FsQ0M7QUFtQ2hCZ0MsbUJBQWlCLEVBQUUsS0FuQ0g7QUFvQ2hCK1Isa0JBQWdCLEVBQUUsS0FwQ0Y7QUFxQ2hCa3dCLG1CQUFpQixFQUFFLElBckNIO0FBc0NoQkMsaUJBQWUsRUFBRSxJQXRDRDtBQXVDaEIzM0IsZ0JBQWMsRUFBRSxLQXZDQTtBQXdDaEI0M0IsNEJBQTBCLEVBQUUsS0F4Q1o7QUF5Q2hCQyxnQkFBYyxFQUFFLEtBekNBO0FBMENoQkMsZ0JBQWMsRUFBRSxLQTFDQTtBQTJDaEJDLG9CQUFrQixFQUFFLEtBM0NKO0FBNENoQi93QixXQUFTLEVBQUUsSUE1Q0s7QUE2Q2hCZ3hCLGdCQUFjLEVBQUUsSUE3Q0E7QUE4Q2hCQyxpQkFBZSxFQUFFLEtBOUNEO0FBK0NoQkMsdUJBQXFCLEVBQUUsS0EvQ1A7QUFnRGhCQyxJQUFFLEVBQUUsSUFoRFk7QUFpRGhCQyxNQUFJLEVBQUUsSUFqRFU7QUFrRGhCQyxXQUFTLEVBQUUsS0FsREs7QUFtRGhCQyxlQUFhLEVBQUUsS0FuREM7QUFvRGhCdGdDLGtCQUFnQixFQUFFLEtBcERGO0FBcURoQnVnQyxZQUFVLEVBQUUsSUFyREk7QUFzRGhCOXdCLGtCQUFnQixFQUFFLEdBdERGO0FBdURoQit3QixtQkFBaUIsRUFBRSxJQXZESDtBQXdEaEIzL0IsaUJBQWUsRUFBRSxJQXhERDtBQXlEaEI0L0IsS0FBRyxFQUFFLElBekRXO0FBMERoQjkvQixtQkFBaUIsRUFBRSxLQTFESDtBQTJEaEIrL0IsWUFBVSxFQUFFLElBM0RJO0FBNERoQkMsYUFBVyxFQUFFLElBNURHO0FBNkRoQkMsZUFBYSxFQUFFLEtBN0RDO0FBOERoQkMsMEJBQXdCLEVBQUUsS0E5RFY7QUErRGhCOXhCLFlBQVUsRUFBRSxJQS9ESTtBQWdFaEIreEIsaUJBQWUsRUFBRSxJQWhFRDtBQWlFaEJDLFFBQU0sRUFBRSxJQWpFUTtBQWtFaEJDLFdBQVMsRUFBRSxJQWxFSztBQW1FaEJDLFdBQVMsRUFBRSxHQW5FSztBQW9FaEJDLFdBQVMsRUFBRSxHQXBFSztBQXFFaEJ2cEIsY0FBWSxFQUFFLEtBckVFO0FBc0VoQmtCLHNCQUFvQixFQUFFLEtBdEVOO0FBdUVoQnNvQiw4QkFBNEIsRUFBRSxLQXZFZDtBQXdFaEJDLE9BQUssRUFBRSxHQXhFUztBQXlFaEJDLFNBQU8sRUFBRSxJQXpFTztBQTBFaEJua0MsT0FBSyxFQUFFLElBMUVTO0FBMkVoQm9rQyxZQUFVLEVBQUUsS0EzRUk7QUE0RWhCQyxZQUFVLEVBQUUsS0E1RUk7QUE2RWhCQyxZQUFVLEVBQUUsS0E3RUk7QUE4RWhCQyxZQUFVLEVBQUUsS0E5RUk7QUErRWhCQyxZQUFVLEVBQUUsS0EvRUk7QUFnRmhCQyxZQUFVLEVBQUUsS0FoRkk7QUFpRmhCaDZCLGlCQUFlLEVBQUUsS0FqRkQ7QUFrRmhCcEssYUFBVyxFQUFFLEtBbEZHO0FBbUZoQnFrQyxvQ0FBa0MsRUFBRSxLQW5GcEI7QUFvRmhCQyxvQ0FBa0MsRUFBRSxLQXBGcEI7QUFxRmhCQyw4Q0FBNEMsRUFBRSxLQXJGOUI7QUFzRmhCQyxzQ0FBb0MsRUFBRSxLQXRGdEI7QUF1RmhCQyxxQkFBbUIsRUFBRSxLQXZGTDtBQXdGaEJwa0Msc0JBQW9CLEVBQUUsS0F4Rk47QUF5RmhCcWtDLG1DQUFpQyxFQUFFLEtBekZuQjtBQTBGaEJDLG1DQUFpQyxFQUFFLEtBMUZuQjtBQTJGaEJDLDJDQUF5QyxFQUFFLEtBM0YzQjtBQTRGaEJDLHlCQUF1QixFQUFFLEtBNUZUO0FBNkZoQkMsT0FBSyxFQUFFLElBN0ZTO0FBOEZoQkMsZ0JBQWMsRUFBRSxJQTlGQTtBQStGaEJDLFlBQVUsRUFBRSxJQS9GSTtBQWdHaEJDLFVBQVEsRUFBRSxLQWhHTTtBQWlHaEJDLHVCQUFxQixFQUFFLEtBakdQO0FBa0doQkMsZUFBYSxFQUFFLEtBbEdDO0FBbUdoQkMsc0JBQW9CLEVBQUUsS0FuR047QUFvR2hCQyxRQUFNLEVBQUUsR0FwR1E7QUFxR2hCQyxTQUFPLEVBQUUsR0FyR087QUFzR2hCQyxZQUFVLEVBQUUsSUF0R0k7QUF1R2hCQyxZQUFVLEVBQUUsS0F2R0k7QUF3R2hCQyxVQUFRLEVBQUUsS0F4R007QUF5R2hCQyxNQUFJLEVBQUUsSUF6R1U7QUEwR2hCQyxXQUFTLEVBQUUsS0ExR0s7QUEyR2hCQyxpQkFBZSxFQUFFLEtBM0dEO0FBNEdoQkMsS0FBRyxFQUFFLElBNUdXO0FBNkdoQkMsVUFBUSxFQUFFLEtBN0dNO0FBOEdoQkMsVUFBUSxFQUFFLEtBOUdNO0FBK0doQkMsVUFBUSxFQUFFLEtBL0dNO0FBZ0hoQkMsY0FBWSxFQUFFLElBaEhFO0FBaUhoQkMsK0JBQTZCLEVBQUUsSUFqSGY7QUFrSGhCQyxtQkFBaUIsRUFBRSxJQWxISDtBQW1IaEJDLGVBQWEsRUFBRSxJQW5IQztBQW9IaEJDLFFBQU0sRUFBRSxJQXBIUTtBQXFIaEJDLE1BQUksRUFBRSxJQXJIVTtBQXNIaEJDLFFBQU0sRUFBRSxHQXRIUTtBQXVIaEJDLE1BQUksRUFBRSxHQXZIVTtBQXdIaEJ6b0MsUUFBTSxFQUFFLElBeEhRO0FBeUhoQnNILHNCQUFvQixFQUFFLElBekhOO0FBMEhoQjhILHVCQUFxQixFQUFFLElBMUhQO0FBMkhoQmtWLE9BQUssRUFBRSxDQTNIUztBQTRIaEJva0IsV0FBUyxFQUFFLENBNUhLO0FBNkhoQkMsWUFBVSxFQUFFLENBN0hJO0FBOEhoQkMsWUFBVSxFQUFFLElBOUhJO0FBK0hoQkMsYUFBVyxFQUFFLEtBL0hHO0FBZ0loQkMsV0FBUyxFQUFFLEtBaElLO0FBaUloQkMsU0FBTyxFQUFFLEtBaklPO0FBa0loQkMsV0FBUyxFQUFFLElBbElLO0FBbUloQkMsaUJBQWUsRUFBRSxJQW5JRDtBQW9JaEJDLGtDQUFnQyxFQUFFLEtBcElsQjtBQXFJaEJDLDJCQUF5QixFQUFFLEtBcklYO0FBc0loQkMsOEJBQTRCLEVBQUUsS0F0SWQ7QUF1SWhCQyx1QkFBcUIsRUFBRSxLQXZJUDtBQXdJaEJDLHlCQUF1QixFQUFFLEtBeElUO0FBeUloQkMsa0JBQWdCLEVBQUUsSUF6SUY7QUEwSWhCQyxxQkFBbUIsRUFBRSxLQTFJTDtBQTJJaEJDLG9CQUFrQixFQUFFLEtBM0lKO0FBNEloQkMsZ0NBQThCLEVBQUUsS0E1SWhCO0FBNkloQkMsNEJBQTBCLEVBQUUsS0E3SVo7QUE4SWhCQyxtQkFBaUIsRUFBRSxJQTlJSDtBQStJaEJDLGNBQVksRUFBRSxLQS9JRTtBQWdKaEJDLFlBQVUsRUFBRSxLQWhKSTtBQWlKaEJ0N0IsaUJBQWUsRUFBRSxLQWpKRDtBQWtKaEJoSixTQUFPLEVBQUUsSUFsSk87QUFtSmhCOEksdUJBQXFCLEVBQUUsSUFuSlA7QUFvSmhCUyx3QkFBc0IsRUFBRSxJQXBKUjtBQXFKaEJnN0IsT0FBSyxFQUFFLEdBckpTO0FBc0poQkMsUUFBTSxFQUFFLElBdEpRO0FBdUpoQkMsTUFBSSxFQUFFLENBdkpVO0FBd0poQkMsVUFBUSxFQUFFLEdBeEpNO0FBeUpoQkMsVUFBUSxFQUFFLENBekpNO0FBMEpoQkMsZ0NBQThCLEVBQUUsS0ExSmhCO0FBMkpoQjd5QixLQUFHLEVBQUUsQ0EzSlc7QUE0SmhCOHlCLDBCQUF3QixFQUFFLEtBNUpWO0FBNkpoQkMsMEJBQXdCLEVBQUUsS0E3SlY7QUE4SmhCQyxxQkFBbUIsRUFBRSxHQTlKTDtBQStKaEJDLHFCQUFtQixFQUFFLEdBL0pMO0FBZ0toQm56QixxQkFBbUIsRUFBRSxHQWhLTDtBQWlLaEJvekIscUJBQW1CLEVBQUUsR0FqS0w7QUFrS2hCQyxlQUFhLEVBQUUsSUFsS0M7QUFtS2hCQyxnQkFBYyxFQUFFLElBbktBO0FBb0toQm4xQixRQUFNLEVBQUUsQ0FwS1E7QUFxS2hCbzFCLHVCQUFxQixFQUFFLEtBcktQO0FBc0toQkMscUJBQW1CLEVBQUUsS0F0S0w7QUF1S2hCQyxzQkFBb0IsRUFBRSxLQXZLTjtBQXdLaEJDLFVBQVEsRUFBRSxJQXhLTTtBQXlLaEJ2b0MsY0FBWSxFQUFFLEtBektFO0FBMEtoQndvQyx5QkFBdUIsRUFBRSxLQTFLVDtBQTJLaEJDLHNCQUFvQixFQUFFLEtBM0tOO0FBNEtoQkMsd0JBQXNCLEVBQUUsS0E1S1I7QUE2S2hCQyx5QkFBdUIsRUFBRSxLQTdLVDtBQThLaEJDLHlCQUF1QixFQUFFLEtBOUtUO0FBK0toQkMscUJBQW1CLEVBQUUsS0EvS0w7QUFnTGhCQyw4QkFBNEIsRUFBRSxLQWhMZDtBQWlMaEJDLHVCQUFxQixFQUFFLEtBakxQO0FBa0xoQkMsMkJBQXlCLEVBQUUsS0FsTFg7QUFtTGhCQyxvQkFBa0IsRUFBRSxLQW5MSjtBQW9MaEJDLFVBQVEsRUFBRSxJQXBMTTtBQXFMaEIxOEIsUUFBTSxFQUFFLEtBckxRO0FBc0xoQjI4QixTQUFPLEVBQUUsSUF0TE87QUF1TGhCQyxLQUFHLEVBQUUsSUF2TFc7QUF3TGhCQyxTQUFPLEVBQUUsS0F4TE87QUF5TGhCQyxRQUFNLEVBQUUsS0F6TFE7QUEwTGhCcnFDLE1BQUksRUFBRSxJQTFMVTtBQTJMaEJzcUMsT0FBSyxFQUFFLEtBM0xTO0FBNExoQkMsWUFBVSxFQUFFLEtBNUxJO0FBNkxoQkMsY0FBWSxFQUFFLEtBN0xFO0FBOExoQkMsU0FBTyxFQUFFLEtBOUxPO0FBK0xoQkMsMEJBQXdCLEVBQUUsS0EvTFY7QUFnTWhCQyxnQkFBYyxFQUFFLEtBaE1BO0FBaU1oQkMsaUJBQWUsRUFBRSxLQWpNRDtBQWtNaEJDLHdCQUFzQixFQUFFLEtBbE1SO0FBbU1oQkMsdUJBQXFCLEVBQUUsS0FuTVA7QUFvTWhCQyxhQUFXLEVBQUUsSUFwTUc7QUFxTWhCQyxjQUFZLEVBQUUsSUFyTUU7QUFzTWhCQyxpQkFBZSxFQUFFLEtBdE1EO0FBdU1oQkMsc0JBQW9CLEVBQUUsS0F2TU47QUF3TWhCQyxhQUFXLEVBQUUsS0F4TUc7QUF5TWhCQywwQkFBd0IsRUFBRSxLQXpNVjtBQTBNaEJDLE9BQUssRUFBRSxJQTFNUztBQTJNaEIxMUIsV0FBUyxFQUFFLEdBM01LO0FBNE1oQjIxQixvQkFBa0IsRUFBRSxHQTVNSjtBQTZNaEJDLFdBQVMsRUFBRSxHQTdNSztBQThNaEJweUIsYUFBVyxFQUFFLEtBOU1HO0FBK01oQnF5QixvQkFBa0IsRUFBRSxLQS9NSjtBQWdOaEJDLG1CQUFpQixFQUFFLEtBaE5IO0FBaU5oQkMsbUJBQWlCLEVBQUUsS0FqTkg7QUFrTmhCQyw4QkFBNEIsRUFBRSxLQWxOZDtBQW1OaEJDLDhCQUE0QixFQUFFLEtBbk5kO0FBb05oQkMsa0JBQWdCLEVBQUUsS0FwTkY7QUFxTmhCQyx5QkFBdUIsRUFBRSxLQXJOVDtBQXNOaEJDLHdCQUFzQixFQUFFLEtBdE5SO0FBdU5oQkMsY0FBWSxFQUFFLElBdk5FO0FBd05oQkMsb0JBQWtCLEVBQUUsSUF4Tko7QUF5TmhCQyxxQkFBbUIsRUFBRSxJQXpOTDtBQTBOaEJDLGNBQVksRUFBRSxJQTFORTtBQTJOaEJDLGNBQVksRUFBRSxJQTNORTtBQTROaEJDLGVBQWEsRUFBRSxJQTVOQztBQTZOaEJDLGdCQUFjLEVBQUUsS0E3TkE7QUE4TmhCQyx5QkFBdUIsRUFBRSxJQTlOVDtBQStOaEJDLHlCQUF1QixFQUFFLElBL05UO0FBZ09oQkMsYUFBVyxFQUFFLElBaE9HO0FBaU9oQkMsY0FBWSxFQUFFLElBak9FO0FBa09oQkMsb0JBQWtCLEVBQUUsSUFsT0o7QUFtT2hCQyxtQkFBaUIsRUFBRSxJQW5PSDtBQW9PaEJDLGFBQVcsRUFBRSxLQXBPRztBQXFPaEJDLGVBQWEsRUFBRSxJQXJPQztBQXNPaEJDLFNBQU8sRUFBRSxJQXRPTztBQXVPaEIzbUMsVUFBUSxFQUFFLEtBdk9NO0FBd09oQjRtQyxVQUFRLEVBQUUsS0F4T007QUF5T2hCQyxVQUFRLEVBQUUsS0F6T007QUEwT2hCQyxVQUFRLEVBQUUsS0ExT007QUEyT2hCQyxVQUFRLEVBQUUsS0EzT007QUE0T2hCQyxVQUFRLEVBQUUsS0E1T007QUE2T2hCQyxVQUFRLEVBQUUsS0E3T007QUE4T2hCQyxVQUFRLEVBQUUsS0E5T007QUErT2hCQyxVQUFRLEVBQUUsS0EvT007QUFnUGhCQyxVQUFRLEVBQUUsS0FoUE07QUFpUGhCQyxXQUFTLEVBQUUsS0FqUEs7QUFrUGhCQyxXQUFTLEVBQUUsS0FsUEs7QUFtUGhCQyxXQUFTLEVBQUUsS0FuUEs7QUFvUGhCQyxXQUFTLEVBQUUsS0FwUEs7QUFxUGhCQyxXQUFTLEVBQUUsS0FyUEs7QUFzUGhCQyxXQUFTLEVBQUUsS0F0UEs7QUF1UGhCQyxXQUFTLEVBQUUsS0F2UEs7QUF3UGhCQyxXQUFTLEVBQUUsS0F4UEs7QUF5UGhCQyxXQUFTLEVBQUUsS0F6UEs7QUEwUGhCQyxXQUFTLEVBQUUsS0ExUEs7QUEyUGhCQyxXQUFTLEVBQUUsS0EzUEs7QUE0UGhCQyxXQUFTLEVBQUUsS0E1UEs7QUE2UGhCQyxXQUFTLEVBQUUsS0E3UEs7QUE4UGhCQyxXQUFTLEVBQUUsS0E5UEs7QUErUGhCQyxXQUFTLEVBQUUsS0EvUEs7QUFnUWhCQyxXQUFTLEVBQUUsS0FoUUs7QUFpUWhCQyxXQUFTLEVBQUUsS0FqUUs7QUFrUWhCQyxXQUFTLEVBQUUsS0FsUUs7QUFtUWhCQyxXQUFTLEVBQUUsS0FuUUs7QUFvUWhCQyxXQUFTLEVBQUUsS0FwUUs7QUFxUWhCQyxXQUFTLEVBQUUsS0FyUUs7QUFzUWhCQyxXQUFTLEVBQUUsS0F0UUs7QUF1UWhCaHNDLFlBQVUsRUFBRSxJQXZRSTtBQXdRaEJpc0Msb0JBQWtCLEVBQUUsS0F4UUo7QUF5UWhCQywwQkFBd0IsRUFBRSxLQXpRVjtBQTBRaEJod0Msa0JBQWdCLEVBQUUsS0ExUUY7QUEyUWhCUSw2QkFBMkIsRUFBRSxLQTNRYjtBQTRRaEJFLDZCQUEyQixFQUFFLEtBNVFiO0FBNlFoQkUsNkJBQTJCLEVBQUUsS0E3UWI7QUE4UWhCTCw2QkFBMkIsRUFBRSxLQTlRYjtBQStRaEJFLDZCQUEyQixFQUFFLEtBL1FiO0FBZ1JoQkUsNkJBQTJCLEVBQUUsS0FoUmI7QUFpUmhCVCxvQkFBa0IsRUFBRSxLQWpSSjtBQWtSaEJDLG9CQUFrQixFQUFFLEtBbFJKO0FBbVJoQkMsZ0JBQWMsRUFBRSxLQW5SQTtBQW9SaEJDLGdCQUFjLEVBQUUsS0FwUkE7QUFxUmhCNHZDLFdBQVMsRUFBRSxDQXJSSztBQXNSaEJDLGNBQVksRUFBRSxDQXRSRTtBQXVSaEJDLGdCQUFjLEVBQUUsQ0F2UkE7QUF3UmhCQyxrQkFBZ0IsRUFBRSxJQXhSRjtBQXlSaEJDLG9DQUFrQyxFQUFFLEtBelJwQjtBQTBSaEJ2dkMscUJBQW1CLEVBQUUsS0ExUkw7QUEyUmhCMk4sZ0NBQThCLEVBQUUsS0EzUmhCO0FBNFJoQi9JLGVBQWEsRUFBRSxJQTVSQztBQTZSaEI0cUMsY0FBWSxFQUFFLElBN1JFO0FBOFJoQnpyQyxnQkFBYyxFQUFFLElBOVJBO0FBK1JoQjByQyx3QkFBc0IsRUFBRSxLQS9SUjtBQWdTaEJDLHdCQUFzQixFQUFFLEtBaFNSO0FBaVNoQkMsc0JBQW9CLEVBQUUsS0FqU047QUFrU2hCQyxpQkFBZSxFQUFFLEtBbFNEO0FBbVNoQkMsUUFBTSxFQUFFLElBblNRO0FBb1NoQi8wQyxTQUFPLEVBQUUsSUFwU087QUFxU2hCZzFDLG9DQUFrQyxFQUFFLEtBclNwQjtBQXNTaEJDLDZCQUEyQixFQUFFLEtBdFNiO0FBdVNoQkMsZ0NBQThCLEVBQUUsS0F2U2hCO0FBd1NoQkMsNkJBQTJCLEVBQUUsS0F4U2I7QUF5U2hCQywwQkFBd0IsRUFBRSxLQXpTVjtBQTBTaEJDLDRCQUEwQixFQUFFLEtBMVNaO0FBMlNoQkMsMEJBQXdCLEVBQUUsS0EzU1Y7QUE0U2hCdmxDLGVBQWEsRUFBRSxLQTVTQztBQTZTaEJ3bEMsVUFBUSxFQUFFLElBN1NNO0FBOFNoQkMsTUFBSSxFQUFFLENBOVNVO0FBK1NoQkMsSUFBRSxFQUFFO0FBL1NZLENBQWpCLEM7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTNQLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQjtBQUNoQixLQUFHLE1BRGE7QUFFaEIsS0FBRyxLQUZhO0FBR2hCLEtBQUcsV0FIYTtBQUloQixLQUFHLFlBSmE7QUFLaEIsS0FBRyxXQUxhO0FBTWhCLEtBQUcsZ0JBTmE7QUFPaEIsS0FBRyxjQVBhO0FBUWhCLE9BQUssa0JBUlc7QUFTaEIsT0FBSyxPQVRXO0FBVWhCLE9BQUssTUFWVztBQVdoQixPQUFLLE9BWFc7QUFZaEIsT0FBSyxRQVpXO0FBYWhCLE9BQUssU0FiVztBQWNoQixPQUFLLFVBZFc7QUFlaEIsT0FBSyxRQWZXO0FBZ0JoQixPQUFLLFFBaEJXO0FBaUJoQixPQUFLLFdBakJXO0FBa0JoQixPQUFLLHFCQWxCVztBQW1CaEIsT0FBSyxXQW5CVztBQW9CaEIsT0FBSyxxQkFwQlc7QUFxQmhCLE9BQUssV0FyQlc7QUFzQmhCLE9BQUsscUJBdEJXO0FBdUJoQixPQUFLLFdBdkJXO0FBd0JoQixPQUFLLHFCQXhCVztBQXlCaEIsT0FBSyxvQkF6Qlc7QUEwQmhCLFFBQU0sb0JBMUJVO0FBMkJoQixRQUFNLE9BM0JVO0FBNEJoQixRQUFNLE1BNUJVO0FBNkJoQixRQUFNLGdCQTdCVTtBQThCaEIsUUFBTSxjQTlCVTtBQStCaEIsUUFBTSxlQS9CVTtBQWdDaEIsUUFBTSxtQkFoQ1U7QUFpQ2hCLFFBQU0sZUFqQ1U7QUFrQ2hCLFFBQU0sK0JBbENVO0FBbUNoQixRQUFNLElBbkNVO0FBb0NoQixRQUFNLEtBcENVO0FBcUNoQixRQUFNLFlBckNVO0FBc0NoQixRQUFNLFdBdENVO0FBdUNoQixRQUFNLGdCQXZDVTtBQXdDaEIsUUFBTSxZQXhDVTtBQXlDaEIsUUFBTSxhQXpDVTtBQTBDaEIsUUFBTSxZQTFDVTtBQTJDaEIsUUFBTSxpQkEzQ1U7QUE0Q2hCLFFBQU0sbUJBNUNVO0FBNkNoQixRQUFNLFlBN0NVO0FBOENoQixRQUFNLGNBOUNVO0FBK0NoQixRQUFNLHFCQS9DVTtBQWdEaEIsUUFBTSxjQWhEVTtBQWlEaEIsUUFBTSxvQkFqRFU7QUFrRGhCLFFBQU0sY0FsRFU7QUFtRGhCLFFBQU0seUJBbkRVO0FBb0RoQixRQUFNLHlCQXBEVTtBQXFEaEIsUUFBTSxhQXJEVTtBQXNEaEIsUUFBTSxtQkF0RFU7QUF1RGhCLFFBQU0sVUF2RFU7QUF3RGhCLFFBQU0sUUF4RFU7QUF5RGhCLFFBQU0sT0F6RFU7QUEwRGhCLFFBQU0sYUExRFU7QUEyRGhCLFFBQU0sY0EzRFU7QUE0RGhCLFFBQU0sbUJBNURVO0FBNkRoQixRQUFNLGlCQTdEVTtBQThEaEIsUUFBTSxrQkE5RFU7QUErRGhCLFFBQU0sZ0JBL0RVO0FBZ0VoQixRQUFNLGtCQWhFVTtBQWlFaEIsUUFBTSxtQkFqRVU7QUFrRWhCLFFBQU0sZUFsRVU7QUFtRWhCLFFBQU0sVUFuRVU7QUFvRWhCLFFBQU0sWUFwRVU7QUFxRWhCLFFBQU0sV0FyRVU7QUFzRWhCLFFBQU0sWUF0RVU7QUF1RWhCLFFBQU0sWUF2RVU7QUF3RWhCLFFBQU0sY0F4RVU7QUF5RWhCLFFBQU0sWUF6RVU7QUEwRWhCLFFBQU0sV0ExRVU7QUEyRWhCLFFBQU0sU0EzRVU7QUE0RWhCLFFBQU0sUUE1RVU7QUE2RWhCLFFBQU0sTUE3RVU7QUE4RWhCLFFBQU0sZUE5RVU7QUErRWhCLFFBQU0sT0EvRVU7QUFnRmhCLFFBQU0sZ0JBaEZVO0FBaUZoQixRQUFNLEtBakZVO0FBa0ZoQixRQUFNLGNBbEZVO0FBbUZoQixRQUFNLE9BbkZVO0FBb0ZoQixRQUFNLFFBcEZVO0FBcUZoQixRQUFNLFNBckZVO0FBc0ZoQixRQUFNLGVBdEZVO0FBdUZoQixRQUFNLGlCQXZGVTtBQXdGaEIsUUFBTSxLQXhGVTtBQXlGaEIsUUFBTSxPQXpGVTtBQTBGaEIsUUFBTSxLQTFGVTtBQTJGaEIsUUFBTSxNQTNGVTtBQTRGaEIsUUFBTSxXQTVGVTtBQTZGaEIsUUFBTSxpQkE3RlU7QUE4RmhCLFFBQU0sTUE5RlU7QUErRmhCLFFBQU0sU0EvRlU7QUFnR2hCLFFBQU0sTUFoR1U7QUFpR2hCLFFBQU0sTUFqR1U7QUFrR2hCLFFBQU0sUUFsR1U7QUFtR2hCLFFBQU0sVUFuR1U7QUFvR2hCLFFBQU0sU0FwR1U7QUFxR2hCLFFBQU0sU0FyR1U7QUFzR2hCLFFBQU0sUUF0R1U7QUF1R2hCLFFBQU0sd0JBdkdVO0FBd0doQixRQUFNLHVCQXhHVTtBQXlHaEIsUUFBTSx1QkF6R1U7QUEwR2hCLFFBQU0sc0JBMUdVO0FBMkdoQixTQUFPLG9CQTNHUztBQTRHaEIsU0FBTyxvQkE1R1M7QUE2R2hCLFNBQU8sZ0JBN0dTO0FBOEdoQixTQUFPLGdCQTlHUztBQStHaEIsU0FBTyxRQS9HUztBQWdIaEIsU0FBTyxzQkFoSFM7QUFpSGhCLFNBQU8sa0JBakhTO0FBa0hoQixTQUFPLGdCQWxIUztBQW1IaEIsU0FBTywwQkFuSFM7QUFvSGhCLFNBQU8sZ0JBcEhTO0FBcUhoQixTQUFPLDBCQXJIUztBQXNIaEIsU0FBTyxhQXRIUztBQXVIaEIsU0FBTyxVQXZIUztBQXdIaEIsU0FBTyxvQkF4SFM7QUF5SGhCLFNBQU8sZUF6SFM7QUEwSGhCLFNBQU8sdUJBMUhTO0FBMkhoQixTQUFPLHdCQTNIUztBQTRIaEIsU0FBTyx3QkE1SFM7QUE2SGhCLFNBQU8scUJBN0hTO0FBOEhoQixTQUFPLHVCQTlIUztBQStIaEIsU0FBTyxPQS9IUztBQWdJaEIsU0FBTyxTQWhJUztBQWlJaEIsU0FBTyxvQkFqSVM7QUFrSWhCLFNBQU8sMEJBbElTO0FBbUloQixTQUFPLGlCQW5JUztBQW9JaEIsU0FBTyxnQkFwSVM7QUFxSWhCLFNBQU8sU0FySVM7QUFzSWhCLFNBQU8sdUJBdElTO0FBdUloQixTQUFPLHdCQXZJUztBQXdJaEIsU0FBTyxlQXhJUztBQXlJaEIsU0FBTyxlQXpJUztBQTBJaEIsU0FBTyxpQkExSVM7QUEySWhCLFNBQU8saUJBM0lTO0FBNEloQixTQUFPLGVBNUlTO0FBNkloQixTQUFPLHNCQTdJUztBQThJaEIsU0FBTyxtQkE5SVM7QUErSWhCLFNBQU8sMEJBL0lTO0FBZ0poQixTQUFPLElBaEpTO0FBaUpoQixTQUFPLHNCQWpKUztBQWtKaEIsU0FBTyxpQkFsSlM7QUFtSmhCLFNBQU8sMEJBbkpTO0FBb0poQixTQUFPLDBCQXBKUztBQXFKaEIsU0FBTyxVQXJKUztBQXNKaEIsU0FBTyxVQXRKUztBQXVKaEIsU0FBTyxVQXZKUztBQXdKaEIsU0FBTyxVQXhKUztBQXlKaEIsU0FBTyxVQXpKUztBQTBKaEIsU0FBTyxVQTFKUztBQTJKaEIsU0FBTyxVQTNKUztBQTRKaEIsU0FBTyxVQTVKUztBQTZKaEIsU0FBTyxVQTdKUztBQThKaEIsU0FBTyxVQTlKUztBQStKaEIsU0FBTyxXQS9KUztBQWdLaEIsU0FBTyxXQWhLUztBQWlLaEIsU0FBTyxXQWpLUztBQWtLaEIsU0FBTyxXQWxLUztBQW1LaEIsU0FBTyxXQW5LUztBQW9LaEIsU0FBTyxXQXBLUztBQXFLaEIsU0FBTyxXQXJLUztBQXNLaEIsU0FBTyxXQXRLUztBQXVLaEIsU0FBTyxXQXZLUztBQXdLaEIsU0FBTyxXQXhLUztBQXlLaEIsU0FBTyxXQXpLUztBQTBLaEIsU0FBTyxXQTFLUztBQTJLaEIsU0FBTyxXQTNLUztBQTRLaEIsU0FBTyxXQTVLUztBQTZLaEIsU0FBTyxXQTdLUztBQThLaEIsU0FBTyxXQTlLUztBQStLaEIsU0FBTyxXQS9LUztBQWdMaEIsU0FBTyxXQWhMUztBQWlMaEIsU0FBTyxXQWpMUztBQWtMaEIsU0FBTyxXQWxMUztBQW1MaEIsU0FBTyxXQW5MUztBQW9MaEIsU0FBTyxXQXBMUztBQXFMaEIsU0FBTyxnQkFyTFM7QUFzTGhCLFNBQU8sdUJBdExTO0FBdUxoQixTQUFPLGVBdkxTO0FBd0xoQixTQUFPLFdBeExTO0FBeUxoQixTQUFPLFdBekxTO0FBMExoQixTQUFPLGtCQTFMUztBQTJMaEIsU0FBTywwQkEzTFM7QUE0TGhCLFNBQU8sNkJBNUxTO0FBNkxoQixTQUFPLDZCQTdMUztBQThMaEIsU0FBTyw2QkE5TFM7QUErTGhCLFNBQU8sNkJBL0xTO0FBZ01oQixTQUFPLDZCQWhNUztBQWlNaEIsU0FBTyw2QkFqTVM7QUFrTWhCLFNBQU8sMkJBbE1TO0FBbU1oQixTQUFPLDZCQW5NUztBQW9NaEIsU0FBTywwQkFwTVM7QUFxTWhCLFNBQU8sNEJBck1TO0FBc01oQixTQUFPLDBCQXRNUztBQXVNaEIsU0FBTyx1QkF2TVM7QUF3TWhCLFNBQU8sNkJBeE1TO0FBeU1oQixTQUFPLGdDQXpNUztBQTBNaEIsU0FBTyw0QkExTVM7QUEyTWhCLFNBQU8sYUEzTVM7QUE0TWhCLFNBQU8sY0E1TVM7QUE2TWhCLFNBQU8sbUJBN01TO0FBOE1oQixTQUFPLG1CQTlNUztBQStNaEIsU0FBTyw4QkEvTVM7QUFnTmhCLFNBQU8sOEJBaE5TO0FBaU5oQixTQUFPLHNCQWpOUztBQWtOaEIsU0FBTyxvQkFsTlM7QUFtTmhCLFNBQU8sZ0NBbk5TO0FBb05oQixTQUFPLHlCQXBOUztBQXFOaEIsU0FBTyxjQXJOUztBQXNOaEIsU0FBTyxzQkF0TlM7QUF1TmhCLFNBQU8sc0JBdk5TO0FBd05oQixTQUFPLDhCQXhOUztBQXlOaEIsU0FBTyxvQ0F6TlM7QUEwTmhCLFNBQU8sYUExTlM7QUEyTmhCLFNBQU8sYUEzTlM7QUE0TmhCLFNBQU8sY0E1TlM7QUE2TmhCLFNBQU8saUJBN05TO0FBOE5oQixTQUFPLGVBOU5TO0FBK05oQixTQUFPLGdDQS9OUztBQWdPaEIsU0FBTyxrQ0FoT1M7QUFpT2hCLFNBQU8sYUFqT1M7QUFrT2hCLFNBQU8sWUFsT1M7QUFtT2hCLFNBQU8sWUFuT1M7QUFvT2hCLFNBQU8sWUFwT1M7QUFxT2hCLFNBQU8sVUFyT1M7QUFzT2hCLFNBQU8sVUF0T1M7QUF1T2hCLFNBQU8sVUF2T1M7QUF3T2hCLFNBQU8sTUF4T1M7QUF5T2hCLFNBQU8sV0F6T1M7QUEwT2hCLFNBQU8sV0ExT1M7QUEyT2hCLFNBQU8sV0EzT1M7QUE0T2hCLFNBQU8sWUE1T1M7QUE2T2hCLFNBQU8sWUE3T1M7QUE4T2hCLFNBQU8sWUE5T1M7QUErT2hCLFNBQU8sWUEvT1M7QUFnUGhCLFNBQU8sY0FoUFM7QUFpUGhCLFNBQU8sZUFqUFM7QUFrUGhCLFNBQU8sZ0JBbFBTO0FBbVBoQixTQUFPLGFBblBTO0FBb1BoQixTQUFPLGlCQXBQUztBQXFQaEIsU0FBTyxpQkFyUFM7QUFzUGhCLFNBQU8sa0JBdFBTO0FBdVBoQixTQUFPLGlCQXZQUztBQXdQaEIsU0FBTywyQkF4UFM7QUF5UGhCLFNBQU8sc0JBelBTO0FBMFBoQixTQUFPLG1CQTFQUztBQTJQaEIsU0FBTyw2QkEzUFM7QUE0UGhCLFNBQU8sMEJBNVBTO0FBNlBoQixTQUFPLGlCQTdQUztBQThQaEIsU0FBTyxrQkE5UFM7QUErUGhCLFNBQU8seUJBL1BTO0FBZ1FoQixTQUFPLHdCQWhRUztBQWlRaEIsU0FBTyxxQkFqUVM7QUFrUWhCLFNBQU8sc0JBbFFTO0FBbVFoQixTQUFPLG9DQW5RUztBQW9RaEIsU0FBTyxvQ0FwUVM7QUFxUWhCLFNBQU8sc0NBclFTO0FBc1FoQixTQUFPLDhDQXRRUztBQXVRaEIsU0FBTyxzQkF2UVM7QUF3UWhCLFNBQU8sbUNBeFFTO0FBeVFoQixTQUFPLDJDQXpRUztBQTBRaEIsU0FBTyxtQ0ExUVM7QUEyUWhCLFNBQU8seUJBM1FTO0FBNFFoQixTQUFPLG1CQTVRUztBQTZRaEIsU0FBTyxrQkE3UVM7QUE4UWhCLFNBQU8sb0JBOVFTO0FBK1FoQixTQUFPLGFBL1FTO0FBZ1JoQixTQUFPLGNBaFJTO0FBaVJoQixTQUFPLG9CQWpSUztBQWtSaEIsU0FBTyxxQkFsUlM7QUFtUmhCLFNBQU8sOEJBblJTO0FBb1JoQixTQUFPLGdCQXBSUztBQXFSaEIsU0FBTyx1QkFyUlM7QUFzUmhCLFNBQU8seUJBdFJTO0FBdVJoQixTQUFPLHdCQXZSUztBQXdSaEIsU0FBTyx5QkF4UlM7QUF5UmhCLFNBQU8seUJBelJTO0FBMFJoQixTQUFPLDJCQTFSUztBQTJSaEIsU0FBTyxRQTNSUztBQTRSaEIsU0FBTyxXQTVSUztBQTZSaEIsU0FBTyxjQTdSUztBQThSaEIsU0FBTyxZQTlSUztBQStSaEIsU0FBTyxTQS9SUztBQWdTaEIsU0FBTyxZQWhTUztBQWlTaEIsU0FBTyxVQWpTUztBQWtTaEIsU0FBTyxpQkFsU1M7QUFtU2hCLFNBQU8sNEJBblNTO0FBb1NoQixTQUFPLHFCQXBTUztBQXFTaEIsU0FBTyw4QkFyU1M7QUFzU2hCLFNBQU8scUJBdFNTO0FBdVNoQixTQUFPLGdDQXZTUztBQXdTaEIsU0FBTyxvQkF4U1M7QUF5U2hCLFNBQU8sb0NBelNTO0FBMFNoQixTQUFPO0FBMVNTLENBQWpCLEM7Ozs7Ozs7Ozs7OztBQ0RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQUVBLE1BQU05dUIsZ0JBQWdCLEdBQUcsWUFBWTtBQUNuQyxPQUFLLE1BQU03YixDQUFYLElBQWdCczZDLGtEQUFoQixFQUE0QjtBQUMxQixRQUFJLENBQUN0MUMsK0NBQUUsQ0FBQ2hGLENBQUQsQ0FBUCxFQUFZO0FBQ1ZnRixxREFBRSxDQUFDaEYsQ0FBRCxDQUFGLEdBQVFzNkMsa0RBQVUsQ0FBQ3Q2QyxDQUFELENBQWxCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSUEsQ0FBQyxLQUFLLE9BQVYsRUFBbUJGLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLGtCQUFaLEVBQWdDQyxDQUFoQztBQUNwQjtBQUNGO0FBQ0YsQ0FSRDs7QUFVZTZiLCtFQUFmLEU7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQUE7QUFBQTtBQUVlLFNBQVNDLG9CQUFULENBQThCemIsRUFBOUIsRUFBa0N3VCxJQUFsQyxFQUF3QztBQUN0RCxRQUFNN1UsR0FBRyxHQUFHcUIsRUFBRSxDQUFDaEMsWUFBSCxDQUFnQndWLElBQWhCLENBQVo7O0FBQ0EsTUFBSSxDQUFDN1UsR0FBTCxFQUFVO0FBQ1QsV0FBTyxLQUFQO0FBQ0E7O0FBQ0QsUUFBTXU3QyxNQUFNLEdBQUcxbUMsSUFBSSxDQUFDclYsS0FBTCxDQUFXLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBZjtBQUNBLFFBQU1nOEMsUUFBUSxHQUFHLElBQUlDLE1BQUosQ0FBWSxHQUFFRixNQUFPLEdBQXJCLENBQWpCOztBQUVBLE9BQUssTUFBTUcsR0FBWCxJQUFrQjE3QyxHQUFsQixFQUF1QjtBQUN0QixVQUFNMjdDLEdBQUcsR0FBRzM3QyxHQUFHLENBQUMwN0MsR0FBRCxDQUFmOztBQUNBLFFBQUksT0FBT0MsR0FBUCxLQUFnQixVQUFwQixFQUFnQztBQUMvQixZQUFNQyxhQUFhLEdBQUdGLEdBQUcsQ0FBQ0csT0FBSixDQUFZTCxRQUFaLEVBQXNCLEVBQXRCLENBQXRCOztBQUNBLFVBQUlFLEdBQUcsQ0FBQ0ksU0FBUixFQUFtQjtBQUNsQno2QyxVQUFFLENBQUN1NkMsYUFBRCxDQUFGLEdBQW9CNTdDLEdBQUcsQ0FBQzA3QyxHQUFELENBQUgsQ0FBU3p5QyxJQUFULENBQWNqSixHQUFkLENBQXBCLENBRGtCLENBRWxCO0FBQ0E7QUFDRDtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNBLEM7Ozs7Ozs7Ozs7OztBQ3RCRDtBQUFBO0FBRWUseUVBQVVxQixFQUFWLEVBQWM4UyxhQUFkLEVBQTZCVSxJQUE3QixFQUFtQztBQUNqRCxNQUFHVixhQUFhLENBQUM0bkMsY0FBZCxLQUFpQ3gyQyxTQUFwQyxFQUErQztBQUFFNE8saUJBQWEsQ0FBQzRuQyxjQUFkLEdBQStCLEVBQS9CO0FBQW9DOztBQUNyRixNQUFHNW5DLGFBQWEsQ0FBQzRuQyxjQUFkLENBQTZCbG5DLElBQTdCLE1BQXVDdFAsU0FBMUMsRUFBcUQ7QUFDcEQ0TyxpQkFBYSxDQUFDNG5DLGNBQWQsQ0FBNkJsbkMsSUFBN0IsSUFBcUN4VCxFQUFFLENBQUMyNkMsaUJBQUgsQ0FBcUI3bkMsYUFBckIsRUFBb0NVLElBQXBDLENBQXJDO0FBQ0E7O0FBRUQsU0FBT1YsYUFBYSxDQUFDNG5DLGNBQWQsQ0FBNkJsbkMsSUFBN0IsQ0FBUDtBQUNBO0FBQUEsQzs7Ozs7Ozs7Ozs7O0FDVEQ7QUFBQTtBQUFBO0FBRUE7QUFFQSxJQUFJb25DLFVBQVUsR0FBRyxLQUFqQjs7QUFDQSxJQUFJQyxNQUFKOztBQUdBLFNBQVNDLFVBQVQsR0FBc0I7QUFDckIsTUFBR24yQywrQ0FBRSxDQUFDbUgsTUFBTixFQUFjO0FBQ2IsV0FBT25ILCtDQUFFLENBQUMzRSxFQUFILENBQU04SixLQUFiO0FBQ0EsR0FGRCxNQUVPO0FBQ04sVUFBTWl4QyxRQUFRLEdBQUdwMkMsK0NBQUUsQ0FBQzNHLFlBQUgsQ0FBZ0IsbUJBQWhCLENBQWpCOztBQUNBLFFBQUcrOEMsUUFBSCxFQUFhO0FBQ1osYUFBT3AyQywrQ0FBRSxDQUFDM0UsRUFBSCxDQUFNOEosS0FBYjtBQUNBLEtBRkQsTUFFTztBQUNOckssYUFBTyxDQUFDb1YsSUFBUixDQUFhLGlEQUFiO0FBQ0EsYUFBT2xRLCtDQUFFLENBQUMzRSxFQUFILENBQU1xTyxhQUFiO0FBQ0E7QUFDRDs7QUFFRHVzQyxZQUFVLEdBQUcsSUFBYjtBQUNBOztBQUFBO0FBRWMsMkVBQVk7QUFDMUIsTUFBRyxDQUFDQSxVQUFKLEVBQWdCO0FBQ2ZDLFVBQU0sR0FBR0MsVUFBVSxFQUFuQjtBQUNBOztBQUdELFNBQU9ELE1BQVA7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUMvQkQ7QUFBQTtBQUFBO0FBRUE7QUFFQSxJQUFJRCxVQUFVLEdBQUcsS0FBakI7QUFDQSxJQUFJSSxTQUFKOztBQUVBLFNBQVNDLGNBQVQsR0FBMEI7QUFDekIsTUFBR3QyQywrQ0FBRSxDQUFDbUgsTUFBTixFQUFjO0FBQ2IsV0FBT25ILCtDQUFFLENBQUMzRSxFQUFILENBQU1pZ0IsVUFBYjtBQUNBLEdBRkQsTUFFTztBQUNOLFVBQU1pN0IsWUFBWSxHQUFHdjJDLCtDQUFFLENBQUMzRyxZQUFILENBQWdCLHdCQUFoQixDQUFyQjs7QUFDQSxRQUFHazlDLFlBQUgsRUFBaUI7QUFDaEIsYUFBT0EsWUFBWSxDQUFDQyxjQUFwQjtBQUNBLEtBRkQsTUFFTztBQUNOMTdDLGFBQU8sQ0FBQ29WLElBQVIsQ0FBYSwyREFBYjtBQUNBLGFBQU9sUSwrQ0FBRSxDQUFDM0UsRUFBSCxDQUFNcU8sYUFBYjtBQUNBO0FBQ0Q7O0FBRUR1c0MsWUFBVSxHQUFHLElBQWI7QUFDQTs7QUFBQTtBQUVjLDJFQUFZO0FBQzFCLE1BQUcsQ0FBQ0EsVUFBSixFQUFnQjtBQUNmSSxhQUFTLEdBQUdDLGNBQWMsRUFBMUI7QUFDQTs7QUFFRCxTQUFPRCxTQUFQO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDN0JEO0FBQUE7QUFFZSx5RUFBVXQ2QyxDQUFWLEVBQWE7QUFDM0IsTUFBSWdWLENBQUosRUFBT3NHLENBQVA7O0FBRUEsTUFBR3RiLENBQUMsQ0FBQ2tpQyxPQUFMLEVBQWM7QUFDYmx0QixLQUFDLEdBQUdoVixDQUFDLENBQUNraUMsT0FBRixDQUFVLENBQVYsRUFBYUMsS0FBakI7QUFDQTdtQixLQUFDLEdBQUd0YixDQUFDLENBQUNraUMsT0FBRixDQUFVLENBQVYsRUFBYUUsS0FBakI7QUFDQSxHQUhELE1BR087QUFDTnB0QixLQUFDLEdBQUdoVixDQUFDLENBQUNxaUMsT0FBTjtBQUNBL21CLEtBQUMsR0FBR3RiLENBQUMsQ0FBQ3NpQyxPQUFOO0FBQ0E7O0FBR0QsU0FBTztBQUNOdHRCLEtBRE07QUFDSHNHO0FBREcsR0FBUDtBQUdBLEM7Ozs7Ozs7Ozs7OztBQ2pCRDtBQUFBO0FBQUE7QUFFQTs7QUFFQSxTQUFTdkcsWUFBVCxDQUF1QkMsQ0FBdkIsRUFBMEI7QUFDeEIsU0FBUUEsQ0FBQyxLQUFLLENBQVAsSUFBYyxFQUFFQSxDQUFDLEdBQUlBLENBQUMsR0FBRyxDQUFYLENBQXJCO0FBQ0Q7O0FBQUE7O0FBRUQsTUFBTWtELG9CQUFvQixHQUFHLFVBQVV3aUMsT0FBVixFQUFtQmhzQyxPQUFuQixFQUE0QnJELE1BQTVCLEVBQW9DQyxPQUFwQyxFQUE2QztBQUN4RSxNQUFJLENBQUNvdkMsT0FBTyxDQUFDanpDLFNBQWIsRUFBd0I7QUFDdEIsUUFBSUEsU0FBUyxHQUFHeEQsK0NBQUUsQ0FBQ3VELE1BQW5COztBQUNBLFFBQUk2RCxNQUFNLElBQUlBLE1BQWQsRUFBc0I7QUFDcEIsVUFBSTBKLFlBQVksQ0FBQzFKLE1BQUQsQ0FBWixJQUF3QjBKLFlBQVksQ0FBQ3pKLE9BQUQsQ0FBeEMsRUFBbUQ7QUFDakQ3RCxpQkFBUyxHQUFHeEQsK0NBQUUsQ0FBQzZSLHFCQUFmO0FBQ0Q7QUFDRjs7QUFFRDRrQyxXQUFPLENBQUNqekMsU0FBUixHQUFvQkEsU0FBcEI7QUFDRDs7QUFFRGl6QyxTQUFPLENBQUN6dEMsTUFBUixHQUFpQnl0QyxPQUFPLENBQUN6dEMsTUFBUixLQUFtQnpKLFNBQW5CLEdBQStCLElBQS9CLEdBQXNDazNDLE9BQU8sQ0FBQ3p0QyxNQUEvRDtBQUNBeXRDLFNBQU8sQ0FBQ256QyxTQUFSLEdBQW9CbXpDLE9BQU8sQ0FBQ256QyxTQUFSLElBQXFCdEQsK0NBQUUsQ0FBQ3VELE1BQTVDO0FBQ0FrekMsU0FBTyxDQUFDaHpDLEtBQVIsR0FBZ0JnekMsT0FBTyxDQUFDaHpDLEtBQVIsSUFBaUJ6RCwrQ0FBRSxDQUFDMEQsYUFBcEM7QUFDQSt5QyxTQUFPLENBQUM5eUMsS0FBUixHQUFnQjh5QyxPQUFPLENBQUM5eUMsS0FBUixJQUFpQjNELCtDQUFFLENBQUMwRCxhQUFwQztBQUNBK3lDLFNBQU8sQ0FBQ2x0QyxjQUFSLEdBQXlCa3RDLE9BQU8sQ0FBQ2x0QyxjQUFSLElBQTBCdkosK0NBQUUsQ0FBQ2dGLElBQXREO0FBQ0F5eEMsU0FBTyxDQUFDanRDLE1BQVIsR0FBaUJpdEMsT0FBTyxDQUFDanRDLE1BQVIsSUFBa0J4SiwrQ0FBRSxDQUFDZ0YsSUFBdEM7QUFDQXl4QyxTQUFPLENBQUNqa0MsZ0JBQVIsR0FBMkJpa0MsT0FBTyxDQUFDamtDLGdCQUFSLEtBQTZCalQsU0FBN0IsR0FBeUMsS0FBekMsR0FBaURrM0MsT0FBTyxDQUFDamtDLGdCQUFwRjtBQUNBaWtDLFNBQU8sQ0FBQ0MsS0FBUixHQUFnQkQsT0FBTyxDQUFDQyxLQUFSLElBQWlCLENBQWpDO0FBQ0EsU0FBT0QsT0FBUDtBQUNELENBckJEOztBQXVCZXhpQyxtRkFBZixFOzs7Ozs7Ozs7Ozs7QUMvQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU0waUMsUUFBUSxHQUFHeHBDLElBQUksQ0FBQ29JLE1BQUwsRUFBakI7QUFDTyxNQUFNcWhDLFdBQU4sQ0FBa0I7QUFDeEJ0NUMsYUFBVyxDQUFDdTVDLEtBQUQsRUFBUXJ0QixTQUFSLEVBQW1Cc3RCLEtBQW5CLEVBQTBCO0FBQ3BDLFNBQUs1ekMsTUFBTCxHQUFjLElBQUloRCwrQ0FBSixDQUFhNG5CLDJEQUFiLEVBQWlCQywwREFBakIsQ0FBZDtBQUNBLFNBQUtndkIsVUFBTCxHQUFrQixJQUFJNzJDLCtDQUFKLENBQWE4MkMseURBQWIsRUFBcUJDLHlEQUFyQixDQUFsQjtBQUVBLFNBQUtDLGFBQUwsR0FBcUIsSUFBSUMsbURBQUosRUFBckI7QUFDQSxTQUFLTixLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLTyxNQUFMLEdBQWMsS0FBZDtBQUNBLFNBQUtDLEtBQUwsR0FBYSxJQUFiO0FBQ0EsU0FBS3A1QyxjQUFMLEdBQXNCNDRDLEtBQUssQ0FBQzU0QyxjQUE1QjtBQUNBLFNBQUs2NEMsS0FBTCxHQUFhLEVBQWI7QUFDQSxTQUFLbHFDLEtBQUwsR0FBYSxFQUFiO0FBRUEsUUFBSWtxQyxLQUFKLEVBQVcsS0FBS1EsUUFBTCxDQUFjUixLQUFkO0FBQ1g7O0FBRURTLE1BQUksR0FBRztBQUNOLFNBQUtGLEtBQUwsR0FBYSxJQUFiO0FBQ0E7O0FBRURHLE1BQUksR0FBRztBQUNOLFNBQUtILEtBQUwsR0FBYSxLQUFiO0FBQ0E7O0FBRUR4dEIsT0FBSyxHQUFHO0FBQ1AsU0FBS3V0QixNQUFMLEdBQWMsSUFBZDtBQUNBOztBQUVEenRCLE1BQUksR0FBRztBQUNOLFNBQUt5dEIsTUFBTCxHQUFjLEtBQWQ7QUFDQTs7QUFFREUsVUFBUSxDQUFDUixLQUFELEVBQVE7QUFDZixRQUFJLENBQUNBLEtBQUssQ0FBQ3I5QyxNQUFYLEVBQW1CO0FBRW5CLFVBQU11QixDQUFDLEdBQUcsSUFBVjtBQUNBLFNBQUtKLElBQUwsR0FBWXdGLDJDQUFJLENBQUM0YyxNQUFMLENBQVloaUIsQ0FBWixFQUFlLEVBQWYsQ0FBWjtBQUVBLFVBQU15OEMsU0FBUyxHQUFHLEVBQWxCOztBQUNBLFNBQUssSUFBSW44QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdzdDLEtBQUssQ0FBQ3I5QyxNQUExQixFQUFrQzZCLENBQUMsRUFBbkMsRUFBdUM7QUFFdEMsWUFBTW84QyxXQUFXLEdBQUdaLEtBQUssQ0FBQ3g3QyxDQUFELENBQXpCO0FBQ0EsWUFBTXVULElBQUksR0FBRzZvQyxXQUFXLENBQUM3b0MsSUFBWixJQUFxQixjQUFhdlQsQ0FBQyxHQUFHLENBQUUsRUFBckQ7QUFFQSxZQUFNb3NCLE1BQU0sR0FBR2d3QixXQUFXLENBQUN2akIsTUFBM0IsQ0FMc0MsQ0FLSjs7QUFFbEMsWUFBTTlXLEdBQUcsR0FBRyxLQUFLcGYsY0FBTCxDQUFvQmlmLFdBQXBCLENBQWdDdzZCLFdBQVcsQ0FBQ241QyxFQUE1QyxFQUFnRG01QyxXQUFXLENBQUNsNUMsRUFBNUQsRUFBZ0VrNUMsV0FBVyxDQUFDQyxJQUE1RSxDQUFaO0FBQ0F0NkIsU0FBRyxDQUFDLENBQUQsQ0FBSCxJQUFVcTZCLFdBQVcsQ0FBQ3ByQyxNQUFaLENBQW1CLENBQW5CLENBQVY7QUFDQStRLFNBQUcsQ0FBQyxDQUFELENBQUgsSUFBVXE2QixXQUFXLENBQUNwckMsTUFBWixDQUFtQixDQUFuQixDQUFWO0FBQ0ErUSxTQUFHLENBQUMsQ0FBRCxDQUFILElBQVVxNkIsV0FBVyxDQUFDcHJDLE1BQVosQ0FBbUIsQ0FBbkIsQ0FBVjtBQUVBLFlBQU13M0IsSUFBSSxHQUFHOFQsNERBQWMsQ0FBQ2x3QixNQUFNLENBQUMsQ0FBRCxDQUFQLEVBQVlySyxHQUFHLENBQUMsQ0FBRCxDQUFmLEVBQW9CcUssTUFBTSxDQUFDLENBQUQsQ0FBMUIsRUFBK0JySyxHQUFHLENBQUMsQ0FBRCxDQUFsQyxFQUF1Q3FLLE1BQU0sQ0FBQyxDQUFELENBQTdDLEVBQWtEckssR0FBRyxDQUFDLENBQUQsQ0FBckQsQ0FBM0I7O0FBRUEsVUFBSXltQixJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBQ2IsWUFBSWlCLENBQUMsR0FBRyxJQUFJakIsSUFBWjtBQUNBem1CLFdBQUcsQ0FBQyxDQUFELENBQUgsR0FBU3FLLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWSxDQUFDckssR0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTcUssTUFBTSxDQUFDLENBQUQsQ0FBaEIsSUFBdUJxZCxDQUE1QztBQUNBMW5CLFdBQUcsQ0FBQyxDQUFELENBQUgsR0FBU3FLLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWSxDQUFDckssR0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTcUssTUFBTSxDQUFDLENBQUQsQ0FBaEIsSUFBdUJxZCxDQUE1QztBQUNBMW5CLFdBQUcsQ0FBQyxDQUFELENBQUgsR0FBU3FLLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWSxDQUFDckssR0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTcUssTUFBTSxDQUFDLENBQUQsQ0FBaEIsSUFBdUJxZCxDQUE1QztBQUNBOztBQUVEMFMsZUFBUyxDQUFDcjlDLElBQVYsQ0FBZXN0QixNQUFmLEVBckJzQyxDQXVCdEM7O0FBQ0EsWUFBTW13QixJQUFJLEdBQUcsS0FBS0MsV0FBTCxDQUFpQmpwQyxJQUFqQixFQUF1QjZvQyxXQUF2QixDQUFiO0FBRUEsV0FBS1osS0FBTCxDQUFXMThDLElBQVgsQ0FBZ0I7QUFDZis1QixjQUFNLEVBQUV1akIsV0FBVyxDQUFDdmpCLE1BREw7QUFFZjlXLFdBRmU7QUFHZnc2QixZQUhlO0FBSWYzdkIsZUFBTyxFQUFFO0FBSk0sT0FBaEI7QUFPQSxZQUFNbUwsSUFBSSxHQUFHLElBQUkwa0IsK0NBQUosQ0FBUyxDQUFDMTZCLEdBQUQsRUFBTXE2QixXQUFXLENBQUN2akIsTUFBbEIsQ0FBVCxDQUFiO0FBQ0EsV0FBS3ZuQixLQUFMLENBQVd4UyxJQUFYLENBQWdCaTVCLElBQWhCO0FBQ0E7O0FBRUQsU0FBS3o0QixJQUFMLENBQVUwbEIsY0FBVixDQUF5Qm0zQixTQUF6QixFQUFvQyxZQUFwQztBQUNBOztBQUVESyxhQUFXLENBQUNqcEMsSUFBRCxFQUFPM0QsSUFBUCxFQUFhO0FBRXZCLFVBQU0yc0MsSUFBSSxHQUFHLzZDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixHQUF2QixDQUFiO0FBQ0E4NkMsUUFBSSxDQUFDRyxTQUFMLEdBQWlCLE1BQWpCOztBQUNBSCxRQUFJLENBQUNJLE9BQUwsR0FBZ0IsTUFBTTtBQUNyQixXQUFLZixhQUFMLENBQW1CZ0IsUUFBbkIsQ0FBNEJodEMsSUFBNUI7QUFDQSxLQUZEOztBQUdBMnNDLFFBQUksQ0FBQ00sU0FBTCxHQUFpQmp0QyxJQUFJLENBQUNrdEMsS0FBdEI7QUFDQSxTQUFLdkIsS0FBTCxDQUFXd0IsYUFBWCxDQUF5QkMsV0FBekIsQ0FBcUNULElBQXJDO0FBRUEsV0FBT0EsSUFBUDtBQUNBOztBQUVEVSxPQUFLLENBQUNsN0IsR0FBRCxFQUFNb0ksVUFBTixFQUFrQkMsZ0JBQWxCLEVBQW9DOHlCLFdBQXBDLEVBQWlEQyxZQUFqRCxFQUErRDtBQUNuRXRyQyxRQUFJLENBQUNxYSxhQUFMLENBQW1CbXZCLFFBQW5CLEVBQTZCdDVCLEdBQTdCLEVBQWtDb0ksVUFBbEM7QUFDQXRZLFFBQUksQ0FBQ3FhLGFBQUwsQ0FBbUJtdkIsUUFBbkIsRUFBNkJBLFFBQTdCLEVBQXVDanhCLGdCQUF2QztBQUVBaXhCLFlBQVEsQ0FBQyxDQUFELENBQVIsSUFBZUEsUUFBUSxDQUFDLENBQUQsQ0FBdkI7QUFDQUEsWUFBUSxDQUFDLENBQUQsQ0FBUixJQUFlQSxRQUFRLENBQUMsQ0FBRCxDQUF2QjtBQUNBQSxZQUFRLENBQUMsQ0FBRCxDQUFSLEdBQWMsQ0FBQ0EsUUFBUSxDQUFDLENBQUQsQ0FBUixHQUFjLENBQWYsSUFBb0I2QixXQUFwQixHQUFrQyxDQUFoRDtBQUNBN0IsWUFBUSxDQUFDLENBQUQsQ0FBUixHQUFjOEIsWUFBWSxHQUFHLENBQUM5QixRQUFRLENBQUMsQ0FBRCxDQUFSLEdBQWMsQ0FBZixJQUFvQjhCLFlBQXBCLEdBQW1DLENBQWhFO0FBRUEsV0FBTzlCLFFBQVA7QUFDQTs7QUFFRHp5QixRQUFNLENBQUN3ekIsV0FBRCxFQUFjO0FBR25CLFVBQU14dkIsT0FBTyxHQUFJLEtBQUtrdkIsTUFBTCxJQUFlLEtBQUtDLEtBQXJCLEdBQThCLENBQTlCLEdBQWtDLENBQWxEOztBQUVBLFNBQUssSUFBSS83QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUt3N0MsS0FBTCxDQUFXcjlDLE1BQS9CLEVBQXVDNkIsQ0FBQyxFQUF4QyxFQUE0QztBQUMzQyxZQUFNbzlDLElBQUksR0FBRyxLQUFLNUIsS0FBTCxDQUFXeDdDLENBQVgsQ0FBYjtBQUdBbzlDLFVBQUksQ0FBQ3h3QixPQUFMLElBQWdCLENBQUNBLE9BQU8sR0FBR3d3QixJQUFJLENBQUN4d0IsT0FBaEIsSUFBMkIsR0FBM0M7O0FBRUEsVUFBSWxjLElBQUksQ0FBQ290QixHQUFMLENBQVNzZixJQUFJLENBQUN4d0IsT0FBTCxHQUFlQSxPQUF4QixJQUFtQyxJQUFuQyxJQUEyQ3d3QixJQUFJLENBQUN4d0IsT0FBTCxLQUFpQkEsT0FBaEUsRUFBeUU7QUFDeEV3d0IsWUFBSSxDQUFDeHdCLE9BQUwsR0FBZUEsT0FBZjtBQUNBOztBQUVELFVBQUl3d0IsSUFBSSxDQUFDYixJQUFMLENBQVVjLEtBQVYsQ0FBZ0J6d0IsT0FBaEIsS0FBNEJ3d0IsSUFBSSxDQUFDeHdCLE9BQXJDLEVBQThDO0FBQzdDd3dCLFlBQUksQ0FBQ2IsSUFBTCxDQUFVYyxLQUFWLENBQWdCendCLE9BQWhCLEdBQTBCd3dCLElBQUksQ0FBQ3h3QixPQUEvQjs7QUFFQSxZQUFJd3dCLElBQUksQ0FBQ3h3QixPQUFMLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3ZCd3dCLGNBQUksQ0FBQ2IsSUFBTCxDQUFVYyxLQUFWLENBQWdCQyxPQUFoQixHQUEwQixNQUExQjtBQUNBLFNBRkQsTUFFTyxJQUFJRixJQUFJLENBQUN4d0IsT0FBTCxLQUFpQixDQUFyQixFQUF3QjtBQUM5Qnd3QixjQUFJLENBQUNiLElBQUwsQ0FBVWMsS0FBVixDQUFnQkMsT0FBaEIsR0FBMEIsT0FBMUI7QUFDQTtBQUNEOztBQUVELFVBQUkxd0IsT0FBSixFQUFhO0FBQ1osY0FBTTJ3QixHQUFHLEdBQUdDLHNEQUFRLENBQUNKLElBQUksQ0FBQ3I3QixHQUFOLENBQXBCO0FBQ0FxN0IsWUFBSSxDQUFDYixJQUFMLENBQVVjLEtBQVYsQ0FBZ0J6eUIsSUFBaEIsR0FBd0IsR0FBRTJ5QixHQUFHLENBQUMsQ0FBRCxDQUFJLElBQWpDO0FBQ0FILFlBQUksQ0FBQ2IsSUFBTCxDQUFVYyxLQUFWLENBQWdCdnlCLEdBQWhCLEdBQXVCLEdBQUV5eUIsR0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTLEVBQUcsSUFBckM7QUFDQTtBQUNEOztBQUVELFFBQUksQ0FBQyxLQUFLekIsTUFBTixJQUFnQixDQUFDLEtBQUtDLEtBQXRCLElBQStCLENBQUMsS0FBS3o4QyxJQUF6QyxFQUErQztBQUUvQyxVQUFNbStDLFNBQVMsR0FBR0MsK0NBQU0sQ0FBQ0MsV0FBUCxDQUFtQmh4QixLQUFuQixDQUF5Qm51QixHQUF6QixDQUE4QjZpQixDQUFELElBQU9BLENBQUMsR0FBRyxHQUF4QyxDQUFsQjtBQUVBLFNBQUt6WixNQUFMLENBQVlELElBQVo7QUFDQSxTQUFLQyxNQUFMLENBQVltTCxPQUFaLENBQW9CLFFBQXBCLEVBQThCLE1BQTlCLEVBQXNDMHFDLFNBQXRDO0FBQ0EsU0FBSzcxQyxNQUFMLENBQVltTCxPQUFaLENBQW9CLFFBQXBCLEVBQThCLE9BQTlCLEVBQXVDMnFDLCtDQUFNLENBQUNDLFdBQVAsQ0FBbUJDLEtBQTFEO0FBQ0EsU0FBS2gyQyxNQUFMLENBQVltTCxPQUFaLENBQW9CLFFBQXBCLEVBQThCLE9BQTlCLEVBQXVDMnFDLCtDQUFNLENBQUNDLFdBQVAsQ0FBbUJqeEIsS0FBMUQ7QUFDQWhvQiw2Q0FBRSxDQUFDZ0QsSUFBSCxDQUFRLEtBQUtwSSxJQUFiLEVBeENtQixDQTBDbkI7O0FBQ0EsU0FBS204QyxVQUFMLENBQWdCOXpDLElBQWhCO0FBQ0EsU0FBSzh6QyxVQUFMLENBQWdCMW9DLE9BQWhCLENBQXdCLFFBQXhCLEVBQWtDLE9BQWxDLEVBQTJDLENBQTNDO0FBQ0EsU0FBSzBvQyxVQUFMLENBQWdCMW9DLE9BQWhCLENBQXdCLFdBQXhCLEVBQXFDLE9BQXJDLEVBQThDLEdBQTlDO0FBQ0EsU0FBSzBvQyxVQUFMLENBQWdCMW9DLE9BQWhCLENBQXdCLFFBQXhCLEVBQWtDLE1BQWxDLEVBQTBDMHFDLFNBQTFDO0FBQ0EsU0FBS2hDLFVBQUwsQ0FBZ0Ixb0MsT0FBaEIsQ0FBd0IsUUFBeEIsRUFBa0MsT0FBbEMsRUFBMkNyTyx5Q0FBRSxDQUFDd2IsV0FBOUM7O0FBRUEsU0FBSyxJQUFJbGdCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS3NSLEtBQUwsQ0FBV25ULE1BQS9CLEVBQXVDNkIsQ0FBQyxFQUF4QyxFQUE0QztBQUMzQyxZQUFNKzNCLElBQUksR0FBRyxLQUFLem1CLEtBQUwsQ0FBV3RSLENBQVgsQ0FBYjtBQUNBMEUsK0NBQUUsQ0FBQ2dELElBQUgsQ0FBUXF3QixJQUFSO0FBQ0E7QUFFRDs7QUE5SnVCLEM7Ozs7Ozs7Ozs7OztBQ2J6QjtBQUFBO0FBRWU7QUFDYjhsQixVQUFRLEVBQUUsQ0FERztBQUViaitDLE9BQUssRUFBRTtBQUNMK1AsU0FBSyxFQUFFO0FBQ0xtc0MsWUFBTSxFQUFFLEtBREg7QUFFTGdDLFNBQUcsRUFBRTtBQUFDcm9DLFNBQUMsRUFBRSxDQUFKO0FBQU9zRyxTQUFDLEVBQUUsQ0FBVjtBQUFheUcsU0FBQyxFQUFFO0FBQWhCLE9BRkE7QUFHTGtLLFdBQUssRUFBRTtBQUFDalgsU0FBQyxFQUFFLENBQUo7QUFBT3NHLFNBQUMsRUFBRSxDQUFWO0FBQWF5RyxTQUFDLEVBQUU7QUFBaEIsT0FIRjtBQUlMVCxTQUFHLEVBQUU7QUFBQ3RNLFNBQUMsRUFBRSxDQUFKO0FBQU9zRyxTQUFDLEVBQUUsQ0FBVjtBQUFheUcsU0FBQyxFQUFFO0FBQWhCO0FBSkE7QUFERixHQUZNO0FBVWJ1N0IsUUFBTSxFQUFFO0FBQ05qQyxVQUFNLEVBQUUsS0FERjtBQUVOa0MsVUFBTSxFQUFFO0FBRkYsR0FWSztBQWNiTCxhQUFXLEVBQUU7QUFDWGp4QixTQUFLLEVBQUUsQ0FESTtBQUVYQyxTQUFLLEVBQUUsQ0FBQyxDQUFELEVBQUksR0FBSixFQUFTLEdBQVQsQ0FGSTtBQUdYaXhCLFNBQUssRUFBRTtBQUhJLEdBZEE7QUFtQmJLLE1BQUksRUFBRTtBQUNKQyxrQkFBYyxFQUFFO0FBRFosR0FuQk87QUFzQmJDLGFBQVcsRUFBRSxLQXRCQTtBQXVCYkMscUJBQW1CLEVBQUUsQ0FDbkIsSUFEbUIsRUFFbkIsQ0FGbUIsRUFHbkIsQ0FIbUIsQ0F2QlI7QUE0QmJwdkIsYUFBVyxFQUFFO0FBQ1hubkIsUUFBSSxFQUFFLENBREs7QUFFWG1qQixRQUFJLEVBQUUsQ0FGSztBQUdYQyxPQUFHLEVBQUU7QUFITSxHQTVCQTtBQWlDYm96QixlQUFhLEVBQUUsSUFqQ0Y7QUFrQ2JDLFFBQU0sRUFBRTtBQUNOQyxVQUFNLEVBQUUsR0FERjtBQUVOM3hCLFdBQU8sRUFBRSxHQUZIO0FBR05ELFNBQUssRUFBRSxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWDtBQUhEO0FBbENLLENBQWYsRTs7Ozs7Ozs7Ozs7O0FDRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQWh1QixzREFBRyxDQUFDNi9DLFdBQUosR0FBa0JDLG1CQUFPLENBQUMsbUZBQUQsQ0FBekI7QUFFQSxJQUFJQyxPQUFPLEdBQUcsSUFBZDs7QUFFQSxNQUFNQyxNQUFNLEdBQUcsTUFBTTtBQUNuQixNQUFJLENBQUNELE9BQUwsRUFBYztBQUNaO0FBQ0Q7O0FBQ0RuK0MsUUFBTSxDQUFDcStDLFFBQVAsQ0FBZ0JDLElBQWhCLEdBQXVCdCtDLE1BQU0sQ0FBQ3ErQyxRQUFQLENBQWdCeHlCLE1BQWhCLEdBQXlCN3JCLE1BQU0sQ0FBQ3ErQyxRQUFQLENBQWdCRSxRQUF6QyxHQUFvRCxVQUFwRCxHQUFpRUMsSUFBSSxDQUFDQyxTQUFMLENBQWV0QiwrQ0FBZixDQUF4RjtBQUNELENBTEQ7O0FBT0EsTUFBTXVCLE9BQU8sR0FBRyxNQUFNO0FBQ3BCLE1BQUksQ0FBQ1AsT0FBTCxFQUFjO0FBQ1o7QUFDRDs7QUFDRG4rQyxRQUFNLENBQUMyK0MsT0FBUCxDQUFlQyxTQUFmLENBQXlCLFlBQXpCLEVBQXVDLE9BQXZDLEVBQWdENStDLE1BQU0sQ0FBQ3ErQyxRQUFQLENBQWdCeHlCLE1BQWhCLEdBQXlCN3JCLE1BQU0sQ0FBQ3ErQyxRQUFQLENBQWdCRSxRQUF6QyxHQUFvRCxVQUFwRCxHQUFpRUMsSUFBSSxDQUFDQyxTQUFMLENBQWV0QiwrQ0FBZixDQUFqSDtBQUNELENBTEQ7O0FBT0EsTUFBTWw3QyxLQUFLLEdBQUcsTUFBTTtBQUNsQmpDLFFBQU0sQ0FBQ3ErQyxRQUFQLENBQWdCQyxJQUFoQixHQUF1QnQrQyxNQUFNLENBQUNxK0MsUUFBUCxDQUFnQnh5QixNQUFoQixHQUF5QjdyQixNQUFNLENBQUNxK0MsUUFBUCxDQUFnQkUsUUFBaEU7QUFDRCxDQUZEOztBQUlBLElBQUlNLFVBQVUsR0FBRyxDQUFDLENBQWxCOztBQUVBLE1BQU1DLFdBQVcsR0FBRyxNQUFNO0FBQ3hCLE1BQUksQ0FBQ1gsT0FBTCxFQUFjO0FBQ1o7QUFDRDs7QUFDRG4rQyxRQUFNLENBQUMrK0MsWUFBUCxDQUFvQkYsVUFBcEI7QUFFQUEsWUFBVSxHQUFHNytDLE1BQU0sQ0FBQ2cvQyxVQUFQLENBQWtCLE1BQU07QUFDbkNoL0MsVUFBTSxDQUFDcStDLFFBQVAsQ0FBZ0JDLElBQWhCLEdBQXVCdCtDLE1BQU0sQ0FBQ3ErQyxRQUFQLENBQWdCeHlCLE1BQWhCLEdBQXlCN3JCLE1BQU0sQ0FBQ3ErQyxRQUFQLENBQWdCRSxRQUF6QyxHQUFvRCxVQUFwRCxHQUFpRUMsSUFBSSxDQUFDQyxTQUFMLENBQWV0QiwrQ0FBZixDQUF4RjtBQUNELEdBRlksRUFFVixHQUZVLENBQWI7QUFHRCxDQVREOztBQVdBLE1BQU10L0MsSUFBSSxHQUFHLENBQUNvaEQsUUFBUSxHQUFHLElBQVosS0FBcUI7QUFDaENkLFNBQU8sR0FBR2MsUUFBVjtBQUNBLFFBQU1DLE1BQU0sR0FBRzlnRCxzREFBRyxDQUFDTyxLQUFKLENBQVVxQixNQUFNLENBQUNxK0MsUUFBUCxDQUFnQmMsTUFBMUIsRUFBa0MsSUFBbEMsQ0FBZjtBQUNBLE1BQUlDLFVBQVUsR0FBRyxFQUFqQjs7QUFDQSxNQUFJRixNQUFNLENBQUNHLEtBQVAsQ0FBYUMsTUFBakIsRUFBeUI7QUFDdkJGLGNBQVUsR0FBR1osSUFBSSxDQUFDNy9DLEtBQUwsQ0FBV3VnRCxNQUFNLENBQUNHLEtBQVAsQ0FBYUMsTUFBeEIsQ0FBYjtBQUNEOztBQUVEOXhDLFFBQU0sQ0FBQ0MsTUFBUCxDQUFjMHZDLCtDQUFkLEVBQXNCaUMsVUFBdEI7QUFDQVYsU0FBTztBQUNSLENBVkQ7O0FBWWU7QUFDYlAsU0FEYTtBQUViQyxRQUZhO0FBR2JuOEMsT0FIYTtBQUlieThDLFNBSmE7QUFLYkksYUFMYTtBQU1iamhEO0FBTmEsQ0FBZixFOzs7Ozs7Ozs7Ozs7QUNuREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFTyxNQUFNMGhELGFBQU4sQ0FBb0I7QUFDMUI5OUMsYUFBVyxHQUFHO0FBQ2IsU0FBSys5QyxZQUFMLEdBQW9COXRDLDhDQUFJLENBQUNnSSxNQUFMLEVBQXBCO0FBQ0EsU0FBSytsQyxpQkFBTCxHQUF5QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUF6QjtBQUNBLFNBQUtDLFdBQUwsR0FBbUIsSUFBSXo2QyxrREFBSixFQUFuQjtBQUVBLFNBQUtxQyxJQUFMLEdBQVk2MUMsK0NBQU0sQ0FBQzF1QixXQUFQLENBQW1Cbm5CLElBQS9CO0FBQ0EsU0FBS280QyxXQUFMLENBQWlCdjFCLEtBQWpCLENBQXVCLENBQUMsS0FBSzdpQixJQUE3QixFQUFtQyxLQUFLQSxJQUF4QyxFQUE4QyxLQUFLQSxJQUFuRCxFQUF5RCxDQUFDLEtBQUtBLElBQS9ELEVBQXFFNjFDLCtDQUFNLENBQUMxdUIsV0FBUCxDQUFtQmhFLElBQXhGLEVBQThGMHlCLCtDQUFNLENBQUMxdUIsV0FBUCxDQUFtQi9ELEdBQWpIO0FBQ0EsU0FBS2kxQixpQkFBTDtBQUVBLFVBQU1DLFNBQVMsR0FBRztBQUFFajRDLGVBQVMsRUFBQ3hELHlDQUFFLENBQUMyUyxxQkFBZjtBQUFzQ3JQLGVBQVMsRUFBQ3RELHlDQUFFLENBQUN1RDtBQUFuRCxLQUFsQjtBQUNBLFNBQUtpRCxHQUFMLEdBQVcsSUFBSWxHLGtEQUFKLENBQWdCLElBQWhCLEVBQXNCLElBQXRCLEVBQTRCbTdDLFNBQTVCLENBQVg7QUFDQTs7QUFFREQsbUJBQWlCLEdBQUc7QUFDbkIsU0FBS0QsV0FBTCxDQUFpQjUyQixNQUFqQixDQUF3QnEwQiwrQ0FBTSxDQUFDVSxtQkFBL0IsRUFBb0QsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBcEQ7QUFDQW5zQyxrREFBSSxDQUFDMkksUUFBTCxDQUFjLEtBQUttbEMsWUFBbkI7QUFDQTl0QyxrREFBSSxDQUFDMkssUUFBTCxDQUFjLEtBQUttakMsWUFBbkIsRUFBaUMsS0FBS0UsV0FBTCxDQUFpQi9pQyxVQUFsRCxFQUE4RCxLQUFLK2lDLFdBQUwsQ0FBaUI5MUIsVUFBL0U7QUFDQTNxQixXQUFPLENBQUNDLEdBQVIsQ0FBWTJnRCx1REFBWjtBQUNBbnVDLGtEQUFJLENBQUMySyxRQUFMLENBQWMsS0FBS21qQyxZQUFuQixFQUFpQ0ssdURBQWpDLEVBQTZDLEtBQUtMLFlBQWxEO0FBQ0E7O0FBRUQva0MsU0FBTyxDQUFDblQsSUFBRCxFQUFPO0FBQ2IsU0FBS0EsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS3c0QyxpQkFBTDtBQUNBOztBQUVEQSxtQkFBaUIsR0FBRztBQUNuQixTQUFLSixXQUFMLENBQWlCdjFCLEtBQWpCLENBQXVCLENBQUMsS0FBSzdpQixJQUE3QixFQUFtQyxLQUFLQSxJQUF4QyxFQUE4QyxLQUFLQSxJQUFuRCxFQUF5RCxDQUFDLEtBQUtBLElBQS9ELEVBQXFFNjFDLCtDQUFNLENBQUMxdUIsV0FBUCxDQUFtQmhFLElBQXhGLEVBQThGMHlCLCtDQUFNLENBQUMxdUIsV0FBUCxDQUFtQi9ELEdBQWpIO0FBQ0EsU0FBS2kxQixpQkFBTDtBQUNBOztBQUVEdDNCLFFBQU0sQ0FBQ3RwQixJQUFELEVBQU87QUFDWixTQUFLNEwsR0FBTCxDQUFTdkQsSUFBVDtBQUNBakQsNkNBQUUsQ0FBQ3NJLEtBQUgsQ0FBUyxDQUFULEVBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEI7QUFDQXRJLDZDQUFFLENBQUM0WCxXQUFILENBQWUsS0FBSzJqQyxXQUFwQjtBQUNFdjdDLDZDQUFFLENBQUMzRSxFQUFILENBQU11Z0QsU0FBTixDQUFnQjU3Qyx5Q0FBRSxDQUFDM0UsRUFBSCxDQUFNMndDLElBQXRCO0FBRUFweEMsUUFBSSxDQUFDaWhELFlBQUw7QUFDRixTQUFLcjFDLEdBQUwsQ0FBU04sTUFBVDtBQUNBOztBQXhDeUIsQzs7Ozs7Ozs7Ozs7O0FDTjNCO0FBQUE7QUFBQSxNQUFNNDFDLElBQUksR0FBRyxNQUFLLENBQUUsQ0FBcEI7O0FBRU8sTUFBTUMsYUFBTixDQUFvQjtBQUMxQnorQyxhQUFXLENBQUN1NUMsS0FBRCxFQUFRO0FBQ2hCLFNBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNGLFNBQUttRixNQUFMLEdBQWMsRUFBZDtBQUNBLFNBQUtDLGNBQUwsR0FBc0IsT0FBdEI7QUFDQSxTQUFLQyxhQUFMLEdBQXFCLEVBQXJCO0FBRUEsU0FBSzkrQyxHQUFMLENBQVMsT0FBVCxFQUFrQjtBQUFFKytDLFNBQUcsRUFBRUwsSUFBUDtBQUFhTSxXQUFLLEVBQUVOLElBQXBCO0FBQTBCcHlCLFlBQU0sRUFBRW95QixJQUFsQztBQUF3QzUzQixZQUFNLEVBQUU0M0I7QUFBaEQsS0FBbEI7QUFDQTs7QUFFRCxNQUFJN2lELEVBQUosR0FBUztBQUNSLFdBQU8sS0FBS2dqRCxjQUFaO0FBQ0E7O0FBRURJLGVBQWEsQ0FBQ0MsR0FBRCxFQUFNQyxHQUFOLEVBQVdDLFFBQVgsRUFBcUI7QUFDakMsU0FBS04sYUFBTCxDQUFtQkksR0FBbkIsRUFBd0JDLEdBQXhCLElBQStCLElBQS9COztBQUVBLFFBQUlDLFFBQUosRUFBYztBQUNiLFdBQUtOLGFBQUwsQ0FBbUJLLEdBQW5CLEVBQXdCRCxHQUF4QixJQUErQixJQUEvQjtBQUNBOztBQUVELFdBQU8sSUFBUDtBQUNBOztBQUVEbC9DLEtBQUcsQ0FBQ25FLEVBQUQsRUFBS3dqRCxLQUFMLEVBQVk7QUFDZCxTQUFLVCxNQUFMLENBQVkvaUQsRUFBWixJQUFrQndqRCxLQUFsQjtBQUNBQSxTQUFLLENBQUM1RixLQUFOLEdBQWMsS0FBS0EsS0FBbkI7QUFFQSxRQUFJLENBQUM0RixLQUFLLENBQUNDLEtBQVgsRUFBaUJELEtBQUssQ0FBQ0MsS0FBTixHQUFjWixJQUFkO0FBQ2pCLFFBQUksQ0FBQ1csS0FBSyxDQUFDTCxLQUFYLEVBQWlCSyxLQUFLLENBQUNMLEtBQU4sR0FBY04sSUFBZDtBQUNqQixRQUFJLENBQUNXLEtBQUssQ0FBQy95QixNQUFYLEVBQWtCK3lCLEtBQUssQ0FBQy95QixNQUFOLEdBQWVveUIsSUFBZjtBQUNsQixRQUFJLENBQUNXLEtBQUssQ0FBQ3Y0QixNQUFYLEVBQWtCdTRCLEtBQUssQ0FBQ3Y0QixNQUFOLEdBQWU0M0IsSUFBZjtBQUNsQixRQUFJLENBQUNXLEtBQUssQ0FBQ04sR0FBWCxFQUFlTSxLQUFLLENBQUNOLEdBQU4sR0FBWUwsSUFBWjtBQUVmLFNBQUtJLGFBQUwsQ0FBbUJqakQsRUFBbkIsSUFBeUIsRUFBekI7QUFFQSxTQUFLb2pELGFBQUwsQ0FBbUIsT0FBbkIsRUFBNEJwakQsRUFBNUIsRUFBZ0MsSUFBaEM7QUFFQSxXQUFPLElBQVA7QUFDQTs7QUFFRHdFLEtBQUcsQ0FBQ3hFLEVBQUQsRUFBS2lTLElBQUwsRUFBVztBQUNiLFFBQUksS0FBS2d4QyxhQUFMLENBQW1CLEtBQUtELGNBQXhCLEVBQXdDaGpELEVBQXhDLENBQUosRUFBaUQ7QUFDN0MsV0FBSytpRCxNQUFMLENBQVksS0FBS0MsY0FBakIsRUFBaUNFLEdBQWpDO0FBRUgsV0FBS0YsY0FBTCxHQUFzQmhqRCxFQUF0QjtBQUVHLFdBQUsraUQsTUFBTCxDQUFZLEtBQUtDLGNBQWpCLEVBQWlDRyxLQUFqQyxDQUF1Q2x4QyxJQUF2QztBQUNBcFEsYUFBTyxDQUFDQyxHQUFSLENBQVksS0FBS2loRCxNQUFMLENBQVksS0FBS0MsY0FBakIsQ0FBWjtBQUNIO0FBQ0Q7O0FBRUQvM0IsUUFBTSxHQUFHO0FBQ1IsU0FBSzgzQixNQUFMLENBQVksS0FBS0MsY0FBakIsRUFBaUMvM0IsTUFBakM7QUFDQTs7QUF0RHlCLEM7Ozs7Ozs7Ozs7OztBQ0YzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7O0FBRUEsTUFBTTZaLFFBQVEsR0FBRyxVQUFVQyxNQUFWLEVBQWtCdEosT0FBbEIsRUFBMkI7QUFFM0MsUUFBTTM2QixDQUFDLEdBQUcyNkIsT0FBTyxJQUFJLEVBQXJCOztBQUNBLE1BQUdzSixNQUFNLENBQUNDLE9BQVYsRUFBbUI7QUFDbEJsa0MsS0FBQyxDQUFDZ1gsQ0FBRixHQUFNaXRCLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlLENBQWYsRUFBa0JDLEtBQXhCO0FBQ0Fua0MsS0FBQyxDQUFDc2QsQ0FBRixHQUFNMm1CLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlLENBQWYsRUFBa0JFLEtBQXhCO0FBQ0EsR0FIRCxNQUdPO0FBQ05wa0MsS0FBQyxDQUFDZ1gsQ0FBRixHQUFNaXRCLE1BQU0sQ0FBQ0ksT0FBYjtBQUNBcmtDLEtBQUMsQ0FBQ3NkLENBQUYsR0FBTTJtQixNQUFNLENBQUNLLE9BQWI7QUFDQTs7QUFFRCxTQUFPdGtDLENBQVA7QUFDQSxDQVpEOztBQWNPLE1BQU00aUQsZUFBTixDQUFzQjtBQUMzQnIvQyxhQUFXLENBQUN1NUMsS0FBRCxFQUFRO0FBQ25CLFNBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUsvK0IsTUFBTCxHQUFjLEtBQUsrK0IsS0FBTCxDQUFXLytCLE1BQXpCO0FBQ0EsU0FBSzhrQyxTQUFMLEdBQWlCO0FBQUM3ckMsT0FBQyxFQUFFLENBQUo7QUFBT3NHLE9BQUMsRUFBRTtBQUFWLEtBQWpCO0FBQ0EsU0FBS21wQixLQUFMLEdBQWE7QUFBQ3p2QixPQUFDLEVBQUUsQ0FBSjtBQUFPc0csT0FBQyxFQUFFO0FBQVYsS0FBYjtBQUNBLFNBQUt3bEMsR0FBTCxHQUFXLElBQUk3N0MsMENBQUosQ0FBUSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFSLEVBQW1CLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQW5CLENBQVg7QUFFQSxTQUFLODdDLGNBQUwsR0FBc0IsSUFBdEI7QUFDQSxTQUFLQyxlQUFMLEdBQXVCLElBQXZCO0FBQ0EsU0FBS0MsWUFBTCxHQUFvQixJQUFwQjtBQUVBLFNBQUsxNEMsT0FBTCxHQUFlLEVBQWY7QUFFQSxTQUFLKzZCLE9BQUwsR0FBZSxLQUFLNGQsTUFBTCxDQUFZaDZDLElBQVosQ0FBaUIsSUFBakIsQ0FBZjtBQUNBLFNBQUtzOEIsT0FBTCxHQUFlLEtBQUsyZCxNQUFMLENBQVlqNkMsSUFBWixDQUFpQixJQUFqQixDQUFmO0FBQ0EsU0FBS3c4QixLQUFMLEdBQWEsS0FBSzBkLElBQUwsQ0FBVWw2QyxJQUFWLENBQWUsSUFBZixDQUFiO0FBQ0E7O0FBRURtNkMsT0FBSyxDQUFFbmtELEVBQUYsRUFBTTA4QyxHQUFHLEdBQUcsSUFBWixFQUFrQjtBQUN0QixVQUFNMEgsTUFBTSxHQUFHMUgsR0FBRyxHQUFHLEtBQUtrQixLQUFMLENBQVd3QixhQUFYLENBQXlCN3RCLG1CQUE1QixHQUFrRCxLQUFLcXNCLEtBQUwsQ0FBV3dCLGFBQVgsQ0FBeUJqOEMsZ0JBQTdGOztBQUNBLFFBQUluRCxFQUFFLEtBQUssUUFBWCxFQUFxQjtBQUNwQm9rRCxZQUFNLENBQUMsV0FBRCxFQUFjLEtBQUs5ZCxPQUFuQixDQUFOO0FBQ0E7QUFDRDs7QUFFRHBZLGFBQVcsQ0FBQ3ByQixDQUFELEVBQUl5a0MsS0FBSixFQUFXO0FBQ3JCLFVBQU16bUMsQ0FBQyxHQUFHZ2tDLFFBQVEsQ0FBQ2hpQyxDQUFELEVBQUl5a0MsS0FBSixDQUFsQjtBQUNBLFVBQU1pRCxFQUFFLEdBQUkxcEMsQ0FBQyxDQUFDZ1gsQ0FBRixHQUFRbFYsTUFBTSxDQUFDMGEsVUFBaEIsR0FBZ0MsR0FBaEMsR0FBc0MsR0FBakQ7QUFDQSxVQUFNbXRCLEVBQUUsR0FBRyxFQUFFM3BDLENBQUMsQ0FBQ3NkLENBQUYsR0FBT3hiLE1BQU0sQ0FBQzJhLFdBQWhCLElBQWdDLEdBQWhDLEdBQXNDLEdBQWpEO0FBR0EsU0FBS3NCLE1BQUwsQ0FBWXFQLFdBQVosQ0FBd0IsQ0FBQ3NjLEVBQUQsRUFBS0MsRUFBTCxFQUFTLENBQVQsQ0FBeEIsRUFBcUMsS0FBS21aLEdBQTFDO0FBQ0E7O0FBR0RTLGNBQVksQ0FBQ0MsR0FBRCxFQUFNO0FBRWpCLFNBQUssTUFBTTdILEdBQVgsSUFBa0I2SCxHQUFsQixFQUF1QjtBQUN0QixXQUFLN0gsR0FBTCxJQUFZNkgsR0FBRyxDQUFDN0gsR0FBRCxDQUFmO0FBQ0E7QUFDRDs7QUFFRDdyQixPQUFLLENBQUN2bEIsT0FBRCxFQUFVaTVDLEdBQVYsRUFBZTtBQUNuQixTQUFLajVDLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtnNUMsWUFBTCxDQUFrQkMsR0FBbEI7QUFDQSxTQUFLMUcsS0FBTCxDQUFXd0IsYUFBWCxDQUF5Qmo4QyxnQkFBekIsQ0FBMEMsV0FBMUMsRUFBdUQsS0FBS2lqQyxPQUE1RDtBQUNBLFNBQUt3WCxLQUFMLENBQVd3QixhQUFYLENBQXlCajhDLGdCQUF6QixDQUEwQyxTQUExQyxFQUFxRCxLQUFLcWpDLEtBQTFEO0FBQ0EsU0FBS29YLEtBQUwsQ0FBV3dCLGFBQVgsQ0FBeUJqOEMsZ0JBQXpCLENBQTBDLFdBQTFDLEVBQXVELEtBQUttakMsT0FBNUQ7QUFDQTs7QUFFRDVWLE1BQUksR0FBRztBQUNOLFNBQUtrdEIsS0FBTCxDQUFXd0IsYUFBWCxDQUF5Qjd0QixtQkFBekIsQ0FBNkMsV0FBN0MsRUFBMEQsS0FBSzZVLE9BQS9EO0FBQ0EsU0FBS3dYLEtBQUwsQ0FBV3dCLGFBQVgsQ0FBeUI3dEIsbUJBQXpCLENBQTZDLFNBQTdDLEVBQXdELEtBQUtpVixLQUE3RDtBQUNBLFNBQUtvWCxLQUFMLENBQVd3QixhQUFYLENBQXlCN3RCLG1CQUF6QixDQUE2QyxXQUE3QyxFQUEwRCxLQUFLK1UsT0FBL0Q7QUFDQTs7QUFFRGllLFlBQVUsQ0FBQ2w1QyxPQUFELEVBQVU7QUFDbkIsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0E7O0FBR0QyNEMsUUFBTSxDQUFDbGhELENBQUQsRUFBSTtBQUNULFNBQUswaEQsSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLYixTQUFMLEdBQWlCN2UsUUFBUSxDQUFDaGlDLENBQUQsQ0FBekI7QUFDQTs7QUFFRG1oRCxRQUFNLENBQUNuaEQsQ0FBRCxFQUFJO0FBQ1QsUUFBSSxLQUFLK2dELGNBQVQsRUFBeUIsS0FBS0EsY0FBTCxDQUFvQixLQUFLVyxJQUF6QjtBQUN6Qjs7QUFFRE4sTUFBSSxDQUFDcGhELENBQUQsRUFBSTtBQUNQLFNBQUswaEQsSUFBTCxHQUFZLEtBQVo7QUFDQSxVQUFNMWpELENBQUMsR0FBR2drQyxRQUFRLENBQUNoaUMsQ0FBRCxDQUFsQjtBQUNBLFVBQU0rbkMsSUFBSSxHQUFHNFosMERBQVksQ0FBQzNqRCxDQUFDLENBQUNnWCxDQUFILEVBQU1oWCxDQUFDLENBQUNzZCxDQUFSLEVBQVcsS0FBS3VsQyxTQUFMLENBQWU3ckMsQ0FBMUIsRUFBNkIsS0FBSzZyQyxTQUFMLENBQWV2bEMsQ0FBNUMsQ0FBekI7O0FBRUEsUUFBSXlzQixJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBRWI7QUFDQSxXQUFLM2MsV0FBTCxDQUFpQnByQixDQUFqQixFQUFvQixLQUFLeWtDLEtBQXpCO0FBQ0EsVUFBSW1ELEdBQUo7O0FBRUEsV0FBSyxJQUFJcm9DLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS2dKLE9BQUwsQ0FBYTdLLE1BQWpDLEVBQXlDNkIsQ0FBQyxFQUExQyxFQUE4QztBQUM3QyxjQUFNVixJQUFJLEdBQUcsS0FBSzBKLE9BQUwsQ0FBYWhKLENBQWIsQ0FBYjtBQUVBcW9DLFdBQUcsR0FBR2dhLGlFQUFtQixDQUFDLEtBQUtkLEdBQU4sRUFBV2ppRCxJQUFJLENBQUMybkIsS0FBaEIsRUFBdUIzbkIsSUFBSSxDQUFDdWQsTUFBNUIsRUFBb0MsS0FBcEMsQ0FBekI7QUFDQSxZQUFJd3JCLEdBQUcsSUFBSSxLQUFLb1osZUFBaEIsRUFBaUMsS0FBS0EsZUFBTCxDQUFxQm5pRCxJQUFyQjtBQUNqQztBQUNEOztBQUVELFFBQUksS0FBS29pRCxZQUFULEVBQXVCLEtBQUtBLFlBQUw7QUFDdkI7O0FBM0YyQixDOzs7Ozs7Ozs7Ozs7QUNuQjdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU1ZLFNBQU4sU0FBd0IvN0MsNENBQXhCLENBQThCO0FBQzdCdkUsYUFBVyxDQUFDYyxPQUFPLEdBQUcsRUFBWCxFQUFlO0FBQ3pCLFFBQUlvckIsU0FBSjs7QUFDQSxRQUFJcHJCLE9BQU8sQ0FBQ29yQixTQUFaLEVBQXVCO0FBQ3RCcHJCLGFBQU8sQ0FBQ2dzQixTQUFSLEdBQW9CLElBQXBCO0FBQ0FaLGVBQVMsR0FBRzFzQixRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjtBQUNBeXNCLGVBQVMsQ0FBQ3d1QixTQUFWLEdBQXNCLGNBQXRCO0FBQ0E1NUMsYUFBTyxDQUFDb3JCLFNBQVIsQ0FBa0I4dUIsV0FBbEIsQ0FBOEI5dUIsU0FBOUI7QUFDQSxLQUxELE1BS087QUFDTkEsZUFBUyxHQUFHMXNCLFFBQVEsQ0FBQytnRCxhQUFULENBQXVCLGVBQXZCLENBQVo7QUFDQXovQyxhQUFPLENBQUNvckIsU0FBUixHQUFvQkEsU0FBcEI7QUFDQTs7QUFFRCxVQUFNcHJCLE9BQU47QUFFQSxRQUFJLENBQUNBLE9BQU8sQ0FBQ2dzQixTQUFiLEVBQXdCMHpCLDJEQUFLLENBQUMsSUFBRCxFQUFPdDBCLFNBQVAsQ0FBTDtBQUV4QixTQUFLcHJCLE9BQUwsR0FBZUEsT0FBZjtBQUVBNEIsNkNBQUUsQ0FBQ21YLG1CQUFIO0FBQ0EsU0FBS2xaLGNBQUwsQ0FBb0JNLEVBQXBCLENBQXVCVixLQUF2QixHQUErQixLQUFLSSxjQUFMLENBQW9CTyxFQUFwQixDQUF1QlgsS0FBdkIsR0FBK0IsR0FBOUQ7QUFDQSxTQUFLSSxjQUFMLENBQW9CSyxNQUFwQixDQUEyQlQsS0FBM0IsR0FBbUMsQ0FBbkM7O0FBRUEsU0FBS0ksY0FBTCxDQUFvQms1QixHQUFwQixDQUF3Qm1DLEtBQXhCLENBQThCLENBQTlCLEVBQWlDdHRCLElBQUksQ0FBQ29SLEVBQUwsR0FBVSxDQUEzQzs7QUFDQSxRQUFJLENBQUM0N0IsK0NBQU0sQ0FBQ0ssTUFBUCxDQUFjakMsTUFBZixJQUF5QixDQUFDNEIsK0NBQU0sQ0FBQzk5QyxLQUFQLENBQWErUCxLQUFiLENBQW1CbXNDLE1BQWpELEVBQXlEO0FBQ3hELFdBQUtuNUMsY0FBTCxDQUFvQkssTUFBcEIsQ0FBMkJnN0IsS0FBM0IsQ0FBaUMsQ0FBakMsRUFBb0MsQ0FBcEM7QUFDQTs7QUFFRCxTQUFLb2UsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFNBQUtqdUIsTUFBTDtBQUVBLFNBQUtzMEIsYUFBTCxHQUFxQjV3QywrQ0FBSSxDQUFDb0ksTUFBTCxFQUFyQjtBQUNBLFNBQUt5b0MsbUJBQUwsR0FBMkI3d0MsK0NBQUksQ0FBQ29JLE1BQUwsRUFBM0I7QUFFQSxTQUFLMG9DLFlBQUwsR0FBb0IsSUFBSWxDLDREQUFKLENBQWtCLElBQWxCLENBQXBCO0FBQ0EsU0FBS2tDLFlBQUwsQ0FBa0I3Z0QsR0FBbEIsQ0FBc0IsTUFBdEIsRUFBOEIsSUFBSThnRCxpREFBSixFQUE5QjtBQUNBLFNBQUtELFlBQUwsQ0FBa0I3Z0QsR0FBbEIsQ0FBc0IsT0FBdEIsRUFBK0IsSUFBSStnRCxrREFBSixFQUEvQjtBQUNBLFNBQUtGLFlBQUwsQ0FBa0I3Z0QsR0FBbEIsQ0FBc0IsVUFBdEIsRUFBa0MsSUFBSWdoRCxxREFBSixFQUFsQztBQUNBLFNBQUtILFlBQUwsQ0FBa0I1QixhQUFsQixDQUFnQyxNQUFoQyxFQUF3QyxPQUF4QyxFQUFpRCxJQUFqRDtBQUNBLFNBQUs0QixZQUFMLENBQWtCNUIsYUFBbEIsQ0FBZ0MsTUFBaEMsRUFBd0MsVUFBeEMsRUFBb0QsSUFBcEQ7QUFDQSxTQUFLNEIsWUFBTCxDQUFrQjVCLGFBQWxCLENBQWdDLE9BQWhDLEVBQXlDLFVBQXpDLEVBQXFELElBQXJEO0FBRUEsU0FBSzlDLElBQUwsQ0FBVSxJQUFWO0FBQ0E7O0FBRUQzMUMsT0FBSyxDQUFFeEYsT0FBRixFQUFXO0FBQ2YsVUFBTXdGLEtBQU4sQ0FBWXhGLE9BQVo7O0FBRUEsU0FBS2k2QyxhQUFMLEdBQXFCajZDLE9BQU8sQ0FBQ29yQixTQUE3QjtBQUVBNjBCLCtEQUFtQixDQUFDM2tELElBQXBCLENBQXlCLEtBQUt1RSxjQUE5QjtBQUVBLFNBQUtxZ0QsZUFBTCxHQUF1QixJQUFJM0IsZ0VBQUosQ0FBb0IsSUFBcEIsQ0FBdkI7QUFDQSxTQUFLNEIsV0FBTCxHQUFtQixJQUFJM0gsd0RBQUosQ0FBZ0IsSUFBaEIsRUFBc0J4NEMsT0FBTyxDQUFDb3JCLFNBQTlCLEVBQXlDd3ZCLCtDQUFNLENBQUNLLE1BQVAsQ0FBY0MsTUFBZCxJQUF3QmtGLDREQUFqRSxDQUFuQjtBQUNBLFNBQUtELFdBQUwsQ0FBaUJySCxhQUFqQixDQUErQjk1QyxHQUEvQixDQUFtQyxLQUFLODVDLGFBQUwsQ0FBbUJqMEMsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBbkM7QUFDQSxTQUFLcTdDLGVBQUwsQ0FBcUJ6MEIsS0FBckIsQ0FBMkIsRUFBM0IsRUFBK0I7QUFDOUI7QUFDQWl6QixvQkFBYyxFQUFFLEtBQUsyQixxQkFBTCxDQUEyQng3QyxJQUEzQixDQUFnQyxJQUFoQztBQUZjLEtBQS9CO0FBS0E7O0FBRURzMkMsTUFBSSxDQUFDbUYsSUFBSSxHQUFHLEtBQVIsRUFBZTtBQUNsQixTQUFLVCxZQUFMLENBQWtCeGdELEdBQWxCLENBQXNCLE1BQXRCLEVBQThCO0FBQUVpaEQ7QUFBRixLQUE5QixFQURrQixDQUVsQjtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVEQyxVQUFRLEdBQUk7QUFDWCxRQUFJLEtBQUtWLFlBQUwsQ0FBa0JoQyxjQUFsQixLQUFxQyxVQUF6QyxFQUFxRDtBQUVwRCxXQUFLZ0MsWUFBTCxDQUFrQnhnRCxHQUFsQixDQUFzQixPQUF0QjtBQUNBLEtBSEQsTUFHTztBQUNOLFdBQUt3Z0QsWUFBTCxDQUFrQnhnRCxHQUFsQixDQUFzQixVQUF0QixFQUFrQztBQUFFbWhELHFCQUFhLEVBQUUsS0FBS1gsWUFBTCxDQUFrQmhDO0FBQW5DLE9BQWxDO0FBQ0E7QUFDRDs7QUFFRGlCLFFBQU0sR0FBRyxDQUNSO0FBQ0E7QUFDQTs7QUFFRHYxQyxlQUFhLEdBQUc7QUFDZjdNLFdBQU8sQ0FBQ0MsR0FBUixDQUFZLGVBQVo7QUFFQSxTQUFLOGpELGNBQUwsR0FBc0JqbUQsK0NBQU0sQ0FBQ3FDLEdBQVAsQ0FBVyxpQkFBWCxDQUF0QjtBQUNBLFNBQUs2akQsR0FBTCxHQUFXbG1ELCtDQUFNLENBQUNxQyxHQUFQLENBQVcsS0FBWCxDQUFYO0FBQ0EsU0FBSzhqRCxLQUFMLEdBQWFubUQsK0NBQU0sQ0FBQ3FDLEdBQVAsQ0FBVyxPQUFYLENBQWI7QUFDQSxTQUFLK2pELFFBQUwsR0FBZ0JwbUQsK0NBQU0sQ0FBQ3FDLEdBQVAsQ0FBVyxVQUFYLENBQWhCO0FBQ0EsU0FBS2drRCxZQUFMLEdBQW9Ccm1ELCtDQUFNLENBQUNxQyxHQUFQLENBQVcsY0FBWCxDQUFwQjtBQUNBOztBQUdEb3VCLFlBQVUsQ0FBQ2pyQixPQUFELEVBQVU7QUFFbkIsU0FBSzhnRCxhQUFMLEdBQXFCLElBQUk5RCw0REFBSixFQUFyQjtBQUNBLFNBQUsrRCxNQUFMLEdBQWMsSUFBSTdrRCw4Q0FBTSxDQUFDZ0gsU0FBWCxFQUFkO0FBQ0EsU0FBSzg5QyxNQUFMLEdBQWMsSUFBSTlrRCw4Q0FBTSxDQUFDaUgsU0FBWCxFQUFkO0FBQ0EsU0FBSzg5QyxNQUFMLEdBQWMsSUFBSS9rRCw4Q0FBTSxDQUFDc0gsY0FBWCxFQUFkOztBQUNBLFFBQUlvM0MsK0NBQU0sQ0FBQ0ssTUFBUCxDQUFjakMsTUFBbEIsRUFBMEI7QUFDekIsV0FBS2tJLE1BQUwsR0FBYyxJQUFJaGxELDhDQUFNLENBQUNrSCxTQUFYLEVBQWQ7QUFDQSxXQUFLKzlDLGVBQUwsR0FBdUIsSUFBSWpsRCw4Q0FBTSxDQUFDa0gsU0FBWCxFQUF2QjtBQUNBLFdBQUtnK0MsWUFBTCxHQUFvQixJQUFJbGxELDhDQUFNLENBQUNrSCxTQUFYLEVBQXBCO0FBQ0E7O0FBQ0QsU0FBS2krQyxLQUFMLEdBQWEsSUFBSW5sRCw4Q0FBTSxDQUFDcUgsUUFBWCxFQUFiO0FBRUEsU0FBSys5QyxNQUFMLEdBQWM5bUQsK0NBQU0sQ0FBQ3FDLEdBQVAsQ0FBVyxhQUFYLENBQWQ7QUFFQSxTQUFLMGtELE9BQUwsR0FBZSxJQUFJQyw0REFBSixFQUFmO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLElBQUlDLHlEQUFKLEVBQWY7QUFDQSxTQUFLQyxZQUFMLEdBQW9CLElBQUlDLDZEQUFKLENBQW1CNWhELE9BQU8sQ0FBQ29yQixTQUEzQixDQUFwQixDQWpCbUIsQ0FpQndDO0FBQzNEOztBQUVEMHRCLGVBQWEsQ0FBQ3dCLElBQUQsRUFBTztBQUNuQixTQUFLdUgsU0FBTCxHQUFpQixLQUFLaGlELGNBQUwsQ0FBb0JLLE1BQXBCLENBQTJCVCxLQUE1QztBQUNBLFNBQUs2NUMsV0FBTCxHQUFtQmdCLElBQW5CO0FBQ0EsU0FBSzZGLFdBQUwsQ0FBaUIvRyxJQUFqQjtBQUNBLFNBQUs4RyxlQUFMLENBQXFCbEIsS0FBckIsQ0FBMkIsUUFBM0IsRUFBcUMsS0FBckM7QUFDQWlCLCtEQUFtQixDQUFDbGdELEtBQXBCLENBQTBCO0FBQ3pCTSxhQUFPLEVBQUVpNkMsSUFBSSxDQUFDaDZDLE1BQUwsQ0FBWSxDQUFaLENBRGdCO0FBQ0FDLGFBQU8sRUFBRSs1QyxJQUFJLENBQUNoNkMsTUFBTCxDQUFZLENBQVosQ0FEVDtBQUN5QkUsYUFBTyxFQUFFODVDLElBQUksQ0FBQ2g2QyxNQUFMLENBQVksQ0FBWixDQURsQztBQUV6QkcsYUFBTyxFQUFFNjVDLElBQUksQ0FBQ3BzQyxNQUFMLENBQVksQ0FBWixDQUZnQjtBQUVBdk4sYUFBTyxFQUFFMjVDLElBQUksQ0FBQ3BzQyxNQUFMLENBQVksQ0FBWixDQUZUO0FBRXlCdE4sYUFBTyxFQUFFMDVDLElBQUksQ0FBQ3BzQyxNQUFMLENBQVksQ0FBWixDQUZsQztBQUd6QmpOLFVBQUksRUFBRSxVQUhtQjtBQUdQRixjQUFRLEVBQUU7QUFISCxLQUExQjtBQU1BMDdDLGNBQVUsQ0FBQyxNQUFJO0FBQ2QsV0FBS2tGLFlBQUwsQ0FBa0I3SSxhQUFsQixDQUFnQ3dCLElBQWhDO0FBQ0EsS0FGUyxFQUVQLElBRk8sQ0FBVjtBQUdBOztBQUVEK0YsdUJBQXFCLENBQUN5QixNQUFELEVBQVM7QUFDN0IsUUFBSUEsTUFBTSxJQUFJLEtBQUt4SSxXQUFuQixFQUFnQztBQUMvQixXQUFLNkcsV0FBTCxDQUFpQmhILElBQWpCO0FBQ0EsV0FBS0csV0FBTCxHQUFtQixJQUFuQjs7QUFDQSxXQUFLcUksWUFBTCxDQUFrQnZJLElBQWxCOztBQUNBNkcsaUVBQW1CLENBQUNsZ0QsS0FBcEIsQ0FBMEI7QUFDekJVLGVBQU8sRUFBRSxDQURnQjtBQUNiRSxlQUFPLEVBQUUsQ0FESTtBQUNEQyxlQUFPLEVBQUUsQ0FEUjtBQUV6QlAsZUFBTyxFQUFFLENBRmdCO0FBRWJFLGVBQU8sRUFBRSxDQUZJO0FBRURDLGVBQU8sRUFBRSxDQUZSO0FBRVdTLFlBQUksRUFBRSxVQUZqQjtBQUU2QkYsZ0JBQVEsRUFBRTtBQUZ2QyxPQUExQjtBQUlBLFdBQUtsQixjQUFMLENBQW9CSyxNQUFwQixDQUEyQlQsS0FBM0IsR0FBbUMsS0FBS29pRCxTQUF4QztBQUNBLFdBQUszQixlQUFMLENBQXFCbEIsS0FBckIsQ0FBMkIsUUFBM0IsRUFBcUMsSUFBckM7QUFDQTtBQUNEOztBQUVEK0Msa0JBQWdCLENBQUM5aUMsR0FBRCxFQUFNO0FBQUU7QUFDdkIsU0FBSzJnQyxtQkFBTCxHQUEyQjNnQyxHQUEzQjtBQUNBOztBQUVEK2lDLGVBQWEsQ0FBQy9pQyxHQUFELEVBQU07QUFBRTtBQUNwQixTQUFLMGdDLGFBQUwsR0FBcUIxZ0MsR0FBckI7QUFDQTs7QUFFRDZHLFFBQU0sR0FBRztBQUNSLFFBQUksS0FBSys1QixZQUFULEVBQXVCLEtBQUtBLFlBQUwsQ0FBa0IvNUIsTUFBbEI7O0FBRXZCLFFBQUksS0FBS3d6QixXQUFULEVBQXNCO0FBQ3JCLFlBQU14c0MsSUFBSSxHQUFHLEtBQUt3c0MsV0FBbEI7QUFDQSxXQUFLejVDLGNBQUwsQ0FBb0JNLEVBQXBCLENBQXVCMDZCLFlBQXZCLElBQXVDLENBQUMvdEIsSUFBSSxDQUFDM00sRUFBTCxHQUFVLEtBQUtOLGNBQUwsQ0FBb0JNLEVBQXBCLENBQXVCMDZCLFlBQWxDLElBQWtELEdBQXpGO0FBQ0EsV0FBS2g3QixjQUFMLENBQW9CTyxFQUFwQixDQUF1Qnk2QixZQUF2QixJQUF1QyxDQUFDL3RCLElBQUksQ0FBQzFNLEVBQUwsR0FBVSxLQUFLUCxjQUFMLENBQW9CTyxFQUFwQixDQUF1Qnk2QixZQUFsQyxJQUFrRCxHQUF6RjtBQUNBLFdBQUtoN0IsY0FBTCxDQUFvQkssTUFBcEIsQ0FBMkIyNkIsWUFBM0IsSUFBMkMsQ0FBQy90QixJQUFJLENBQUN5c0MsSUFBTCxHQUFZLEtBQUsxNUMsY0FBTCxDQUFvQkssTUFBcEIsQ0FBMkIyNkIsWUFBeEMsSUFBd0QsR0FBbkc7QUFDQTs7QUFFRGo1Qiw2Q0FBRSxDQUFDc0ksS0FBSCxDQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixDQUFsQjs7QUFDQSxRQUFJMHdDLCtDQUFNLENBQUNLLE1BQVAsQ0FBY2pDLE1BQWxCLEVBQTBCO0FBQ3pCLFdBQUtrSSxNQUFMLENBQVl0OEMsSUFBWixDQUFpQixLQUFLKzZDLGFBQXRCLEVBQXFDLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLENBQXJDLEVBQXNELENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQXREOztBQUNBLFdBQUt5QixZQUFMLENBQWtCeDhDLElBQWxCLENBQXVCLEtBQUtnN0MsbUJBQTVCLEVBQWlELENBQUMsS0FBRCxFQUFRLEtBQVIsRUFBZSxLQUFmLENBQWpELEVBQXdFLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQXhFOztBQUNBLFdBQUt1QixlQUFMLENBQXFCdjhDLElBQXJCLENBQTBCLEtBQUsvRSxjQUFMLENBQW9CUyxNQUE5QyxFQUFzRCxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixDQUF0RCxFQUEwRSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUExRTtBQUNBOztBQUVELFNBQUt3Z0QsYUFBTCxDQUFtQmg3QixNQUFuQixDQUEwQixLQUFLeTdCLE9BQS9CO0FBQ0EzL0MsNkNBQUUsQ0FBQzRYLFdBQUgsQ0FBZSxLQUFLRSxNQUFwQixFQWxCUSxDQWtCcUI7O0FBRTdCLFNBQUsybkMsS0FBTCxDQUFXejhDLElBQVgsQ0FBZ0IsS0FBSzA4QyxNQUFyQixFQXBCUSxDQXFCUjtBQUNBOzs7QUFFQSxRQUFJLEtBQUtuQixXQUFULEVBQXNCLEtBQUtBLFdBQUwsQ0FBaUJyNkIsTUFBakI7O0FBQ3RCLFNBQUsyN0IsT0FBTCxDQUFhMzdCLE1BQWIsQ0FBb0IsS0FBS2c3QixhQUFMLENBQW1CN0QsWUFBdkMsRUFBcUQsS0FBSzZELGFBQUwsQ0FBbUIxNEMsR0FBbkIsQ0FBdUIyRCxZQUE1RTs7QUFDQSxTQUFLdzFDLE9BQUwsQ0FBYXo3QixNQUFiLENBQW9CLEtBQUsyNkIsY0FBekIsRUFBeUMsS0FBS0MsR0FBOUMsRUFBbUQsS0FBS0MsS0FBeEQsRUFBK0QsS0FBS0MsUUFBcEUsRUFBOEUsS0FBS0MsWUFBbkYsRUFBaUcsS0FBS3ZILFdBQXRHOztBQUVBLFFBQUlzQiwrQ0FBTSxDQUFDUyxXQUFYLEVBQXdCO0FBQ3ZCejVDLCtDQUFFLENBQUNvYSxPQUFILENBQVdwYSx5Q0FBRSxDQUFDZ1gsVUFBZDtBQUNBLFlBQU1oYyxDQUFDLEdBQUcsR0FBVjtBQUNBZ0YsK0NBQUUsQ0FBQ2lHLFFBQUgsQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQmpMLENBQWxCLEVBQXFCQSxDQUFyQjs7QUFDQSxXQUFLbWtELE1BQUwsQ0FBWW44QyxJQUFaLENBQWlCLEtBQUtrOEMsYUFBTCxDQUFtQjE0QyxHQUFuQixDQUF1QjBELGVBQXZCLEVBQWpCOztBQUNBbEssK0NBQUUsQ0FBQytXLE1BQUgsQ0FBVS9XLHlDQUFFLENBQUNnWCxVQUFiO0FBQ0E7QUFDRDs7QUFFRHlTLFFBQU0sQ0FBQ3ZZLENBQUQsRUFBSUUsQ0FBSixFQUFPO0FBQ1pxWSx5REFBTSxDQUFDdlksQ0FBRCxFQUFJRSxDQUFKLEVBQU8sS0FBS2hULE9BQUwsQ0FBYW9yQixTQUFiLENBQXVCNjJCLFdBQTlCLEVBQTJDLEtBQUtqaUQsT0FBTCxDQUFhb3JCLFNBQWIsQ0FBdUI4MkIsWUFBbEUsQ0FBTjtBQUNBLFNBQUt4b0MsTUFBTCxDQUFZb1AsY0FBWixDQUEyQmxuQix5Q0FBRSxDQUFDd2IsV0FBOUI7QUFDQTs7QUFyTTRCOztBQXlNZm9pQyx3RUFBZixFOzs7Ozs7Ozs7Ozs7QUM5TkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTlnRCxRQUFRLENBQUN5akQsSUFBYixFQUFtQjtBQUNsQjM4QyxPQUFLO0FBQ0wsQ0FGRCxNQUVPO0FBQ04vSCxRQUFNLENBQUNPLGdCQUFQLENBQXdCLGtCQUF4QixFQUE0Q3dILEtBQTVDO0FBQ0E7O0FBRUQsU0FBU0EsS0FBVCxHQUFpQjtBQUNoQjQ4QywrREFBTyxDQUFDO0FBQUUxbkQsK0RBQU1BO0FBQVIsR0FBRCxDQUFQLENBQW9CcTBCLElBQXBCLENBQXlCc3pCLE1BQXpCLEVBQWlDQyxRQUFqQztBQUNBOztBQUVELFNBQVNBLFFBQVQsQ0FBa0Iza0QsQ0FBbEIsRUFBcUI7QUFDcEJqQixTQUFPLENBQUNDLEdBQVIsQ0FBWSxPQUFaLEVBQXFCZ0IsQ0FBckI7QUFDQTs7QUFFRCxTQUFTMGtELE1BQVQsR0FBa0I7QUFFakIsTUFBSUUsSUFBSixFQUE0QztBQUMzQ0MscURBQVEsQ0FBQ2xuRCxJQUFUO0FBQ0EsR0FKZ0IsQ0FNakI7OztBQUNBLFFBQU1tOUMsS0FBSyxHQUFHLElBQUkrRyxrREFBSixFQUFkOztBQUVBLE1BQUkrQyxJQUFKLEVBQTRDO0FBQzNDN2xELFdBQU8sQ0FBQ0MsR0FBUixDQUFZLGdCQUFaO0FBQ0E4bEQsc0VBQVcsQ0FBQ2hLLEtBQUQsQ0FBWDtBQUNBbjdDLGdGQUFjLENBQUVtQixHQUFELElBQVM7QUFDcEJnNkMsV0FBSyxDQUFDNkksTUFBTixDQUFhaHRDLGFBQWIsQ0FBMkI3VixHQUEzQjtBQUNELEtBRlcsQ0FBZDtBQUdBO0FBQ0QsQzs7Ozs7Ozs7Ozs7O0FDdkNEO0FBQUEsTUFBTWpELFlBQVksR0FBRyxDQUNwQjtBQUFDLFFBQUssT0FBTjtBQUFjLFNBQU0sbUNBQXBCO0FBQXdELFVBQU87QUFBL0QsQ0FEb0IsRUFFcEI7QUFBQyxRQUFLLFdBQU47QUFBa0IsU0FBTSx1Q0FBeEI7QUFBZ0UsVUFBTztBQUF2RSxDQUZvQixFQUdwQjtBQUFDLFFBQUssbUJBQU47QUFBMEIsU0FBTSwrQ0FBaEM7QUFBZ0YsVUFBTztBQUF2RixDQUhvQixFQUlwQjtBQUFDLFFBQUssT0FBTjtBQUFjLFNBQU0sbUNBQXBCO0FBQXdELFVBQU87QUFBL0QsQ0FKb0IsRUFLcEI7QUFBQyxRQUFLLFNBQU47QUFBZ0IsU0FBTSxxQ0FBdEI7QUFBNEQsVUFBTztBQUFuRSxDQUxvQixFQU1wQjtBQUFDLFFBQUssVUFBTjtBQUFpQixTQUFNLHNDQUF2QjtBQUE4RCxVQUFPO0FBQXJFLENBTm9CLEVBT3BCO0FBQUMsUUFBSyxVQUFOO0FBQWlCLFNBQU0sc0NBQXZCO0FBQThELFVBQU87QUFBckUsQ0FQb0IsRUFRcEI7QUFBQyxRQUFLLFVBQU47QUFBaUIsU0FBTSxzQ0FBdkI7QUFBOEQsVUFBTztBQUFyRSxDQVJvQixFQVNwQjtBQUFDLFFBQUssVUFBTjtBQUFpQixTQUFNLHNDQUF2QjtBQUE4RCxVQUFPO0FBQXJFLENBVG9CLEVBVXBCO0FBQUMsUUFBSyxVQUFOO0FBQWlCLFNBQU0sc0NBQXZCO0FBQThELFVBQU87QUFBckUsQ0FWb0IsRUFXcEI7QUFBQyxRQUFLLFVBQU47QUFBaUIsU0FBTSxzQ0FBdkI7QUFBOEQsVUFBTztBQUFyRSxDQVhvQixFQVlwQjtBQUFDLFFBQUssVUFBTjtBQUFpQixTQUFNLHNDQUF2QjtBQUE4RCxVQUFPO0FBQXJFLENBWm9CLEVBYXBCO0FBQUMsUUFBSyxRQUFOO0FBQWUsU0FBTSxvQ0FBckI7QUFBMEQsVUFBTztBQUFqRSxDQWJvQixFQWNwQjtBQUFDLFFBQUssT0FBTjtBQUFjLFNBQU0sbUNBQXBCO0FBQXdELFVBQU87QUFBL0QsQ0Fkb0IsRUFlcEI7QUFBQyxRQUFLLGNBQU47QUFBcUIsU0FBTSwwQ0FBM0I7QUFBc0UsVUFBTztBQUE3RSxDQWZvQixFQWdCcEI7QUFBQyxRQUFLLGFBQU47QUFBb0IsU0FBTSx5Q0FBMUI7QUFBb0UsVUFBTztBQUEzRSxDQWhCb0IsRUFpQnBCO0FBQUMsUUFBSyxpQkFBTjtBQUF3QixTQUFNLDZDQUE5QjtBQUE0RSxVQUFPO0FBQW5GLENBakJvQixFQWtCcEI7QUFBQyxRQUFLLFlBQU47QUFBbUIsU0FBTSxvREFBekI7QUFBOEUsVUFBTztBQUFyRixDQWxCb0IsRUFtQnBCO0FBQUMsUUFBSyxlQUFOO0FBQXNCLFNBQU0sdURBQTVCO0FBQW9GLFVBQU87QUFBM0YsQ0FuQm9CLEVBb0JwQjtBQUFDLFFBQUssbUJBQU47QUFBMEIsU0FBTSwyREFBaEM7QUFBNEYsVUFBTztBQUFuRyxDQXBCb0IsRUFxQnBCO0FBQUMsUUFBSyxXQUFOO0FBQWtCLFNBQU0sbURBQXhCO0FBQTRFLFVBQU87QUFBbkYsQ0FyQm9CLEVBc0JwQjtBQUFDLFFBQUssY0FBTjtBQUFxQixTQUFNLHNEQUEzQjtBQUFrRixVQUFPO0FBQXpGLENBdEJvQixFQXVCcEI7QUFBQyxRQUFLLGtCQUFOO0FBQXlCLFNBQU0sMERBQS9CO0FBQTBGLFVBQU87QUFBakcsQ0F2Qm9CLENBQXJCO0FBMkJlQSwyRUFBZixFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUFlLGlFQUFmLEU7Ozs7Ozs7Ozs7OztBQ0FBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNbWtDLFFBQVEsR0FBRyxVQUFVQyxNQUFWLEVBQWtCdEosT0FBbEIsRUFBMkI7QUFFM0MsUUFBTTM2QixDQUFDLEdBQUcyNkIsT0FBTyxJQUFJLEVBQXJCOztBQUNBLE1BQUdzSixNQUFNLENBQUNDLE9BQVYsRUFBbUI7QUFDbEJsa0MsS0FBQyxDQUFDZ1gsQ0FBRixHQUFNaXRCLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlLENBQWYsRUFBa0JDLEtBQXhCO0FBQ0Fua0MsS0FBQyxDQUFDc2QsQ0FBRixHQUFNMm1CLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlLENBQWYsRUFBa0JFLEtBQXhCO0FBQ0EsR0FIRCxNQUdPO0FBQ05wa0MsS0FBQyxDQUFDZ1gsQ0FBRixHQUFNaXRCLE1BQU0sQ0FBQ0ksT0FBYjtBQUNBcmtDLEtBQUMsQ0FBQ3NkLENBQUYsR0FBTTJtQixNQUFNLENBQUNLLE9BQWI7QUFDQTs7QUFFRCxTQUFPdGtDLENBQVA7QUFDQSxDQVpEOztBQWNBLE1BQU0rbUQsUUFBUSxHQUFHdnpDLElBQUksQ0FBQ2dJLE1BQUwsRUFBakI7QUFDQSxNQUFNRCxjQUFjLEdBQUcvSCxJQUFJLENBQUNnSSxNQUFMLEVBQXZCOztBQUVBLE1BQU13ckMsWUFBTixDQUFtQjtBQUNsQnpqRCxhQUFXLEdBQUc7QUFDYixTQUFLa3NCLFNBQUwsR0FBaUIxc0IsUUFBUSxDQUFDK2dELGFBQVQsQ0FBdUIsZ0JBQXZCLENBQWpCO0FBRUEsU0FBS21ELFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxTQUFLQyxZQUFMLEdBQW9CLElBQUk5SixtREFBSixFQUFwQjtBQUNBLFNBQUsrSixhQUFMLEdBQXFCLElBQUkvSixtREFBSixFQUFyQjtBQUVBLFNBQUt5RixTQUFMLEdBQWlCO0FBQUM3ckMsT0FBQyxFQUFFLENBQUo7QUFBT3NHLE9BQUMsRUFBRTtBQUFWLEtBQWpCO0FBQ0EsU0FBS21wQixLQUFMLEdBQWE7QUFBQ3p2QixPQUFDLEVBQUUsQ0FBSjtBQUFPc0csT0FBQyxFQUFFO0FBQVYsS0FBYjtBQUNBLFNBQUt3bEMsR0FBTCxHQUFXLElBQUk3N0MsMENBQUosQ0FBUSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFSLEVBQW1CLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFDLENBQVIsQ0FBbkIsQ0FBWDtBQUNBLFNBQUttZ0QsVUFBTCxHQUFrQixJQUFsQjtBQUNBOztBQUVEem5ELE1BQUksQ0FBQ205QyxLQUFELEVBQVF2eUMsT0FBUixFQUFpQjtBQUNsQixTQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLdXlDLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUsvK0IsTUFBTCxHQUFjKytCLEtBQUssQ0FBQy8rQixNQUFwQjs7QUFFRixRQUFJa2hDLCtDQUFNLENBQUNLLE1BQVAsQ0FBY2pDLE1BQWxCLEVBQTBCO0FBQ3pCLFdBQUtnSyxjQUFMO0FBRUEsV0FBS3ZLLEtBQUwsQ0FBV3dCLGFBQVgsQ0FBeUJqOEMsZ0JBQXpCLENBQTBDLFdBQTFDLEVBQXVELEtBQUs2Z0QsTUFBTCxDQUFZaDZDLElBQVosQ0FBaUIsSUFBakIsQ0FBdkQ7QUFDQSxXQUFLNHpDLEtBQUwsQ0FBV3dCLGFBQVgsQ0FBeUJqOEMsZ0JBQXpCLENBQTBDLFdBQTFDLEVBQXVELEtBQUs4Z0QsTUFBTCxDQUFZajZDLElBQVosQ0FBaUIsSUFBakIsQ0FBdkQ7QUFDQSxXQUFLNHpDLEtBQUwsQ0FBV3dCLGFBQVgsQ0FBeUJqOEMsZ0JBQXpCLENBQTBDLFNBQTFDLEVBQXFELEtBQUsrZ0QsSUFBTCxDQUFVbDZDLElBQVYsQ0FBZSxJQUFmLENBQXJEO0FBRUFwSCxZQUFNLENBQUNPLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DaWxELEtBQUssSUFBSTtBQUMzQyxjQUFNM0wsR0FBRyxHQUFHMkwsS0FBSyxDQUFDQyxPQUFsQjtBQUNBLFlBQUk1TCxHQUFHLEdBQUcsRUFBTixJQUFZQSxHQUFHLEdBQUcsRUFBdEIsRUFBMEI7QUFFMUI1NkMsZUFBTyxDQUFDQyxHQUFSLENBQVlzbUQsS0FBSyxDQUFDQyxPQUFsQjtBQUNBLGNBQU1qakQsR0FBRyxHQUFHLEtBQUt3NEMsS0FBTCxDQUFXNTRDLGNBQXZCO0FBQ0EsY0FBTXNqRCxJQUFJLEdBQUdsakQsR0FBRyxDQUFDSyxNQUFKLENBQVcsQ0FBWCxJQUFpQkwsR0FBRyxDQUFDcW1CLFFBQUosQ0FBYSxDQUFiLENBQTlCLENBTjJDLENBTUk7O0FBQy9DLGNBQU04OEIsSUFBSSxHQUFHbmpELEdBQUcsQ0FBQ0ssTUFBSixDQUFXLENBQVgsSUFBaUJMLEdBQUcsQ0FBQ3FtQixRQUFKLENBQWEsQ0FBYixDQUE5QixDQVAyQyxDQU9JOztBQUMvQyxZQUFJK2MsS0FBSyxHQUFHejFCLElBQUksQ0FBQ3kxQyxLQUFMLENBQVdELElBQVgsRUFBaUJELElBQWpCLENBQVo7QUFFQSxZQUFJN0wsR0FBRyxLQUFLLEVBQVosRUFBZ0JqVSxLQUFLLElBQUl6MUIsSUFBSSxDQUFDb1IsRUFBZCxDQUFoQixLQUNLLElBQUlzNEIsR0FBRyxLQUFLLEVBQVosRUFBZ0JqVSxLQUFLLElBQUl6MUIsSUFBSSxDQUFDb1IsRUFBTCxHQUFVLENBQW5CLENBQWhCLEtBQ0EsSUFBSXM0QixHQUFHLEtBQUssRUFBWixFQUFnQmpVLEtBQUssSUFBSXoxQixJQUFJLENBQUNvUixFQUFMLEdBQVUsQ0FBbkI7QUFFckIsY0FBTXJNLENBQUMsR0FBRy9FLElBQUksQ0FBQ3dSLEdBQUwsQ0FBU2lrQixLQUFULENBQVY7QUFDQSxjQUFNM2pCLENBQUMsR0FBRzlSLElBQUksQ0FBQ3NSLEdBQUwsQ0FBU21rQixLQUFULENBQVY7QUFFQXBqQyxXQUFHLENBQUNTLGNBQUosQ0FBbUIsQ0FBbkIsS0FBeUJpUyxDQUFDLEdBQUcsR0FBN0I7QUFDQTFTLFdBQUcsQ0FBQ1MsY0FBSixDQUFtQixDQUFuQixLQUF5QmdmLENBQUMsR0FBRyxHQUE3QjtBQUNBemYsV0FBRyxDQUFDSyxNQUFKLENBQVcsQ0FBWCxLQUFpQnFTLENBQUMsR0FBRyxHQUFyQjtBQUNBMVMsV0FBRyxDQUFDSyxNQUFKLENBQVcsQ0FBWCxLQUFpQm9mLENBQUMsR0FBRyxHQUFyQjtBQUNBLE9BckJEO0FBc0JBO0FBQ0E7O0FBRURxSixhQUFXLENBQUNwckIsQ0FBRCxFQUFJeWtDLEtBQUosRUFBVztBQUN0QixVQUFNem1DLENBQUMsR0FBR2drQyxRQUFRLENBQUNoaUMsQ0FBRCxFQUFJeWtDLEtBQUosQ0FBbEI7QUFDQSxVQUFNaUQsRUFBRSxHQUFJMXBDLENBQUMsQ0FBQ2dYLENBQUYsR0FBUWxWLE1BQU0sQ0FBQzBhLFVBQWhCLEdBQWdDLEdBQWhDLEdBQXNDLEdBQWpEO0FBQ0EsVUFBTW10QixFQUFFLEdBQUcsRUFBRTNwQyxDQUFDLENBQUNzZCxDQUFGLEdBQU94YixNQUFNLENBQUMyYSxXQUFoQixJQUFnQyxHQUFoQyxHQUFzQyxHQUFqRDtBQUdBLFNBQUtzQixNQUFMLENBQVlxUCxXQUFaLENBQXdCLENBQUNzYyxFQUFELEVBQUtDLEVBQUwsRUFBUyxDQUFULENBQXhCLEVBQXFDLEtBQUttWixHQUExQztBQUNBOztBQUVESSxRQUFNLENBQUNsaEQsQ0FBRCxFQUFJO0FBQ1RBLEtBQUMsQ0FBQ0MsY0FBRjtBQUNBLFNBQUs0Z0QsU0FBTCxHQUFpQjdlLFFBQVEsQ0FBQ2hpQyxDQUFELENBQXpCO0FBQ0E7O0FBRURtaEQsUUFBTSxDQUFDbmhELENBQUQsRUFBSTtBQUVUQSxLQUFDLENBQUNDLGNBQUY7QUFDQSxVQUFNMGxELEtBQUssR0FBRyxLQUFLcDlDLE9BQW5CO0FBRUEsUUFBSW85QyxLQUFLLENBQUNqb0QsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUV4QixTQUFLMHRCLFdBQUwsQ0FBaUJwckIsQ0FBakIsRUFBb0IsS0FBS3lrQyxLQUF6QjtBQUVBLFFBQUltRCxHQUFKO0FBRUEsUUFBSWdlLFVBQUo7QUFDQSxRQUFJQyxZQUFZLEdBQUcsU0FBbkI7QUFDQSxRQUFJOWQsSUFBSjs7QUFFQSxTQUFLLElBQUl0UyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHa3dCLEtBQUssQ0FBQ2pvRCxNQUExQixFQUFrQyszQixDQUFDLEVBQW5DLEVBQXVDO0FBQ3RDLFlBQU1qSyxJQUFJLEdBQUdtNkIsS0FBSyxDQUFDbHdCLENBQUQsQ0FBbEI7QUFDQSxZQUFNeEUsTUFBTSxHQUFHekYsSUFBSSxDQUFDczZCLFdBQXBCO0FBR0EsVUFBSSxDQUFDNzBCLE1BQUwsRUFBYTs7QUFFYixXQUFLLElBQUkxeEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzB4QixNQUFNLENBQUN2ekIsTUFBM0IsRUFBbUM2QixDQUFDLEVBQXBDLEVBQXdDO0FBR3ZDLGNBQU1WLElBQUksR0FBR295QixNQUFNLENBQUMxeEIsQ0FBRCxDQUFuQjtBQUdBaVMsWUFBSSxDQUFDMkssUUFBTCxDQUFjNG9DLFFBQWQsRUFBd0J2NUIsSUFBSSxDQUFDNVIsT0FBTCxJQUFnQkwsY0FBeEMsRUFBd0QxYSxJQUFJLENBQUN1ZCxNQUE3RDtBQUdBd3JCLFdBQUcsR0FBR2dhLGlFQUFtQixDQUFDLEtBQUtkLEdBQU4sRUFBV2ppRCxJQUFJLENBQUMybkIsS0FBaEIsRUFBdUJ1K0IsUUFBdkIsRUFBaUMsSUFBakMsQ0FBekI7O0FBR0EsWUFBSW5kLEdBQUosRUFBUztBQUNSRyxjQUFJLEdBQUc4VCw0REFBYyxDQUFDLEtBQUtpRixHQUFMLENBQVNuMUIsTUFBVCxDQUFnQixDQUFoQixDQUFELEVBQXFCLEtBQUttMUIsR0FBTCxDQUFTbjFCLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBckIsRUFBeUMsS0FBS20xQixHQUFMLENBQVNuMUIsTUFBVCxDQUFnQixDQUFoQixDQUF6QyxFQUE2RGljLEdBQUcsQ0FBQyxDQUFELENBQWhFLEVBQXFFQSxHQUFHLENBQUMsQ0FBRCxDQUF4RSxFQUE2RUEsR0FBRyxDQUFDLENBQUQsQ0FBaEYsQ0FBckI7O0FBRUEsY0FBSUcsSUFBSSxHQUFHOGQsWUFBWCxFQUF5QjtBQUN4QkEsd0JBQVksR0FBRzlkLElBQWY7QUFDQTZkLHNCQUFVLEdBQUcsQ0FBQyxHQUFHaGUsR0FBSixDQUFiO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsUUFBSWdlLFVBQUosRUFBZ0I7QUFDZixXQUFLOUssS0FBTCxDQUFXdUosYUFBWCxDQUF5QnVCLFVBQXpCO0FBQ0E7QUFDRDs7QUFFRHhFLE1BQUksQ0FBQ3BoRCxDQUFELEVBQUk7QUFDUEEsS0FBQyxDQUFDQyxjQUFGO0FBRUEsVUFBTWpDLENBQUMsR0FBR2drQyxRQUFRLENBQUNoaUMsQ0FBRCxDQUFsQjtBQUNBLFVBQU0rbkMsSUFBSSxHQUFHNFosMERBQVksQ0FBQzNqRCxDQUFDLENBQUNnWCxDQUFILEVBQU1oWCxDQUFDLENBQUNzZCxDQUFSLEVBQVcsS0FBS3VsQyxTQUFMLENBQWU3ckMsQ0FBMUIsRUFBNkIsS0FBSzZyQyxTQUFMLENBQWV2bEMsQ0FBNUMsQ0FBekI7O0FBRUEsUUFBSXlzQixJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBQ2IsV0FBSytTLEtBQUwsQ0FBV3NKLGdCQUFYLENBQTRCLENBQUMsR0FBRyxLQUFLdEosS0FBTCxDQUFXa0gsYUFBZixDQUE1QjtBQUNBLFdBQUtvRCxVQUFMLEdBQWtCLENBQUMsR0FBRyxLQUFLdEssS0FBTCxDQUFXa0gsYUFBZixDQUFsQixDQUZhLENBR1Y7O0FBQ0EsV0FBS2xILEtBQUwsQ0FBVzU0QyxjQUFYLENBQTBCUyxNQUExQixHQUFtQyxDQUFDLEdBQUcsS0FBS200QyxLQUFMLENBQVdrSCxhQUFmLENBQW5DO0FBQ0g7QUFDRDs7QUFFRHFELGdCQUFjLEdBQUc7QUFDaEJwSSxtREFBTSxDQUFDSyxNQUFQLENBQWNDLE1BQWQsQ0FBcUJwOUMsT0FBckIsQ0FBNkI0bEQsS0FBSyxJQUFJO0FBQ3JDLFdBQUtDLFFBQUwsQ0FBY0QsS0FBZDtBQUNBLEtBRkQ7QUFHQTs7QUFFREMsVUFBUSxDQUFDRCxLQUFELEVBQVE7QUFFZixTQUFLZCxRQUFMO0FBQ0EsVUFBTWdCLEdBQUcsR0FBR2xsRCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjtBQUNBLFVBQU1nb0MsQ0FBQyxHQUFHam9DLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixHQUF2QixDQUFWOztBQUNBZ29DLEtBQUMsQ0FBQ2tULE9BQUYsR0FBWSxNQUFNLEtBQUtnSixZQUFMLENBQWtCL0ksUUFBbEIsQ0FBMkI0SixLQUEzQixDQUFsQixDQUxlLENBTWY7OztBQUNBL2MsS0FBQyxDQUFDa2QsU0FBRixHQUFjSCxLQUFLLENBQUMxSixLQUFwQjtBQUVBLFVBQU04SixFQUFFLEdBQUdwbEQsUUFBUSxDQUFDQyxhQUFULENBQXVCLEdBQXZCLENBQVg7QUFDQW1sRCxNQUFFLENBQUNsSyxTQUFILEdBQWUsUUFBZjs7QUFDQWtLLE1BQUUsQ0FBQ2pLLE9BQUgsR0FBYSxNQUFNO0FBQ2xCLFdBQUt6dUIsU0FBTCxDQUFlOU4sV0FBZixDQUEyQnNtQyxHQUEzQjtBQUNBLFdBQUtkLGFBQUwsQ0FBbUJoSixRQUFuQixDQUE0QjRKLEtBQTVCO0FBQ0EsS0FIRDs7QUFJQUksTUFBRSxDQUFDRCxTQUFILEdBQWUsR0FBZjtBQUVBRCxPQUFHLENBQUMxSixXQUFKLENBQWdCdlQsQ0FBaEI7QUFDQWlkLE9BQUcsQ0FBQzFKLFdBQUosQ0FBZ0I0SixFQUFoQjtBQUNBLFNBQUsxNEIsU0FBTCxDQUFlOHVCLFdBQWYsQ0FBMkIwSixHQUEzQjtBQUNBOztBQTNKaUI7O0FBOEpKLG1FQUFJakIsWUFBSixFQUFmLEU7Ozs7Ozs7Ozs7OztBQ3RMQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNb0IsVUFBVSxHQUFHLENBQUNDLFdBQUQsRUFBY2p1QixNQUFkLEVBQXNCbDdCLEVBQXRCLEVBQTBCZ2hELE1BQU0sR0FBRyxLQUFuQyxFQUEwQ3ByQyxJQUExQyxLQUFtRDtBQUNyRXV6QyxhQUFXLENBQUNDLFFBQVosQ0FBcUJsdUIsTUFBckIsRUFBNkJsN0IsRUFBN0IsRUFBaUNxcEQsUUFBakMsQ0FBMEMsTUFBTTtBQUMvQ0MsY0FBVSxDQUFDcHVCLE1BQUQsRUFBU2w3QixFQUFULEVBQWFnaEQsTUFBYixDQUFWO0FBQ0EsR0FGRCxFQUVHcHJDLElBRkgsQ0FFUUEsSUFBSSxJQUFJNVYsRUFGaEI7QUFHQSxDQUpEOztBQU1BLE1BQU1zcEQsVUFBVSxHQUFHLENBQUNwdUIsTUFBRCxFQUFTbDdCLEVBQVQsRUFBYWdoRCxNQUFNLEdBQUcsS0FBdEIsS0FBZ0M7QUFDbEQsTUFBSTlsQixNQUFNLENBQUNsN0IsRUFBRCxDQUFOLENBQVd5SixPQUFYLENBQW1CLEdBQW5CLElBQTBCLENBQUMsQ0FBL0IsRUFBa0M7QUFDakMsVUFBTTgvQyxNQUFNLEdBQUdDLDhDQUFNLENBQUN0dUIsTUFBTSxDQUFDbDdCLEVBQUQsQ0FBUCxDQUFyQjtBQUVBazdCLFVBQU0sQ0FBQ2w3QixFQUFELENBQU4sR0FBYSxDQUFDdXBELE1BQU0sQ0FBQ0UsR0FBUixFQUFhRixNQUFNLENBQUNHLEtBQXBCLEVBQTJCSCxNQUFNLENBQUNJLElBQWxDLENBQWI7QUFDQTs7QUFDRCxNQUFJM0ksTUFBSixFQUFZO0FBQ1gyRyxxREFBUSxDQUFDM0csTUFBVDtBQUNBLEdBRkQsTUFFTztBQUNOMkcscURBQVEsQ0FBQ3JHLE9BQVQ7QUFDQTtBQUNELENBWEQ7O0FBY0EsTUFBTXNHLFdBQVcsR0FBSWhLLEtBQUQsSUFBVztBQUU5QixRQUFNZ00sUUFBUSxHQUFHO0FBQ2hCQyxRQUFJLEVBQUMsTUFBTTtBQUNWQyw0REFBUSxDQUFDL0osK0NBQUQsRUFBUyxVQUFULENBQVI7QUFDQTtBQUhlLEdBQWpCO0FBTUE2QixZQUFVLENBQUMsTUFBSztBQUNmOzs7QUFHQSxVQUFNbUksT0FBTyxHQUFHO0FBQ2ZDLGlCQUFXLEVBQUMsTUFBTTtBQUNqQnBNLGFBQUssQ0FBQzU0QyxjQUFOLENBQXFCUyxNQUFyQixHQUE4QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUE5QjtBQUNBLE9BSGM7QUFJZndrRCxnQkFBVSxFQUFDLE1BQU07QUFDaEJILDhEQUFRLENBQUMvSiwrQ0FBTSxDQUFDSyxNQUFQLENBQWNDLE1BQWYsRUFBdUIsYUFBdkIsQ0FBUjtBQUNBLE9BTmM7QUFPZnlJLGNBQVEsRUFBRSxNQUFNO0FBRWYsWUFBSWhCLHFEQUFZLENBQUNJLFVBQWIsS0FBNEIsSUFBaEMsRUFBc0M7QUFFdEMsY0FBTS9JLEtBQUssR0FBRytLLE1BQU0sQ0FBQyxPQUFELEVBQVUsRUFBVixDQUFwQjtBQUVBLFlBQUkvSyxLQUFLLEtBQUssSUFBZCxFQUFvQjtBQUVwQixjQUFNOXJDLE1BQU0sR0FBR3VxQyxLQUFLLENBQUM1NEMsY0FBTixDQUFxQmEsY0FBcEM7QUFDQSxjQUFNSixNQUFNLEdBQUdxaUQscURBQVksQ0FBQ0ksVUFBNUI7QUFDQSxjQUFNajJDLElBQUksR0FBRztBQUNaM00sWUFBRSxFQUFFczRDLEtBQUssQ0FBQzU0QyxjQUFOLENBQXFCazVCLEdBQXJCLENBQXlCdDVCLEtBRGpCO0FBRVpXLFlBQUUsRUFBRXE0QyxLQUFLLENBQUM1NEMsY0FBTixDQUFxQm01QixHQUFyQixDQUF5QnY1QixLQUZqQjtBQUdaYSxnQkFBTSxFQUFFbTRDLEtBQUssQ0FBQzU0QyxjQUFOLENBQXFCUyxNQUhqQjtBQUlaeTFCLGdCQUFNLEVBQUU0c0IscURBQVksQ0FBQ0ksVUFKVDtBQUtaNzBDLGdCQUxZO0FBTVpxckMsY0FBSSxFQUFFZCxLQUFLLENBQUM1NEMsY0FBTixDQUFxQkssTUFBckIsQ0FBNEJULEtBTnRCO0FBT1p1NkM7QUFQWSxTQUFiO0FBVUFZLHVEQUFNLENBQUNLLE1BQVAsQ0FBY0MsTUFBZCxDQUFxQmwvQyxJQUFyQixDQUEwQjhRLElBQTFCO0FBRUE2MUMsNkRBQVksQ0FBQ2dCLFFBQWIsQ0FBc0I3MkMsSUFBdEI7QUFDQTAxQyx5REFBUSxDQUFDckcsT0FBVDtBQUNBd0csNkRBQVksQ0FBQ0ksVUFBYixHQUEwQixJQUExQjtBQUNBO0FBaENjLEtBQWhCO0FBa0NBLFVBQU1pQyxPQUFPLEdBQUdqbUQsR0FBRyxDQUFDa21ELFNBQUosQ0FBYyxRQUFkLENBQWhCO0FBQ0FELFdBQU8sQ0FBQ2htRCxHQUFSLENBQVk0N0MsK0NBQU0sQ0FBQ0ssTUFBbkIsRUFBMkIsUUFBM0IsRUFBcUNpSixRQUFyQyxDQUE4QzFCLGlEQUFRLENBQUMzRyxNQUF2RDtBQUdBLFVBQU1xSixNQUFNLEdBQUdubUQsR0FBRyxDQUFDa21ELFNBQUosQ0FBYyxhQUFkLENBQWY7QUFDQUMsVUFBTSxDQUFDbG1ELEdBQVAsQ0FBVzQ3QywrQ0FBTSxDQUFDOTlDLEtBQVAsQ0FBYStQLEtBQXhCLEVBQStCLFFBQS9CLEVBQXlDcTNDLFFBQXpDLENBQWtEMUIsaURBQVEsQ0FBQzNHLE1BQTNEO0FBQ0FxSixVQUFNLENBQUNsbUQsR0FBUCxDQUFXNDdDLCtDQUFNLENBQUM5OUMsS0FBUCxDQUFhK1AsS0FBYixDQUFtQm11QyxHQUE5QixFQUFtQyxHQUFuQyxFQUF3QyxDQUF4QyxFQUEyQ3B0QyxJQUFJLENBQUNvUixFQUFMLEdBQVUsQ0FBckQsRUFBd0RtbUMsSUFBeEQsQ0FBNkQsR0FBN0QsRUFBa0UxMEMsSUFBbEUsQ0FBdUUsT0FBdkUsRUFBZ0Z5ekMsUUFBaEYsQ0FBeUYxQixpREFBUSxDQUFDckcsT0FBbEc7QUFDQStJLFVBQU0sQ0FBQ2xtRCxHQUFQLENBQVc0N0MsK0NBQU0sQ0FBQzk5QyxLQUFQLENBQWErUCxLQUFiLENBQW1CbXVDLEdBQTlCLEVBQW1DLEdBQW5DLEVBQXdDLENBQXhDLEVBQTJDcHRDLElBQUksQ0FBQ29SLEVBQUwsR0FBVSxDQUFyRCxFQUF3RG1tQyxJQUF4RCxDQUE2RCxHQUE3RCxFQUFrRTEwQyxJQUFsRSxDQUF1RSxPQUF2RSxFQUFnRnl6QyxRQUFoRixDQUF5RjFCLGlEQUFRLENBQUNyRyxPQUFsRztBQUNBK0ksVUFBTSxDQUFDbG1ELEdBQVAsQ0FBVzQ3QywrQ0FBTSxDQUFDOTlDLEtBQVAsQ0FBYStQLEtBQWIsQ0FBbUJtdUMsR0FBOUIsRUFBbUMsR0FBbkMsRUFBd0MsQ0FBeEMsRUFBMkNwdEMsSUFBSSxDQUFDb1IsRUFBTCxHQUFVLENBQXJELEVBQXdEbW1DLElBQXhELENBQTZELEdBQTdELEVBQWtFMTBDLElBQWxFLENBQXVFLE9BQXZFLEVBQWdGeXpDLFFBQWhGLENBQXlGMUIsaURBQVEsQ0FBQ3JHLE9BQWxHO0FBRUErSSxVQUFNLENBQUNsbUQsR0FBUCxDQUFXNDdDLCtDQUFNLENBQUM5OUMsS0FBUCxDQUFhK1AsS0FBYixDQUFtQitjLEtBQTlCLEVBQXFDLEdBQXJDLEVBQTBDLENBQTFDLEVBQTZDLENBQTdDLEVBQWdEdTdCLElBQWhELENBQXFELEtBQXJELEVBQTREMTBDLElBQTVELENBQWlFLFNBQWpFLEVBQTRFeXpDLFFBQTVFLENBQXFGMUIsaURBQVEsQ0FBQ3JHLE9BQTlGO0FBQ0ErSSxVQUFNLENBQUNsbUQsR0FBUCxDQUFXNDdDLCtDQUFNLENBQUM5OUMsS0FBUCxDQUFhK1AsS0FBYixDQUFtQitjLEtBQTlCLEVBQXFDLEdBQXJDLEVBQTBDLENBQTFDLEVBQTZDLENBQTdDLEVBQWdEdTdCLElBQWhELENBQXFELEtBQXJELEVBQTREMTBDLElBQTVELENBQWlFLFNBQWpFLEVBQTRFeXpDLFFBQTVFLENBQXFGMUIsaURBQVEsQ0FBQ3JHLE9BQTlGO0FBQ0ErSSxVQUFNLENBQUNsbUQsR0FBUCxDQUFXNDdDLCtDQUFNLENBQUM5OUMsS0FBUCxDQUFhK1AsS0FBYixDQUFtQitjLEtBQTlCLEVBQXFDLEdBQXJDLEVBQTBDLENBQTFDLEVBQTZDLENBQTdDLEVBQWdEdTdCLElBQWhELENBQXFELEtBQXJELEVBQTREMTBDLElBQTVELENBQWlFLFNBQWpFLEVBQTRFeXpDLFFBQTVFLENBQXFGMUIsaURBQVEsQ0FBQ3JHLE9BQTlGO0FBRUErSSxVQUFNLENBQUNsbUQsR0FBUCxDQUFXNDdDLCtDQUFNLENBQUM5OUMsS0FBUCxDQUFhK1AsS0FBYixDQUFtQm9TLEdBQTlCLEVBQW1DLEdBQW5DLEVBQXdDLENBQUMsQ0FBekMsRUFBNEMsQ0FBNUMsRUFBK0NrbUMsSUFBL0MsQ0FBb0QsSUFBcEQsRUFBMEQxMEMsSUFBMUQsQ0FBK0QsT0FBL0QsRUFBd0V5ekMsUUFBeEUsQ0FBaUYxQixpREFBUSxDQUFDckcsT0FBMUY7QUFDQStJLFVBQU0sQ0FBQ2xtRCxHQUFQLENBQVc0N0MsK0NBQU0sQ0FBQzk5QyxLQUFQLENBQWErUCxLQUFiLENBQW1Cb1MsR0FBOUIsRUFBbUMsR0FBbkMsRUFBd0MsQ0FBQyxHQUF6QyxFQUE4QyxHQUE5QyxFQUFtRGttQyxJQUFuRCxDQUF3RCxJQUF4RCxFQUE4RDEwQyxJQUE5RCxDQUFtRSxPQUFuRSxFQUE0RXl6QyxRQUE1RSxDQUFxRjFCLGlEQUFRLENBQUNyRyxPQUE5RjtBQUNBK0ksVUFBTSxDQUFDbG1ELEdBQVAsQ0FBVzQ3QywrQ0FBTSxDQUFDOTlDLEtBQVAsQ0FBYStQLEtBQWIsQ0FBbUJvUyxHQUE5QixFQUFtQyxHQUFuQyxFQUF3QyxDQUFDLENBQXpDLEVBQTRDLENBQTVDLEVBQStDa21DLElBQS9DLENBQW9ELElBQXBELEVBQTBEMTBDLElBQTFELENBQStELE9BQS9ELEVBQXdFeXpDLFFBQXhFLENBQWlGMUIsaURBQVEsQ0FBQ3JHLE9BQTFGO0FBRUEsVUFBTXhnRCxDQUFDLEdBQUc7QUFBRXlwRCxtQkFBYSxFQUFFLE1BQU0zTSxLQUFLLENBQUM1NEMsY0FBTixDQUFxQnloQyxJQUFyQixDQUEwQixDQUFDbVgsS0FBSyxDQUFDNTRDLGNBQU4sQ0FBcUI2Z0MsV0FBaEQ7QUFBdkIsS0FBVjtBQUNBd2tCLFVBQU0sQ0FBQ2xtRCxHQUFQLENBQVdyRCxDQUFYLEVBQWMsZUFBZDs7QUFFQSxRQUFJaS9DLCtDQUFNLENBQUNLLE1BQVAsQ0FBY2pDLE1BQWxCLEVBQTBCO0FBRXpCMkosMkRBQVksQ0FBQ3JuRCxJQUFiLENBQWtCbTlDLEtBQWxCLEVBQXlCLENBQUNBLEtBQUssQ0FBQzhJLE9BQVAsQ0FBekI7QUFDQXlELGFBQU8sQ0FBQ2htRCxHQUFSLENBQVk0bEQsT0FBWixFQUFxQixVQUFyQixFQUFpQ24wQyxJQUFqQyxDQUFzQyxXQUF0QztBQUNBdTBDLGFBQU8sQ0FBQ2htRCxHQUFSLENBQVk0bEQsT0FBWixFQUFxQixhQUFyQixFQUFvQ24wQyxJQUFwQyxDQUF5QyxjQUF6QztBQUNBdTBDLGFBQU8sQ0FBQ2htRCxHQUFSLENBQVk0bEQsT0FBWixFQUFxQixZQUFyQixFQUFtQ24wQyxJQUFuQyxDQUF3QyxNQUF4QztBQUVBa3lDLDJEQUFZLENBQUNHLGFBQWIsQ0FBMkI5akQsR0FBM0IsQ0FBZ0NxbUQsRUFBRCxJQUFRO0FBQ3RDLGNBQU1DLE9BQU8sR0FBRzFLLCtDQUFNLENBQUNLLE1BQVAsQ0FBY0MsTUFBZCxDQUFxQjUyQyxPQUFyQixDQUE2QitnRCxFQUE3QixDQUFoQjtBQUNDekssdURBQU0sQ0FBQ0ssTUFBUCxDQUFjQyxNQUFkLENBQXFCdHZCLE1BQXJCLENBQTRCMDVCLE9BQTVCLEVBQXFDLENBQXJDO0FBQ0E5Qyx5REFBUSxDQUFDckcsT0FBVDtBQUNELE9BSkQ7QUFNQXdHLDJEQUFZLENBQUNFLFlBQWIsQ0FBMEI3akQsR0FBMUIsQ0FBK0JxbUQsRUFBRCxJQUFRO0FBQ3JDNU0sYUFBSyxDQUFDNTRDLGNBQU4sQ0FBcUJNLEVBQXJCLENBQXdCaUIsS0FBeEIsQ0FBOEJpa0QsRUFBRSxDQUFDbGxELEVBQWpDO0FBQ0FzNEMsYUFBSyxDQUFDNTRDLGNBQU4sQ0FBcUJPLEVBQXJCLENBQXdCZ0IsS0FBeEIsQ0FBOEJpa0QsRUFBRSxDQUFDamxELEVBQWpDO0FBQ0FxNEMsYUFBSyxDQUFDNTRDLGNBQU4sQ0FBcUJLLE1BQXJCLENBQTRCa0IsS0FBNUIsQ0FBa0Npa0QsRUFBRSxDQUFDOUwsSUFBckM7QUFDQWQsYUFBSyxDQUFDNTRDLGNBQU4sQ0FBcUJTLE1BQXJCLEdBQThCK2tELEVBQUUsQ0FBQy9rRCxNQUFqQztBQUNBLE9BTEQ7QUFPQTtBQUVEOzs7OztBQUlBLFVBQU1pbEQsb0JBQW9CLEdBQUc7QUFDNUI1eUMsT0FBQyxFQUFFaW9DLCtDQUFNLENBQUNVLG1CQUFQLENBQTJCLENBQTNCLENBRHlCO0FBRTVCcmlDLE9BQUMsRUFBRTJoQywrQ0FBTSxDQUFDVSxtQkFBUCxDQUEyQixDQUEzQixDQUZ5QjtBQUc1QjU3QixPQUFDLEVBQUVrN0IsK0NBQU0sQ0FBQ1UsbUJBQVAsQ0FBMkIsQ0FBM0I7QUFIeUIsS0FBN0I7QUFNQSxVQUFNa0ssU0FBUyxHQUFHem1ELEdBQUcsQ0FBQ2ttRCxTQUFKLENBQWMsY0FBZCxDQUFsQjtBQUNBTyxhQUFTLENBQUN4bUQsR0FBVixDQUFjNDdDLCtDQUFkLEVBQXNCLGFBQXRCLEVBQXFDc0osUUFBckMsQ0FBOEMxQixpREFBUSxDQUFDckcsT0FBdkQ7QUFDQXFKLGFBQVMsQ0FBQ3htRCxHQUFWLENBQWM0N0MsK0NBQU0sQ0FBQzF1QixXQUFyQixFQUFrQyxNQUFsQyxFQUEwQyxHQUExQyxFQUErQyxFQUEvQyxFQUFtRGc0QixRQUFuRCxDQUE0RCxNQUFNO0FBQ2pFekwsV0FBSyxDQUFDcUksYUFBTixDQUFvQjVvQyxPQUFwQixDQUE0QjBpQywrQ0FBTSxDQUFDMXVCLFdBQVAsQ0FBbUJubkIsSUFBL0M7QUFDQXk5Qyx1REFBUSxDQUFDckcsT0FBVDtBQUNBLEtBSEQ7QUFLQTRILGNBQVUsQ0FBQ3lCLFNBQUQsRUFBWTVLLCtDQUFNLENBQUNZLE1BQW5CLEVBQTJCLE9BQTNCLEVBQW9DLEtBQXBDLEVBQTJDLGNBQTNDLENBQVY7QUFFQWdLLGFBQVMsQ0FBQ3htRCxHQUFWLENBQWM0N0MsK0NBQU0sQ0FBQzF1QixXQUFyQixFQUFrQyxNQUFsQyxFQUEwQyxDQUExQyxFQUE2QyxFQUE3QyxFQUFpRGk1QixJQUFqRCxDQUFzRCxHQUF0RCxFQUEyRGpCLFFBQTNELENBQW9FLE1BQU07QUFDekV6TCxXQUFLLENBQUNxSSxhQUFOLENBQW9CdkQsaUJBQXBCO0FBQ0FpRix1REFBUSxDQUFDckcsT0FBVDtBQUNBLEtBSEQ7QUFLQXFKLGFBQVMsQ0FBQ3htRCxHQUFWLENBQWM0N0MsK0NBQU0sQ0FBQzF1QixXQUFyQixFQUFrQyxLQUFsQyxFQUF5QyxDQUF6QyxFQUE0QyxFQUE1QyxFQUFnRGk1QixJQUFoRCxDQUFxRCxHQUFyRCxFQUEwRGpCLFFBQTFELENBQW1FLE1BQU07QUFDeEV6TCxXQUFLLENBQUNxSSxhQUFOLENBQW9CdkQsaUJBQXBCO0FBQ0FpRix1REFBUSxDQUFDckcsT0FBVDtBQUNBLEtBSEQ7QUFLQSxVQUFNc0osS0FBSyxHQUFHLENBQWQ7QUFFQUQsYUFBUyxDQUFDeG1ELEdBQVYsQ0FBY3VtRCxvQkFBZCxFQUFvQyxHQUFwQyxFQUF5QyxDQUFDRSxLQUExQyxFQUFpREEsS0FBakQsRUFBd0R2QixRQUF4RCxDQUFpRSxNQUFNO0FBQ3RFdEoscURBQU0sQ0FBQ1UsbUJBQVAsQ0FBMkIsQ0FBM0IsSUFBZ0NpSyxvQkFBb0IsQ0FBQzV5QyxDQUFyRDtBQUNBOGxDLFdBQUssQ0FBQ3FJLGFBQU4sQ0FBb0IxRCxpQkFBcEI7QUFDQW9GLHVEQUFRLENBQUNyRyxPQUFUO0FBQ0EsS0FKRDtBQU1BcUosYUFBUyxDQUFDeG1ELEdBQVYsQ0FBY3VtRCxvQkFBZCxFQUFvQyxHQUFwQyxFQUF5QyxDQUF6QyxFQUE0QyxFQUE1QyxFQUFnRHJCLFFBQWhELENBQXlELE1BQU07QUFDOUR0SixxREFBTSxDQUFDVSxtQkFBUCxDQUEyQixDQUEzQixJQUFnQ2lLLG9CQUFvQixDQUFDdHNDLENBQXJEO0FBQ0F3L0IsV0FBSyxDQUFDcUksYUFBTixDQUFvQjFELGlCQUFwQjtBQUNBb0YsdURBQVEsQ0FBQ3JHLE9BQVQ7QUFDQSxLQUpEO0FBTUFxSixhQUFTLENBQUN4bUQsR0FBVixDQUFjdW1ELG9CQUFkLEVBQW9DLEdBQXBDLEVBQXlDLENBQUNFLEtBQTFDLEVBQWlEQSxLQUFqRCxFQUF3RHZCLFFBQXhELENBQWlFLE1BQU07QUFDdEV0SixxREFBTSxDQUFDVSxtQkFBUCxDQUEyQixDQUEzQixJQUFnQ2lLLG9CQUFvQixDQUFDN2xDLENBQXJEO0FBQ0ErNEIsV0FBSyxDQUFDcUksYUFBTixDQUFvQjFELGlCQUFwQjtBQUNBb0YsdURBQVEsQ0FBQ3JHLE9BQVQ7QUFDQSxLQUpEO0FBTUE7Ozs7QUFHQSxVQUFNdUosSUFBSSxHQUFHO0FBQ1p2SyxVQUFJLEVBQUUsTUFBTTtBQUFFMUMsYUFBSyxDQUFDMEMsSUFBTjtBQUFjLE9BRGhCO0FBRVpvRixjQUFRLEVBQUUsTUFBTTtBQUNmOUgsYUFBSyxDQUFDOEgsUUFBTjtBQUNBO0FBSlcsS0FBYjtBQU1BeGhELE9BQUcsQ0FBQ0MsR0FBSixDQUFRMG1ELElBQVIsRUFBYyxNQUFkLEVBQXNCajFDLElBQXRCLENBQTJCLFVBQTNCO0FBQ0ExUixPQUFHLENBQUNDLEdBQUosQ0FBUTBtRCxJQUFSLEVBQWMsVUFBZCxFQUEwQmoxQyxJQUExQixDQUErQixrQkFBL0I7QUFHQTFSLE9BQUcsQ0FBQ0MsR0FBSixDQUFRNDdDLCtDQUFNLENBQUNDLFdBQWYsRUFBNEIsT0FBNUIsRUFBcUMsR0FBckMsRUFBMEMsQ0FBMUMsRUFBNkNzSyxJQUE3QyxDQUFrRCxHQUFsRCxFQUF1RDEwQyxJQUF2RCxDQUE0RCxjQUE1RDtBQUNBMVIsT0FBRyxDQUFDQyxHQUFKLENBQVE0N0MsK0NBQU0sQ0FBQ0MsV0FBZixFQUE0QixPQUE1QixFQUFxQyxDQUFyQyxFQUF3QyxDQUF4QyxFQUEyQ3NLLElBQTNDLENBQWdELElBQWhELEVBQXNEMTBDLElBQXRELENBQTJELGNBQTNEO0FBQ0FzekMsY0FBVSxDQUFDaGxELEdBQUQsRUFBTTY3QywrQ0FBTSxDQUFDQyxXQUFiLEVBQTBCLE9BQTFCLEVBQW1DLEtBQW5DLEVBQTBDLGNBQTFDLENBQVY7QUFDQTk3QyxPQUFHLENBQUNDLEdBQUosQ0FBUTQ3QywrQ0FBTSxDQUFDTyxJQUFmLEVBQXFCLGdCQUFyQixFQUF1QzFxQyxJQUF2QyxDQUE0QyxvQkFBNUM7QUFFQSxVQUFNazFDLE1BQU0sR0FBRzVtRCxHQUFHLENBQUNrbUQsU0FBSixDQUFjLE9BQWQsQ0FBZjtBQUNBVSxVQUFNLENBQUMzbUQsR0FBUCxDQUFXNDdDLCtDQUFYLEVBQW1CLFVBQW5CLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDdUssSUFBckMsQ0FBMEMsSUFBMUM7QUFFQXBtRCxPQUFHLENBQUNDLEdBQUosQ0FBUXlsRCxRQUFSLEVBQWtCLE1BQWxCLEVBQTBCaDBDLElBQTFCLENBQStCLGVBQS9CO0FBQ0ExUixPQUFHLENBQUNDLEdBQUosQ0FBUXdqRCxpREFBUixFQUFrQixPQUFsQixFQUEyQi94QyxJQUEzQixDQUFnQyxlQUFoQztBQUVBLEdBMUpTLEVBMEpQLEdBMUpPLENBQVY7QUEySkEsQ0FuS0Q7O0FBc0tlZ3lDLDBFQUFmLEU7Ozs7Ozs7Ozs7OztBQ2xNQTtBQUFBO0FBQUEsTUFBTS9DLEtBQUssR0FBRyxDQUFDakgsS0FBRCxFQUFRcnRCLFNBQVIsS0FBc0I7QUFDbEMsUUFBTXc2QixHQUFHLEdBQUdsbkQsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQVo7QUFDQWluRCxLQUFHLENBQUNoTSxTQUFKLEdBQWdCLEtBQWhCO0FBRUEsUUFBTWlNLEVBQUUsR0FBR25uRCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBWDtBQUNBa25ELElBQUUsQ0FBQ2hDLFNBQUgsR0FBZSxNQUFmOztBQUNBZ0MsSUFBRSxDQUFDaE0sT0FBSCxHQUFhLE1BQU07QUFBRXBCLFNBQUssQ0FBQzBDLElBQU47QUFBYyxHQUFuQzs7QUFDQXlLLEtBQUcsQ0FBQzFMLFdBQUosQ0FBZ0IyTCxFQUFoQjtBQUVBLFFBQU0vQixFQUFFLEdBQUdwbEQsUUFBUSxDQUFDQyxhQUFULENBQXVCLEdBQXZCLENBQVg7QUFDQW1sRCxJQUFFLENBQUNELFNBQUgsR0FBZSxVQUFmOztBQUNBQyxJQUFFLENBQUNqSyxPQUFILEdBQWEsTUFBSTtBQUFFcEIsU0FBSyxDQUFDOEgsUUFBTjtBQUFrQixHQUFyQzs7QUFDQXFGLEtBQUcsQ0FBQzFMLFdBQUosQ0FBZ0I0SixFQUFoQjtBQUNBMTRCLFdBQVMsQ0FBQzh1QixXQUFWLENBQXNCMEwsR0FBdEI7QUFDRCxDQWREOzs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFTyxNQUFNRSxPQUFPLEdBQUcsQ0FBQ2ovQyxLQUFELEVBQVFDLE1BQVIsRUFBZ0JpL0MsS0FBaEIsRUFBdUI5bUMsR0FBdkIsRUFBNEIrN0IsR0FBNUIsS0FBb0M7QUFFMUQsUUFBTXpxQixDQUFDLEdBQUdwaEIsOENBQUksQ0FBQ2dJLE1BQUwsRUFBVjtBQUNBLE1BQUk2akMsR0FBSixFQUFTN3JDLDhDQUFJLENBQUN3SyxNQUFMLENBQVk0VyxDQUFaLEVBQWVBLENBQWYsRUFBa0J5cUIsR0FBbEI7QUFDVCxNQUFJLzdCLEdBQUosRUFBUzlQLDhDQUFJLENBQUM0WCxTQUFMLENBQWV3SixDQUFmLEVBQWtCQSxDQUFsQixFQUFxQnRSLEdBQXJCO0FBQ1QsTUFBSUEsR0FBSixFQUFTOVAsOENBQUksQ0FBQ3lhLEtBQUwsQ0FBVzJHLENBQVgsRUFBY0EsQ0FBZCxFQUFpQixDQUFDMXBCLEtBQUQsRUFBUUMsTUFBUixFQUFnQmkvQyxLQUFoQixDQUFqQjtBQUVSLFFBQU12bUMsSUFBSSxHQUFHeGQsMkNBQUksQ0FBQ3dkLElBQUwsQ0FBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUFiO0FBQ0QsU0FBTztBQUNKaGpCLFFBQUksRUFBRWdqQixJQURGO0FBRUoyRSxTQUFLLEVBQUU2aEMsOERBQWdCLENBQUN4bUMsSUFBRCxDQUZuQjtBQUdKekYsVUFBTSxFQUFFd1c7QUFISixHQUFQO0FBS0EsQ0FiTSxDOzs7Ozs7Ozs7Ozs7QUNMUDtBQUFBO0FBQUE7QUFBQTtBQUVBLElBQUl0ekIsRUFBSjtBQUFRLElBQUlncEQsTUFBSjtBQUFZLElBQUlDLE1BQUo7QUFBWSxJQUMvQnhvQyxJQUQrQjtBQUdoQyxNQUFNeW9DLFVBQVUsR0FBRyxFQUFuQjtBQUNBLE1BQU1DLFVBQVUsR0FBRyxFQUFuQjs7QUFFQSxNQUFNek0sSUFBTixTQUFtQno5Qyw4Q0FBTSxDQUFDNkYsSUFBMUIsQ0FBK0I7QUFDOUI3QyxhQUFXLENBQUNnaUIsUUFBRCxFQUFXNEMsQ0FBWCxFQUFjdWlDLFFBQVEsR0FBR3prRCx5Q0FBRSxDQUFDaTBDLFNBQTVCLEVBQXVDO0FBQ2pENTRDLE1BQUUsR0FBRzJFLHlDQUFMO0FBQ0EsVUFBTXlrRCxRQUFOO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQnhpQyxDQUFyQjtBQUVBLFVBQU15aUMsSUFBSSxHQUFHLENBQ1osQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FEWSxFQUVaLENBQUMsTUFBTSxHQUFQLEVBQVksTUFBTSxHQUFsQixFQUF1QixDQUF2QixDQUZZLEVBR1osQ0FBQyxLQUFLLEdBQU4sRUFBVyxNQUFNLEdBQWpCLEVBQXNCLENBQXRCLENBSFksRUFJWixDQUFDLENBQUQsRUFBSSxNQUFNLEdBQVYsRUFBZSxDQUFmLENBSlksRUFLWixDQUFDLENBQUMsR0FBRCxHQUFPLEdBQVIsRUFBYSxNQUFNLEdBQW5CLEVBQXdCLENBQXhCLENBTFksRUFNWixDQUFDLENBQUMsRUFBRCxHQUFNLEdBQVAsRUFBWSxNQUFNLEdBQWxCLEVBQXVCLENBQXZCLENBTlksQ0FBYjtBQVNBLFNBQUs1b0MsU0FBTCxHQUFpQixFQUFqQjtBQUNBLFNBQUs2b0MsVUFBTCxHQUFrQixFQUFsQjtBQUNBLFNBQUtDLFlBQUwsR0FBb0IsRUFBcEI7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0EsU0FBSzcvQyxLQUFMLEdBQWEsRUFBYjtBQUNBLFNBQUs0c0IsR0FBTCxHQUFXLEVBQVg7QUFDQSxTQUFLa3pCLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQSxTQUFLeHNCLElBQUwsR0FBWSxFQUFaO0FBRUEsU0FBS29zQixJQUFMLEdBQVlybEMsUUFBUSxJQUFJcWxDLElBQXhCO0FBRUEsU0FBS3R4QixJQUFMLENBQVUsSUFBVjtBQUNBOztBQUVEQSxNQUFJLENBQUMyeEIsV0FBVyxHQUFHLElBQWYsRUFBcUI7QUFDeEIsVUFBTXJvQyxDQUFDLEdBQUcsS0FBS2dvQyxJQUFmO0FBRUEsU0FBSzVvQyxTQUFMLENBQWV0aUIsTUFBZixHQUF3QmtqQixDQUFDLENBQUNsakIsTUFBRixHQUFXLENBQW5DO0FBQ0EsU0FBS3FyRCxRQUFMLENBQWNyckQsTUFBZCxHQUF1QmtqQixDQUFDLENBQUNsakIsTUFBRixHQUFXLENBQWxDO0FBRUEsUUFBSXNSLEtBQUssR0FBRyxDQUFaO0FBQ0EsUUFBSWs2QyxNQUFNLEdBQUcsQ0FBYjtBQUVBLFNBQUtGLFFBQUwsQ0FBY3RyRCxNQUFkLEdBQXVCLEtBQUtzaUIsU0FBTCxDQUFldGlCLE1BQXRDO0FBQ0EsU0FBSzgrQixJQUFMLENBQVU5K0IsTUFBVixHQUFtQixLQUFLc2lCLFNBQUwsQ0FBZXRpQixNQUFsQzs7QUFFQSxTQUFLLElBQUk2QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcWhCLENBQUMsQ0FBQ2xqQixNQUF0QixFQUE4QjZCLENBQUMsRUFBL0IsRUFBbUM7QUFDbEMsVUFBSTBwRCxXQUFKLEVBQWlCO0FBQ2hCLGNBQU05aUMsQ0FBQyxHQUFHNW1CLENBQUMsR0FBR3FoQixDQUFDLENBQUNsakIsTUFBaEI7QUFDQSxhQUFLcXJELFFBQUwsQ0FBY0csTUFBTSxFQUFwQixJQUEwQixDQUFDL2lDLENBQUQsQ0FBMUI7QUFDQSxhQUFLNGlDLFFBQUwsQ0FBY0csTUFBTSxFQUFwQixJQUEwQixDQUFDL2lDLENBQUQsQ0FBMUI7QUFDQSxPQUxpQyxDQU9sQzs7O0FBQ0EsV0FBS25HLFNBQUwsQ0FBZWhSLEtBQUssRUFBcEIsSUFBMEI0UixDQUFDLENBQUNyaEIsQ0FBRCxDQUFELENBQUssQ0FBTCxDQUExQjtBQUNBLFdBQUt5Z0IsU0FBTCxDQUFlaFIsS0FBSyxFQUFwQixJQUEwQjRSLENBQUMsQ0FBQ3JoQixDQUFELENBQUQsQ0FBSyxDQUFMLENBQTFCO0FBQ0EsV0FBS3lnQixTQUFMLENBQWVoUixLQUFLLEVBQXBCLElBQTBCNFIsQ0FBQyxDQUFDcmhCLENBQUQsQ0FBRCxDQUFLLENBQUwsQ0FBMUI7QUFFQSxXQUFLeWdCLFNBQUwsQ0FBZWhSLEtBQUssRUFBcEIsSUFBMEI0UixDQUFDLENBQUNyaEIsQ0FBRCxDQUFELENBQUssQ0FBTCxDQUExQjtBQUNBLFdBQUt5Z0IsU0FBTCxDQUFlaFIsS0FBSyxFQUFwQixJQUEwQjRSLENBQUMsQ0FBQ3JoQixDQUFELENBQUQsQ0FBSyxDQUFMLENBQTFCO0FBQ0EsV0FBS3lnQixTQUFMLENBQWVoUixLQUFLLEVBQXBCLElBQTBCNFIsQ0FBQyxDQUFDcmhCLENBQUQsQ0FBRCxDQUFLLENBQUwsQ0FBMUI7QUFDQTs7QUFFRCxTQUFLcWxELE9BQUwsQ0FBYXFFLFdBQWI7QUFDQTs7QUFFRHJFLFNBQU8sQ0FBQ3FFLFdBQUQsRUFBYztBQUNwQixVQUFNRSxTQUFTLEdBQUcsQ0FBQy9yRCxDQUFELEVBQUk2USxDQUFKLEtBQVU7QUFDM0IsWUFBTW03QyxFQUFFLEdBQUdoc0QsQ0FBQyxHQUFHLENBQWY7QUFDQSxZQUFNaXNELEVBQUUsR0FBR3A3QyxDQUFDLEdBQUcsQ0FBZjtBQUVBLGFBQ0MsS0FBSytSLFNBQUwsQ0FBZW9wQyxFQUFmLE1BQXVCLEtBQUtwcEMsU0FBTCxDQUFlcXBDLEVBQWYsQ0FBdkIsSUFDSSxLQUFLcnBDLFNBQUwsQ0FBZW9wQyxFQUFFLEdBQUcsQ0FBcEIsTUFBMkIsS0FBS3BwQyxTQUFMLENBQWVxcEMsRUFBRSxHQUFHLENBQXBCLENBRC9CLElBRUksS0FBS3JwQyxTQUFMLENBQWVvcEMsRUFBRSxHQUFHLENBQXBCLE1BQTJCLEtBQUtwcEMsU0FBTCxDQUFlcXBDLEVBQUUsR0FBRyxDQUFwQixDQUhoQztBQUtBLEtBVEQ7O0FBV0EsVUFBTUMsTUFBTSxHQUFHLENBQUNsc0QsQ0FBRCxFQUFJaXNDLEdBQUosS0FBWTtBQUMxQixVQUFJLENBQUNBLEdBQUwsRUFBVUEsR0FBRyxHQUFHbWYsVUFBTjtBQUVWLFlBQU1ZLEVBQUUsR0FBR2hzRCxDQUFDLEdBQUcsQ0FBZjtBQUVBaXNDLFNBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxLQUFLcnBCLFNBQUwsQ0FBZW9wQyxFQUFmLENBQVQ7QUFDQS9mLFNBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxLQUFLcnBCLFNBQUwsQ0FBZW9wQyxFQUFFLEdBQUcsQ0FBcEIsQ0FBVDtBQUNBL2YsU0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTLEtBQUtycEIsU0FBTCxDQUFlb3BDLEVBQUUsR0FBRyxDQUFwQixDQUFUO0FBQ0EsS0FSRDs7QUFVQSxVQUFNRyxDQUFDLEdBQUcsS0FBS3ZwQyxTQUFMLENBQWV0aUIsTUFBZixHQUF3QixDQUFsQztBQUVBLFFBQUlzUixLQUFLLEdBQUcsQ0FBWjtBQUNBLFFBQUl3NkMsTUFBTSxHQUFHLENBQWI7O0FBRUEsUUFBSUwsU0FBUyxDQUFDLENBQUQsRUFBSUksQ0FBQyxHQUFHLENBQVIsQ0FBYixFQUF5QjtBQUN4QkQsWUFBTSxDQUFDQyxDQUFDLEdBQUcsQ0FBTCxDQUFOO0FBQ0EsS0FGRCxNQUVPO0FBQ05ELFlBQU0sQ0FBQyxDQUFELENBQU47QUFDQTs7QUFFRCxTQUFLTixRQUFMLENBQWNoNkMsS0FBSyxFQUFuQixJQUF5Qnc1QyxVQUFVLENBQUMsQ0FBRCxDQUFuQztBQUNBLFNBQUtRLFFBQUwsQ0FBY2g2QyxLQUFLLEVBQW5CLElBQXlCdzVDLFVBQVUsQ0FBQyxDQUFELENBQW5DO0FBQ0EsU0FBS1EsUUFBTCxDQUFjaDZDLEtBQUssRUFBbkIsSUFBeUJ3NUMsVUFBVSxDQUFDLENBQUQsQ0FBbkM7QUFFQSxTQUFLUSxRQUFMLENBQWNoNkMsS0FBSyxFQUFuQixJQUF5Qnc1QyxVQUFVLENBQUMsQ0FBRCxDQUFuQztBQUNBLFNBQUtRLFFBQUwsQ0FBY2g2QyxLQUFLLEVBQW5CLElBQXlCdzVDLFVBQVUsQ0FBQyxDQUFELENBQW5DO0FBQ0EsU0FBS1EsUUFBTCxDQUFjaDZDLEtBQUssRUFBbkIsSUFBeUJ3NUMsVUFBVSxDQUFDLENBQUQsQ0FBbkM7O0FBRUEsU0FBSyxJQUFJanBELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdncUQsQ0FBcEIsRUFBdUJocUQsQ0FBQyxFQUF4QixFQUE0QjtBQUMzQjtBQUNBK3BELFlBQU0sQ0FBQy9wRCxDQUFELEVBQUlpcEQsVUFBSixDQUFOOztBQUVBLFVBQUlqcEQsQ0FBQyxHQUFHLENBQVIsRUFBVztBQUNWO0FBQ0EsYUFBS2k5QixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBQ0EsYUFBS2hzQixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBQ0EsYUFBS2hzQixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBRUEsYUFBS2hzQixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBQ0EsYUFBS2hzQixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBQ0EsYUFBS2hzQixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBRUEsYUFBS1EsUUFBTCxDQUFjaDZDLEtBQUssRUFBbkIsSUFBeUJ5NUMsVUFBVSxDQUFDLENBQUQsQ0FBbkM7QUFDQSxhQUFLTyxRQUFMLENBQWNoNkMsS0FBSyxFQUFuQixJQUF5Qnk1QyxVQUFVLENBQUMsQ0FBRCxDQUFuQztBQUNBLGFBQUtPLFFBQUwsQ0FBY2g2QyxLQUFLLEVBQW5CLElBQXlCeTVDLFVBQVUsQ0FBQyxDQUFELENBQW5DO0FBRUEsYUFBS08sUUFBTCxDQUFjaDZDLEtBQUssRUFBbkIsSUFBeUJ5NUMsVUFBVSxDQUFDLENBQUQsQ0FBbkM7QUFDQSxhQUFLTyxRQUFMLENBQWNoNkMsS0FBSyxFQUFuQixJQUF5Qnk1QyxVQUFVLENBQUMsQ0FBRCxDQUFuQztBQUNBLGFBQUtPLFFBQUwsQ0FBY2g2QyxLQUFLLEVBQW5CLElBQXlCeTVDLFVBQVUsQ0FBQyxDQUFELENBQW5DO0FBQ0E7O0FBRURBLGdCQUFVLENBQUMsQ0FBRCxDQUFWLEdBQWdCRCxVQUFVLENBQUMsQ0FBRCxDQUExQjtBQUNBQyxnQkFBVSxDQUFDLENBQUQsQ0FBVixHQUFnQkQsVUFBVSxDQUFDLENBQUQsQ0FBMUI7QUFDQUMsZ0JBQVUsQ0FBQyxDQUFELENBQVYsR0FBZ0JELFVBQVUsQ0FBQyxDQUFELENBQTFCO0FBQ0E7O0FBRUQsUUFBSVcsU0FBUyxDQUFDSSxDQUFDLEdBQUcsQ0FBTCxFQUFRLENBQVIsQ0FBYixFQUF5QjtBQUN4QkQsWUFBTSxDQUFDLENBQUQsRUFBSWQsVUFBSixDQUFOO0FBQ0EsS0FGRCxNQUVPO0FBQ05jLFlBQU0sQ0FBQ0MsQ0FBQyxHQUFHLENBQUwsRUFBUWYsVUFBUixDQUFOO0FBQ0E7O0FBRUQsU0FBS2hzQixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBQ0EsU0FBS2hzQixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBQ0EsU0FBS2hzQixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBRUEsU0FBS2hzQixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBQ0EsU0FBS2hzQixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBQ0EsU0FBS2hzQixJQUFMLENBQVVndEIsTUFBTSxFQUFoQixJQUFzQmhCLFVBQVUsQ0FBQyxDQUFELENBQWhDO0FBRUF4NUMsU0FBSyxHQUFHLENBQVI7QUFFQSxTQUFLZ1YsaUJBQUwsQ0FBdUIsS0FBS2hFLFNBQTVCLEVBQXVDLGlCQUF2QyxFQUEwRCxDQUExRDtBQUNBLFNBQUtnRSxpQkFBTCxDQUF1QixLQUFLd1ksSUFBNUIsRUFBa0MsT0FBbEMsRUFBMkMsQ0FBM0M7QUFDQSxTQUFLeFksaUJBQUwsQ0FBdUIsS0FBS2dsQyxRQUE1QixFQUFzQyxXQUF0QyxFQUFtRCxDQUFuRDs7QUFFQSxRQUFJQyxXQUFKLEVBQWlCO0FBQ2hCajZDLFdBQUssR0FBRyxDQUFSO0FBQ0EsV0FBSzhtQixHQUFMLEdBQVcsRUFBWDtBQUNBLFVBQUkzZ0IsQ0FBSjs7QUFDQSxXQUFLLElBQUlsRyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHczZDLENBQXBCLEVBQXVCdDZDLENBQUMsRUFBeEIsRUFBNEI7QUFDM0IsWUFBSSxLQUFLMDVDLGFBQVQsRUFBd0I7QUFDdkJ4ekMsV0FBQyxHQUFHLEtBQUt3ekMsYUFBTCxDQUFtQjE1QyxDQUFDLElBQUlzNkMsQ0FBQyxHQUFHLENBQVIsQ0FBcEIsQ0FBSjtBQUNBLFNBRkQsTUFFTztBQUNOcDBDLFdBQUMsR0FBRyxHQUFKO0FBQ0E7O0FBRUQsYUFBS2pNLEtBQUwsQ0FBVzhGLEtBQUssRUFBaEIsSUFBc0JtRyxDQUF0QjtBQUNBLGFBQUtqTSxLQUFMLENBQVc4RixLQUFLLEVBQWhCLElBQXNCbUcsQ0FBdEI7QUFDQSxhQUFLMmdCLEdBQUwsQ0FBU3ozQixJQUFULENBQWMsQ0FBQzRRLENBQUMsSUFBSXM2QyxDQUFDLEdBQUcsQ0FBUixDQUFGLEVBQWMsQ0FBZCxDQUFkO0FBQ0EsYUFBS3p6QixHQUFMLENBQVN6M0IsSUFBVCxDQUFjLENBQUM0USxDQUFDLElBQUlzNkMsQ0FBQyxHQUFHLENBQVIsQ0FBRixFQUFjLENBQWQsQ0FBZDtBQUNBOztBQUVEdjZDLFdBQUssR0FBRyxDQUFSO0FBQ0EsV0FBSzg1QyxZQUFMLEdBQW9CLEVBQXBCOztBQUNBLFdBQUssSUFBSTc1QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHczZDLENBQUMsR0FBRyxDQUF4QixFQUEyQnQ2QyxDQUFDLEVBQTVCLEVBQWdDO0FBQy9CLGNBQU13NkMsQ0FBQyxHQUFHeDZDLENBQUMsR0FBRyxDQUFkO0FBRUEsYUFBSzY1QyxZQUFMLENBQWtCOTVDLEtBQUssRUFBdkIsSUFBNkJ5NkMsQ0FBN0I7QUFDQSxhQUFLWCxZQUFMLENBQWtCOTVDLEtBQUssRUFBdkIsSUFBNkJ5NkMsQ0FBQyxHQUFHLENBQWpDO0FBQ0EsYUFBS1gsWUFBTCxDQUFrQjk1QyxLQUFLLEVBQXZCLElBQTZCeTZDLENBQUMsR0FBRyxDQUFqQztBQUVBLGFBQUtYLFlBQUwsQ0FBa0I5NUMsS0FBSyxFQUF2QixJQUE2Qnk2QyxDQUFDLEdBQUcsQ0FBakM7QUFDQSxhQUFLWCxZQUFMLENBQWtCOTVDLEtBQUssRUFBdkIsSUFBNkJ5NkMsQ0FBQyxHQUFHLENBQWpDO0FBQ0EsYUFBS1gsWUFBTCxDQUFrQjk1QyxLQUFLLEVBQXZCLElBQTZCeTZDLENBQUMsR0FBRyxDQUFqQztBQUNBOztBQUVEejZDLFdBQUssR0FBRyxDQUFSO0FBQ0EsV0FBSzY1QyxVQUFMLEdBQWtCLEVBQWxCOztBQUNBLFdBQUssSUFBSXRwRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUt5Z0IsU0FBTCxDQUFldGlCLE1BQWYsR0FBd0IsQ0FBNUMsRUFBK0M2QixDQUFDLEVBQWhELEVBQW9EO0FBQ25ELFlBQUlBLENBQUMsR0FBRyxDQUFKLEtBQVUsQ0FBZCxFQUFpQjtBQUNoQixlQUFLc3BELFVBQUwsQ0FBZ0I3NUMsS0FBSyxFQUFyQixJQUEyQixDQUFDLENBQUQsQ0FBM0I7QUFDQSxTQUZELE1BRU87QUFDTixlQUFLNjVDLFVBQUwsQ0FBZ0I3NUMsS0FBSyxFQUFyQixJQUEyQixDQUFDLENBQUMsQ0FBRixDQUEzQjtBQUNBO0FBQ0Q7O0FBRUQsV0FBSytSLFdBQUwsQ0FBaUIsS0FBSytuQyxZQUF0QjtBQUNBLFdBQUs5a0MsaUJBQUwsQ0FBdUIsS0FBSzZrQyxVQUE1QixFQUF3QyxZQUF4QyxFQUFzRCxDQUF0RDtBQUVBLFdBQUsvbkMsY0FBTCxDQUFvQixLQUFLZ1YsR0FBekI7QUFDQSxXQUFLOVIsaUJBQUwsQ0FBdUIsS0FBSytrQyxRQUE1QixFQUFzQyxXQUF0QyxFQUFtRCxDQUFuRDtBQUNBO0FBQ0Q7O0FBRUQ1Z0MsUUFBTSxDQUFDbzFCLE1BQUQsRUFBUzBMLFdBQVcsR0FBRyxLQUF2QixFQUE4QjtBQUNuQyxTQUFLTCxJQUFMLEdBQVlyTCxNQUFNLElBQUksS0FBS3FMLElBQTNCO0FBRUEsU0FBS3R4QixJQUFMLENBQVUyeEIsV0FBVjtBQUNBOztBQTNNNkI7Ozs7Ozs7Ozs7Ozs7O0FDUi9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVPLE1BQU01RyxhQUFOLFNBQTRCcUgsMERBQTVCLENBQXlDO0FBQy9DckosT0FBSyxDQUFDbHhDLElBQUksR0FBRyxFQUFSLEVBQVk7QUFDaEI7QUFDQW16QywrREFBbUIsQ0FBQ2xnRCxLQUFwQixDQUEwQjtBQUN6QmdCLGNBQVEsRUFBRSxDQURlO0FBRXpCWixRQUFFLEVBQUUsS0FGcUI7QUFHekJDLFFBQUUsRUFBRSxLQUhxQjtBQUl6QkYsWUFBTSxFQUFFLElBSmlCO0FBS3pCZSxVQUFJLEVBQUU7QUFMbUIsS0FBMUIsRUFGZ0IsQ0FTaEI7O0FBQ0EsU0FBS3czQyxLQUFMLENBQVcwSCxXQUFYLENBQXVCMTBCLEtBQXZCO0FBQ0EsU0FBS2d0QixLQUFMLENBQVcwSCxXQUFYLENBQXVCaEgsSUFBdkI7QUFDQTs7QUFFRDRFLEtBQUcsR0FBRztBQUNMLFNBQUt0RixLQUFMLENBQVcwSCxXQUFYLENBQXVCNTBCLElBQXZCO0FBQ0E7O0FBakI4QyxDOzs7Ozs7Ozs7Ozs7QUNIaEQ7QUFBQTtBQUFPLE1BQU04N0IsWUFBTixDQUFtQjtBQUN6Qm5vRCxhQUFXLENBQUN1NUMsS0FBRCxFQUFRO0FBQ2xCLFNBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNBOztBQUVEdUYsT0FBSyxHQUFHLENBQUU7O0FBQ1YxeUIsUUFBTSxHQUFHLENBQUU7O0FBQ1h5eUIsS0FBRyxHQUFHLENBQUU7O0FBUGlCLEM7Ozs7Ozs7Ozs7OztBQ0ExQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRU8sTUFBTStCLFNBQU4sU0FBd0J1SCwwREFBeEIsQ0FBcUM7QUFDM0Nub0QsYUFBVyxDQUFDdTVDLEtBQUQsRUFBUTtBQUNsQixVQUFNQSxLQUFOO0FBRUEsU0FBS3hYLE9BQUwsR0FBZSxLQUFLNGQsTUFBTCxDQUFZaDZDLElBQVosQ0FBaUIsSUFBakIsQ0FBZjtBQUNBLFNBQUtzOEIsT0FBTCxHQUFlLEtBQUsyZCxNQUFMLENBQVlqNkMsSUFBWixDQUFpQixJQUFqQixDQUFmO0FBQ0EsU0FBS3c4QixLQUFMLEdBQWEsS0FBSzBkLElBQUwsQ0FBVWw2QyxJQUFWLENBQWUsSUFBZixDQUFiO0FBQ0E7O0FBRURtNUMsT0FBSyxDQUFDbHhDLElBQUksR0FBRyxFQUFSLEVBQVk7QUFDaEIsU0FBS3V5QyxJQUFMLEdBQVksS0FBWjtBQUNBLFNBQUtpSSxJQUFMLEdBQVksQ0FBWjtBQUNBLFNBQUtDLEtBQUwsR0FBYSxLQUFLOU8sS0FBTCxDQUFXOEksT0FBeEI7QUFDQSxTQUFLdGhELEdBQUwsR0FBVyxLQUFLdzRDLEtBQUwsQ0FBVzU0QyxjQUF0QjtBQUNBLFNBQUsybkQsS0FBTCxHQUFhLEtBQWI7QUFDQSxTQUFLdm9DLEdBQUwsR0FBVztBQUFDdE0sT0FBQyxFQUFFLENBQUo7QUFBT3NHLE9BQUMsRUFBRTtBQUFWLEtBQVg7QUFFQSxTQUFLd3VDLGVBQUw7O0FBQ0EsUUFBSTM2QyxJQUFJLENBQUN3ekMsSUFBVCxFQUFlO0FBQ2QsV0FBS2tILEtBQUwsR0FBYSxJQUFiO0FBRUEsV0FBS0QsS0FBTCxDQUFXaHRCLFNBQVgsR0FBdUIsQ0FBQzNzQixJQUFJLENBQUNvUixFQUFOLEdBQVcsQ0FBbEM7QUFDQSxXQUFLdW9DLEtBQUwsQ0FBVy9zQixTQUFYLEdBQXVCLENBQUM1c0IsSUFBSSxDQUFDb1IsRUFBTixHQUFXLENBQWxDO0FBQ0EsV0FBS3VvQyxLQUFMLENBQVd0dUMsQ0FBWCxHQUFlLENBQWY7QUFHQSxXQUFLaFosR0FBTCxDQUFTSyxNQUFULENBQWdCLENBQWhCLElBQXFCLElBQXJCO0FBQ0EsV0FBS0wsR0FBTCxDQUFTRSxFQUFULENBQVlpQixLQUFaLENBQWtCLEtBQWxCO0FBQ0EsV0FBS25CLEdBQUwsQ0FBU0csRUFBVCxDQUFZZ0IsS0FBWixDQUFrQixLQUFsQjtBQUNBLFdBQUtzbUQsWUFBTDtBQUNBLEtBWkQsTUFZTztBQUNOekgsaUVBQW1CLENBQUNsZ0QsS0FBcEIsQ0FBMEI7QUFBRVEsZUFBTyxFQUFFLElBQVg7QUFBaUJKLFVBQUUsRUFBRSxLQUFyQjtBQUE0QkMsVUFBRSxFQUFFLEtBQWhDO0FBQXVDVyxnQkFBUSxFQUFFLENBQWpEO0FBQW9ERSxZQUFJLEVBQUU7QUFBMUQsT0FBMUI7QUFDQUosa0RBQUksQ0FBQ0MsRUFBTCxDQUFRLEtBQUt5bUQsS0FBYixFQUFvQixDQUFwQixFQUF1QjtBQUN0QnR1QyxTQUFDLEVBQUUsQ0FEbUI7QUFFdEJzaEIsaUJBQVMsRUFBRSxDQUFDM3NCLElBQUksQ0FBQ29SLEVBQU4sR0FBVyxDQUZBO0FBR3RCd2IsaUJBQVMsRUFBRSxDQUFDNXNCLElBQUksQ0FBQ29SLEVBQU4sR0FBVyxDQUhBO0FBSXRCL2QsWUFBSSxFQUFFLFlBSmdCO0FBS3RCSSxrQkFBVSxFQUFFLE1BQUs7QUFDaEIsZUFBS3FtRCxZQUFMO0FBQ0EsZUFBS0YsS0FBTCxHQUFhLElBQWI7QUFDQTtBQVJxQixPQUF2QjtBQVVBO0FBQ0Q7O0FBRURDLGlCQUFlLEdBQUc7QUFDakIsU0FBS2hQLEtBQUwsQ0FBV3dCLGFBQVgsQ0FBeUI3dEIsbUJBQXpCLENBQTZDLFdBQTdDLEVBQTBELEtBQUs2VSxPQUEvRDtBQUNBLFNBQUt3WCxLQUFMLENBQVd3QixhQUFYLENBQXlCN3RCLG1CQUF6QixDQUE2QyxTQUE3QyxFQUF3RCxLQUFLaVYsS0FBN0Q7QUFDQSxTQUFLb1gsS0FBTCxDQUFXd0IsYUFBWCxDQUF5Qjd0QixtQkFBekIsQ0FBNkMsV0FBN0MsRUFBMEQsS0FBSytVLE9BQS9EO0FBQ0E7O0FBRUR1bUIsY0FBWSxHQUFHO0FBQ2QsU0FBS2pQLEtBQUwsQ0FBV3dCLGFBQVgsQ0FBeUJqOEMsZ0JBQXpCLENBQTBDLFdBQTFDLEVBQXVELEtBQUtpakMsT0FBNUQ7QUFDQSxTQUFLd1gsS0FBTCxDQUFXd0IsYUFBWCxDQUF5Qmo4QyxnQkFBekIsQ0FBMEMsU0FBMUMsRUFBcUQsS0FBS3FqQyxLQUExRDtBQUNBLFNBQUtvWCxLQUFMLENBQVd3QixhQUFYLENBQXlCajhDLGdCQUF6QixDQUEwQyxXQUExQyxFQUF1RCxLQUFLbWpDLE9BQTVEO0FBQ0E7O0FBRUQwZCxRQUFNLENBQUNsaEQsQ0FBRCxFQUFJO0FBQ1QsU0FBSzBoRCxJQUFMLEdBQVksSUFBWjtBQUNBLFNBQUtwZ0MsR0FBTCxHQUFXMGdCLHNEQUFRLENBQUNoaUMsQ0FBRCxDQUFuQjtBQUNBOztBQUVEbWhELFFBQU0sQ0FBQ25oRCxDQUFELEVBQUk7QUFFVCxRQUFJLENBQUMsS0FBSzBoRCxJQUFWLEVBQWdCO0FBRWhCLFVBQU1wZ0MsR0FBRyxHQUFHMGdCLHNEQUFRLENBQUNoaUMsQ0FBRCxDQUFwQjtBQUNBLFVBQU0rbkMsSUFBSSxHQUFHNFosMERBQVksQ0FBQyxLQUFLcmdDLEdBQUwsQ0FBU3RNLENBQVYsRUFBYXNNLEdBQUcsQ0FBQ3RNLENBQWpCLEVBQW9CLEtBQUtzTSxHQUFMLENBQVNoRyxDQUE3QixFQUFnQ2dHLEdBQUcsQ0FBQ2hHLENBQXBDLENBQXpCOztBQUNBLFFBQUl5c0IsSUFBSSxHQUFHLEtBQUssRUFBaEIsRUFBb0I7QUFDbkIsV0FBSytTLEtBQUwsQ0FBV29ILFlBQVgsQ0FBd0J4Z0QsR0FBeEIsQ0FBNEIsT0FBNUI7QUFDQTtBQUNEOztBQUVEMC9DLE1BQUksQ0FBQ3BoRCxDQUFELEVBQUk7QUFDUCxTQUFLMGhELElBQUwsR0FBWSxLQUFaO0FBQ0E7O0FBRUR0QixLQUFHLEdBQUc7QUFDTGw5QyxnREFBSSxDQUFDQyxFQUFMLENBQVEsS0FBS3ltRCxLQUFiLEVBQW9CLENBQXBCLEVBQXVCO0FBQ3RCdHVDLE9BQUMsRUFBRSxDQURtQjtBQUV0QnNoQixlQUFTLEVBQUUsQ0FBQzNzQixJQUFJLENBQUNvUixFQUFOLEdBQVcsQ0FGQTtBQUd0QndiLGVBQVMsRUFBRSxDQUhXO0FBSXRCdjVCLFVBQUksRUFBRTtBQUpnQixLQUF2QjtBQU9BZy9DLCtEQUFtQixDQUFDbGdELEtBQXBCLENBQTBCO0FBQ3pCTSxhQUFPLEVBQUUsQ0FEZ0I7QUFFekJFLGFBQU8sRUFBRSxDQUZnQjtBQUd6QkMsYUFBTyxFQUFFLENBSGdCO0FBSXpCUyxVQUFJLEVBQUUsWUFKbUI7QUFLekJGLGNBQVEsRUFBRTtBQUxlLEtBQTFCO0FBT0EsU0FBSzBtRCxlQUFMO0FBQ0E7O0FBRUQzaEMsUUFBTSxHQUFHO0FBQ1IsUUFBSTgwQiwrQ0FBTSxDQUFDTyxJQUFQLENBQVlDLGNBQVosSUFBOEIsS0FBS29NLEtBQXZDLEVBQThDO0FBQzdDLFdBQUt2bkQsR0FBTCxDQUFTRyxFQUFULENBQVlYLEtBQVosSUFBcUJtTyxJQUFJLENBQUNzUixHQUFMLENBQVM5YyxnREFBUyxDQUFDdWxELFNBQVYsR0FBc0IsSUFBL0IsSUFBdUMsS0FBNUQ7QUFDQSxXQUFLSixLQUFMLENBQVd0dUMsQ0FBWCxHQUFlLElBQUlyTCxJQUFJLENBQUN3UixHQUFMLENBQVNoZCxnREFBUyxDQUFDdWxELFNBQVYsR0FBc0IsR0FBL0IsSUFBc0MsR0FBekQ7QUFDQSxXQUFLSixLQUFMLENBQVdodEIsU0FBWCxHQUF1QixDQUFDM3NCLElBQUksQ0FBQ29SLEVBQU4sR0FBVyxDQUFYLEdBQWUsS0FBZixHQUF1QnBSLElBQUksQ0FBQ3dSLEdBQUwsQ0FBU2hkLGdEQUFTLENBQUN1bEQsU0FBVixHQUFzQixHQUEvQixJQUFzQyxLQUFwRjtBQUNBO0FBQ0Q7O0FBckcwQyxDOzs7Ozs7Ozs7Ozs7QUNQNUM7QUFBQTtBQUFBO0FBQUE7QUFHTyxNQUFNNUgsVUFBTixTQUF5QnNILDBEQUF6QixDQUFzQztBQUM1Q3JKLE9BQUssR0FBRztBQUNQLFNBQUt1SixLQUFMLEdBQWEsS0FBSzlPLEtBQUwsQ0FBVzhJLE9BQXhCO0FBQ0EsU0FBS3RoRCxHQUFMLEdBQVcsS0FBS3c0QyxLQUFMLENBQVc1NEMsY0FBdEI7QUFDQTs7QUFKMkMsQzs7Ozs7Ozs7Ozs7O0FDSDdDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0RBO0FBQUE7QUFBQTtBQUFBO0FBRUEsTUFBTXk5QyxVQUFVLEdBQUdudUMsOENBQUksQ0FBQ3NZLFVBQUwsQ0FDakIsR0FEaUIsRUFDWixHQURZLEVBQ1AsR0FETyxFQUNGLEdBREUsRUFFakIsR0FGaUIsRUFFWixHQUZZLEVBRVAsR0FGTyxFQUVGLEdBRkUsRUFHakIsR0FIaUIsRUFHWixHQUhZLEVBR1AsR0FITyxFQUdGLEdBSEUsRUFJakIsR0FKaUIsRUFJWixHQUpZLEVBSVAsR0FKTyxFQUlGLEdBSkUsQ0FBbkI7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQUE7QUFBQTtBQUFBO0FBRWUsTUFBTW02QixjQUFOLENBQXFCO0FBQ25DMWlELGFBQVcsQ0FBQ2tzQixTQUFELEVBQVk7QUFDdEIsU0FBS0EsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxTQUFLdzhCLE9BQUwsR0FBZWxwRCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZjtBQUNBLFNBQUtpcEQsT0FBTCxDQUFhaE8sU0FBYixHQUF5QixZQUF6QjtBQUNBLFNBQUtnTyxPQUFMLENBQWFyTixLQUFiLENBQW1CQyxPQUFuQixHQUE2QixNQUE3QjtBQUVBLFNBQUtmLElBQUwsR0FBWS82QyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBWjtBQUNBLFNBQUs4NkMsSUFBTCxDQUFVb0ssU0FBVixHQUFzQiw2Q0FBdEI7QUFDQSxTQUFLK0QsT0FBTCxDQUFhMU4sV0FBYixDQUF5QixLQUFLVCxJQUE5QjtBQUVBLFNBQUtoN0MsR0FBTCxHQUFXQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWDtBQUNBLFNBQUtGLEdBQUwsQ0FBU203QyxTQUFULEdBQXFCLFlBQXJCO0FBQ0EsU0FBS2dPLE9BQUwsQ0FBYTFOLFdBQWIsQ0FBeUIsS0FBS3o3QyxHQUE5QjtBQUVBLFVBQU1vcEQsU0FBUyxHQUFHbnBELFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUFsQjtBQUNBa3BELGFBQVMsQ0FBQ2pPLFNBQVYsR0FBc0IsT0FBdEI7QUFDQWlPLGFBQVMsQ0FBQ2hPLE9BQVYsR0FBb0IsS0FBS1QsSUFBTCxDQUFVdjBDLElBQVYsQ0FBZSxJQUFmLENBQXBCO0FBQ0EsU0FBSytpRCxPQUFMLENBQWExTixXQUFiLENBQXlCMk4sU0FBekI7QUFFQXo4QixhQUFTLENBQUM4dUIsV0FBVixDQUFzQixLQUFLME4sT0FBM0I7QUFDQTs7QUFFRHpPLE1BQUksR0FBRztBQUNOLFNBQUt5TyxPQUFMLENBQWFyTixLQUFiLENBQW1CQyxPQUFuQixHQUE2QixPQUE3QjtBQUNBOztBQUVEcEIsTUFBSSxHQUFHO0FBQ04sU0FBS3dPLE9BQUwsQ0FBYXJOLEtBQWIsQ0FBbUJDLE9BQW5CLEdBQTZCLE1BQTdCO0FBQ0E7O0FBRUQxQixlQUFhLENBQUN3QixJQUFELEVBQU87QUFDbkIsU0FBS25CLElBQUw7QUFFQSxVQUFNcm1DLENBQUMsR0FBRyxLQUFLc1ksU0FBTCxDQUFlMDhCLFdBQXpCO0FBQ0EsU0FBS3JPLElBQUwsQ0FBVU0sU0FBVixHQUFzQk8sSUFBSSxDQUFDTixLQUEzQjtBQUVBLFVBQU0rTixLQUFLLEdBQUdyTixzREFBUSxDQUFDSixJQUFJLENBQUN2a0IsTUFBTixDQUF0QjtBQUNBLFVBQU1wakIsQ0FBQyxHQUFHbzFDLEtBQUssQ0FBQyxDQUFELENBQWY7QUFDQSxVQUFNOXVDLENBQUMsR0FBRzh1QyxLQUFLLENBQUMsQ0FBRCxDQUFmOztBQUVBLFFBQUlwMUMsQ0FBQyxHQUFHRyxDQUFDLEdBQUcsQ0FBWixFQUFlO0FBQ2QsV0FBSzgwQyxPQUFMLENBQWFyTixLQUFiLENBQW1CeHlCLEtBQW5CLEdBQTJCLE1BQTNCO0FBQ0EsV0FBSzYvQixPQUFMLENBQWFyTixLQUFiLENBQW1CenlCLElBQW5CLEdBQTJCLEdBQUVsYSxJQUFJLENBQUNMLEdBQUwsQ0FBU3VGLENBQUMsR0FBRyxDQUFiLEVBQWdCSCxDQUFDLEdBQUcsRUFBcEIsQ0FBd0IsSUFBckQ7QUFDQSxLQUhELE1BR087QUFDTixXQUFLaTFDLE9BQUwsQ0FBYXJOLEtBQWIsQ0FBbUJ6eUIsSUFBbkIsR0FBMEIsTUFBMUI7QUFDQSxXQUFLOC9CLE9BQUwsQ0FBYXJOLEtBQWIsQ0FBbUJ4eUIsS0FBbkIsR0FBNEIsR0FBRW5hLElBQUksQ0FBQ04sR0FBTCxDQUFTd0YsQ0FBQyxHQUFHLENBQWIsRUFBZ0JILENBQUMsR0FBRyxFQUFwQixDQUF3QixJQUF0RDtBQUNBO0FBQ0Q7O0FBRURxMUMsYUFBVyxDQUFDcjFDLENBQUQsRUFBSXNHLENBQUosRUFBTyxDQUVqQjs7QUFwRGtDLEM7Ozs7Ozs7Ozs7OztBQ0ZwQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVlLE1BQU15b0MsU0FBTixTQUF3Qi85Qyw2Q0FBeEIsQ0FBK0I7QUFFNUN6RSxhQUFXLEdBQUc7QUFDWixVQUFNd3FCLDBEQUFOLEVBQVVDLDBEQUFWO0FBRUEsU0FBS3MrQixXQUFMLEdBQW1CLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQW5CO0FBQ0EsU0FBS3ArQixLQUFMLEdBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBYjtBQUNBLFNBQUs1USxDQUFMLEdBQVMsQ0FBQyxHQUFWLENBTFksQ0FNWjs7QUFDQSxVQUFNbFUsSUFBSSxHQUFHLEVBQWI7QUFDQSxTQUFLdkksSUFBTCxHQUFZd0YsMkNBQUksQ0FBQ3diLEtBQUwsQ0FBV3pZLElBQVgsRUFBaUJBLElBQWpCLEVBQXVCLENBQXZCLEVBQTBCLElBQTFCLENBQVo7QUFDRDs7QUFFRCtnQixRQUFNLENBQUNtM0IsWUFBRCxFQUFlaUwsWUFBZixFQUE2QjtBQUNqQyxVQUFNQyxXQUFXLEdBQUd2TiwrQ0FBTSxDQUFDWSxNQUFQLENBQWMzeEIsS0FBZCxDQUFvQm51QixHQUFwQixDQUF5QjZpQixDQUFELElBQU9BLENBQUMsR0FBRyxHQUFuQyxDQUFwQjtBQUVBLFNBQUt6WixNQUFMLENBQVlELElBQVosR0FIaUMsQ0FJakM7O0FBQ0EsU0FBS0MsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixRQUFwQixFQUE4QixNQUE5QixFQUFzQyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUF0QztBQUNBLFNBQUtuTCxNQUFMLENBQVltTCxPQUFaLENBQW9CLGNBQXBCLEVBQW9DLE1BQXBDLEVBQTRDazRDLFdBQTVDO0FBQ0EsU0FBS3JqRCxNQUFMLENBQVltTCxPQUFaLENBQW9CLGdCQUFwQixFQUFzQyxPQUF0QyxFQUErQyxHQUEvQztBQUNBLFNBQUtuTCxNQUFMLENBQVltTCxPQUFaLENBQW9CLGNBQXBCLEVBQW9DLFdBQXBDLEVBQWlELENBQWpEO0FBQ0FpNEMsZ0JBQVksQ0FBQ3JqRCxJQUFiLENBQWtCLENBQWxCLEVBVGlDLENBV2pDO0FBQ0E7O0FBQ0EsU0FBS0MsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixVQUFwQixFQUFnQyxPQUFoQyxFQUF5QzJxQywrQ0FBTSxDQUFDVyxhQUFoRCxFQWJpQyxDQWNqQzs7QUFHQSxTQUFLejJDLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IsZUFBcEIsRUFBcUMsa0JBQXJDLEVBQXlEZ3RDLFlBQXpEO0FBRUEsU0FBS240QyxNQUFMLENBQVltTCxPQUFaLENBQW9CLGNBQXBCLEVBQW9DLE1BQXBDLEVBQTRDazRDLFdBQTVDOztBQUVBLFNBQUt6dUIsT0FBTDs7QUFHQSxTQUFLNTBCLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IsU0FBcEIsRUFBK0IsTUFBL0IsRUFBdUMsS0FBS3NILE9BQTVDO0FBRUEzViw2Q0FBRSxDQUFDZ0QsSUFBSCxDQUFRLEtBQUtwSSxJQUFiO0FBQ0Q7O0FBeEMyQyxDOzs7Ozs7Ozs7Ozs7QUNUOUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTWttRCxRQUFRLEdBQUd2ekMsOENBQUksQ0FBQ2dJLE1BQUwsRUFBakI7O0FBRUEsTUFBTWl4QyxlQUFlLEdBQUcsVUFBVXY0QixPQUFWLEVBQW1CO0FBQzFDLE1BQUl3NEIsTUFBTSxHQUFHLEVBQWI7O0FBQ0EsT0FBSyxNQUFNQyxHQUFYLElBQWtCejRCLE9BQWxCLEVBQTJCO0FBQ3ZCLFFBQUdBLE9BQU8sQ0FBQ3k0QixHQUFELENBQVYsRUFBaUI7QUFDaEJELFlBQU0sSUFBSyxXQUFVQyxHQUFJLElBQUd6NEIsT0FBTyxDQUFDeTRCLEdBQUQsQ0FBTSxJQUF6QztBQUNBO0FBRUo7O0FBQ0QsU0FBT0QsTUFBUDtBQUNBLENBVEQ7O0FBV0EsTUFBTTdHLFlBQU4sU0FBMkI3OUMsNkNBQTNCLENBQWtDO0FBRWpDekUsYUFBVyxHQUFHO0FBQ2IsVUFBTTJ3QixPQUFPLEdBQUc7QUFDZjA0QixpQkFBVyxFQUFFLENBQUMsQ0FBQzNtRCx5Q0FBRSxDQUFDM0csWUFBSCxDQUFnQix3QkFBaEIsQ0FBRixHQUE4QyxDQUE5QyxHQUFrRCxDQURoRDtBQUVmdXRELGFBQU8sRUFBRSxDQUZNO0FBR2ZDLHNCQUFnQixFQUFFLENBSEg7QUFJZkMsbUJBQWEsRUFBRSxDQUpBO0FBS2ZDLHFCQUFlLEVBQUUsQ0FMRjtBQU1mQyxzQkFBZ0IsRUFBRTtBQU5ILEtBQWhCO0FBUUEsVUFBTUMsU0FBUyxHQUFHVCxlQUFlLENBQUN2NEIsT0FBRCxDQUFqQyxDQVRhLENBVWI7O0FBQ0EsVUFBTXpLLEdBQUcsR0FBSSxHQUFFeWpDLFNBQVUsS0FBSW4vQix3REFBRyxFQUFoQztBQUNBLFVBQU1yRSxHQUFHLEdBQUksR0FBRXdqQyxTQUFVLEtBQUlsL0Isd0RBQUcsRUFBaEMsQ0FaYSxDQWNiOztBQUNBLFVBQU12RSxHQUFOLEVBQVdDLEdBQVg7QUFHQSxTQUFLeWpDLFdBQUwsR0FBbUIsSUFBSWhuRCwrQ0FBSixDQUFhNG5CLHdEQUFiLEVBQWlCcS9CLDBEQUFqQixDQUFuQjtBQUNBLFNBQUtDLFlBQUwsR0FBb0IsSUFBSWxuRCwrQ0FBSixDQUFhbW5ELDJEQUFiLEVBQXVCQywwREFBdkIsQ0FBcEI7QUFDQTs7QUFFREMsVUFBUSxHQUFHO0FBQ1YsU0FBS2hsQyxLQUFMLEdBQWEsRUFBYjtBQUVBLFNBQUtzL0IsV0FBTCxDQUFpQjNsRCxPQUFqQixDQUF5QnRCLElBQUksSUFBSTtBQUNoQyxZQUFNMm5CLEtBQUssR0FBRzZoQyw4REFBZ0IsQ0FBQ3hwRCxJQUFELENBQTlCO0FBQ0EsV0FBSzJuQixLQUFMLEdBQWEsQ0FBQyxHQUFHLEtBQUtBLEtBQVQsRUFBZ0IsR0FBR0EsS0FBbkIsQ0FBYjtBQUNBLEtBSEQ7QUFJQTs7QUFFRDNlLE9BQUssR0FBRztBQUdQLFFBQUlvMUMsK0NBQU0sQ0FBQ0ssTUFBUCxDQUFjakMsTUFBZCxJQUF3QjRCLCtDQUFNLENBQUM5OUMsS0FBUCxDQUFhK1AsS0FBYixDQUFtQm1zQyxNQUEvQyxFQUF1RDtBQUN0RCxXQUFLb1EsV0FBTCxHQUFtQmo2Qyw4Q0FBSSxDQUFDZ0ksTUFBTCxFQUFuQjtBQUNBLFdBQUtreUMsU0FBTCxHQUFpQm50RCw4Q0FBTSxDQUFDOEYsSUFBUCxDQUFZd2QsSUFBWixDQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixDQUFqQjtBQUVBLFdBQUtpa0MsV0FBTCxHQUFtQixFQUFuQjtBQUNBLFdBQUtBLFdBQUwsQ0FBaUJ6bkQsSUFBakIsQ0FBc0I4cEQsaUVBQU8sQ0FBQyxLQUFELEVBQVEsR0FBUixFQUFhLEtBQWIsRUFBb0IsQ0FBQyxDQUFELEVBQUksQ0FBQyxLQUFMLEVBQVksQ0FBWixDQUFwQixDQUE3QjtBQUNBLFdBQUtyQyxXQUFMLENBQWlCem5ELElBQWpCLENBQXNCOHBELGlFQUFPLENBQUMsSUFBRCxFQUFPLEtBQVAsRUFBYyxJQUFkLEVBQW9CLENBQUMsQ0FBRCxFQUFJLEtBQUosRUFBVyxDQUFYLENBQXBCLENBQTdCO0FBQ0EsV0FBS3JDLFdBQUwsQ0FBaUJ6bkQsSUFBakIsQ0FBc0I4cEQsaUVBQU8sQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLEtBQWQsRUFBcUIsQ0FBQyxDQUFDLEtBQUYsRUFBUyxDQUFDLEtBQVYsRUFBaUIsQ0FBQyxLQUFsQixDQUFyQixDQUE3QixFQVBzRCxDQVN0RDtBQUNBOztBQUlELFNBQUt0cEQsSUFBTCxHQUFZaEMsK0NBQU0sQ0FBQ3FDLEdBQVAsQ0FBVyxXQUFYLENBQVo7QUFDQSxTQUFLeXNELFNBQUwsR0FBaUIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBakIsQ0FsQk8sQ0FtQlA7QUFDQTs7QUFFRDdMLGNBQVksR0FBRztBQUNkLFNBQUtxTCxXQUFMLENBQWlCamtELElBQWpCO0FBQ0FqRCw2Q0FBRSxDQUFDK1gsTUFBSCxDQUFVLEtBQUtwQyxPQUFmO0FBRUEzViw2Q0FBRSxDQUFDZ0QsSUFBSCxDQUFRLEtBQUtwSSxJQUFiO0FBQ0E7O0FBRURzcEIsUUFBTSxDQUFDeWpDLFVBQUQsRUFBYUMsVUFBYixFQUF5QkMsU0FBekIsRUFBb0NDLFlBQXBDLEVBQWtEQyxZQUFsRCxFQUFnRUMscUJBQWhFLEVBQXVGO0FBQzVGLFNBQUs5a0QsTUFBTCxDQUFZRCxJQUFaO0FBRUEsU0FBS0MsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixRQUFwQixFQUE4QixXQUE5QixFQUEyQyxDQUEzQztBQUNBdzVDLGFBQVMsQ0FBQzVrRCxJQUFWLENBQWUsQ0FBZjtBQUNBLFNBQUtDLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IsVUFBcEIsRUFBZ0MsV0FBaEMsRUFBNkMsQ0FBN0M7QUFDQXpWLG1EQUFNLENBQUNxQyxHQUFQLENBQVcsU0FBWCxFQUFzQmdJLElBQXRCLENBQTJCLENBQTNCO0FBRUEsU0FBS0MsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixjQUFwQixFQUFvQyxXQUFwQyxFQUFpRCxDQUFqRDtBQUNBLFNBQUtuTCxNQUFMLENBQVltTCxPQUFaLENBQW9CLGdCQUFwQixFQUFzQyxXQUF0QyxFQUFtRCxDQUFuRDtBQUVBczVDLGNBQVUsQ0FBQzFrRCxJQUFYLENBQWdCLENBQWhCO0FBQ0Eya0QsY0FBVSxDQUFDM2tELElBQVgsQ0FBZ0IsQ0FBaEI7QUFFQSxTQUFLQyxNQUFMLENBQVltTCxPQUFaLENBQW9CLFdBQXBCLEVBQWlDLFdBQWpDLEVBQThDLENBQTlDO0FBQ0F5NUMsZ0JBQVksQ0FBQzdrRCxJQUFiLENBQWtCLENBQWxCO0FBQ0EsU0FBS0MsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixlQUFwQixFQUFxQyxXQUFyQyxFQUFrRCxDQUFsRDtBQUNBMDVDLGdCQUFZLENBQUM5a0QsSUFBYixDQUFrQixDQUFsQjtBQUVBLFNBQUtDLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IsV0FBcEIsRUFBaUMsV0FBakMsRUFBOEMycUMsK0NBQU0sQ0FBQ0csUUFBckQ7QUFDQSxTQUFLajJDLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IsV0FBcEIsRUFBaUMsV0FBakMsRUFBOEMsS0FBSzQ1QyxRQUFuRCxFQXBCNEYsQ0FzQjVGOztBQUNBLFNBQUsva0QsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixpQkFBcEIsRUFBdUMsTUFBdkMsRUFBK0MsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsQ0FBL0M7QUFDQSxTQUFLbkwsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixhQUFwQixFQUFtQyxNQUFuQyxFQUEyQyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUEzQztBQUVBLFNBQUtuTCxNQUFMLENBQVltTCxPQUFaLENBQW9CLGtCQUFwQixFQUF3QyxNQUF4QyxFQUFnRCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBaEQ7QUFDQSxTQUFLbkwsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixlQUFwQixFQUFxQyxNQUFyQyxFQUE2QyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBN0M7QUFDQSxTQUFLbkwsTUFBTCxDQUFZbUwsT0FBWixDQUFvQixrQkFBcEIsRUFBd0MsTUFBeEMsRUFBZ0QsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQWhEO0FBRUEsU0FBS25MLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IsWUFBcEIsRUFBa0MsTUFBbEMsRUFBMENyTyx5Q0FBRSxDQUFDOFgsTUFBSCxDQUFVNE0sUUFBcEQ7QUFDQSxTQUFLeGhCLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0Isb0JBQXBCLEVBQTBDLE9BQTFDLEVBQW1ELENBQW5EO0FBRUEsU0FBS25MLE1BQUwsQ0FBWW1MLE9BQVosQ0FBb0IsZ0JBQXBCLEVBQXNDLE1BQXRDLEVBQThDMjVDLHFCQUFxQixHQUFHQSxxQkFBcUIsQ0FBQzd6QixNQUF6QixHQUFrQyxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixDQUFyRztBQUVBbjBCLDZDQUFFLENBQUMrWCxNQUFILENBQVUsS0FBS3BDLE9BQWY7QUFDQTNWLDZDQUFFLENBQUNnRCxJQUFILENBQVEsS0FBS3BJLElBQWI7O0FBRUEsUUFBSW8rQywrQ0FBTSxDQUFDOTlDLEtBQVAsQ0FBYStQLEtBQWIsQ0FBbUJtc0MsTUFBdkIsRUFBK0I7QUFDOUIsV0FBS2dRLFlBQUwsQ0FBa0Jua0QsSUFBbEI7QUFDQSxXQUFLbWtELFlBQUwsQ0FBa0IvNEMsT0FBbEIsQ0FBMEIsUUFBMUIsRUFBb0MsT0FBcEMsRUFBNkMsRUFBN0M7QUFDQSxXQUFLKzRDLFlBQUwsQ0FBa0IvNEMsT0FBbEIsQ0FBMEIsUUFBMUIsRUFBb0MsTUFBcEMsRUFBNEMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBNUM7QUFDQWQsb0RBQUksQ0FBQzJJLFFBQUwsQ0FBYyxLQUFLc3hDLFdBQW5CO0FBQ0EsWUFBTXBPLEdBQUcsR0FBR0osK0NBQU0sQ0FBQzk5QyxLQUFQLENBQWErUCxLQUFiLENBQW1CbXVDLEdBQS9CO0FBQ0E3ckMsb0RBQUksQ0FBQ3dxQixPQUFMLENBQWEsS0FBS3l2QixXQUFsQixFQUErQixLQUFLQSxXQUFwQyxFQUFpRHBPLEdBQUcsQ0FBQ3JvQyxDQUFyRDtBQUNBeEQsb0RBQUksQ0FBQ3lxQixPQUFMLENBQWEsS0FBS3d2QixXQUFsQixFQUErQixLQUFLQSxXQUFwQyxFQUFpRHBPLEdBQUcsQ0FBQy9oQyxDQUFyRDtBQUNBOUosb0RBQUksQ0FBQzBxQixPQUFMLENBQWEsS0FBS3V2QixXQUFsQixFQUErQixLQUFLQSxXQUFwQyxFQUFpRHBPLEdBQUcsQ0FBQ3Q3QixDQUFyRDtBQUNBLFlBQU1ULEdBQUcsR0FBRzI3QiwrQ0FBTSxDQUFDOTlDLEtBQVAsQ0FBYStQLEtBQWIsQ0FBbUJvUyxHQUEvQjtBQUNBOVAsb0RBQUksQ0FBQzRYLFNBQUwsQ0FBZSxLQUFLcWlDLFdBQXBCLEVBQWlDLEtBQUtBLFdBQXRDLEVBQW1ELENBQUNucUMsR0FBRyxDQUFDdE0sQ0FBTCxFQUFRc00sR0FBRyxDQUFDaEcsQ0FBWixFQUFlZ0csR0FBRyxDQUFDUyxDQUFuQixDQUFuRDtBQUNBLFlBQU1rSyxLQUFLLEdBQUdneEIsK0NBQU0sQ0FBQzk5QyxLQUFQLENBQWErUCxLQUFiLENBQW1CK2MsS0FBakM7QUFDQXphLG9EQUFJLENBQUN5YSxLQUFMLENBQVcsS0FBS3cvQixXQUFoQixFQUE2QixLQUFLQSxXQUFsQyxFQUErQyxDQUFDeC9CLEtBQUssQ0FBQ2pYLENBQVAsRUFBVWlYLEtBQUssQ0FBQzNRLENBQWhCLEVBQW1CMlEsS0FBSyxDQUFDbEssQ0FBekIsQ0FBL0M7QUFFQXZRLG9EQUFJLENBQUMySyxRQUFMLENBQWM0b0MsUUFBZCxFQUF3QixLQUFLbnJDLE9BQTdCLEVBQXNDLEtBQUs2eEMsV0FBM0M7QUFFQXhuRCwrQ0FBRSxDQUFDK1gsTUFBSCxDQUFVK29DLFFBQVY7QUFDQTlnRCwrQ0FBRSxDQUFDZ0QsSUFBSCxDQUFRLEtBQUt5a0QsU0FBYjtBQUVBLFdBQUtMLFlBQUwsQ0FBa0IvNEMsT0FBbEIsQ0FBMEIsUUFBMUIsRUFBb0MsTUFBcEMsRUFBNEMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBNUM7QUFDQSxXQUFLKzRDLFlBQUwsQ0FBa0IvNEMsT0FBbEIsQ0FBMEIsUUFBMUIsRUFBb0MsT0FBcEMsRUFBNkMsRUFBN0M7O0FBQ0EsV0FBSyxJQUFJL1MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLdW1ELFdBQUwsQ0FBaUJwb0QsTUFBckMsRUFBNkM2QixDQUFDLEVBQTlDLEVBQWtEO0FBQ2pELGNBQU00c0QsTUFBTSxHQUFHLEtBQUtyRyxXQUFMLENBQWlCdm1ELENBQWpCLENBQWY7QUFDQWlTLHNEQUFJLENBQUMySyxRQUFMLENBQWM0b0MsUUFBZCxFQUF3QixLQUFLbnJDLE9BQTdCLEVBQXNDdXlDLE1BQU0sQ0FBQy92QyxNQUE3QztBQUNBblksaURBQUUsQ0FBQytYLE1BQUgsQ0FBVStvQyxRQUFWO0FBQ0E5Z0QsaURBQUUsQ0FBQ2dELElBQUgsQ0FBUWtsRCxNQUFNLENBQUN0dEQsSUFBZjtBQUNBO0FBQ0Q7QUFHRDs7QUFsSWdDOztBQXVJbkJnbEQsMkVBQWYsRTs7Ozs7Ozs7Ozs7O0FDbktBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTs7QUFFQXZpQixNQUFNLENBQUM4cUIsU0FBUCxDQUFpQkMsVUFBakIsR0FBOEIsVUFBU3BOLE1BQVQsRUFBaUJxTixXQUFqQixFQUE4QjtBQUN4RCxNQUFJbDBCLE1BQU0sR0FBRyxJQUFiO0FBQ0EsU0FBT0EsTUFBTSxDQUFDMGhCLE9BQVAsQ0FBZSxJQUFJSixNQUFKLENBQVd1RixNQUFYLEVBQW1CLEdBQW5CLENBQWYsRUFBd0NxTixXQUF4QyxDQUFQO0FBQ0gsQ0FIRDs7QUFLQSxNQUFNQyxPQUFPLEdBQUcsTUFBTTtBQUNyQnpzRCxRQUFNLENBQUNPLGdCQUFQLENBQXdCLFNBQXhCLEVBQW9DTCxDQUFELElBQU87QUFDekMsUUFBR0EsQ0FBQyxDQUFDdWxELE9BQUYsS0FBYyxFQUFkLElBQW9CdmxELENBQUMsQ0FBQ3dzRCxPQUF6QixFQUFrQztBQUNqQ3hzRCxPQUFDLENBQUNDLGNBQUY7QUFDQSxZQUFNd3NELElBQUksR0FBRyxJQUFJQyxJQUFKLEVBQWI7QUFDQSxVQUFJQyxPQUFPLEdBQ1QsR0FBRUYsSUFBSSxDQUFDRyxXQUFMLEVBQW1CLEdBQXRCLEdBQ0MsR0FBRUgsSUFBSSxDQUFDSSxRQUFMLEtBQWtCLENBQUUsR0FEdkIsR0FFQyxHQUFFSixJQUFJLENBQUNLLE9BQUwsRUFBZSxHQUZsQixHQUdDLEdBQUVMLElBQUksQ0FBQ00sUUFBTCxFQUFnQixHQUhuQixHQUlDLEdBQUVOLElBQUksQ0FBQ08sVUFBTCxFQUFrQixHQUpyQixHQUtDLEdBQUVQLElBQUksQ0FBQ1EsVUFBTCxFQUFrQixFQU50QjtBQVFBQyx5REFBUyxDQUFDanBELHlDQUFFLENBQUNnVCxNQUFKLEVBQVkwMUMsT0FBWixDQUFUO0FBQ0E7QUFDRCxHQWREO0FBZUEsQ0FoQkQ7O0FBbUJlSixzRUFBTyxFQUF0QixFOzs7Ozs7Ozs7Ozs7QUM3QkE7QUFBQTtBQUFBLE1BQU1ZLFNBQVMsR0FBSTd0RCxFQUFELElBQVE7QUFDekIsUUFBTTh0RCxlQUFlLEdBQUc5dEQsRUFBRSxDQUFDbU4sWUFBSCxDQUFnQm5OLEVBQUUsQ0FBQ3d4Qyx1QkFBbkIsQ0FBeEI7O0FBQ0EsT0FBSyxJQUFJdWMsSUFBSSxHQUFHLENBQWhCLEVBQW1CQSxJQUFJLEdBQUdELGVBQTFCLEVBQTJDQyxJQUFJLEVBQS9DLEVBQW1EO0FBQ2xEL3RELE1BQUUsQ0FBQzhQLGFBQUgsQ0FBaUI5UCxFQUFFLENBQUMrUCxRQUFILEdBQWNnK0MsSUFBL0I7QUFDQS90RCxNQUFFLENBQUMwSSxXQUFILENBQWUxSSxFQUFFLENBQUN5TSxVQUFsQixFQUE4QixJQUE5QjtBQUNBek0sTUFBRSxDQUFDMEksV0FBSCxDQUFlMUksRUFBRSxDQUFDMkksZ0JBQWxCLEVBQW9DLElBQXBDO0FBQ0E7O0FBRUQzSSxJQUFFLENBQUNnZixVQUFILENBQWNoZixFQUFFLENBQUNpZixZQUFqQixFQUErQixJQUEvQjtBQUNBamYsSUFBRSxDQUFDZ2YsVUFBSCxDQUFjaGYsRUFBRSxDQUFDeWxCLG9CQUFqQixFQUF1QyxJQUF2QztBQUNBemxCLElBQUUsQ0FBQ3lLLGdCQUFILENBQW9CekssRUFBRSxDQUFDMEssWUFBdkIsRUFBcUMsSUFBckM7QUFDQTFLLElBQUUsQ0FBQ2tLLGVBQUgsQ0FBbUJsSyxFQUFFLENBQUNtSyxXQUF0QixFQUFtQyxJQUFuQztBQUNBLENBWkQ7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFBQTtBQUFBLE1BQU02akQsYUFBYSxHQUFHLENBQUNubUQsTUFBRCxFQUFTN0gsRUFBVCxLQUFnQjtBQUNwQ0EsSUFBRSxDQUFDNlMsVUFBSCxDQUFjLElBQWQ7QUFDQTdTLElBQUUsQ0FBQ3N2QixhQUFILENBQWlCem5CLE1BQU0sQ0FBQ2lMLGFBQXhCO0FBQ0QsQ0FIRDs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQSxNQUFNd29DLFFBQVEsR0FBR3hwQyw4Q0FBSSxDQUFDb0ksTUFBTCxFQUFqQixDLENBQ0E7O0FBRUEsTUFBTXVqQyxRQUFRLEdBQUl6N0IsR0FBRCxJQUFTO0FBQ3hCbFEsZ0RBQUksQ0FBQ3FhLGFBQUwsQ0FBbUJtdkIsUUFBbkIsRUFBNkJ0NUIsR0FBN0IsRUFBa0NyZCx5Q0FBRSxDQUFDOFgsTUFBSCxDQUFVbkMsT0FBNUM7QUFDQXhJLGdEQUFJLENBQUNxYSxhQUFMLENBQW1CbXZCLFFBQW5CLEVBQTZCQSxRQUE3QixFQUF1QzMyQyx5Q0FBRSxDQUFDOFgsTUFBSCxDQUFVVSxVQUFqRDtBQUVBbStCLFVBQVEsQ0FBQyxDQUFELENBQVIsSUFBZUEsUUFBUSxDQUFDLENBQUQsQ0FBdkI7QUFDQUEsVUFBUSxDQUFDLENBQUQsQ0FBUixJQUFlQSxRQUFRLENBQUMsQ0FBRCxDQUF2QjtBQUNBQSxVQUFRLENBQUMsQ0FBRCxDQUFSLEdBQWMsQ0FBQ0EsUUFBUSxDQUFDLENBQUQsQ0FBUixHQUFjLENBQWYsSUFBb0IzMkMseUNBQUUsQ0FBQ2lGLEtBQXZCLEdBQStCLENBQTdDO0FBQ0EweEMsVUFBUSxDQUFDLENBQUQsQ0FBUixHQUFjMzJDLHlDQUFFLENBQUNrRixNQUFILEdBQVksQ0FBQ3l4QyxRQUFRLENBQUMsQ0FBRCxDQUFSLEdBQWMsQ0FBZixJQUFvQjMyQyx5Q0FBRSxDQUFDa0YsTUFBdkIsR0FBZ0MsQ0FBMUQ7QUFFQSxTQUFPeXhDLFFBQVA7QUFDRCxDQVZEOzs7Ozs7Ozs7Ozs7OztBQ05BO0FBQUE7QUFBQSxNQUFNK0csWUFBWSxHQUFHLFVBQVM0TCxFQUFULEVBQWFDLEVBQWIsRUFBaUJDLEVBQWpCLEVBQXFCQyxFQUFyQixFQUF5QjtBQUM1QyxNQUFJQyxLQUFLLEdBQUdKLEVBQUUsR0FBR0UsRUFBakI7QUFDQSxNQUFJRyxLQUFLLEdBQUdKLEVBQUUsR0FBR0UsRUFBakI7QUFFQSxTQUFPQyxLQUFLLEdBQUdBLEtBQVIsR0FBZ0JDLEtBQUssR0FBR0EsS0FBL0I7QUFDRCxDQUxEOzs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQUE7QUFBQSxNQUFNL1IsY0FBYyxHQUFHLFVBQVMwUixFQUFULEVBQWFDLEVBQWIsRUFBaUJLLEVBQWpCLEVBQXFCSixFQUFyQixFQUF5QkMsRUFBekIsRUFBNkJJLEVBQTdCLEVBQWlDO0FBQ3RELE1BQUlILEtBQUssR0FBR0osRUFBRSxHQUFHRSxFQUFqQjtBQUNBLE1BQUlHLEtBQUssR0FBR0osRUFBRSxHQUFHRSxFQUFqQjtBQUNBLE1BQUlLLEtBQUssR0FBR0YsRUFBRSxHQUFHQyxFQUFqQjtBQUVBLFNBQU9ILEtBQUssR0FBR0EsS0FBUixHQUFnQkMsS0FBSyxHQUFHQSxLQUF4QixHQUFnQ0csS0FBSyxHQUFHQSxLQUEvQztBQUNELENBTkQ7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFBQTtBQUFBLE1BQU0xRixnQkFBZ0IsR0FBSXhwRCxJQUFELElBQVU7QUFDakMsUUFBTTJuQixLQUFLLEdBQUcsRUFBZDs7QUFFQSxPQUFLLElBQUl4WCxLQUFLLEdBQUcsQ0FBakIsRUFBb0JBLEtBQUssR0FBR25RLElBQUksQ0FBQ3FoQixPQUFMLENBQWF4aUIsTUFBekMsRUFBaURzUixLQUFLLElBQUksQ0FBMUQsRUFBNkQ7QUFDM0QsVUFBTWcvQyxPQUFPLEdBQUdudkQsSUFBSSxDQUFDcWhCLE9BQUwsQ0FBYWxSLEtBQWIsQ0FBaEI7QUFDQSxVQUFNaS9DLE9BQU8sR0FBR3B2RCxJQUFJLENBQUNxaEIsT0FBTCxDQUFhbFIsS0FBSyxHQUFHLENBQXJCLENBQWhCO0FBQ0EsVUFBTWsvQyxPQUFPLEdBQUdydkQsSUFBSSxDQUFDcWhCLE9BQUwsQ0FBYWxSLEtBQUssR0FBRyxDQUFyQixDQUFoQjtBQUNBLFVBQU1rcUIsRUFBRSxHQUFHcjZCLElBQUksQ0FBQzBrQixRQUFMLENBQWN5cUMsT0FBZCxDQUFYO0FBQ0EsVUFBTWxtQixFQUFFLEdBQUdqcEMsSUFBSSxDQUFDMGtCLFFBQUwsQ0FBYzBxQyxPQUFkLENBQVg7QUFDQSxVQUFNRSxFQUFFLEdBQUd0dkQsSUFBSSxDQUFDMGtCLFFBQUwsQ0FBYzJxQyxPQUFkLENBQVg7QUFFQTFuQyxTQUFLLENBQUNub0IsSUFBTixDQUFXLENBQUM2NkIsRUFBRCxFQUFLNE8sRUFBTCxFQUFTcW1CLEVBQVQsQ0FBWDtBQUNEOztBQUVELFNBQU8zbkMsS0FBUDtBQUNELENBZkQ7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUEsTUFBTXdiLFFBQVEsR0FBRyxVQUFVQyxNQUFWLEVBQWtCdEosT0FBbEIsRUFBMkI7QUFFM0MsUUFBTTM2QixDQUFDLEdBQUcyNkIsT0FBTyxJQUFJLEVBQXJCOztBQUNBLE1BQUdzSixNQUFNLENBQUNDLE9BQVYsRUFBbUI7QUFDbEJsa0MsS0FBQyxDQUFDZ1gsQ0FBRixHQUFNaXRCLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlLENBQWYsRUFBa0JDLEtBQXhCO0FBQ0Fua0MsS0FBQyxDQUFDc2QsQ0FBRixHQUFNMm1CLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlLENBQWYsRUFBa0JFLEtBQXhCO0FBQ0EsR0FIRCxNQUdPO0FBQ05wa0MsS0FBQyxDQUFDZ1gsQ0FBRixHQUFNaXRCLE1BQU0sQ0FBQ0ksT0FBYjtBQUNBcmtDLEtBQUMsQ0FBQ3NkLENBQUYsR0FBTTJtQixNQUFNLENBQUNLLE9BQWI7QUFDQTs7QUFFRCxTQUFPdGtDLENBQVA7QUFDQSxDQVpEOzs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUEsTUFBTTRpQixDQUFDLEdBQUd2UCw4Q0FBSSxDQUFDbUksTUFBTCxFQUFWOztBQUVBLFNBQVN3QyxNQUFULENBQWdCb3lDLEdBQWhCLEVBQXFCaHlDLE1BQXJCLEVBQTZCO0FBQzVCL0ssZ0RBQUksQ0FBQzZLLElBQUwsQ0FBVTBFLENBQVYsRUFBYSxDQUFDd3RDLEdBQUcsQ0FBQyxDQUFELENBQUosRUFBU0EsR0FBRyxDQUFDLENBQUQsQ0FBWixFQUFpQkEsR0FBRyxDQUFDLENBQUQsQ0FBcEIsRUFBeUIsR0FBekIsQ0FBYjtBQUNBLzhDLGdEQUFJLENBQUNvYSxhQUFMLENBQW1CN0ssQ0FBbkIsRUFBc0JBLENBQXRCLEVBQXlCeEUsTUFBekI7QUFFQSxTQUFPL0ssOENBQUksQ0FBQzZOLEtBQUwsQ0FBVzBCLENBQVgsQ0FBUDtBQUNBOztBQUVELE1BQU1naEMsbUJBQW1CLEdBQUcsQ0FBQ2QsR0FBRCxFQUFNdDZCLEtBQU4sRUFBYXBLLE1BQWIsRUFBcUJpeUMsVUFBVSxHQUFHLEtBQWxDLEtBQTRDO0FBQ3ZFLE1BQUl6bUIsR0FBSjtBQUFTLE1BQUlDLEVBQUo7QUFBUSxNQUFJM08sRUFBSjtBQUFRLE1BQ3hCNE8sRUFEd0I7QUFHekIsTUFBSThkLFVBQUo7QUFDQSxNQUFJQyxZQUFZLEdBQUcsU0FBbkI7QUFDQSxNQUFJOWQsSUFBSjs7QUFFQSxPQUFJLElBQUl4b0MsQ0FBQyxHQUFHLENBQVosRUFBZUEsQ0FBQyxHQUFHaW5CLEtBQUssQ0FBQzlvQixNQUF6QixFQUFpQzZCLENBQUMsRUFBbEMsRUFBc0M7QUFDckMsVUFBTSt1RCxPQUFPLEdBQUc5bkMsS0FBSyxDQUFDam5CLENBQUQsQ0FBTCxDQUFTLENBQVQsQ0FBaEI7QUFDQSxVQUFNZ3ZELFFBQVEsR0FBRy9uQyxLQUFLLENBQUNqbkIsQ0FBRCxDQUFMLENBQVMsQ0FBVCxDQUFqQjtBQUNBLFVBQU1pdkQsUUFBUSxHQUFHaG9DLEtBQUssQ0FBQ2puQixDQUFELENBQUwsQ0FBUyxDQUFULENBQWpCOztBQUVBLFFBQUk2YyxNQUFKLEVBQVk7QUFDWHlyQixRQUFFLEdBQUc3ckIsTUFBTSxDQUFDc3lDLE9BQUQsRUFBVWx5QyxNQUFWLENBQVg7QUFDQThjLFFBQUUsR0FBR2xkLE1BQU0sQ0FBQ3V5QyxRQUFELEVBQVdueUMsTUFBWCxDQUFYO0FBQ0EwckIsUUFBRSxHQUFHOXJCLE1BQU0sQ0FBQ3d5QyxRQUFELEVBQVdweUMsTUFBWCxDQUFYO0FBQ0EsS0FKRCxNQUlPO0FBQ055ckIsUUFBRSxHQUFHeW1CLE9BQUw7QUFDQXAxQixRQUFFLEdBQUdxMUIsUUFBTDtBQUNBem1CLFFBQUUsR0FBRzBtQixRQUFMO0FBQ0E7O0FBRUQ1bUIsT0FBRyxHQUFHa1osR0FBRyxDQUFDNW1CLGlCQUFKLENBQXNCMk4sRUFBdEIsRUFBMEIzTyxFQUExQixFQUE4QjRPLEVBQTlCLEVBQWtDLEtBQWxDLENBQU47O0FBR0EsUUFBR0YsR0FBSCxFQUFRO0FBQ1AsVUFBSXltQixVQUFKLEVBQWdCO0FBQ1h0bUIsWUFBSSxHQUFHOFQsNERBQWMsQ0FBQ2lGLEdBQUcsQ0FBQ24xQixNQUFKLENBQVcsQ0FBWCxDQUFELEVBQWdCbTFCLEdBQUcsQ0FBQ24xQixNQUFKLENBQVcsQ0FBWCxDQUFoQixFQUErQm0xQixHQUFHLENBQUNuMUIsTUFBSixDQUFXLENBQVgsQ0FBL0IsRUFBOENpYyxHQUFHLENBQUMsQ0FBRCxDQUFqRCxFQUFzREEsR0FBRyxDQUFDLENBQUQsQ0FBekQsRUFBOERBLEdBQUcsQ0FBQyxDQUFELENBQWpFLENBQXJCOztBQUVKLFlBQUlHLElBQUksR0FBRzhkLFlBQVgsRUFBeUI7QUFDeEJBLHNCQUFZLEdBQUc5ZCxJQUFmO0FBQ0E2ZCxvQkFBVSxHQUFHLENBQUMsR0FBR2hlLEdBQUosQ0FBYjtBQUNBO0FBQ0QsT0FQRCxNQU9PO0FBQ04sZUFBT0EsR0FBUDtBQUNBO0FBQ0Q7O0FBQUE7QUFDRDs7QUFFRCxTQUFPZ2UsVUFBUDtBQUNBLENBekNEOzs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQUE7QUFBQSxNQUFNN25ELEdBQUcsR0FBRyxDQUFDNjdDLEdBQUQsRUFBTTZVLFFBQU4sRUFBZ0JDLFFBQWhCLEVBQTBCQyxTQUExQixFQUFxQ0MsU0FBckMsS0FBb0QsQ0FBQ0EsU0FBUyxHQUFHRCxTQUFiLEtBQTJCLENBQUMvVSxHQUFHLEdBQUc2VSxRQUFQLEtBQW9CQyxRQUFRLEdBQUdELFFBQS9CLENBQTNCLENBQUQsR0FBeUVFLFNBQXhJOzs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtDQUVBOztBQUNBOztBQUVBLE1BQU1FLGVBQWUsR0FBRyxNQUFNLElBQUloK0IsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUM5RCxRQUFNandCLEdBQUcsR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQVo7O0FBRUFGLEtBQUcsQ0FBQ0csTUFBSixHQUFhLE1BQU07QUFDbEJsQyxXQUFPLENBQUNDLEdBQVIsQ0FBWSxZQUFaLEVBQTBCOEIsR0FBMUI7QUFDQWd3QixXQUFPLENBQUNod0IsR0FBRCxDQUFQO0FBQ0EsR0FIRDs7QUFLQUEsS0FBRyxDQUFDSSxHQUFKLEdBQVUsNEJBQVY7QUFDQSxDQVQ2QixDQUE5Qjs7QUFZQSxNQUFNNHRELFVBQVUsR0FBRyxDQUFDenNELE9BQU8sR0FBRyxFQUFYLEtBQWtCLElBQUl3dUIsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUNyRTtBQUNBLFFBQU05WixNQUFNLEdBQUdsVyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjtBQUNBLFFBQU15c0IsU0FBUyxHQUFHcHJCLE9BQU8sQ0FBQ29yQixTQUFSLElBQXFCMXNCLFFBQVEsQ0FBQ3lqRCxJQUFULENBQWMxQyxhQUFkLENBQTRCLFlBQTVCLENBQXZDO0FBQ0E3cUMsUUFBTSxDQUFDZ2xDLFNBQVAsR0FBbUIsYUFBbkI7QUFDQXh1QixXQUFTLENBQUM4dUIsV0FBVixDQUFzQnRsQyxNQUF0QixFQUxxRSxDQU9yRTs7QUFDQWhULDJDQUFFLENBQUN0RyxJQUFILENBQVFzWixNQUFSLEVBQWdCO0FBQUU4M0MsZ0JBQVksRUFBRSxLQUFoQjtBQUF1QkMseUJBQXFCLEVBQUU7QUFBOUMsR0FBaEI7QUFFQWwrQixTQUFPO0FBQ1AsQ0FYb0MsQ0FBckM7O0FBYUEsTUFBTW0rQixpQkFBaUIsR0FBRyxNQUFNLElBQUlwK0IsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUNoRWh5QixTQUFPLENBQUNDLEdBQVIsQ0FBWSwwQkFBWjtBQUNBOHhCLFNBQU87QUFDUCxDQUgrQixDQUFoQzs7QUFLQSxNQUFNbytCLFVBQVUsR0FBSW55RCxNQUFELElBQVksSUFBSTh6QixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQy9EaHlCLFNBQU8sQ0FBQ0MsR0FBUixDQUFZLGFBQVo7O0FBQ0EsTUFBSWpDLE1BQU0sQ0FBQ1csTUFBUCxHQUFnQixDQUFwQixFQUF1QjtBQUN0QnFELFlBQVEsQ0FBQ3lqRCxJQUFULENBQWMySyxTQUFkLENBQXdCOXRELEdBQXhCLENBQTRCLFdBQTVCO0FBRUEsUUFBSSt0RCxvREFBSixDQUFpQjtBQUNoQnJ5RDtBQURnQixLQUFqQixFQUdFb2hDLEVBSEYsQ0FHSyxPQUhMLEVBR2U3eEIsS0FBRCxJQUFXO0FBQ3ZCdk4sYUFBTyxDQUFDQyxHQUFSLENBQVksU0FBWixFQUF1QnNOLEtBQXZCO0FBQ0EsS0FMRixFQU1FNnhCLEVBTkYsQ0FNSyxVQU5MLEVBTWtCNkssQ0FBRCxJQUFPO0FBQ3RCO0FBQ0EsWUFBTTdRLE1BQU0sR0FBR3AzQixRQUFRLENBQUN5akQsSUFBVCxDQUFjMUMsYUFBZCxDQUE0QixjQUE1QixDQUFmO0FBQ0EsVUFBSTNwQixNQUFKLEVBQVlBLE1BQU0sQ0FBQ3lrQixLQUFQLENBQWExekMsS0FBYixHQUFzQixHQUFHOC9CLENBQUMsR0FBRyxHQUFLLEdBQWxDO0FBQ1osS0FWRixFQVdFN0ssRUFYRixDQVdLLFVBWEwsRUFXa0JuZ0MsQ0FBRCxJQUFPO0FBQ3RCOHlCLGFBQU8sQ0FBQzl5QixDQUFELENBQVA7QUFDQSxLQWJGLEVBY0U4dkIsS0FkRjtBQWVBLEdBbEJELE1Ba0JPO0FBQ05nRCxXQUFPLENBQUMsRUFBRCxDQUFQO0FBQ0E7QUFDRCxDQXZCOEIsQ0FBL0I7O0FBeUJBLE1BQU11K0IsZUFBZSxHQUFHLENBQUNodEQsT0FBTyxHQUFHLEVBQVgsS0FBa0IsSUFBSXd1QixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQzFFaHlCLFNBQU8sQ0FBQ0MsR0FBUixDQUFZLGFBQVo7O0FBQ0EsTUFBSXFELE9BQU8sQ0FBQ3RGLE1BQVIsQ0FBZVcsTUFBZixHQUF3QixDQUE1QixFQUErQjtBQUM5QnFELFlBQVEsQ0FBQ3lqRCxJQUFULENBQWMySyxTQUFkLENBQXdCOXRELEdBQXhCLENBQTRCLFdBQTVCO0FBR0EsVUFBTWl1RCxhQUFhLEdBQUdqdEQsT0FBTyxDQUFDdEYsTUFBUixDQUFlZ0IsR0FBZixDQUFvQnd4RCxLQUFELElBQVU7QUFDbERBLFdBQUssQ0FBQ3J4RCxHQUFOLEdBQVksQ0FBQ21FLE9BQU8sQ0FBQ210RCxVQUFSLElBQXNCLEVBQXZCLElBQThCRCxLQUFLLENBQUNyeEQsR0FBaEQ7QUFFQSxhQUFPcXhELEtBQVA7QUFDQSxLQUpxQixDQUF0QjtBQU1BLFFBQUlILG9EQUFKLENBQWlCO0FBQ2hCcnlELFlBQU0sRUFBRXV5RDtBQURRLEtBQWpCLEVBR0VueEIsRUFIRixDQUdLLE9BSEwsRUFHZTd4QixLQUFELElBQVc7QUFDdkJ2TixhQUFPLENBQUNDLEdBQVIsQ0FBWSxTQUFaLEVBQXVCc04sS0FBdkI7QUFDQSxLQUxGLEVBTUU2eEIsRUFORixDQU1LLFVBTkwsRUFNa0I2SyxDQUFELElBQU87QUFDdEI7QUFDQSxVQUFJM21DLE9BQU8sQ0FBQ290RCxVQUFaLEVBQXdCcHRELE9BQU8sQ0FBQ290RCxVQUFSO0FBQ3hCLEtBVEYsRUFVRXR4QixFQVZGLENBVUssVUFWTCxFQVVrQm5nQyxDQUFELElBQU87QUFDdEIsVUFBSXFFLE9BQU8sQ0FBQ3FCLFVBQVosRUFBd0JyQixPQUFPLENBQUNxQixVQUFSO0FBQ3hCb3RCLGFBQU8sQ0FBQzl5QixDQUFELENBQVA7QUFDQSxLQWJGLEVBY0U4dkIsS0FkRjtBQWVBLEdBekJELE1BeUJPO0FBQ05nRCxXQUFPLENBQUMsRUFBRCxDQUFQO0FBQ0E7QUFDRCxDQTlCeUMsQ0FBMUM7O0FBZ0NBLE1BQU00K0IsVUFBVSxHQUFHLENBQUNDLFVBQUQsRUFBYS94RCxPQUFiLEtBQXlCLElBQUlpekIsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUM1RWh5QixTQUFPLENBQUNDLEdBQVIsQ0FBWSxhQUFaLEVBQTJCcEIsT0FBM0I7QUFDQSxRQUFNdTZCLE1BQU0sR0FBR3AzQixRQUFRLENBQUN5akQsSUFBVCxDQUFjMUMsYUFBZCxDQUE0QixjQUE1QixDQUFmO0FBQ0EzcEIsUUFBTSxDQUFDeWtCLEtBQVAsQ0FBYTF6QyxLQUFiLEdBQXFCLE1BQXJCLENBSDRFLENBSzVFOztBQUNBck0saURBQU0sQ0FBQ2MsSUFBUCxDQUFZQyxPQUFaLEVBQXFCK3hELFVBQXJCO0FBRUE3K0IsU0FBTztBQUNQLENBVDJDLENBQTVDOztBQVdBLE1BQU04K0IsZUFBZSxHQUFHLENBQUNELFVBQUQsRUFBYS94RCxPQUFiLEtBQXlCLElBQUlpekIsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUNqRmh5QixTQUFPLENBQUNDLEdBQVIsQ0FBWSxhQUFaLEVBQTJCcEIsT0FBM0IsRUFEaUYsQ0FFakY7O0FBQ0FmLGlEQUFNLENBQUNjLElBQVAsQ0FBWUMsT0FBWixFQUFxQit4RCxVQUFyQjtBQUVBNytCLFNBQU87QUFDUCxDQU5nRCxDQUFqRDs7QUFRQSxNQUFNKytCLGdCQUFnQixHQUFHLE1BQU0sSUFBSWgvQixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQy9EaHlCLFNBQU8sQ0FBQ0MsR0FBUixDQUFZLHlCQUFaO0FBQ0E4L0MsWUFBVSxDQUFDLE1BQU07QUFDaEIvOUMsWUFBUSxDQUFDeWpELElBQVQsQ0FBYzJLLFNBQWQsQ0FBd0JXLE1BQXhCLENBQStCLFdBQS9CO0FBQ0EsR0FGUyxFQUVQLEdBRk8sQ0FBVjtBQUlBaFIsWUFBVSxDQUFDLE1BQU07QUFDaEJodUIsV0FBTztBQUNQLEdBRlMsRUFFUCxHQUZPLENBQVY7QUFHQSxDQVQ4QixDQUEvQjs7QUFXQSxNQUFNMnpCLE9BQU8sR0FBSXBpRCxPQUFELElBQWEsSUFBSXd1QixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQzdEaHlCLFNBQU8sQ0FBQ0MsR0FBUixDQUFZLFNBQVosRUFBdUJxRCxPQUF2QjtBQUNBeXNELFlBQVUsR0FDUjE5QixJQURGLENBQ095OUIsZUFEUCxFQUVFejlCLElBRkYsQ0FFTzY5QixpQkFGUCxFQUdFNzlCLElBSEYsQ0FHTzg5QixVQUFVLENBQUNob0QsSUFBWCxDQUFnQixJQUFoQixFQUFzQjdFLE9BQU8sQ0FBQ3RGLE1BQTlCLENBSFAsRUFJRXEwQixJQUpGLENBSU9zK0IsVUFBVSxDQUFDeG9ELElBQVgsQ0FBZ0IsSUFBaEIsRUFBc0I3RSxPQUFPLENBQUN0RixNQUE5QixDQUpQLEVBS0VxMEIsSUFMRixDQUtPeStCLGdCQUxQLEVBTUV6K0IsSUFORixDQU1PLE1BQU07QUFDWE4sV0FBTztBQUNQLEdBUkYsRUFTRVMsS0FURixDQVNTdnhCLENBQUQsSUFBTztBQUNiakIsV0FBTyxDQUFDQyxHQUFSLENBQVksT0FBWixFQUFxQmdCLENBQXJCO0FBQ0EsR0FYRjtBQVlBLENBZDRCLENBQTdCOztBQWdCTyxNQUFNK3ZELFlBQVksR0FBSTF0RCxPQUFELElBQWEsSUFBSXd1QixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3pFKzlCLFlBQVUsQ0FBQ3pzRCxPQUFELENBQVYsQ0FDRSt1QixJQURGLENBQ09pK0IsZUFBZSxDQUFDbm9ELElBQWhCLENBQXFCLElBQXJCLEVBQTJCN0UsT0FBM0IsQ0FEUCxFQUVFK3VCLElBRkYsQ0FFT3crQixlQUFlLENBQUMxb0QsSUFBaEIsQ0FBcUIsSUFBckIsRUFBMkI3RSxPQUFPLENBQUN0RixNQUFuQyxDQUZQLEVBR0VxMEIsSUFIRixDQUdPLE1BQU07QUFDWE4sV0FBTztBQUNQLEdBTEYsRUFNRVMsS0FORixDQU1TdnhCLENBQUQsSUFBTztBQUNiakIsV0FBTyxDQUFDQyxHQUFSLENBQVksT0FBWixFQUFxQmdCLENBQXJCO0FBQ0EsR0FSRjtBQVNBLENBVndDLENBQWxDO0FBWVF5a0Qsc0VBQWYsRTs7Ozs7Ozs7Ozs7O0FDeEpBO0FBQUE7QUFBQTtBQUFBO0FBRUE7O0FBRUEsTUFBTS8yQixNQUFNLEdBQUcsQ0FBQ3ZZLENBQUQsRUFBSUUsQ0FBSixFQUFPMjZDLGNBQVAsRUFBdUJDLGVBQXZCLEtBQTRDO0FBRTFERCxnQkFBYyxJQUFJbHdELE1BQU0sQ0FBQzBhLFVBQXpCO0FBQ0F5MUMsaUJBQWUsSUFBSW53RCxNQUFNLENBQUMyYSxXQUExQjtBQUVBdEYsR0FBQyxHQUFhQSxDQUFDLElBQUk2NkMsY0FBbkI7QUFDQTM2QyxHQUFDLEdBQWFBLENBQUMsSUFBSTQ2QyxlQUFuQjtBQUVBaHNELDJDQUFFLENBQUNzVyxPQUFILENBQVdwRixDQUFYLEVBQWNFLENBQWQ7QUFDQSxNQUFJNjZDLEVBQUUsR0FBUWpnRCxJQUFJLENBQUNOLEdBQUwsQ0FBU3dGLENBQVQsRUFBWTY2QyxjQUFaLENBQWQ7QUFDQSxNQUFJRyxFQUFFLEdBQVFsZ0QsSUFBSSxDQUFDTixHQUFMLENBQVMwRixDQUFULEVBQVk0NkMsZUFBWixDQUFkO0FBRUEsUUFBTTF2QyxFQUFFLEdBQU15dkMsY0FBYyxHQUFHNzZDLENBQS9CO0FBQ0EsUUFBTXFMLEVBQUUsR0FBTXl2QyxlQUFlLEdBQUc1NkMsQ0FBaEM7QUFDQSxRQUFNNFcsS0FBSyxHQUFHaGMsSUFBSSxDQUFDTixHQUFMLENBQVM0USxFQUFULEVBQWFDLEVBQWIsQ0FBZDtBQUNBMHZDLElBQUUsR0FBWS82QyxDQUFDLEdBQUc4VyxLQUFsQjtBQUNBa2tDLElBQUUsR0FBWTk2QyxDQUFDLEdBQUc0VyxLQUFsQjtBQUVBaG9CLDJDQUFFLENBQUNnVCxNQUFILENBQVUybEMsS0FBVixDQUFnQjF6QyxLQUFoQixHQUEwQixHQUFFZ25ELEVBQUcsSUFBL0I7QUFDQWpzRCwyQ0FBRSxDQUFDZ1QsTUFBSCxDQUFVMmxDLEtBQVYsQ0FBZ0J6ekMsTUFBaEIsR0FBMEIsR0FBRWduRCxFQUFHLElBQS9CO0FBQ0EsQ0FwQkQ7Ozs7Ozs7Ozs7Ozs7O0FDSkE7QUFBQTtBQUFBO0FBRUEsTUFBTUMsY0FBYyxHQUFHLEtBQXZCO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLFlBQWxCOztBQUdBLE1BQU1DLGFBQWEsR0FBSUMsT0FBRCxJQUFhO0FBQy9CLE1BQUlwN0IsR0FBRyxHQUFHbzdCLE9BQU8sQ0FBQzl5RCxLQUFSLENBQWMsR0FBZCxDQUFWO0FBQUEsTUFBOEIreUQsSUFBSSxHQUFHcjdCLEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBT3VNLEtBQVAsQ0FBYSxTQUFiLEVBQXdCLENBQXhCLENBQXJDO0FBQUEsTUFDSSt1QixJQUFJLEdBQUdDLElBQUksQ0FBQ3Y3QixHQUFHLENBQUMsQ0FBRCxDQUFKLENBRGY7QUFBQSxNQUN5QnMwQixDQUFDLEdBQUdnSCxJQUFJLENBQUMveUQsTUFEbEM7QUFBQSxNQUMwQ2l6RCxLQUFLLEdBQUcsSUFBSTUzQyxVQUFKLENBQWUwd0MsQ0FBZixDQURsRDs7QUFFQSxTQUFNQSxDQUFDLEVBQVAsRUFBVTtBQUNOa0gsU0FBSyxDQUFDbEgsQ0FBRCxDQUFMLEdBQVdnSCxJQUFJLENBQUNHLFVBQUwsQ0FBZ0JuSCxDQUFoQixDQUFYO0FBQ0g7O0FBQ0QsU0FBTyxJQUFJb0gsSUFBSixDQUFTLENBQUNGLEtBQUQsQ0FBVCxFQUFrQjtBQUFDampELFFBQUksRUFBQzhpRDtBQUFOLEdBQWxCLENBQVA7QUFDSCxDQVBEOztBQVNBLE1BQU10RCxTQUFTLEdBQUcsQ0FBQ2oyQyxNQUFELEVBQVM2NUMsUUFBVCxLQUFzQjtBQUV2QyxNQUFJQyxJQUFJLEdBQUdod0QsUUFBUSxDQUFDQyxhQUFULENBQXVCLEdBQXZCLENBQVg7QUFDQSxNQUFJZ3dELE9BQU8sR0FBRy81QyxNQUFNLENBQUNnNkMsU0FBUCxDQUFpQjtBQUM5QnhqRCxVQUFNLEVBQUUsS0FEc0I7QUFFOUJ5akQsY0FBVSxFQUFFO0FBRmtCLEdBQWpCLENBQWQsQ0FIdUMsQ0FNdkM7O0FBQ0EsTUFBSUMsSUFBSSxHQUFHYixhQUFhLENBQUNVLE9BQUQsQ0FBeEI7QUFDQSxNQUFJSSxNQUFNLEdBQUdDLEdBQUcsQ0FBQ0MsZUFBSixDQUFvQkgsSUFBcEIsQ0FBYjtBQUVBSixNQUFJLENBQUNRLFFBQUwsR0FBaUIsR0FBRVQsUUFBUyxNQUE1QjtBQUVBQyxNQUFJLENBQUMzUyxJQUFMLEdBQVlnVCxNQUFaO0FBRUFMLE1BQUksQ0FBQ1MsS0FBTDtBQUNBLENBZkQ7Ozs7Ozs7Ozs7Ozs7O0FDZkE7QUFBQTtBQUFBO0FBRUEsTUFBTXhLLFFBQVEsR0FBRyxDQUFDOXhDLEdBQUQsRUFBTTNDLEtBQUssR0FBQyxPQUFaLEVBQXFCay9DLE9BQU8sR0FBQyxJQUE3QixLQUFzQztBQUN0RCxNQUFJQyxHQUFHLEdBQUdELE9BQU8sR0FBR25ULElBQUksQ0FBQ0MsU0FBTCxDQUFlcnBDLEdBQWYsRUFBb0IsSUFBcEIsRUFBMEIsQ0FBMUIsQ0FBSCxHQUFrQ29wQyxJQUFJLENBQUNDLFNBQUwsQ0FBZXJwQyxHQUFmLENBQW5EO0FBQ0EsTUFBSS9GLElBQUksR0FBR3dpRCxNQUFNLENBQUVELEdBQUYsQ0FBakI7QUFFQSxNQUFJUCxJQUFJLEdBQUcsSUFBSU4sSUFBSixDQUFVLENBQUUxaEQsSUFBRixDQUFWLEVBQW9CO0FBQzlCekIsUUFBSSxFQUFFO0FBRHdCLEdBQXBCLENBQVg7QUFJQSxNQUFJeFAsR0FBRyxHQUFHbXpELEdBQUcsQ0FBQ0MsZUFBSixDQUFxQkgsSUFBckIsQ0FBVjtBQUNBLE1BQUlKLElBQUksR0FBR2h3RCxRQUFRLENBQUNDLGFBQVQsQ0FBd0IsR0FBeEIsQ0FBWDtBQUNBK3ZELE1BQUksQ0FBQ2EsWUFBTCxDQUFtQixNQUFuQixFQUEyQjF6RCxHQUEzQjtBQUNBNnlELE1BQUksQ0FBQ2EsWUFBTCxDQUFtQixVQUFuQixFQUFnQyxHQUFFci9DLEtBQU0sT0FBeEM7QUFDQSxNQUFJK3lDLEtBQUssR0FBR3ZrRCxRQUFRLENBQUNnOUIsV0FBVCxDQUFzQixhQUF0QixDQUFaO0FBQ0F1bkIsT0FBSyxDQUFDdU0sY0FBTixDQUFzQixPQUF0QixFQUErQixJQUEvQixFQUFxQyxJQUFyQyxFQUEyQy94RCxNQUEzQyxFQUFtRCxDQUFuRCxFQUFzRCxDQUF0RCxFQUF5RCxDQUF6RCxFQUE0RCxDQUE1RCxFQUErRCxDQUEvRCxFQUFrRSxLQUFsRSxFQUF5RSxLQUF6RSxFQUFnRixLQUFoRixFQUF1RixLQUF2RixFQUE4RixDQUE5RixFQUFpRyxJQUFqRztBQUNBaXhELE1BQUksQ0FBQ3h5QixhQUFMLENBQW9CK21CLEtBQXBCO0FBQ0EsQ0FmRDs7QUFrQkEsTUFBTXFNLE1BQU0sR0FBSzF5RCxDQUFGLElBQVM7QUFDdkIsTUFBSW9xQyxHQUFHLEdBQUcsRUFBVjs7QUFDQSxPQUFNLElBQUk5cEMsQ0FBQyxHQUFHLENBQWQsRUFBaUJBLENBQUMsR0FBR04sQ0FBQyxDQUFDdkIsTUFBdkIsRUFBK0I2QixDQUFDLEVBQWhDLEVBQXFDO0FBQ3BDOHBDLE9BQUcsQ0FBQzlwQyxDQUFELENBQUgsR0FBU04sQ0FBQyxDQUFDMnhELFVBQUYsQ0FBYXJ4RCxDQUFiLENBQVQ7QUFDQTs7QUFDRCxTQUFPLElBQUl3WixVQUFKLENBQWdCc3dCLEdBQWhCLENBQVA7QUFDQSxDQU5EOzs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUFBO0FBQUEsTUFBTXlvQixhQUFhLEdBQUcsQ0FBQ3BzQixLQUFELEVBQVFxc0IsV0FBUixLQUF3QjtBQUM1Q0EsYUFBVyxJQUFJOWhELElBQUksQ0FBQ29SLEVBQUwsR0FBVSxDQUF6QjtBQUNBcWtCLE9BQUssSUFBSXoxQixJQUFJLENBQUNvUixFQUFMLEdBQVUsQ0FBbkI7QUFDQSxNQUFJcWtCLEtBQUssR0FBRyxDQUFaLEVBQWNBLEtBQUssSUFBSXoxQixJQUFJLENBQUNvUixFQUFMLEdBQVUsQ0FBbkI7QUFDZCxNQUFJMHdDLFdBQVcsR0FBRyxDQUFsQixFQUFvQkEsV0FBVyxJQUFJOWhELElBQUksQ0FBQ29SLEVBQUwsR0FBVSxDQUF6QjtBQUNwQixNQUFJMndDLFdBQVcsR0FBR0QsV0FBVyxHQUFHcnNCLEtBQWhDO0FBQ0EsTUFBSXVzQixXQUFXLEdBQUlGLFdBQVcsR0FBSTloRCxJQUFJLENBQUNvUixFQUFMLEdBQVUsQ0FBMUIsR0FBZ0Nxa0IsS0FBbEQ7QUFDQSxNQUFJd3NCLFdBQVcsR0FBSUgsV0FBVyxHQUFJOWhELElBQUksQ0FBQ29SLEVBQUwsR0FBVSxDQUExQixHQUFnQ3FrQixLQUFsRDtBQUNBLE1BQUl5c0IsY0FBYyxHQUFHbGlELElBQUksQ0FBQ290QixHQUFMLENBQVMyMEIsV0FBVCxDQUFyQjtBQUNBLE1BQUlJLGNBQWMsR0FBR25pRCxJQUFJLENBQUNvdEIsR0FBTCxDQUFTNDBCLFdBQVQsQ0FBckI7QUFDQSxNQUFJSSxjQUFjLEdBQUdwaUQsSUFBSSxDQUFDb3RCLEdBQUwsQ0FBUzYwQixXQUFULENBQXJCO0FBQ0EsTUFBSUksVUFBVSxHQUFHTixXQUFqQjs7QUFDQSxNQUFJSSxjQUFjLEdBQUdELGNBQWpCLElBQW1DQyxjQUFjLEdBQUdDLGNBQXhELEVBQXdFO0FBQ3RFQyxjQUFVLEdBQUdMLFdBQWI7QUFDRCxHQUZELE1BRU8sSUFBSUksY0FBYyxHQUFHRixjQUFqQixJQUFtQ0UsY0FBYyxHQUFHRCxjQUF4RCxFQUF3RTtBQUM3RUUsY0FBVSxHQUFHSixXQUFiO0FBQ0Q7O0FBQ0QsU0FBT0ksVUFBUDtBQUNELENBbEJEOzs7Ozs7Ozs7Ozs7OztBQ0NBLGNBQWMsbUJBQU8sQ0FBQyxnTkFBc0c7O0FBRTVILDRDQUE0QyxRQUFTOztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxzR0FBbUQ7O0FBRXhFOztBQUVBLEdBQUcsS0FBVSxFQUFFLEU7Ozs7Ozs7Ozs7OztBQ2xCZixjQUFjLG1CQUFPLENBQUMsME5BQTJHOztBQUVqSSw0Q0FBNEMsUUFBUzs7QUFFckQ7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsc0dBQW1EOztBQUV4RTs7QUFFQSxHQUFHLEtBQVUsRUFBRSxFOzs7Ozs7Ozs7Ozs7QUNuQmY7QUFBZSx1R0FBd0Msb0RBQW9ELCtCQUErQiw4QkFBOEIsMkJBQTJCLGlDQUFpQywrQkFBK0IscUJBQXFCLGdHQUFnRyxvQ0FBb0MsR0FBRyxDOzs7Ozs7Ozs7Ozs7QUNBL1o7QUFBZSw0SUFBNkUseUNBQXlDLHVCQUF1Qiw2QkFBNkIscUJBQXFCLDBDQUEwQyxHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0EzUDtBQUFlLHNGQUF1QixrREFBa0QsdUJBQXVCLHlCQUF5QixvQkFBb0Isb0NBQW9DLEdBQUcsQzs7Ozs7Ozs7Ozs7O0FDQW5NO0FBQWUsc0dBQXVDLGdEQUFnRCw4QkFBOEIsNEJBQTRCLG1DQUFtQyxpQ0FBaUMsMEJBQTBCLHNCQUFzQiw0QkFBNEIsK0JBQStCLHdCQUF3Qix5QkFBeUIsK0JBQStCLG1DQUFtQyxpREFBaUQsb0RBQW9ELGdEQUFnRCw4Q0FBOEMsa0RBQWtELDBDQUEwQywrQ0FBK0MsR0FBRyxtQ0FBbUMsaUNBQWlDLG1DQUFtQyw4QkFBOEIseUJBQXlCLGdDQUFnQyxpQkFBaUIsYUFBYSw0RUFBNEUsaUVBQWlFLDBCQUEwQixpQkFBaUIsaUJBQWlCLGdGQUFnRixxRUFBcUUsK0JBQStCLGtHQUFrRyxXQUFXLE9BQU8seUJBQXlCLEdBQUcsb0JBQW9CLHVEQUF1RCw2QkFBNkIsaUZBQWlGLE9BQU8sQzs7Ozs7Ozs7Ozs7O0FDQTVyRDtBQUFlLHNGQUF1QixvREFBb0QsK0JBQStCLHlCQUF5Qix5QkFBeUIsNEJBQTRCLDJCQUEyQixpQ0FBaUMsNkJBQTZCLCtCQUErQix1QkFBdUIsOEJBQThCLDhCQUE4QixvQkFBb0Isa0VBQWtFLGdGQUFnRix5REFBeUQscUNBQXFDLDREQUE0RCxHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0FydEI7QUFBZSw0SEFBNkQseUNBQXlDLHVCQUF1Qiw2QkFBNkIsMEJBQTBCLHFCQUFxQix1Q0FBdUMsK0NBQStDLEdBQUcsQzs7Ozs7Ozs7Ozs7O0FDQWpUO0FBQWUsc0ZBQXVCLHNEQUFzRCwrQkFBK0IsNkJBQTZCLDJCQUEyQix1QkFBdUIsNEJBQTRCLHlCQUF5Qiw4QkFBOEIsMkJBQTJCLGlDQUFpQyxzQkFBc0IsNEJBQTRCLHVCQUF1QixxQkFBcUIseUJBQXlCLHNCQUFzQix1QkFBdUIsMEJBQTBCLGlCQUFpQiw4QkFBOEIsa0JBQWtCLHlDQUF5Qyx3RUFBd0UsNEJBQTRCLGdHQUFnRywrR0FBK0csOEVBQThFLHVDQUF1QyxzQkFBc0Isd0JBQXdCLDJJQUEySSxpRkFBaUYscUVBQXFFLDRCQUE0Qix3QkFBd0IsNkJBQTZCLG9EQUFvRCxnREFBZ0QscUNBQXFDLGtDQUFrQyx5QkFBeUIsMENBQTBDLGtEQUFrRCxLQUFLLDJDQUEyQyxzREFBc0QsS0FBSyxVQUFVLGdIQUFnSCx1QkFBdUIsNERBQTRELG9HQUFvRywwQ0FBMEMsaURBQWlELHNCQUFzQiwyQ0FBMkMsT0FBTyxPQUFPLG1CQUFtQixTQUFTLEtBQUssc0NBQXNDLCtCQUErQix1QkFBdUIsc0JBQXNCLDBEQUEwRCw4Q0FBOEMsR0FBRyxHOzs7Ozs7Ozs7Ozs7QUNBN2lGO0FBQWUsdUdBQXdDLG9EQUFvRCw0QkFBNEIsK0JBQStCLHlCQUF5Qiw4QkFBOEIsMkJBQTJCLGlDQUFpQyx1QkFBdUIsc0JBQXNCLCtCQUErQix1QkFBdUIscUJBQXFCLDBDQUEwQyw2Q0FBNkMsNEJBQTRCLDhCQUE4QixzRkFBc0Ysb0NBQW9DLHdCQUF3QixHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0F2ckI7QUFBZSx1TkFBd0osb0RBQW9ELG1DQUFtQyxxQ0FBcUMseURBQXlELDhEQUE4RCxtQ0FBbUMsK0RBQStELDZCQUE2QixtRUFBbUUsK0JBQStCLDRDQUE0QyxpQ0FBaUMsMkJBQTJCLDBCQUEwQixrQ0FBa0MsNkJBQTZCLGdDQUFnQyw0QkFBNEIsMkJBQTJCLDBCQUEwQiwrQkFBK0IsdUJBQXVCLGlDQUFpQyx5QkFBeUIsMlZBQTJWLGdCQUFnQixpRkFBaUYsZ0ZBQWdGLDZFQUE2RSxzRkFBc0YsbUdBQW1HLDhGQUE4RixvRUFBb0UscUZBQXFGLHlFQUF5RSw2R0FBNkcsOEVBQThFLDJEQUEyRCx5Q0FBeUMsb0NBQW9DLHFDQUFxQyxvR0FBb0csbUZBQW1GLDRHQUE0RyxzRUFBc0UseUNBQXlDLDJCQUEyQixzQkFBc0Isa0NBQWtDLGtDQUFrQyxpREFBaUQsaURBQWlELG1HQUFtRyxtQ0FBbUMseUNBQXlDLHFDQUFxQyw4QkFBOEIsOEVBQThFLG1GQUFtRixvSEFBb0gsdUJBQXVCLEdBQUcsMEVBQTBFLHlCQUF5QixvRkFBb0YsMktBQTJLLHlFQUF5RSwwSEFBMEgsMkdBQTJHLDRGQUE0RixnR0FBZ0cscUVBQXFFLGdGQUFnRixnR0FBZ0csbUNBQW1DLGdDQUFnQyxHQUFHLHNDQUFzQyx5Q0FBeUMsR0FBRyxpREFBaUQsMElBQTBJLEdBQUcsa0RBQWtELGtDQUFrQyxrQ0FBa0MsdUNBQXVDLGlHQUFpRywrRkFBK0YsdUNBQXVDLEdBQUcsc0RBQXNELDRFQUE0RSx3RkFBd0Ysd0NBQXdDLEdBQUcsaUJBQWlCLGtGQUFrRiw0Q0FBNEMsa0ZBQWtGLDREQUE0RCw0RUFBNEUsb0dBQW9HLCtEQUErRCwwREFBMEQsbUVBQW1FLGtEQUFrRCxtRUFBbUUsNkhBQTZILHNVQUFzVSxvREFBb0Qsc0VBQXNFLGtEQUFrRCwySEFBMkgsMkdBQTJHLG1HQUFtRyx5SEFBeUgsbUVBQW1FLHlEQUF5RCw2REFBNkQsNkRBQTZELDZEQUE2RCxpUUFBaVEsc0lBQXNJLHdEQUF3RCw0REFBNEQsbUhBQW1ILDREQUE0RCxpTEFBaUwsOEVBQThFLGtHQUFrRyxxRUFBcUUscUlBQXFJLHdCQUF3QiwrTUFBK00sK0RBQStELCtEQUErRCxtRUFBbUUsNkVBQTZFLHdFQUF3RSx5RUFBeUUsb0ZBQW9GLDZGQUE2RixtRkFBbUYsb0RBQW9ELGlEQUFpRCxLQUFLLEM7Ozs7Ozs7Ozs7OztBQ0EvNlQ7QUFBZSxzSEFBdUQsb0RBQW9ELCtCQUErQix5QkFBeUIsOEJBQThCLDJCQUEyQixpQ0FBaUMsdUJBQXVCLDZCQUE2Qix1Q0FBdUMsOEJBQThCLCtCQUErQix1QkFBdUIseUJBQXlCLGlDQUFpQyxrQ0FBa0MscURBQXFELEdBQUcscUJBQXFCLDhEQUE4RCw4Q0FBOEMsMkVBQTJFLGtDQUFrQywwREFBMEQsaURBQWlELDhGQUE4RixtRUFBbUUsR0FBRyxHIiwiZmlsZSI6ImFzc2V0cy9qcy9hcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9qcy9tb2RlbFZpZXdlci9hcHAuanNcIik7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIW5ldyBCbG9iKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygyMCk7XG59XG5cbkVtaXR0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbkVtaXR0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW1pdHRlcjtcblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnModHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJy4vZW1pdHRlci5qcycpO1xudmFyIGNyZWF0ZUxvYWRlciA9IHJlcXVpcmUoJy4vbG9hZGVyJyk7XG52YXIgYXV0b0lkID0gMDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVHcm91cChjb25maWcpIHtcbiAgICB2YXIgZ3JvdXA7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIHZhciBhc3NldHMgPSBbXTtcbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICB2YXIgbnVtTG9hZGVkID0gMDtcbiAgICB2YXIgbnVtVG90YWwgPSAwO1xuICAgIHZhciBsb2FkZXJzID0ge307XG5cbiAgICB2YXIgYWRkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAvLyBjb25zb2xlLmRlYnVnKCdhZGQnLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZm9yRWFjaChhZGQpO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0dyb3VwID0gISFvcHRpb25zLmFzc2V0cyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuYXNzZXRzKTtcbiAgICAgICAgLy8gY29uc29sZS5kZWJ1ZygnaXNHcm91cCcsIGlzR3JvdXApO1xuICAgICAgICB2YXIgbG9hZGVyO1xuICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgbG9hZGVyID0gY3JlYXRlR3JvdXAoY29uZmlndXJlKG9wdGlvbnMsIGNvbmZpZykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZGVyID0gY3JlYXRlTG9hZGVyKGNvbmZpZ3VyZShvcHRpb25zLCBjb25maWcpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZXIub25jZSgnZGVzdHJveScsIGRlc3Ryb3lIYW5kbGVyKTtcbiAgICAgICAgcXVldWUucHVzaChsb2FkZXIpO1xuICAgICAgICBsb2FkZXJzW2xvYWRlci5pZF0gPSBsb2FkZXI7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9O1xuXG4gICAgdmFyIGdldCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzc2V0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFwW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcFtpZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvYWRlcnNbaWRdO1xuICAgIH07XG5cbiAgICB2YXIgZmluZCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChnZXQoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KGlkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm91bmQgPSBudWxsO1xuICAgICAgICBPYmplY3Qua2V5cyhsb2FkZXJzKS5zb21lKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZm91bmQgPSBsb2FkZXJzW2tleV0uZmluZCAmJiBsb2FkZXJzW2tleV0uZmluZChpZCk7XG4gICAgICAgICAgICByZXR1cm4gISFmb3VuZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEV4dGVuc2lvbiA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICByZXR1cm4gdXJsICYmIHVybC5zcGxpdCgnPycpWzBdLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmlzVG91Y2hMb2NrZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5pc1RvdWNoTG9ja2VkID0gZGVmYXVsdHMuaXNUb3VjaExvY2tlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmJsb2IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5ibG9iID0gZGVmYXVsdHMuYmxvYjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmJhc2VQYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYmFzZVBhdGggPSBkZWZhdWx0cy5iYXNlUGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMuaWQgPSBvcHRpb25zLmlkIHx8IG9wdGlvbnMudXJsIHx8IFN0cmluZygrK2F1dG9JZCk7XG4gICAgICAgIG9wdGlvbnMudHlwZSA9IG9wdGlvbnMudHlwZSB8fCBnZXRFeHRlbnNpb24ob3B0aW9ucy51cmwpO1xuICAgICAgICBvcHRpb25zLmNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpbiB8fCBkZWZhdWx0cy5jcm9zc09yaWdpbjtcbiAgICAgICAgb3B0aW9ucy53ZWJBdWRpb0NvbnRleHQgPSBvcHRpb25zLndlYkF1ZGlvQ29udGV4dCB8fCBkZWZhdWx0cy53ZWJBdWRpb0NvbnRleHQ7XG4gICAgICAgIG9wdGlvbnMubG9nID0gZGVmYXVsdHMubG9nO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG5cbiAgICB2YXIgc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtVG90YWwgPSBxdWV1ZS5sZW5ndGg7XG5cbiAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbihsb2FkZXIpIHtcbiAgICAgICAgICAgIGxvYWRlclxuICAgICAgICAgICAgICAgIC5vbigncHJvZ3Jlc3MnLCBwcm9ncmVzc0hhbmRsZXIpXG4gICAgICAgICAgICAgICAgLm9uY2UoJ2NvbXBsZXRlJywgY29tcGxldGVIYW5kbGVyKVxuICAgICAgICAgICAgICAgIC5vbmNlKCdlcnJvcicsIGVycm9ySGFuZGxlcilcbiAgICAgICAgICAgICAgICAuc3RhcnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcXVldWUgPSBbXTtcblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcblxuICAgIHZhciBwcm9ncmVzc0hhbmRsZXIgPSBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICB2YXIgbG9hZGVkID0gbnVtTG9hZGVkICsgcHJvZ3Jlc3M7XG4gICAgICAgIGdyb3VwLmVtaXQoJ3Byb2dyZXNzJywgbG9hZGVkIC8gbnVtVG90YWwpO1xuICAgIH07XG5cbiAgICB2YXIgY29tcGxldGVIYW5kbGVyID0gZnVuY3Rpb24oYXNzZXQsIGlkLCB0eXBlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFzc2V0KSkge1xuICAgICAgICAgICAgYXNzZXQgPSB7IGlkOiBpZCwgZmlsZTogYXNzZXQsIHR5cGU6IHR5cGUgfTtcbiAgICAgICAgfVxuICAgICAgICBudW1Mb2FkZWQrKztcbiAgICAgICAgZ3JvdXAuZW1pdCgncHJvZ3Jlc3MnLCBudW1Mb2FkZWQgLyBudW1Ub3RhbCk7XG4gICAgICAgIG1hcFthc3NldC5pZF0gPSBhc3NldC5maWxlO1xuICAgICAgICBhc3NldHMucHVzaChhc3NldCk7XG4gICAgICAgIGdyb3VwLmVtaXQoJ2NoaWxkY29tcGxldGUnLCBhc3NldCk7XG4gICAgICAgIGNoZWNrQ29tcGxldGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICBudW1Ub3RhbC0tO1xuICAgICAgICBpZiAoZ3JvdXAubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xuICAgICAgICAgICAgZ3JvdXAuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ29tcGxldGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlc3Ryb3lIYW5kbGVyID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgbG9hZGVyc1tpZF0gPSBudWxsO1xuICAgICAgICBkZWxldGUgbG9hZGVyc1tpZF07XG5cbiAgICAgICAgbWFwW2lkXSA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSBtYXBbaWRdO1xuXG4gICAgICAgIGFzc2V0cy5zb21lKGZ1bmN0aW9uKGFzc2V0LCBpKSB7XG4gICAgICAgICAgICBpZiAoYXNzZXQuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgYXNzZXRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjaGVja0NvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChudW1Mb2FkZWQgPj0gbnVtVG90YWwpIHtcbiAgICAgICAgICAgIGdyb3VwLmVtaXQoJ2NvbXBsZXRlJywgYXNzZXRzLCBtYXAsIGNvbmZpZy5pZCwgJ2dyb3VwJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcXVldWUucG9wKCkuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwLm9mZignZXJyb3InKTtcbiAgICAgICAgZ3JvdXAub2ZmKCdwcm9ncmVzcycpO1xuICAgICAgICBncm91cC5vZmYoJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFzc2V0cyA9IFtdO1xuICAgICAgICBtYXAgPSB7fTtcbiAgICAgICAgY29uZmlnLndlYkF1ZGlvQ29udGV4dCA9IG51bGw7XG4gICAgICAgIG51bVRvdGFsID0gMDtcbiAgICAgICAgbnVtTG9hZGVkID0gMDtcblxuICAgICAgICBPYmplY3Qua2V5cyhsb2FkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgbG9hZGVyc1trZXldLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvYWRlcnMgPSB7fTtcblxuICAgICAgICBncm91cC5lbWl0KCdkZXN0cm95JywgZ3JvdXAuaWQpO1xuXG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9O1xuXG4gICAgLy8gZW1pdHM6IHByb2dyZXNzLCBlcnJvciwgY29tcGxldGUsIGRlc3Ryb3lcblxuICAgIGdyb3VwID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSwge1xuICAgICAgICBfZXZlbnRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiB7XG4gICAgICAgICAgICB2YWx1ZTogYWRkXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICB2YWx1ZTogc3RhcnRcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiB7XG4gICAgICAgICAgICB2YWx1ZTogZ2V0XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmaW5kXG4gICAgICAgIH0sXG4gICAgICAgIGdldExvYWRlcjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlcnNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb2FkZWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bUxvYWRlZCA+PSBudW1Ub3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiB7XG4gICAgICAgICAgICB2YWx1ZTogZGVzdHJveVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25maWcgPSBjb25maWd1cmUoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIGJhc2VQYXRoOiAnJyxcbiAgICAgICAgYmxvYjogZmFsc2UsXG4gICAgICAgIHRvdWNoTG9ja2VkOiBmYWxzZSxcbiAgICAgICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgICAgIHdlYkF1ZGlvQ29udGV4dDogbnVsbCxcbiAgICAgICAgbG9nOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmFzc2V0cykpIHtcbiAgICAgICAgYWRkKGNvbmZpZy5hc3NldHMpO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NldHNMb2FkZXIgPSByZXF1aXJlKCcuL2dyb3VwJyk7XG5hc3NldHNMb2FkZXIuc3RhdHMgPSByZXF1aXJlKCcuL3N0YXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzZXRzTG9hZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJy4vZW1pdHRlci5qcycpO1xudmFyIGJyb3dzZXJIYXNCbG9iID0gcmVxdWlyZSgnLi9icm93c2VyLWhhcy1ibG9iLmpzJyk7XG52YXIgc3RhdHMgPSByZXF1aXJlKCcuL3N0YXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBpZCA9IG9wdGlvbnMuaWQ7XG4gICAgdmFyIGJhc2VQYXRoID0gb3B0aW9ucy5iYXNlUGF0aCB8fCAnJztcbiAgICB2YXIgdXJsID0gb3B0aW9ucy51cmw7XG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdmFyIGNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICB2YXIgaXNUb3VjaExvY2tlZCA9IG9wdGlvbnMuaXNUb3VjaExvY2tlZDtcbiAgICB2YXIgYmxvYiA9IG9wdGlvbnMuYmxvYiAmJiBicm93c2VySGFzQmxvYjtcbiAgICB2YXIgd2ViQXVkaW9Db250ZXh0ID0gb3B0aW9ucy53ZWJBdWRpb0NvbnRleHQ7XG4gICAgdmFyIGxvZyA9IG9wdGlvbnMubG9nO1xuXG4gICAgdmFyIGxvYWRlcjtcbiAgICB2YXIgbG9hZEhhbmRsZXI7XG4gICAgdmFyIHJlcXVlc3Q7XG4gICAgdmFyIHN0YXJ0VGltZTtcbiAgICB2YXIgdGltZW91dDtcbiAgICB2YXIgZmlsZTtcblxuICAgIHZhciBzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgICAgbG9hZEpTT04oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2pwZyc6XG4gICAgICAgICAgICBjYXNlICdwbmcnOlxuICAgICAgICAgICAgY2FzZSAnZ2lmJzpcbiAgICAgICAgICAgIGNhc2UgJ3dlYnAnOlxuICAgICAgICAgICAgY2FzZSAnc3ZnJzpcbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgICBjYXNlICdvZ2cnOlxuICAgICAgICAgICAgY2FzZSAnb3B1cyc6XG4gICAgICAgICAgICBjYXNlICd3YXYnOlxuICAgICAgICAgICAgY2FzZSAnbTRhJzpcbiAgICAgICAgICAgICAgICBsb2FkQXVkaW8oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29ndic6XG4gICAgICAgICAgICBjYXNlICdtcDQnOlxuICAgICAgICAgICAgY2FzZSAnd2VibSc6XG4gICAgICAgICAgICBjYXNlICdobHMnOlxuICAgICAgICAgICAgICAgIGxvYWRWaWRlbygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmluJzpcbiAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgICAgICAgbG9hZFhIUignYXJyYXlidWZmZXInKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3R4dCc6XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICBsb2FkWEhSKCd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93ICdBc3NldHNMb2FkZXIgRVJST1I6IFVua25vd24gdHlwZSBmb3IgZmlsZSB3aXRoIFVSTDogJyArIGJhc2VQYXRoICsgdXJsICsgJyAoJyArIHR5cGUgKyAnKSc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRpc3BhdGNoQ29tcGxldGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbGUgPSB7aWQ6IGlkLCBmaWxlOiBkYXRhLCB0eXBlOiB0eXBlfTtcbiAgICAgICAgbG9hZGVyLmVtaXQoJ3Byb2dyZXNzJywgMSk7XG4gICAgICAgIGxvYWRlci5lbWl0KCdjb21wbGV0ZScsIGZpbGUsIGlkLCB0eXBlKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgfTtcblxuICAgIHZhciBsb2FkWEhSID0gZnVuY3Rpb24ocmVzcG9uc2VUeXBlLCBjdXN0b21Mb2FkSGFuZGxlcikge1xuICAgICAgICBsb2FkSGFuZGxlciA9IGN1c3RvbUxvYWRIYW5kbGVyIHx8IGNvbXBsZXRlSGFuZGxlcjtcblxuICAgICAgICByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgYmFzZVBhdGggKyB1cmwsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHByb2dyZXNzSGFuZGxlcik7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRIYW5kbGVyKTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH07XG5cbiAgICB2YXIgcHJvZ3Jlc3NIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgIGxvYWRlci5lbWl0KCdwcm9ncmVzcycsIGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY29tcGxldGVIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzdWNjZXNzKCkpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ29tcGxldGUocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3N1Y2Nlc3MnLCB1cmwsIHJlcXVlc3Quc3RhdHVzKTtcbiAgICAgICAgaWYgKHJlcXVlc3QgJiYgcmVxdWVzdC5zdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAgIHN0YXRzLnVwZGF0ZShyZXF1ZXN0LCBzdGFydFRpbWUsIHVybCwgbG9nKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ySGFuZGxlcihyZXF1ZXN0ICYmIHJlcXVlc3Quc3RhdHVzVGV4dCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8ganNvblxuXG4gICAgdmFyIGxvYWRKU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRYSFIoJ2pzb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hDb21wbGV0ZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGltYWdlXG5cbiAgICB2YXIgbG9hZEltYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChibG9iKSB7XG4gICAgICAgICAgICBsb2FkSW1hZ2VCbG9iKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkSW1hZ2VFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxvYWRJbWFnZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVxdWVzdCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpZiAoY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGVsZW1lbnRMb2FkSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICByZXF1ZXN0LnNyYyA9IGJhc2VQYXRoICsgdXJsO1xuICAgIH07XG5cbiAgICB2YXIgZWxlbWVudExvYWRIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgaWYgKCFldmVudCAmJiAocmVxdWVzdC5lcnJvciB8fCAhcmVxdWVzdC5yZWFkeVN0YXRlKSkge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2hDb21wbGV0ZShyZXF1ZXN0KTtcbiAgICB9O1xuXG4gICAgdmFyIGxvYWRJbWFnZUJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9hZFhIUignYmxvYicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MoKSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgaW1hZ2VCbG9iSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Quc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgaW1hZ2VCbG9iSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTChyZXF1ZXN0LnNyYyk7XG4gICAgICAgIGRpc3BhdGNoQ29tcGxldGUocmVxdWVzdCk7XG4gICAgfTtcblxuICAgIC8vIGF1ZGlvXG5cbiAgICB2YXIgbG9hZEF1ZGlvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh3ZWJBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIGxvYWRBdWRpb0J1ZmZlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZE1lZGlhRWxlbWVudCgnYXVkaW8nKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB2aWRlb1xuXG4gICAgdmFyIGxvYWRWaWRlbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYmxvYikge1xuICAgICAgICAgICAgbG9hZFhIUignYmxvYicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZE1lZGlhRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhdWRpbyBidWZmZXJcblxuICAgIHZhciBsb2FkQXVkaW9CdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9hZFhIUignYXJyYXlidWZmZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKCkpIHtcbiAgICAgICAgICAgICAgICB3ZWJBdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDb21wbGV0ZShidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gbWVkaWEgZWxlbWVudFxuXG4gICAgdmFyIGxvYWRNZWRpYUVsZW1lbnQgPSBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgICAgIHJlcXVlc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuXG4gICAgICAgIGlmICghaXNUb3VjaExvY2tlZCkge1xuICAgICAgICAgICAgLy8gdGltZW91dCBiZWNhdXNlIHNvbWV0aW1lcyBjYW5wbGF5dGhyb3VnaCBkb2Vzbid0IGZpcmVcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZWxlbWVudExvYWRIYW5kbGVyLCAyMDAwKTtcbiAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCBlbGVtZW50TG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgcmVxdWVzdC5wcmVsb2FkID0gJ2F1dG8nO1xuICAgICAgICByZXF1ZXN0LnNyYyA9IGJhc2VQYXRoICsgdXJsO1xuICAgICAgICByZXF1ZXN0LmxvYWQoKTtcblxuICAgICAgICBpZiAoaXNUb3VjaExvY2tlZCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hDb21wbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBlcnJvclxuXG4gICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZXJyb3JIYW5kbGVyJywgdXJsLCBlcnIpO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgIHZhciBtZXNzYWdlID0gZXJyO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0ICYmIHJlcXVlc3QudGFnTmFtZSAmJiByZXF1ZXN0LmVycm9yKSB7XG4gICAgICAgICAgICB2YXIgRVJST1JfU1RBVEUgPSBbJycsICdBQk9SVEVEJywgJ05FVFdPUksnLCAnREVDT0RFJywgJ1NSQ19OT1RfU1VQUE9SVEVEJ107XG4gICAgICAgICAgICBtZXNzYWdlID0gJ01lZGlhRXJyb3I6ICcgKyBFUlJPUl9TVEFURVtyZXF1ZXN0LmVycm9yLmNvZGVdICsgJyAnICsgcmVxdWVzdC5zcmM7XG4gICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdCAmJiByZXF1ZXN0LnN0YXR1c1RleHQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSByZXF1ZXN0LnN0YXR1c1RleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyICYmIGVyci5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyICYmIGVyci50eXBlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBsb2FkZXIuZW1pdCgnZXJyb3InLCAnRXJyb3IgbG9hZGluZyBcIicgKyBiYXNlUGF0aCArIHVybCArICdcIiAnICsgbWVzc2FnZSk7XG5cbiAgICAgICAgZGVzdHJveSgpO1xuICAgIH07XG5cbiAgICAvLyBjbGVhbiB1cFxuXG4gICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkZXIub2ZmKCdlcnJvcicpO1xuICAgICAgICBsb2FkZXIub2ZmKCdwcm9ncmVzcycpO1xuICAgICAgICBsb2FkZXIub2ZmKCdjb21wbGV0ZScpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgcHJvZ3Jlc3NIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgZWxlbWVudExvYWRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCBlbGVtZW50TG9hZEhhbmRsZXIpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgaW1hZ2VCbG9iSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QgJiYgcmVxdWVzdC5hYm9ydCAmJiByZXF1ZXN0LnJlYWR5U3RhdGUgPCA0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgd2ViQXVkaW9Db250ZXh0ID0gbnVsbDtcbiAgICAgICAgZmlsZSA9IG51bGw7XG5cbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgICBsb2FkZXIuZW1pdCgnZGVzdHJveScsIGlkKTtcbiAgICB9O1xuXG4gICAgLy8gZW1pdHM6IHByb2dyZXNzLCBlcnJvciwgY29tcGxldGVcblxuICAgIGxvYWRlciA9IE9iamVjdC5jcmVhdGUoRW1pdHRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgX2V2ZW50czoge1xuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5pZFxuICAgICAgICB9LFxuICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgdmFsdWU6IHN0YXJ0XG4gICAgICAgIH0sXG4gICAgICAgIGxvYWRlZDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFmaWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiB7XG4gICAgICAgICAgICB2YWx1ZTogZGVzdHJveVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9hZGVyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbWJzOiAwLFxuICAgIHNlY3M6IDAsXG4gICAgdXBkYXRlOiBmdW5jdGlvbihyZXF1ZXN0LCBzdGFydFRpbWUsIHVybCwgbG9nKSB7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHZhciBoZWFkZXJzID0gcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGhlYWRlcnMubWF0Y2goL2NvbnRlbnQtbGVuZ3RoOiAoXFxkKykvaSk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFyIGxlbmd0aCA9IHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IHBhcnNlSW50KGxlbmd0aCwgMTApO1xuICAgICAgICAgICAgdmFyIG1icyA9IGxlbmd0aCAvIDEwMjQgLyAxMDI0O1xuICAgICAgICAgICAgdmFyIHNlY3MgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMDAwO1xuICAgICAgICAgICAgdGhpcy5zZWNzICs9IHNlY3M7XG4gICAgICAgICAgICB0aGlzLm1icyArPSBtYnM7XG4gICAgICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2codXJsLCBtYnMsIHNlY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYobG9nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4uY2FsbChjb25zb2xlLCAnQ2FuXFwndCBnZXQgQ29udGVudC1MZW5ndGg6JywgdXJsKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbG9nOiBmdW5jdGlvbih1cmwsIG1icywgc2Vjcykge1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICB2YXIgZmlsZSA9ICdGaWxlIGxvYWRlZDogJyArXG4gICAgICAgICAgICAgICAgdXJsLnN1YnN0cih1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpICtcbiAgICAgICAgICAgICAgICAnIHNpemU6JyArIG1icy50b0ZpeGVkKDIpICsgJ21iJyArXG4gICAgICAgICAgICAgICAgJyB0aW1lOicgKyBzZWNzLnRvRml4ZWQoMikgKyAncycgK1xuICAgICAgICAgICAgICAgICcgc3BlZWQ6JyArIChtYnMgLyBzZWNzKS50b0ZpeGVkKDIpICsgJ21icHMnO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZy5jYWxsKGNvbnNvbGUsIGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3RhbCA9ICdUb3RhbCBsb2FkZWQ6ICcgKyB0aGlzLm1icy50b0ZpeGVkKDIpICsgJ21iJyArXG4gICAgICAgICAgICAnIHRpbWU6JyArIHRoaXMuc2Vjcy50b0ZpeGVkKDIpICsgJ3MnICtcbiAgICAgICAgICAgICcgc3BlZWQ6JyArIHRoaXMuZ2V0TWJwcygpLnRvRml4ZWQoMikgKyAnbWJwcyc7XG4gICAgICAgIGNvbnNvbGUubG9nLmNhbGwoY29uc29sZSwgdG90YWwpO1xuICAgIH0sXG4gICAgZ2V0TWJwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1icyAvIHRoaXMuc2VjcztcbiAgICB9XG59O1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJodG1sLCBib2R5IHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwMDAwO1xcbiAgLyogT2xkIGJyb3dzZXJzICovXFxuICAvKiBQZXJtYWxpbmsgLSB1c2UgdG8gZWRpdCBhbmQgc2hhcmUgdGhpcyBncmFkaWVudDogaHR0cDovL2NvbG9yemlsbGEuY29tL2dyYWRpZW50LWVkaXRvci8jNmQ2ZDZkKzAsMDAwMDAwKzEwMCAqLyB9XFxuXFxuaHRtbCB7XFxuICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IG5vbmU7XFxuICAtbW96LXRleHQtc2l6ZS1hZGp1c3Q6IG5vbmU7XFxuICB0ZXh0LXNpemUtYWRqdXN0OiBub25lOyB9XFxuXFxuaDEsIGgyLCBoMywgaDQsIHRleHQsIHAge1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAtbW96LW9zeC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgZm9udC1mYW1pbHk6ICdPcGVuIFNhbnMnLCBzYW5zLXNlcmlmOyB9XFxuXFxuLk1haW4tQ2FudmFzIHtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgb3BhY2l0eTogMTtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgLjVzIGVhc2Utb3V0IC4yNXM7IH1cXG4gIC5pc0xvYWRpbmcgLk1haW4tQ2FudmFzIHtcXG4gICAgb3BhY2l0eTogMDsgfVxcblxcbi5lZGl0b3ItcG9pbnRzIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHBhZGRpbmc6IDUwcHggMCAwIDIwcHg7XFxuICBsZWZ0OiAwO1xcbiAgei1pbmRleDogMTAwMDtcXG4gIGNvbG9yOiB3aGl0ZTsgfVxcbiAgLmVkaXRvci1wb2ludHMgZGl2IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBiYWNrZ3JvdW5kOiBibGFjaztcXG4gICAgaGVpZ2h0OiAyMHB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIG1hcmdpbi1ib3R0b206IDJweDtcXG4gICAgcGFkZGluZzogMnB4O1xcbiAgICBtaW4td2lkdGg6IDEwMHB4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGRpc3BsYXk6IGZsZXg7IH1cXG4gICAgLmVkaXRvci1wb2ludHMgZGl2IHAge1xcbiAgICAgIG1hcmdpbjogMDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxuICAgICAgbWF4LXdpZHRoOiAxODBweDtcXG4gICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7IH1cXG4gICAgLmVkaXRvci1wb2ludHMgZGl2IHAuZGVsZXRlIHtcXG4gICAgICBjb2xvcjogcmVkO1xcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICByaWdodDogMDtcXG4gICAgICB0b3A6IDUwJTtcXG4gICAgICBtYXJnaW4tdG9wOiAtMTBweDsgfVxcblxcbi5tYXJrZXJzIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB6LWluZGV4OiAxMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgY29sb3I6IHdoaXRlOyB9XFxuXFxuLm1hcmtlcnMgcCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgZm9udC1mYW1pbHk6ICdJVENBdmFudEdhcmRlU3RkLURlbWknO1xcbiAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXFxuLm1hcmtlcnMgcDpob3ZlciB7XFxuICBjb2xvcjogIzAwOUFERDsgfVxcblxcbi5jb250YWluZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjsgfVxcblxcbi5jYW1lcmEtc3BvdHMgbmF2IHtcXG4gIGNvbG9yOiBibGFjaztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogMjBweDtcXG4gIGxlZnQ6IDIwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgd2lkdGg6IDEwMCU7IH1cXG4gIC5jYW1lcmEtc3BvdHMgbmF2IHAge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIG1hcmdpbjogMCAzMHB4OyB9XFxuXFxuLk1lc3NhZ2Uge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiA5OTk7XFxuICB3aWR0aDogMTAwJTtcXG4gIHRvcDogY2FsYyg1MCUgLSA1MHB4KTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGxldHRlci1zcGFjaW5nOiAxMXB4O1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgb3BhY2l0eTogMDtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgLjVzIGVhc2Utb3V0LCBsZXR0ZXItc3BhY2luZyAuNXMgZWFzZS1vdXQ7IH1cXG4gIC5pc0xvYWRpbmcgLk1lc3NhZ2Uge1xcbiAgICBsZXR0ZXItc3BhY2luZzogMTBweDtcXG4gICAgb3BhY2l0eTogMTsgfVxcblxcbi5Mb2FkaW5nLUJhciB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDk5ODtcXG4gIHdpZHRoOiAwJTtcXG4gIGhlaWdodDogMXB4O1xcbiAgdG9wOiA1MCU7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxuICBvcGFjaXR5OiAwO1xcbiAgdHJhbnNpdGlvbjogd2lkdGggLjVzIGVhc2Utb3V0LCBvcGFjaXR5IC41cyBlYXNlLW91dDsgfVxcbiAgLmlzTG9hZGluZyAuTG9hZGluZy1CYXIge1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuXFxuLmVudiB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB3aWR0aDogMTAwJTtcXG4gIHotaW5kZXg6IDk5OTk7XFxuICBjb2xvcjogd2hpdGU7XFxuICB0b3A6IDEwMHB4O1xcbiAgZm9udC1zaXplOiAyNHB4O1xcbiAgcGFkZGluZzogMjBweDsgfVxcblwiLCBcIlwiXSk7XG5cbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmNhbWVyYS1zcG90cyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgei1pbmRleDogMTA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGNvbG9yOiBibGFjazsgfVxcblxcbi5jYW1lcmEtc3BvdHMgcDpob3ZlciB7XFxuICBjb2xvcjogIzAwOUFERDsgfVxcblxcbi5jYW1lcmEtc3BvdHMgLmFubm90YXRpb24ge1xcbiAgd2lkdGg6IDMwJTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMzAlO1xcbiAgbWF4LXdpZHRoOiAyNTBweDtcXG4gIHBhZGRpbmc6IDEwcHggNXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjYpO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDsgfVxcbiAgLmNhbWVyYS1zcG90cyAuYW5ub3RhdGlvbiBwIHtcXG4gICAgY29sb3I6IHdoaXRlO1xcbiAgICBtYXJnaW46IGF1dG87XFxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgd2lkdGg6IDk1JTsgfVxcbiAgLmNhbWVyYS1zcG90cyAuYW5ub3RhdGlvbiAuaW1hZ2Utc3BvdCB7XFxuICAgIHdpZHRoOiA5NSU7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBtYXJnaW46IGF1dG87XFxuICAgIGJhY2tncm91bmQtY29sb3I6IGdyZWVuO1xcbiAgICBtaW4taGVpZ2h0OiAxMDBweDsgfVxcbiAgLmNhbWVyYS1zcG90cyAuYW5ub3RhdGlvbiAuY2xvc2Uge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHJpZ2h0OiA4cHg7XFxuICAgIHRvcDogOHB4O1xcbiAgICB3aWR0aDogMjBweDtcXG4gICAgaGVpZ2h0OiAyMHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7IH1cXG5cXG4uY2FtZXJhLXNwb3RzIHAuc3BvdCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMjAwcHg7XFxuICBtYXJnaW4tdG9wOiAtMTBweDtcXG4gIG1hcmdpbi1sZWZ0OiAtMTAwcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgZm9udC1mYW1pbHk6ICdJVENBdmFudEdhcmRlU3RkLURlbWknO1xcbiAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXCIsIFwiXCJdKTtcblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuICdAbWVkaWEgJyArIGl0ZW1bMl0gKyAneycgKyBjb250ZW50ICsgJ30nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IG1vZHVsZXNbaV07IC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcbiAgICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG4gICAgICAvLyB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG4gICAgICAvLyBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cbiAgICAgIGlmIChpdGVtWzBdID09IG51bGwgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgaWYgKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgICAgaXRlbVsyXSA9ICcoJyArIGl0ZW1bMl0gKyAnKSBhbmQgKCcgKyBtZWRpYVF1ZXJ5ICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuICByZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufSIsIlwidXNlIHN0cmljdFwiO1xuLypcbkNvcHlyaWdodCAoYykgMjAxNCBQZXRrYSBBbnRvbm92XG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG4qL1xuZnVuY3Rpb24gVXJsKCkge1xuICAgIC8vRm9yIG1vcmUgZWZmaWNpZW50IGludGVybmFsIHJlcHJlc2VudGF0aW9uIGFuZCBsYXppbmVzcy5cbiAgICAvL1RoZSBub24tdW5kZXJzY29yZSB2ZXJzaW9ucyBvZiB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NvciBmdW5jdGlvbnNcbiAgICAvL2RlZmluZWQgb24gdGhlIHByb3RvdHlwZS5cbiAgICB0aGlzLl9wcm90b2NvbCA9IG51bGw7XG4gICAgdGhpcy5faHJlZiA9IFwiXCI7XG4gICAgdGhpcy5fcG9ydCA9IC0xO1xuICAgIHRoaXMuX3F1ZXJ5ID0gbnVsbDtcblxuICAgIHRoaXMuYXV0aCA9IG51bGw7XG4gICAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgICB0aGlzLmhvc3QgPSBudWxsO1xuICAgIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICAgIHRoaXMuaGFzaCA9IG51bGw7XG4gICAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICAgIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuXG4gICAgdGhpcy5fcHJlcGVuZFNsYXNoID0gZmFsc2U7XG59XG5cbnZhciBxdWVyeXN0cmluZyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcblxuVXJsLnF1ZXJ5U3RyaW5nID0gcXVlcnlzdHJpbmc7XG5cblVybC5wcm90b3R5cGUucGFyc2UgPVxuZnVuY3Rpb24gVXJsJHBhcnNlKHN0ciwgcGFyc2VRdWVyeVN0cmluZywgaG9zdERlbm90ZXNTbGFzaCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICtcbiAgICAgICAgICAgIHR5cGVvZiBzdHIpO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIHZhciBlbmQgPSBzdHIubGVuZ3RoIC0gMTtcblxuICAgIC8vVHJpbSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3c1xuICAgIHdoaWxlIChzdHIuY2hhckNvZGVBdChzdGFydCkgPD0gMHgyMCAvKicgJyovKSBzdGFydCsrO1xuICAgIHdoaWxlIChzdHIuY2hhckNvZGVBdChlbmQpIDw9IDB4MjAgLyonICcqLykgZW5kLS07XG5cbiAgICBzdGFydCA9IHRoaXMuX3BhcnNlUHJvdG9jb2woc3RyLCBzdGFydCwgZW5kKTtcblxuICAgIC8vSmF2YXNjcmlwdCBkb2Vzbid0IGhhdmUgaG9zdFxuICAgIGlmICh0aGlzLl9wcm90b2NvbCAhPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9wYXJzZUhvc3Qoc3RyLCBzdGFydCwgZW5kLCBob3N0RGVub3Rlc1NsYXNoKTtcbiAgICAgICAgdmFyIHByb3RvID0gdGhpcy5fcHJvdG9jb2w7XG4gICAgICAgIGlmICghdGhpcy5ob3N0bmFtZSAmJlxuICAgICAgICAgICAgKHRoaXMuc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoUHJvdG9jb2xzW3Byb3RvXSkpKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydCA8PSBlbmQpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgyRiAvKicvJyovIHx8IGNoID09PSAweDVDIC8qJ1xcJyovKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVBhdGgoc3RyLCBzdGFydCwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgzRiAvKic/JyovKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVF1ZXJ5KHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MjMgLyonIycqLykge1xuICAgICAgICAgIHRoaXMuX3BhcnNlSGFzaChzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Byb3RvY29sICE9PSBcImphdmFzY3JpcHRcIikge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQYXRoKHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vRm9yIGphdmFzY3JpcHQgdGhlIHBhdGhuYW1lIGlzIGp1c3QgdGhlIHJlc3Qgb2YgaXRcbiAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnBhdGhuYW1lICYmIHRoaXMuaG9zdG5hbWUgJiZcbiAgICAgICAgdGhpcy5fc2xhc2hQcm90b2NvbHNbdGhpcy5fcHJvdG9jb2xdKSB7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBcIi9cIjtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2g7XG4gICAgICAgIGlmIChzZWFyY2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VhcmNoID0gdGhpcy5zZWFyY2ggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2guY2hhckNvZGVBdCgwKSA9PT0gMHgzRiAvKic/JyovKSB7XG4gICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2guc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9UaGlzIGNhbGxzIGEgc2V0dGVyIGZ1bmN0aW9uLCB0aGVyZSBpcyBubyAucXVlcnkgZGF0YSBwcm9wZXJ0eVxuICAgICAgICB0aGlzLnF1ZXJ5ID0gVXJsLnF1ZXJ5U3RyaW5nLnBhcnNlKHNlYXJjaCk7XG4gICAgfVxufTtcblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gVXJsJHJlc29sdmUocmVsYXRpdmUpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KFVybC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gVXJsJGZvcm1hdCgpIHtcbiAgICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCBcIlwiO1xuXG4gICAgaWYgKGF1dGgpIHtcbiAgICAgICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICAgICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksIFwiOlwiKTtcbiAgICAgICAgYXV0aCArPSBcIkBcIjtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8IFwiXCI7XG4gICAgdmFyIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCBcIlwiO1xuICAgIHZhciBoYXNoID0gdGhpcy5oYXNoIHx8IFwiXCI7XG4gICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IFwiXCI7XG4gICAgdmFyIHF1ZXJ5ID0gXCJcIjtcbiAgICB2YXIgaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8IFwiXCI7XG4gICAgdmFyIHBvcnQgPSB0aGlzLnBvcnQgfHwgXCJcIjtcbiAgICB2YXIgaG9zdCA9IGZhbHNlO1xuICAgIHZhciBzY2hlbWUgPSBcIlwiO1xuXG4gICAgLy9DYWNoZSB0aGUgcmVzdWx0IG9mIHRoZSBnZXR0ZXIgZnVuY3Rpb25cbiAgICB2YXIgcSA9IHRoaXMucXVlcnk7XG4gICAgaWYgKHEgJiYgdHlwZW9mIHEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcXVlcnkgPSBVcmwucXVlcnlTdHJpbmcuc3RyaW5naWZ5KHEpO1xuICAgIH1cblxuICAgIGlmICghc2VhcmNoKSB7XG4gICAgICAgIHNlYXJjaCA9IHF1ZXJ5ID8gXCI/XCIgKyBxdWVyeSA6IFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJDb2RlQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09IDB4M0EgLyonOicqLylcbiAgICAgICAgcHJvdG9jb2wgKz0gXCI6XCI7XG5cbiAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICAgIH1cbiAgICBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgICAgICB2YXIgaXA2ID0gaG9zdG5hbWUuaW5kZXhPZihcIjpcIikgPiAtMTtcbiAgICAgICAgaWYgKGlwNikgaG9zdG5hbWUgPSBcIltcIiArIGhvc3RuYW1lICsgXCJdXCI7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgaG9zdG5hbWUgKyAocG9ydCA/IFwiOlwiICsgcG9ydCA6IFwiXCIpO1xuICAgIH1cblxuICAgIHZhciBzbGFzaGVzID0gdGhpcy5zbGFzaGVzIHx8XG4gICAgICAgICgoIXByb3RvY29sIHx8XG4gICAgICAgIHNsYXNoUHJvdG9jb2xzW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpO1xuXG5cbiAgICBpZiAocHJvdG9jb2wpIHNjaGVtZSA9IHByb3RvY29sICsgKHNsYXNoZXMgPyBcIi8vXCIgOiBcIlwiKTtcbiAgICBlbHNlIGlmIChzbGFzaGVzKSBzY2hlbWUgPSBcIi8vXCI7XG5cbiAgICBpZiAoc2xhc2hlcyAmJiBwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQ29kZUF0KDApICE9PSAweDJGIC8qJy8nKi8pIHtcbiAgICAgICAgcGF0aG5hbWUgPSBcIi9cIiArIHBhdGhuYW1lO1xuICAgIH1cbiAgICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQ29kZUF0KDApICE9PSAweDNGIC8qJz8nKi8pXG4gICAgICAgIHNlYXJjaCA9IFwiP1wiICsgc2VhcmNoO1xuICAgIGlmIChoYXNoICYmIGhhc2guY2hhckNvZGVBdCgwKSAhPT0gMHgyMyAvKicjJyovKVxuICAgICAgICBoYXNoID0gXCIjXCIgKyBoYXNoO1xuXG4gICAgcGF0aG5hbWUgPSBlc2NhcGVQYXRoTmFtZShwYXRobmFtZSk7XG4gICAgc2VhcmNoID0gZXNjYXBlU2VhcmNoKHNlYXJjaCk7XG5cbiAgICByZXR1cm4gc2NoZW1lICsgKGhvc3QgPT09IGZhbHNlID8gXCJcIiA6IGhvc3QpICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24gVXJsJHJlc29sdmVPYmplY3QocmVsYXRpdmUpIHtcbiAgICBpZiAodHlwZW9mIHJlbGF0aXZlID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZWxhdGl2ZSA9IFVybC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Nsb25lKCk7XG5cbiAgICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlXCJzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICAgIGlmICghcmVsYXRpdmUuaHJlZikge1xuICAgICAgICByZXN1bHQuX2hyZWYgPSBcIlwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICAgIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5fcHJvdG9jb2wpIHtcbiAgICAgICAgcmVsYXRpdmUuX2NvcHlQcm9wc1RvKHJlc3VsdCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNsYXNoUHJvdG9jb2xzW3Jlc3VsdC5fcHJvdG9jb2xdICYmXG4gICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAocmVsYXRpdmUuX3Byb3RvY29sICYmIHJlbGF0aXZlLl9wcm90b2NvbCAhPT0gcmVzdWx0Ll9wcm90b2NvbCkge1xuICAgICAgICAvLyBpZiBpdFwicyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgICAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAgICAgLy8gZmlyc3QsIGlmIGl0XCJzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgICAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgICAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhhdFwicyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgICAgICBpZiAoIXNsYXNoUHJvdG9jb2xzW3JlbGF0aXZlLl9wcm90b2NvbF0pIHtcbiAgICAgICAgICAgIHJlbGF0aXZlLl9jb3B5UHJvcHNUbyhyZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0Ll9wcm90b2NvbCA9IHJlbGF0aXZlLl9wcm90b2NvbDtcbiAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmIHJlbGF0aXZlLl9wcm90b2NvbCAhPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAocmVsUGF0aFswXSAhPT0gXCJcIikgcmVsUGF0aC51bnNoaWZ0KFwiXCIpO1xuICAgICAgICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KFwiXCIpO1xuICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKFwiL1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8IFwiXCI7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgcmVzdWx0Ll9wb3J0ID0gcmVsYXRpdmUuX3BvcnQ7XG4gICAgICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgaXNTb3VyY2VBYnMgPVxuICAgICAgICAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQ29kZUF0KDApID09PSAweDJGIC8qJy8nKi8pO1xuICAgIHZhciBpc1JlbEFicyA9IChcbiAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICAgIChyZWxhdGl2ZS5wYXRobmFtZSAmJlxuICAgICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyRiAvKicvJyovKVxuICAgICAgICApO1xuICAgIHZhciBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKTtcblxuICAgIHZhciByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicztcblxuICAgIHZhciBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdChcIi9cIikgfHwgW107XG4gICAgdmFyIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdChcIi9cIikgfHwgW107XG4gICAgdmFyIHBzeWNob3RpYyA9IHJlc3VsdC5fcHJvdG9jb2wgJiYgIXNsYXNoUHJvdG9jb2xzW3Jlc3VsdC5fcHJvdG9jb2xdO1xuXG4gICAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAgIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gICAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IFwiXCI7XG4gICAgICAgIHJlc3VsdC5fcG9ydCA9IC0xO1xuICAgICAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgICAgICAgIGlmIChzcmNQYXRoWzBdID09PSBcIlwiKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICAgICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lmhvc3QgPSBcIlwiO1xuICAgICAgICBpZiAocmVsYXRpdmUuX3Byb3RvY29sKSB7XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IFwiXCI7XG4gICAgICAgICAgICByZWxhdGl2ZS5fcG9ydCA9IC0xO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gXCJcIikgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgICAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gXCJcIiB8fCBzcmNQYXRoWzBdID09PSBcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWxBYnMpIHtcbiAgICAgICAgLy8gaXRcInMgYWJzb2x1dGUuXG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCA/XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lID9cbiAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgICAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gICAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgICAgICAvLyBpdFwicyByZWxhdGl2ZVxuICAgICAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICAgICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgICAgIHNyY1BhdGgucG9wKCk7XG4gICAgICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICB9IGVsc2UgaWYgKHJlbGF0aXZlLnNlYXJjaCkge1xuICAgICAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgICAgIC8vIGxpa2UgaHJlZj1cIj9mb29cIi5cbiAgICAgICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoXCJtYWlsdG86bG9jYWwxQGRvbWFpbjFcIiwgXCJsb2NhbDJAZG9tYWluMlwiKVxuICAgICAgICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKFwiQFwiKSA+IDAgP1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KFwiQFwiKSA6IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgICAgICByZXN1bHQuX2hyZWYgPSBcIlwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgICAgICAvLyB3ZVwidmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gICAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gXCIuXCIgfHwgbGFzdCA9PT0gXCIuLlwiKSB8fFxuICAgICAgICBsYXN0ID09PSBcIlwiKTtcblxuICAgIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICAgIHZhciB1cCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICAgICAgaWYgKGxhc3QgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXArKztcbiAgICAgICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cC0tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICAgIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgICAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdChcIi4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gXCJcIiAmJlxuICAgICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQ29kZUF0KDApICE9PSAweDJGIC8qJy8nKi8pKSB7XG4gICAgICAgIHNyY1BhdGgudW5zaGlmdChcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKFwiL1wiKS5zdWJzdHIoLTEpICE9PSBcIi9cIikpIHtcbiAgICAgICAgc3JjUGF0aC5wdXNoKFwiXCIpO1xuICAgIH1cblxuICAgIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gXCJcIiB8fFxuICAgICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJDb2RlQXQoMCkgPT09IDB4MkYgLyonLycqLyk7XG5cbiAgICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gXCJcIiA6XG4gICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6IFwiXCI7XG4gICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgLy91cmwucmVzb2x2ZU9iamVjdChcIm1haWx0bzpsb2NhbDFAZG9tYWluMVwiLCBcImxvY2FsMkBkb21haW4yXCIpXG4gICAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZihcIkBcIikgPiAwID9cbiAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KFwiQFwiKSA6IGZhbHNlO1xuICAgICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgICAgICBzcmNQYXRoLnVuc2hpZnQoXCJcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5sZW5ndGggPT09IDAgPyBudWxsIDogc3JjUGF0aC5qb2luKFwiL1wiKTtcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoXCJwdW55Y29kZVwiKTtcblVybC5wcm90b3R5cGUuX2hvc3RJZG5hID0gZnVuY3Rpb24gVXJsJF9ob3N0SWRuYShob3N0bmFtZSkge1xuICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICByZXR1cm4gcHVueWNvZGUudG9BU0NJSShob3N0bmFtZSk7XG59O1xuXG52YXIgZXNjYXBlUGF0aE5hbWUgPSBVcmwucHJvdG90eXBlLl9lc2NhcGVQYXRoTmFtZSA9XG5mdW5jdGlvbiBVcmwkX2VzY2FwZVBhdGhOYW1lKHBhdGhuYW1lKSB7XG4gICAgaWYgKCFjb250YWluc0NoYXJhY3RlcjIocGF0aG5hbWUsIDB4MjMgLyonIycqLywgMHgzRiAvKic/JyovKSkge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vQXZvaWQgY2xvc3VyZSBjcmVhdGlvbiB0byBrZWVwIHRoaXMgaW5saW5hYmxlXG4gICAgcmV0dXJuIF9lc2NhcGVQYXRoKHBhdGhuYW1lKTtcbn07XG5cbnZhciBlc2NhcGVTZWFyY2ggPSBVcmwucHJvdG90eXBlLl9lc2NhcGVTZWFyY2ggPVxuZnVuY3Rpb24gVXJsJF9lc2NhcGVTZWFyY2goc2VhcmNoKSB7XG4gICAgaWYgKCFjb250YWluc0NoYXJhY3RlcjIoc2VhcmNoLCAweDIzIC8qJyMnKi8sIC0xKSkgcmV0dXJuIHNlYXJjaDtcbiAgICAvL0F2b2lkIGNsb3N1cmUgY3JlYXRpb24gdG8ga2VlcCB0aGlzIGlubGluYWJsZVxuICAgIHJldHVybiBfZXNjYXBlU2VhcmNoKHNlYXJjaCk7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZVByb3RvY29sID0gZnVuY3Rpb24gVXJsJF9wYXJzZVByb3RvY29sKHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBkb0xvd2VyQ2FzZSA9IGZhbHNlO1xuICAgIHZhciBwcm90b2NvbENoYXJhY3RlcnMgPSB0aGlzLl9wcm90b2NvbENoYXJhY3RlcnM7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDNBIC8qJzonKi8pIHtcbiAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IHN0ci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICBpZiAoZG9Mb3dlckNhc2UpIHByb3RvY29sID0gcHJvdG9jb2wudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gcHJvdG9jb2w7XG4gICAgICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdG9jb2xDaGFyYWN0ZXJzW2NoXSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGNoIDwgMHg2MSAvKidhJyovKVxuICAgICAgICAgICAgICAgIGRvTG93ZXJDYXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiBzdGFydDtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlQXV0aCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VBdXRoKHN0ciwgc3RhcnQsIGVuZCwgZGVjb2RlKSB7XG4gICAgdmFyIGF1dGggPSBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEpO1xuICAgIGlmIChkZWNvZGUpIHtcbiAgICAgICAgYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG4gICAgdGhpcy5hdXRoID0gYXV0aDtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlUG9ydCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VQb3J0KHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIC8vSW50ZXJuYWwgZm9ybWF0IGlzIGludGVnZXIgZm9yIG1vcmUgZWZmaWNpZW50IHBhcnNpbmdcbiAgICAvL2FuZCBmb3IgZWZmaWNpZW50IHRyaW1taW5nIG9mIGxlYWRpbmcgemVyb3NcbiAgICB2YXIgcG9ydCA9IDA7XG4gICAgLy9EaXN0aW5ndWlzaCBiZXR3ZWVuIDowIGFuZCA6IChubyBwb3J0IG51bWJlciBhdCBhbGwpXG4gICAgdmFyIGhhZENoYXJzID0gZmFsc2U7XG4gICAgdmFyIHZhbGlkUG9ydCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKDB4MzAgLyonMCcqLyA8PSBjaCAmJiBjaCA8PSAweDM5IC8qJzknKi8pIHtcbiAgICAgICAgICAgIHBvcnQgPSAoMTAgKiBwb3J0KSArIChjaCAtIDB4MzAgLyonMCcqLyk7XG4gICAgICAgICAgICBoYWRDaGFycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZFBvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qy8qJ1xcJyovIHx8IGNoID09PSAweDJGLyonLycqLykge1xuICAgICAgICAgICAgICAgIHZhbGlkUG9ydCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIGlmICgocG9ydCA9PT0gMCAmJiAhaGFkQ2hhcnMpIHx8ICF2YWxpZFBvcnQpIHtcbiAgICAgICAgaWYgKCF2YWxpZFBvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcnQgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB0aGlzLl9wb3J0ID0gcG9ydDtcbiAgICByZXR1cm4gaSAtIHN0YXJ0O1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VIb3N0ID1cbmZ1bmN0aW9uIFVybCRfcGFyc2VIb3N0KHN0ciwgc3RhcnQsIGVuZCwgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgICB2YXIgaG9zdEVuZGluZ0NoYXJhY3RlcnMgPSB0aGlzLl9ob3N0RW5kaW5nQ2hhcmFjdGVycztcbiAgICB2YXIgZmlyc3QgPSBzdHIuY2hhckNvZGVBdChzdGFydCk7XG4gICAgdmFyIHNlY29uZCA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgMSk7XG4gICAgaWYgKChmaXJzdCA9PT0gMHgyRiAvKicvJyovIHx8IGZpcnN0ID09PSAweDVDIC8qJ1xcJyovKSAmJlxuICAgICAgICAoc2Vjb25kID09PSAweDJGIC8qJy8nKi8gfHwgc2Vjb25kID09PSAweDVDIC8qJ1xcJyovKSkge1xuICAgICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuXG4gICAgICAgIC8vVGhlIHN0cmluZyBzdGFydHMgd2l0aCAvL1xuICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vVGhlIHN0cmluZyBpcyBqdXN0IFwiLy9cIlxuICAgICAgICAgICAgaWYgKGVuZCA8IDIpIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgIC8vSWYgc2xhc2hlcyBkbyBub3QgZGVub3RlIGhvc3QgYW5kIHRoZXJlIGlzIG5vIGF1dGgsXG4gICAgICAgICAgICAvL3RoZXJlIGlzIG5vIGhvc3Qgd2hlbiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIC8vXG4gICAgICAgICAgICB2YXIgaGFzQXV0aCA9XG4gICAgICAgICAgICAgICAgY29udGFpbnNDaGFyYWN0ZXIoc3RyLCAweDQwIC8qJ0AnKi8sIDIsIGhvc3RFbmRpbmdDaGFyYWN0ZXJzKTtcbiAgICAgICAgICAgIGlmICghaGFzQXV0aCAmJiAhc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL1RoZXJlIGlzIGEgaG9zdCB0aGF0IHN0YXJ0cyBhZnRlciB0aGUgLy9cbiAgICAgICAgc3RhcnQgKz0gMjtcbiAgICB9XG4gICAgLy9JZiB0aGVyZSBpcyBubyBzbGFzaGVzLCB0aGVyZSBpcyBubyBob3N0bmFtZSBpZlxuICAgIC8vMS4gdGhlcmUgd2FzIG5vIHByb3RvY29sIGF0IGFsbFxuICAgIGVsc2UgaWYgKCF0aGlzLl9wcm90b2NvbCB8fFxuICAgICAgICAvLzIuIHRoZXJlIHdhcyBhIHByb3RvY29sIHRoYXQgcmVxdWlyZXMgc2xhc2hlc1xuICAgICAgICAvL2UuZy4gaW4gJ2h0dHA6YXNkJyAnYXNkJyBpcyBub3QgYSBob3N0bmFtZVxuICAgICAgICBzbGFzaFByb3RvY29sc1t0aGlzLl9wcm90b2NvbF1cbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cblxuICAgIHZhciBkb0xvd2VyQ2FzZSA9IGZhbHNlO1xuICAgIHZhciBpZG5hID0gZmFsc2U7XG4gICAgdmFyIGhvc3ROYW1lU3RhcnQgPSBzdGFydDtcbiAgICB2YXIgaG9zdE5hbWVFbmQgPSBlbmQ7XG4gICAgdmFyIGxhc3RDaCA9IC0xO1xuICAgIHZhciBwb3J0TGVuZ3RoID0gMDtcbiAgICB2YXIgY2hhcnNBZnRlckRvdCA9IDA7XG4gICAgdmFyIGF1dGhOZWVkc0RlY29kaW5nID0gZmFsc2U7XG5cbiAgICB2YXIgaiA9IC0xO1xuXG4gICAgLy9GaW5kIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYW4gQC1zaWduIHVudGlsIGhvc3RlbmRpbmcgY2hhcmFjdGVyIGlzIG1ldFxuICAgIC8vYWxzbyBtYXJrIGlmIGRlY29kaW5nIGlzIG5lZWRlZCBmb3IgdGhlIGF1dGggcG9ydGlvblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4NDAgLyonQCcqLykge1xuICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgLy9UaGlzIGNoZWNrIGlzIHZlcnksIHZlcnkgY2hlYXAuIFVubmVlZGVkIGRlY29kZVVSSUNvbXBvbmVudCBpcyB2ZXJ5XG4gICAgICAgIC8vdmVyeSBleHBlbnNpdmVcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MjUgLyonJScqLykge1xuICAgICAgICAgICAgYXV0aE5lZWRzRGVjb2RpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvc3RFbmRpbmdDaGFyYWN0ZXJzW2NoXSA9PT0gMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL0Atc2lnbiB3YXMgZm91bmQgYXQgaW5kZXggaiwgZXZlcnl0aGluZyB0byB0aGUgbGVmdCBmcm9tIGl0XG4gICAgLy9pcyBhdXRoIHBhcnRcbiAgICBpZiAoaiA+IC0xKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlQXV0aChzdHIsIHN0YXJ0LCBqIC0gMSwgYXV0aE5lZWRzRGVjb2RpbmcpO1xuICAgICAgICAvL2hvc3RuYW1lIHN0YXJ0cyBhZnRlciB0aGUgbGFzdCBALXNpZ25cbiAgICAgICAgc3RhcnQgPSBob3N0TmFtZVN0YXJ0ID0gaiArIDE7XG4gICAgfVxuXG4gICAgLy9Ib3N0IG5hbWUgaXMgc3RhcnRpbmcgd2l0aCBhIFtcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoc3RhcnQpID09PSAweDVCIC8qJ1snKi8pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgICAgIC8vQXNzdW1lIHZhbGlkIElQNiBpcyBiZXR3ZWVuIHRoZSBicmFja2V0c1xuICAgICAgICAgICAgaWYgKGNoID09PSAweDVEIC8qJ10nKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSArIDEpID09PSAweDNBIC8qJzonKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydExlbmd0aCA9IHRoaXMuX3BhcnNlUG9ydChzdHIsIGkgKyAyLCBlbmQpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGhvc3RuYW1lID0gc3RyLnNsaWNlKHN0YXJ0ICsgMSwgaSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gaG9zdG5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0ID0gdGhpcy5fcG9ydCA+IDAgP1xuICAgICAgICAgICAgICAgICAgICBcIltcIiArIGhvc3RuYW1lICsgXCJdOlwiICsgdGhpcy5fcG9ydCA6XG4gICAgICAgICAgICAgICAgICAgIFwiW1wiICsgaG9zdG5hbWUgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gXCIvXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyBwb3J0TGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL0VtcHR5IGhvc3RuYW1lLCBbIHN0YXJ0cyBhIHBhdGhcbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICBpZiAoY2hhcnNBZnRlckRvdCA+IDYyKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0ID0gc3RyLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQSAvKic6JyovKSB7XG4gICAgICAgICAgICBwb3J0TGVuZ3RoID0gdGhpcy5fcGFyc2VQb3J0KHN0ciwgaSArIDEsIGVuZCkgKyAxO1xuICAgICAgICAgICAgaG9zdE5hbWVFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoIDwgMHg2MSAvKidhJyovKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDB4MkUgLyonLicqLykge1xuICAgICAgICAgICAgICAgIC8vTm9kZS5qcyBpZ25vcmVzIHRoaXMgZXJyb3JcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2ggPT09IERPVCB8fCBsYXN0Q2ggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3QgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2hhcnNBZnRlckRvdCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoMHg0MSAvKidBJyovIDw9IGNoICYmIGNoIDw9IDB4NUEgLyonWicqLykge1xuICAgICAgICAgICAgICAgIGRvTG93ZXJDYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vVmFsaWQgY2hhcmFjdGVycyBvdGhlciB0aGFuIEFTQ0lJIGxldHRlcnMgLSwgXywgKywgMC05XG4gICAgICAgICAgICBlbHNlIGlmICghKGNoID09PSAweDJEIC8qJy0nKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2ggPT09IDB4NUYgLyonXycqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjaCA9PT0gMHgyQiAvKicrJyovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICgweDMwIC8qJzAnKi8gPD0gY2ggJiYgY2ggPD0gMHgzOSAvKic5JyovKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdEVuZGluZ0NoYXJhY3RlcnNbY2hdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vUHJlcGVuZFNsYXNoSG9zdEVuZGVyc1tjaF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGVuZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9zdE5hbWVFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA+PSAweDdCIC8qJ3snKi8pIHtcbiAgICAgICAgICAgIGlmIChjaCA8PSAweDdFIC8qJ34nKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbm9QcmVwZW5kU2xhc2hIb3N0RW5kZXJzW2NoXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVwZW5kU2xhc2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBob3N0TmFtZUVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRuYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENoID0gY2g7XG4gICAgICAgIGNoYXJzQWZ0ZXJEb3QrKztcbiAgICB9XG5cbiAgICAvL05vZGUuanMgaWdub3JlcyB0aGlzIGVycm9yXG4gICAgLypcbiAgICBpZiAobGFzdENoID09PSBET1QpIHtcbiAgICAgICAgaG9zdE5hbWVFbmQtLTtcbiAgICB9XG4gICAgKi9cblxuICAgIGlmIChob3N0TmFtZUVuZCArIDEgIT09IHN0YXJ0ICYmXG4gICAgICAgIGhvc3ROYW1lRW5kIC0gaG9zdE5hbWVTdGFydCA8PSAyNTYpIHtcbiAgICAgICAgdmFyIGhvc3RuYW1lID0gc3RyLnNsaWNlKGhvc3ROYW1lU3RhcnQsIGhvc3ROYW1lRW5kICsgMSk7XG4gICAgICAgIGlmIChkb0xvd2VyQ2FzZSkgaG9zdG5hbWUgPSBob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoaWRuYSkgaG9zdG5hbWUgPSB0aGlzLl9ob3N0SWRuYShob3N0bmFtZSk7XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgPSBob3N0bmFtZTtcbiAgICAgICAgdGhpcy5ob3N0ID0gdGhpcy5fcG9ydCA+IDAgPyBob3N0bmFtZSArIFwiOlwiICsgdGhpcy5fcG9ydCA6IGhvc3RuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBob3N0TmFtZUVuZCArIDEgKyBwb3J0TGVuZ3RoO1xuXG59O1xuXG5VcmwucHJvdG90eXBlLl9jb3B5UHJvcHNUbyA9IGZ1bmN0aW9uIFVybCRfY29weVByb3BzVG8oaW5wdXQsIG5vUHJvdG9jb2wpIHtcbiAgICBpZiAoIW5vUHJvdG9jb2wpIHtcbiAgICAgICAgaW5wdXQuX3Byb3RvY29sID0gdGhpcy5fcHJvdG9jb2w7XG4gICAgfVxuICAgIGlucHV0Ll9ocmVmID0gdGhpcy5faHJlZjtcbiAgICBpbnB1dC5fcG9ydCA9IHRoaXMuX3BvcnQ7XG4gICAgaW5wdXQuX3ByZXBlbmRTbGFzaCA9IHRoaXMuX3ByZXBlbmRTbGFzaDtcbiAgICBpbnB1dC5hdXRoID0gdGhpcy5hdXRoO1xuICAgIGlucHV0LnNsYXNoZXMgPSB0aGlzLnNsYXNoZXM7XG4gICAgaW5wdXQuaG9zdCA9IHRoaXMuaG9zdDtcbiAgICBpbnB1dC5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWU7XG4gICAgaW5wdXQuaGFzaCA9IHRoaXMuaGFzaDtcbiAgICBpbnB1dC5zZWFyY2ggPSB0aGlzLnNlYXJjaDtcbiAgICBpbnB1dC5wYXRobmFtZSA9IHRoaXMucGF0aG5hbWU7XG59O1xuXG5VcmwucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uIFVybCRfY2xvbmUoKSB7XG4gICAgdmFyIHJldCA9IG5ldyBVcmwoKTtcbiAgICByZXQuX3Byb3RvY29sID0gdGhpcy5fcHJvdG9jb2w7XG4gICAgcmV0Ll9ocmVmID0gdGhpcy5faHJlZjtcbiAgICByZXQuX3BvcnQgPSB0aGlzLl9wb3J0O1xuICAgIHJldC5fcHJlcGVuZFNsYXNoID0gdGhpcy5fcHJlcGVuZFNsYXNoO1xuICAgIHJldC5hdXRoID0gdGhpcy5hdXRoO1xuICAgIHJldC5zbGFzaGVzID0gdGhpcy5zbGFzaGVzO1xuICAgIHJldC5ob3N0ID0gdGhpcy5ob3N0O1xuICAgIHJldC5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWU7XG4gICAgcmV0Lmhhc2ggPSB0aGlzLmhhc2g7XG4gICAgcmV0LnNlYXJjaCA9IHRoaXMuc2VhcmNoO1xuICAgIHJldC5wYXRobmFtZSA9IHRoaXMucGF0aG5hbWU7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblVybC5wcm90b3R5cGUuX2dldENvbXBvbmVudEVzY2FwZWQgPVxuZnVuY3Rpb24gVXJsJF9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgc3RhcnQsIGVuZCwgaXNBZnRlclF1ZXJ5KSB7XG4gICAgdmFyIGN1ciA9IHN0YXJ0O1xuICAgIHZhciBpID0gc3RhcnQ7XG4gICAgdmFyIHJldCA9IFwiXCI7XG4gICAgdmFyIGF1dG9Fc2NhcGVNYXAgPSBpc0FmdGVyUXVlcnkgP1xuICAgICAgICB0aGlzLl9hZnRlclF1ZXJ5QXV0b0VzY2FwZU1hcCA6IHRoaXMuX2F1dG9Fc2NhcGVNYXA7XG4gICAgZm9yICg7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBlc2NhcGVkID0gYXV0b0VzY2FwZU1hcFtjaF07XG5cbiAgICAgICAgaWYgKGVzY2FwZWQgIT09IFwiXCIgJiYgZXNjYXBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoY3VyIDwgaSkgcmV0ICs9IHN0ci5zbGljZShjdXIsIGkpO1xuICAgICAgICAgICAgcmV0ICs9IGVzY2FwZWQ7XG4gICAgICAgICAgICBjdXIgPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VyIDwgaSArIDEpIHJldCArPSBzdHIuc2xpY2UoY3VyLCBpKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VQYXRoID1cbmZ1bmN0aW9uIFVybCRfcGFyc2VQYXRoKHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIHZhciBwYXRoU3RhcnQgPSBzdGFydDtcbiAgICB2YXIgcGF0aEVuZCA9IGVuZDtcbiAgICB2YXIgZXNjYXBlID0gZmFsc2U7XG4gICAgdmFyIGF1dG9Fc2NhcGVDaGFyYWN0ZXJzID0gdGhpcy5fYXV0b0VzY2FwZUNoYXJhY3RlcnM7XG4gICAgdmFyIHByZVBhdGggPSB0aGlzLl9wb3J0ID09PSAtMiA/IFwiLzpcIiA6IFwiXCI7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaCA9PT0gMHgyMyAvKicjJyovKSB7XG4gICAgICAgICAgdGhpcy5fcGFyc2VIYXNoKHN0ciwgaSwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgICAgIHBhdGhFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAweDNGIC8qJz8nKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUXVlcnkoc3RyLCBpLCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgICAgICAgICAgcGF0aEVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVBdXRvRXNjYXBlQ2hhcnMgJiYgIWVzY2FwZSAmJiBhdXRvRXNjYXBlQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aFN0YXJ0ID4gcGF0aEVuZCkge1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gcHJlUGF0aCA9PT0gXCJcIiA/IFwiL1wiIDogcHJlUGF0aDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoO1xuICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgcGF0aCA9IHRoaXMuX2dldENvbXBvbmVudEVzY2FwZWQoc3RyLCBwYXRoU3RhcnQsIHBhdGhFbmQsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhdGggPSBzdHIuc2xpY2UocGF0aFN0YXJ0LCBwYXRoRW5kICsgMSk7XG4gICAgfVxuICAgIHRoaXMucGF0aG5hbWUgPSBwcmVQYXRoID09PSBcIlwiXG4gICAgICAgID8gKHRoaXMuX3ByZXBlbmRTbGFzaCA/IFwiL1wiICsgcGF0aCA6IHBhdGgpXG4gICAgICAgIDogcHJlUGF0aCArIHBhdGg7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZVF1ZXJ5ID0gZnVuY3Rpb24gVXJsJF9wYXJzZVF1ZXJ5KHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIHZhciBxdWVyeVN0YXJ0ID0gc3RhcnQ7XG4gICAgdmFyIHF1ZXJ5RW5kID0gZW5kO1xuICAgIHZhciBlc2NhcGUgPSBmYWxzZTtcbiAgICB2YXIgYXV0b0VzY2FwZUNoYXJhY3RlcnMgPSB0aGlzLl9hdXRvRXNjYXBlQ2hhcmFjdGVycztcblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4MjMgLyonIycqLykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VIYXNoKHN0ciwgaSwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgICAgIHF1ZXJ5RW5kID0gaSAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyAmJiAhZXNjYXBlICYmIGF1dG9Fc2NhcGVDaGFyYWN0ZXJzW2NoXSA9PT0gMSkge1xuICAgICAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChxdWVyeVN0YXJ0ID4gcXVlcnlFbmQpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBcIlwiO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXJ5O1xuICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgcXVlcnkgPSB0aGlzLl9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgcXVlcnlTdGFydCwgcXVlcnlFbmQsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcXVlcnkgPSBzdHIuc2xpY2UocXVlcnlTdGFydCwgcXVlcnlFbmQgKyAxKTtcbiAgICB9XG4gICAgdGhpcy5zZWFyY2ggPSBxdWVyeTtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlSGFzaCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VIYXNoKHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICB0aGlzLmhhc2ggPSBcIlwiO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5oYXNoID0gZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyA/XG4gICAgICAgIHN0ci5zbGljZShzdGFydCwgZW5kICsgMSkgOiB0aGlzLl9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgc3RhcnQsIGVuZCwgdHJ1ZSk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsLnByb3RvdHlwZSwgXCJwb3J0XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fcG9ydCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKFwiXCIgKyB0aGlzLl9wb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gcGFyc2VJbnQodiwgMTApO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcmwucHJvdG90eXBlLCBcInF1ZXJ5XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeTtcbiAgICAgICAgaWYgKHF1ZXJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2g7XG5cbiAgICAgICAgaWYgKHNlYXJjaCkge1xuICAgICAgICAgICAgaWYgKHNlYXJjaC5jaGFyQ29kZUF0KDApID09PSAweDNGIC8qJz8nKi8pIHtcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2guc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VhcmNoICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnkgPSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5ID0gdjtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8IFwiXCI7XG4gICAgICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgXCJcIjtcbiAgICAgICAgaWYgKHAgfHwgcykge1xuICAgICAgICAgICAgcmV0dXJuIHAgKyBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocCA9PSBudWxsICYmIHMpID8gKFwiL1wiICsgcykgOiBudWxsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbigpIHt9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwicHJvdG9jb2xcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm90byA9IHRoaXMuX3Byb3RvY29sO1xuICAgICAgICByZXR1cm4gcHJvdG8gPyBwcm90byArIFwiOlwiIDogcHJvdG87XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gdi5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKHYuY2hhckNvZGVBdChlbmQpID09PSAweDNBIC8qJzonKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHYuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsLnByb3RvdHlwZSwgXCJocmVmXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHJlZiA9IHRoaXMuX2hyZWY7XG4gICAgICAgIGlmICghaHJlZikge1xuICAgICAgICAgICAgaHJlZiA9IHRoaXMuX2hyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX2hyZWYgPSB2O1xuICAgIH1cbn0pO1xuXG5VcmwucGFyc2UgPSBmdW5jdGlvbiBVcmwkUGFyc2Uoc3RyLCBwYXJzZVF1ZXJ5U3RyaW5nLCBob3N0RGVub3Rlc1NsYXNoLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKSB7XG4gICAgaWYgKHN0ciBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHN0cjtcbiAgICB2YXIgcmV0ID0gbmV3IFVybCgpO1xuICAgIHJldC5wYXJzZShzdHIsICEhcGFyc2VRdWVyeVN0cmluZywgISFob3N0RGVub3Rlc1NsYXNoLCAhIWRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5VcmwuZm9ybWF0ID0gZnVuY3Rpb24gVXJsJEZvcm1hdChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvYmogPSBVcmwucGFyc2Uob2JqKTtcbiAgICB9XG4gICAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkge1xuICAgICAgICByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufTtcblxuVXJsLnJlc29sdmUgPSBmdW5jdGlvbiBVcmwkUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gICAgcmV0dXJuIFVybC5wYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn07XG5cblVybC5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24gVXJsJFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICAgIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gICAgcmV0dXJuIFVybC5wYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn07XG5cbmZ1bmN0aW9uIF9lc2NhcGVQYXRoKHBhdGhuYW1lKSB7XG4gICAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9lc2NhcGVTZWFyY2goc2VhcmNoKSB7XG4gICAgcmV0dXJuIHNlYXJjaC5yZXBsYWNlKC8jL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICAgIH0pO1xufVxuXG4vL1NlYXJjaCBgY2hhcjFgIChpbnRlZ2VyIGNvZGUgZm9yIGEgY2hhcmFjdGVyKSBpbiBgc3RyaW5nYFxuLy9zdGFydGluZyBmcm9tIGBmcm9tSW5kZXhgIGFuZCBlbmRpbmcgYXQgYHN0cmluZy5sZW5ndGggLSAxYFxuLy9vciB3aGVuIGEgc3RvcCBjaGFyYWN0ZXIgaXMgZm91bmRcbmZ1bmN0aW9uIGNvbnRhaW5zQ2hhcmFjdGVyKHN0cmluZywgY2hhcjEsIGZyb21JbmRleCwgc3RvcENoYXJhY3RlclRhYmxlKSB7XG4gICAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IGZyb21JbmRleDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gY2hhcjEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0b3BDaGFyYWN0ZXJUYWJsZVtjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vU2VlIGlmIGBjaGFyMWAgb3IgYGNoYXIyYCAoaW50ZWdlciBjb2RlcyBmb3IgY2hhcmFjdGVycylcbi8vaXMgY29udGFpbmVkIGluIGBzdHJpbmdgXG5mdW5jdGlvbiBjb250YWluc0NoYXJhY3RlcjIoc3RyaW5nLCBjaGFyMSwgY2hhcjIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09IGNoYXIxIHx8IGNoID09PSBjaGFyMikgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy9NYWtlcyBhbiBhcnJheSBvZiAxMjggdWludDgncyB3aGljaCByZXByZXNlbnQgYm9vbGVhbiB2YWx1ZXMuXG4vL1NwZWMgaXMgYW4gYXJyYXkgb2YgYXNjaWkgY29kZSBwb2ludHMgb3IgYXNjaWkgY29kZSBwb2ludCByYW5nZXNcbi8vcmFuZ2VzIGFyZSBleHByZXNzZWQgYXMgW3N0YXJ0LCBlbmRdXG5cbi8vQ3JlYXRlIGEgdGFibGUgd2l0aCB0aGUgY2hhcmFjdGVycyAweDMwLTB4MzkgKGRlY2ltYWxzICcwJyAtICc5JykgYW5kXG4vLzB4N0EgKGxvd2VyY2FzZWxldHRlciAneicpIGFzIGB0cnVlYDpcbi8vXG4vL3ZhciBhID0gbWFrZUFzY2lpVGFibGUoW1sweDMwLCAweDM5XSwgMHg3QV0pO1xuLy9hWzB4MzBdOyAvLzFcbi8vYVsweDE1XTsgLy8wXG4vL2FbMHgzNV07IC8vMVxuZnVuY3Rpb24gbWFrZUFzY2lpVGFibGUoc3BlYykge1xuICAgIHZhciByZXQgPSBuZXcgVWludDhBcnJheSgxMjgpO1xuICAgIHNwZWMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXRbaXRlbV0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaXRlbVswXTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpdGVtWzFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmV0W2pdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuXG52YXIgYXV0b0VzY2FwZSA9IFtcIjxcIiwgXCI+XCIsIFwiXFxcIlwiLCBcImBcIiwgXCIgXCIsIFwiXFxyXCIsIFwiXFxuXCIsXG4gICAgXCJcXHRcIiwgXCJ7XCIsIFwifVwiLCBcInxcIiwgXCJcXFxcXCIsIFwiXlwiLCBcImBcIiwgXCInXCJdO1xuXG52YXIgYXV0b0VzY2FwZU1hcCA9IG5ldyBBcnJheSgxMjgpO1xuXG5cblxuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF1dG9Fc2NhcGVNYXAubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBhdXRvRXNjYXBlTWFwW2ldID0gXCJcIjtcbn1cblxuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgYyA9IGF1dG9Fc2NhcGVbaV07XG4gICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChjKTtcbiAgICBpZiAoZXNjID09PSBjKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShjKTtcbiAgICB9XG4gICAgYXV0b0VzY2FwZU1hcFtjLmNoYXJDb2RlQXQoMCldID0gZXNjO1xufVxudmFyIGFmdGVyUXVlcnlBdXRvRXNjYXBlTWFwID0gYXV0b0VzY2FwZU1hcC5zbGljZSgpO1xuYXV0b0VzY2FwZU1hcFsweDVDIC8qJ1xcJyovXSA9IFwiL1wiO1xuXG52YXIgc2xhc2hQcm90b2NvbHMgPSBVcmwucHJvdG90eXBlLl9zbGFzaFByb3RvY29scyA9IHtcbiAgICBodHRwOiB0cnVlLFxuICAgIGh0dHBzOiB0cnVlLFxuICAgIGdvcGhlcjogdHJ1ZSxcbiAgICBmaWxlOiB0cnVlLFxuICAgIGZ0cDogdHJ1ZSxcblxuICAgIFwiaHR0cDpcIjogdHJ1ZSxcbiAgICBcImh0dHBzOlwiOiB0cnVlLFxuICAgIFwiZ29waGVyOlwiOiB0cnVlLFxuICAgIFwiZmlsZTpcIjogdHJ1ZSxcbiAgICBcImZ0cDpcIjogdHJ1ZVxufTtcblxuLy9PcHRpbWl6ZSBiYWNrIGZyb20gbm9ybWFsaXplZCBvYmplY3QgY2F1c2VkIGJ5IG5vbi1pZGVudGlmaWVyIGtleXNcbmZ1bmN0aW9uIGYoKXt9XG5mLnByb3RvdHlwZSA9IHNsYXNoUHJvdG9jb2xzO1xuXG5VcmwucHJvdG90eXBlLl9wcm90b2NvbENoYXJhY3RlcnMgPSBtYWtlQXNjaWlUYWJsZShbXG4gICAgWzB4NjEgLyonYScqLywgMHg3QSAvKid6JyovXSxcbiAgICBbMHg0MSAvKidBJyovLCAweDVBIC8qJ1onKi9dLFxuICAgIDB4MkUgLyonLicqLywgMHgyQiAvKicrJyovLCAweDJEIC8qJy0nKi9cbl0pO1xuXG5VcmwucHJvdG90eXBlLl9ob3N0RW5kaW5nQ2hhcmFjdGVycyA9IG1ha2VBc2NpaVRhYmxlKFtcbiAgICAweDIzIC8qJyMnKi8sIDB4M0YgLyonPycqLywgMHgyRiAvKicvJyovLCAweDVDIC8qJ1xcJyovXG5dKTtcblxuVXJsLnByb3RvdHlwZS5fYXV0b0VzY2FwZUNoYXJhY3RlcnMgPSBtYWtlQXNjaWlUYWJsZShcbiAgICBhdXRvRXNjYXBlLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2LmNoYXJDb2RlQXQoMCk7XG4gICAgfSlcbik7XG5cbi8vSWYgdGhlc2UgY2hhcmFjdGVycyBlbmQgYSBob3N0IG5hbWUsIHRoZSBwYXRoIHdpbGwgbm90IGJlIHByZXBlbmRlZCBhIC9cblVybC5wcm90b3R5cGUuX25vUHJlcGVuZFNsYXNoSG9zdEVuZGVycyA9IG1ha2VBc2NpaVRhYmxlKFxuICAgIFtcbiAgICAgICAgXCI8XCIsIFwiPlwiLCBcIidcIiwgXCJgXCIsIFwiIFwiLCBcIlxcclwiLFxuICAgICAgICBcIlxcblwiLCBcIlxcdFwiLCBcIntcIiwgXCJ9XCIsIFwifFwiLFxuICAgICAgICBcIl5cIiwgXCJgXCIsIFwiXFxcIlwiLCBcIiVcIiwgXCI7XCJcbiAgICBdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2LmNoYXJDb2RlQXQoMCk7XG4gICAgfSlcbik7XG5cblVybC5wcm90b3R5cGUuX2F1dG9Fc2NhcGVNYXAgPSBhdXRvRXNjYXBlTWFwO1xuVXJsLnByb3RvdHlwZS5fYWZ0ZXJRdWVyeUF1dG9Fc2NhcGVNYXAgPSBhZnRlclF1ZXJ5QXV0b0VzY2FwZU1hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG5cblVybC5yZXBsYWNlID0gZnVuY3Rpb24gVXJsJFJlcGxhY2UoKSB7XG4gICAgcmVxdWlyZS5jYWNoZS51cmwgPSB7XG4gICAgICAgIGV4cG9ydHM6IFVybFxuICAgIH07XG59O1xuIiwiLyoqXHJcbiAqIENvbW1vbiB1dGlsaXRpZXNcclxuICogQG1vZHVsZSBnbE1hdHJpeFxyXG4gKi9cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5leHBvcnQgdmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCB2YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5leHBvcnQgdmFyIFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuLyoqXHJcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3Rvcn0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG4vKipcclxuICogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbihhKSB7XG4gIHJldHVybiBhICogZGVncmVlO1xufVxuLyoqXHJcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcclxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xyXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MiBmcm9tIFwiLi9tYXQyLmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQyZCBmcm9tIFwiLi9tYXQyZC5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MyBmcm9tIFwiLi9tYXQzLmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gXCIuL21hdDQuanNcIjtcbmltcG9ydCAqIGFzIHF1YXQgZnJvbSBcIi4vcXVhdC5qc1wiO1xuaW1wb3J0ICogYXMgcXVhdDIgZnJvbSBcIi4vcXVhdDIuanNcIjtcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSBcIi4vdmVjMi5qc1wiO1xuaW1wb3J0ICogYXMgdmVjMyBmcm9tIFwiLi92ZWMzLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL3ZlYzQuanNcIjtcbmV4cG9ydCB7IGdsTWF0cml4LCBtYXQyLCBtYXQyZCwgbWF0MywgbWF0NCwgcXVhdCwgcXVhdDIsIHZlYzIsIHZlYzMsIHZlYzQgfTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAyeDIgTWF0cml4XHJcbiAqIEBtb2R1bGUgbWF0MlxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIG1hdHJpeCB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZVxuICAvLyBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGExID0gYVsxXTtcbiAgICBvdXRbMV0gPSBhWzJdO1xuICAgIG91dFsyXSA9IGExO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhWzFdO1xuICAgIG91dFszXSA9IGFbM107XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYTMgKiBkZXQ7XG4gIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgb3V0WzJdID0gLWEyICogZGV0O1xuICBvdXRbM10gPSBhMCAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgdmFyIGEwID0gYVswXTtcbiAgb3V0WzBdID0gYVszXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gbWF0MidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgdjAgPSB2WzBdLFxuICAgICAgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMCAqIHYwO1xuICBvdXRbMV0gPSBhMSAqIHYwO1xuICBvdXRbMl0gPSBhMiAqIHYxO1xuICBvdXRbM10gPSBhMyAqIHYxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0Mi5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MihcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIExEVShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdIC8gYVswXTtcbiAgVVswXSA9IGFbMF07XG4gIFVbMV0gPSBhWzFdO1xuICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdO1xuICByZXR1cm4gW0wsIEQsIFVdO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSk7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDIncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAyeDMgTWF0cml4XHJcbiAqIEBtb2R1bGUgbWF0MmRcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XHJcbiAqIDxwcmU+XHJcbiAqIFthLCBiLFxyXG4gKiAgYywgZCxcclxuICogIHR4LCB0eV1cclxuICogPC9wcmU+XHJcbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcclxuICogPHByZT5cclxuICogW2EsIGIsIDAsXHJcbiAqICBjLCBkLCAwLFxyXG4gKiAgdHgsIHR5LCAxXVxyXG4gKiA8L3ByZT5cclxuICogVGhlIGxhc3QgY29sdW1uIGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJkXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQyZCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXQyZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIG91dFsyXSA9IGM7XG4gIG91dFszXSA9IGQ7XG4gIG91dFs0XSA9IHR4O1xuICBvdXRbNV0gPSB0eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyZCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgb3V0WzBdID0gYTtcbiAgb3V0WzFdID0gYjtcbiAgb3V0WzJdID0gYztcbiAgb3V0WzNdID0gZDtcbiAgb3V0WzRdID0gdHg7XG4gIG91dFs1XSA9IHR5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYWEgPSBhWzBdLFxuICAgICAgYWIgPSBhWzFdLFxuICAgICAgYWMgPSBhWzJdLFxuICAgICAgYWQgPSBhWzNdO1xuICB2YXIgYXR4ID0gYVs0XSxcbiAgICAgIGF0eSA9IGFbNV07XG4gIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgb3V0WzFdID0gLWFiICogZGV0O1xuICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gIG91dFszXSA9IGFhICogZGV0O1xuICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdO1xuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgb3V0WzRdID0gYTAgKiBiNCArIGEyICogYjUgKyBhNDtcbiAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0MmQgYnkgdGhlIGdpdmVuIGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGEwICogYyArIGEyICogcztcbiAgb3V0WzFdID0gYTEgKiBjICsgYTMgKiBzO1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICBvdXRbNF0gPSBhNDtcbiAgb3V0WzVdID0gYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV07XG4gIHZhciB2MCA9IHZbMF0sXG4gICAgICB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIHYwID0gdlswXSxcbiAgICAgIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTA7XG4gIG91dFsxXSA9IGExO1xuICBvdXRbMl0gPSBhMjtcbiAgb3V0WzNdID0gYTM7XG4gIG91dFs0XSA9IGEwICogdjAgKyBhMiAqIHYxICsgYTQ7XG4gIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDJkLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyZC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gdlsxXTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSB2WzBdO1xuICBvdXRbNV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDJkKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCAxKTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyZCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyZCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAzeDMgTWF0cml4XHJcbiAqIEBtb2R1bGUgbWF0M1xyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzRdO1xuICBvdXRbNF0gPSBhWzVdO1xuICBvdXRbNV0gPSBhWzZdO1xuICBvdXRbNl0gPSBhWzhdO1xuICBvdXRbN10gPSBhWzldO1xuICBvdXRbOF0gPSBhWzEwXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0MyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDMgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMTIgPSBhWzVdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhMDE7XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhMDI7XG4gICAgb3V0WzddID0gYTEyO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVszXTtcbiAgICBvdXRbMl0gPSBhWzZdO1xuICAgIG91dFszXSA9IGFbMV07XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzddO1xuICAgIG91dFs2XSA9IGFbMl07XG4gICAgb3V0WzddID0gYVs1XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICB2YXIgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxO1xuICB2YXIgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMDtcbiAgdmFyIGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMDsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYjAxICogZGV0O1xuICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICBvdXRbM10gPSBiMTEgKiBkZXQ7XG4gIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gIG91dFs2XSA9IGIyMSAqIGRldDtcbiAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIG91dFswXSA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcbiAgb3V0WzFdID0gYTAyICogYTIxIC0gYTAxICogYTIyO1xuICBvdXRbMl0gPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIG91dFszXSA9IGExMiAqIGEyMCAtIGExMCAqIGEyMjtcbiAgb3V0WzRdID0gYTAwICogYTIyIC0gYTAyICogYTIwO1xuICBvdXRbNV0gPSBhMDIgKiBhMTAgLSBhMDAgKiBhMTI7XG4gIG91dFs2XSA9IGExMCAqIGEyMSAtIGExMSAqIGEyMDtcbiAgb3V0WzddID0gYTAxICogYTIwIC0gYTAwICogYTIxO1xuICBvdXRbOF0gPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICB2YXIgYjAwID0gYlswXSxcbiAgICAgIGIwMSA9IGJbMV0sXG4gICAgICBiMDIgPSBiWzJdO1xuICB2YXIgYjEwID0gYlszXSxcbiAgICAgIGIxMSA9IGJbNF0sXG4gICAgICBiMTIgPSBiWzVdO1xuICB2YXIgYjIwID0gYls2XSxcbiAgICAgIGIyMSA9IGJbN10sXG4gICAgICBiMjIgPSBiWzhdO1xuICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdO1xuICBvdXRbMF0gPSBhMDA7XG4gIG91dFsxXSA9IGEwMTtcbiAgb3V0WzJdID0gYTAyO1xuICBvdXRbM10gPSBhMTA7XG4gIG91dFs0XSA9IGExMTtcbiAgb3V0WzVdID0gYTEyO1xuICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuICBvdXRbNl0gPSBhMjA7XG4gIG91dFs3XSA9IGEyMTtcbiAgb3V0WzhdID0gYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdO1xuICBvdXRbMF0gPSB4ICogYVswXTtcbiAgb3V0WzFdID0geCAqIGFbMV07XG4gIG91dFsyXSA9IHggKiBhWzJdO1xuICBvdXRbM10gPSB5ICogYVszXTtcbiAgb3V0WzRdID0geSAqIGFbNF07XG4gIG91dFs1XSA9IHkgKiBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQzLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSB2WzBdO1xuICBvdXRbN10gPSB2WzFdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gLXM7XG4gIG91dFs0XSA9IGM7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gdlsxXTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgbWF0MmQgaW50byBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQyZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gYVsyXTtcbiAgb3V0WzRdID0gYVszXTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gYVs0XTtcbiAgb3V0WzddID0gYVs1XTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbM10gPSB5eCAtIHd6O1xuICBvdXRbNl0gPSB6eCArIHd5O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzddID0genkgLSB3eDtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzVdID0genkgKyB3eDtcbiAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhIDN4MyBub3JtYWwgbWF0cml4ICh0cmFuc3Bvc2UgaW52ZXJzZSkgZnJvbSB0aGUgNHg0IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbEZyb21NYXQ0KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgdmFyIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgdmFyIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgdmFyIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgdmFyIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgdmFyIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgdmFyIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbMl0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFs0XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzZdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSAyRCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgeW91ciBnbCBjb250ZXh0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGdsIGNvbnRleHRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2plY3Rpb24ob3V0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIG91dFswXSA9IDIgLyB3aWR0aDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gLTIgLyBoZWlnaHQ7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IC0xO1xuICBvdXRbN10gPSAxO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQzKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcclxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSwgYVs3XSwgYVs4XSk7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MydzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XSAqIHNjYWxlO1xuICBvdXRbN10gPSBhWzddICsgYls3XSAqIHNjYWxlO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XSxcbiAgICAgIGE4ID0gYVs4XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XSxcbiAgICAgIGI4ID0gYls4XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDR4NCBNYXRyaXg8YnI+Rm9ybWF0OiBjb2x1bW4tbWFqb3IsIHdoZW4gdHlwZWQgb3V0IGl0IGxvb2tzIGxpa2Ugcm93LW1ham9yPGJyPlRoZSBtYXRyaWNlcyBhcmUgYmVpbmcgcG9zdCBtdWx0aXBsaWVkLlxyXG4gKiBAbW9kdWxlIG1hdDRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcclxuICpcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0NCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gQSBuZXcgbWF0NFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQ0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXTtcbiAgICB2YXIgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcbiAgICB2YXIgYTIzID0gYVsxMV07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGEwMTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGEwMjtcbiAgICBvdXRbOV0gPSBhMTI7XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhMDM7XG4gICAgb3V0WzEzXSA9IGExMztcbiAgICBvdXRbMTRdID0gYTIzO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGFbMV07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGFbMl07XG4gICAgb3V0WzldID0gYVs2XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhWzNdO1xuICAgIG91dFsxM10gPSBhWzddO1xuICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICBvdXRbMF0gPSBhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMik7XG4gIG91dFsxXSA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzJdID0gYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpO1xuICBvdXRbM10gPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs0XSA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzVdID0gYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpO1xuICBvdXRbNl0gPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs3XSA9IGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzhdID0gYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpO1xuICBvdXRbOV0gPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gIG91dFsxMF0gPSBhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSk7XG4gIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gIG91dFsxM10gPSBhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSk7XG4gIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gIG91dFsxNV0gPSBhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0c1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTsgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG5cbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls0XTtcbiAgYjEgPSBiWzVdO1xuICBiMiA9IGJbNl07XG4gIGIzID0gYls3XTtcbiAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs1XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbNl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls4XTtcbiAgYjEgPSBiWzldO1xuICBiMiA9IGJbMTBdO1xuICBiMyA9IGJbMTFdO1xuICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzldID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxMF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbMTJdO1xuICBiMSA9IGJbMTNdO1xuICBiMiA9IGJbMTRdO1xuICBiMyA9IGJbMTVdO1xuICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxM10gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzE0XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV0sXG4gICAgICB6ID0gdlsyXTtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gIH0gZWxzZSB7XG4gICAgYTAwID0gYVswXTtcbiAgICBhMDEgPSBhWzFdO1xuICAgIGEwMiA9IGFbMl07XG4gICAgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdO1xuICAgIGExMSA9IGFbNV07XG4gICAgYTEyID0gYVs2XTtcbiAgICBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07XG4gICAgYTIxID0gYVs5XTtcbiAgICBhMjIgPSBhWzEwXTtcbiAgICBhMjMgPSBhWzExXTtcbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcbiAgICBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwO1xuICAgIG91dFs1XSA9IGExMTtcbiAgICBvdXRbNl0gPSBhMTI7XG4gICAgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDtcbiAgICBvdXRbOV0gPSBhMjE7XG4gICAgb3V0WzEwXSA9IGEyMjtcbiAgICBvdXRbMTFdID0gYTIzO1xuICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICBvdXRbMF0gPSBhWzBdICogeDtcbiAgb3V0WzFdID0gYVsxXSAqIHg7XG4gIG91dFsyXSA9IGFbMl0gKiB4O1xuICBvdXRbM10gPSBhWzNdICogeDtcbiAgb3V0WzRdID0gYVs0XSAqIHk7XG4gIG91dFs1XSA9IGFbNV0gKiB5O1xuICBvdXRbNl0gPSBhWzZdICogeTtcbiAgb3V0WzddID0gYVs3XSAqIHk7XG4gIG91dFs4XSA9IGFbOF0gKiB6O1xuICBvdXRbOV0gPSBhWzldICogejtcbiAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgdmFyIGIwMCwgYjAxLCBiMDI7XG4gIHZhciBiMTAsIGIxMSwgYjEyO1xuICB2YXIgYjIwLCBiMjEsIGIyMjtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG4gIGEwMCA9IGFbMF07XG4gIGEwMSA9IGFbMV07XG4gIGEwMiA9IGFbMl07XG4gIGEwMyA9IGFbM107XG4gIGExMCA9IGFbNF07XG4gIGExMSA9IGFbNV07XG4gIGExMiA9IGFbNl07XG4gIGExMyA9IGFbN107XG4gIGEyMCA9IGFbOF07XG4gIGEyMSA9IGFbOV07XG4gIGEyMiA9IGFbMTBdO1xuICBhMjMgPSBhWzExXTsgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG5cbiAgYjAwID0geCAqIHggKiB0ICsgYztcbiAgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBiMTAgPSB4ICogeSAqIHQgLSB6ICogcztcbiAgYjExID0geSAqIHkgKiB0ICsgYztcbiAgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIGIyMCA9IHggKiB6ICogdCArIHkgKiBzO1xuICBiMjEgPSB5ICogeiAqIHQgLSB4ICogcztcbiAgYjIyID0geiAqIHogKiB0ICsgYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGExMCA9IGFbNF07XG4gIHZhciBhMTEgPSBhWzVdO1xuICB2YXIgYTEyID0gYVs2XTtcbiAgdmFyIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gdlsxXTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IHZbMl07XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gLXM7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBzO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gIG91dFsxXSA9IHh5ICsgd3o7XG4gIG91dFsyXSA9IHh6IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHh5IC0gd3o7XG4gIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gIG91dFs2XSA9IHl6ICsgd3g7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHh6ICsgd3k7XG4gIG91dFs5XSA9IHl6IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGZyb20gYSBkdWFsIHF1YXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IE1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQyKG91dCwgYSkge1xuICB2YXIgdHJhbnNsYXRpb24gPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XTtcbiAgdmFyIG1hZ25pdHVkZSA9IGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiArIGJ3ICogYnc7IC8vT25seSBzY2FsZSBpZiBpdCBtYWtlcyBzZW5zZVxuXG4gIGlmIChtYWduaXR1ZGUgPiAwKSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMiAvIG1hZ25pdHVkZTtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDIgLyBtYWduaXR1ZGU7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMjtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDI7XG4gIH1cblxuICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIGEsIHRyYW5zbGF0aW9uKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cclxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcclxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcclxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxyXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGluZyhvdXQsIG1hdCkge1xuICB2YXIgbTExID0gbWF0WzBdO1xuICB2YXIgbTEyID0gbWF0WzFdO1xuICB2YXIgbTEzID0gbWF0WzJdO1xuICB2YXIgbTIxID0gbWF0WzRdO1xuICB2YXIgbTIyID0gbWF0WzVdO1xuICB2YXIgbTIzID0gbWF0WzZdO1xuICB2YXIgbTMxID0gbWF0WzhdO1xuICB2YXIgbTMyID0gbWF0WzldO1xuICB2YXIgbTMzID0gbWF0WzEwXTtcbiAgb3V0WzBdID0gTWF0aC5oeXBvdChtMTEsIG0xMiwgbTEzKTtcbiAgb3V0WzFdID0gTWF0aC5oeXBvdChtMjEsIG0yMiwgbTIzKTtcbiAgb3V0WzJdID0gTWF0aC5oeXBvdChtMzEsIG0zMiwgbTMzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uYWwgY29tcG9uZW50XHJcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxyXG4gKiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sIHRoZSByZXR1cm5lZCBxdWF0ZXJuaW9uIHdpbGwgYmUgdGhlXHJcbiAqICBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIG9yaWdpbmFsbHkgc3VwcGxpZWQuXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxyXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGlvbihvdXQsIG1hdCkge1xuICB2YXIgc2NhbGluZyA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBnZXRTY2FsaW5nKHNjYWxpbmcsIG1hdCk7XG4gIHZhciBpczEgPSAxIC8gc2NhbGluZ1swXTtcbiAgdmFyIGlzMiA9IDEgLyBzY2FsaW5nWzFdO1xuICB2YXIgaXMzID0gMSAvIHNjYWxpbmdbMl07XG4gIHZhciBzbTExID0gbWF0WzBdICogaXMxO1xuICB2YXIgc20xMiA9IG1hdFsxXSAqIGlzMjtcbiAgdmFyIHNtMTMgPSBtYXRbMl0gKiBpczM7XG4gIHZhciBzbTIxID0gbWF0WzRdICogaXMxO1xuICB2YXIgc20yMiA9IG1hdFs1XSAqIGlzMjtcbiAgdmFyIHNtMjMgPSBtYXRbNl0gKiBpczM7XG4gIHZhciBzbTMxID0gbWF0WzhdICogaXMxO1xuICB2YXIgc20zMiA9IG1hdFs5XSAqIGlzMjtcbiAgdmFyIHNtMzMgPSBtYXRbMTBdICogaXMzO1xuICB2YXIgdHJhY2UgPSBzbTExICsgc20yMiArIHNtMzM7XG4gIHZhciBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFsxXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgIG91dFsyXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICB9IGVsc2UgaWYgKHNtMTEgPiBzbTIyICYmIHNtMTEgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTExIC0gc20yMiAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMl0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgfSBlbHNlIGlmIChzbTIyID4gc20zMykge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20yMiAtIHNtMTEgLSBzbTMzKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzBdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKHNtMjMgKyBzbTMyKSAvIFM7XG4gIH0gZWxzZSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTMzIC0gc20xMSAtIHNtMjIpICogMjtcbiAgICBvdXRbM10gPSAoc20xMiAtIHNtMjEpIC8gUztcbiAgICBvdXRbMF0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgICBvdXRbMV0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbihvdXQsIHEsIHYsIHMsIG8pIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgdmFyIHN4ID0gc1swXTtcbiAgdmFyIHN5ID0gc1sxXTtcbiAgdmFyIHN6ID0gc1syXTtcbiAgdmFyIG94ID0gb1swXTtcbiAgdmFyIG95ID0gb1sxXTtcbiAgdmFyIG96ID0gb1syXTtcbiAgdmFyIG91dDAgPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgdmFyIG91dDEgPSAoeHkgKyB3eikgKiBzeDtcbiAgdmFyIG91dDIgPSAoeHogLSB3eSkgKiBzeDtcbiAgdmFyIG91dDQgPSAoeHkgLSB3eikgKiBzeTtcbiAgdmFyIG91dDUgPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgdmFyIG91dDYgPSAoeXogKyB3eCkgKiBzeTtcbiAgdmFyIG91dDggPSAoeHogKyB3eSkgKiBzejtcbiAgdmFyIG91dDkgPSAoeXogLSB3eCkgKiBzejtcbiAgdmFyIG91dDEwID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFswXSA9IG91dDA7XG4gIG91dFsxXSA9IG91dDE7XG4gIG91dFsyXSA9IG91dDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IG91dDQ7XG4gIG91dFs1XSA9IG91dDU7XG4gIG91dFs2XSA9IG91dDY7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IG91dDg7XG4gIG91dFs5XSA9IG91dDk7XG4gIG91dFsxMF0gPSBvdXQxMDtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdICsgb3ggLSAob3V0MCAqIG94ICsgb3V0NCAqIG95ICsgb3V0OCAqIG96KTtcbiAgb3V0WzEzXSA9IHZbMV0gKyBveSAtIChvdXQxICogb3ggKyBvdXQ1ICogb3kgKyBvdXQ5ICogb3opO1xuICBvdXRbMTRdID0gdlsyXSArIG96IC0gKG91dDIgKiBveCArIG91dDYgKiBveSArIG91dDEwICogb3opO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB5eCAtIHd6O1xuICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzZdID0genkgKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0genggKyB3eTtcbiAgb3V0WzldID0genkgLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KTtcbiAgdmFyIHRiID0gMSAvICh0b3AgLSBib3R0b20pO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBuZWFyICogMiAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBuZWFyICogMiAqIHRiO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAqIDIgKiBuZjtcbiAgb3V0WzE1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxyXG4gKiBQYXNzaW5nIG51bGwvdW5kZWZpbmVkL25vIHZhbHVlIGZvciBmYXIgd2lsbCBnZW5lcmF0ZSBpbmZpbml0ZSBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcclxuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bSwgY2FuIGJlIG51bGwgb3IgSW5maW5pdHlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICBuZjtcbiAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gZjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNV0gPSAwO1xuXG4gIGlmIChmYXIgIT0gbnVsbCAmJiBmYXIgIT09IEluZmluaXR5KSB7XG4gICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTRdID0gMiAqIGZhciAqIG5lYXIgKiBuZjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMTBdID0gLTE7XG4gICAgb3V0WzE0XSA9IC0yICogbmVhcjtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cclxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxyXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pO1xuICB2YXIgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG4gIG91dFswXSA9IHhTY2FsZTtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgb3V0WzRdID0gMC4wO1xuICBvdXRbNV0gPSB5U2NhbGU7XG4gIG91dFs2XSA9IDAuMDtcbiAgb3V0WzddID0gMC4wO1xuICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgb3V0WzldID0gKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjU7XG4gIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxMV0gPSAtMS4wO1xuICBvdXRbMTJdID0gMC4wO1xuICBvdXRbMTNdID0gMC4wO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzE1XSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICB2YXIgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXMuXHJcbiAqIElmIHlvdSB3YW50IGEgbWF0cml4IHRoYXQgYWN0dWFsbHkgbWFrZXMgYW4gb2JqZWN0IGxvb2sgYXQgYW5vdGhlciBvYmplY3QsIHlvdSBzaG91bGQgdXNlIHRhcmdldFRvIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbjtcbiAgdmFyIGV5ZXggPSBleWVbMF07XG4gIHZhciBleWV5ID0gZXllWzFdO1xuICB2YXIgZXlleiA9IGV5ZVsyXTtcbiAgdmFyIHVweCA9IHVwWzBdO1xuICB2YXIgdXB5ID0gdXBbMV07XG4gIHZhciB1cHogPSB1cFsyXTtcbiAgdmFyIGNlbnRlcnggPSBjZW50ZXJbMF07XG4gIHZhciBjZW50ZXJ5ID0gY2VudGVyWzFdO1xuICB2YXIgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gaWRlbnRpdHkob3V0KTtcbiAgfVxuXG4gIHowID0gZXlleCAtIGNlbnRlcng7XG4gIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gIHoyID0gZXlleiAtIGNlbnRlcno7XG4gIGxlbiA9IDEgLyBNYXRoLmh5cG90KHowLCB6MSwgejIpO1xuICB6MCAqPSBsZW47XG4gIHoxICo9IGxlbjtcbiAgejIgKj0gbGVuO1xuICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSBNYXRoLmh5cG90KHgwLCB4MSwgeDIpO1xuXG4gIGlmICghbGVuKSB7XG4gICAgeDAgPSAwO1xuICAgIHgxID0gMDtcbiAgICB4MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeTAsIHkxLCB5Mik7XG5cbiAgaWYgKCFsZW4pIHtcbiAgICB5MCA9IDA7XG4gICAgeTEgPSAwO1xuICAgIHkyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHkwICo9IGxlbjtcbiAgICB5MSAqPSBsZW47XG4gICAgeTIgKj0gbGVuO1xuICB9XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHkwO1xuICBvdXRbMl0gPSB6MDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geDE7XG4gIG91dFs1XSA9IHkxO1xuICBvdXRbNl0gPSB6MTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geDI7XG4gIG91dFs5XSA9IHkyO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBtYXRyaXggdGhhdCBtYWtlcyBzb21ldGhpbmcgbG9vayBhdCBzb21ldGhpbmcgZWxzZS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRhcmdldFRvKG91dCwgZXllLCB0YXJnZXQsIHVwKSB7XG4gIHZhciBleWV4ID0gZXllWzBdLFxuICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICB1cHggPSB1cFswXSxcbiAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgdXB6ID0gdXBbMl07XG4gIHZhciB6MCA9IGV5ZXggLSB0YXJnZXRbMF0sXG4gICAgICB6MSA9IGV5ZXkgLSB0YXJnZXRbMV0sXG4gICAgICB6MiA9IGV5ZXogLSB0YXJnZXRbMl07XG4gIHZhciBsZW4gPSB6MCAqIHowICsgejEgKiB6MSArIHoyICogejI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG4gIH1cblxuICB2YXIgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxLFxuICAgICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyLFxuICAgICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSB4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geDE7XG4gIG91dFsyXSA9IHgyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgb3V0WzVdID0gejIgKiB4MCAtIHowICogeDI7XG4gIG91dFs2XSA9IHowICogeDEgLSB6MSAqIHgwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6MDtcbiAgb3V0WzldID0gejE7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSBleWV4O1xuICBvdXRbMTNdID0gZXlleTtcbiAgb3V0WzE0XSA9IGV5ZXo7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQ0KFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIsIFwiICsgYVs5XSArIFwiLCBcIiArIGFbMTBdICsgXCIsIFwiICsgYVsxMV0gKyBcIiwgXCIgKyBhWzEyXSArIFwiLCBcIiArIGFbMTNdICsgXCIsIFwiICsgYVsxNF0gKyBcIiwgXCIgKyBhWzE1XSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0sIGFbOV0sIGFbMTBdLCBhWzExXSwgYVsxMl0sIGFbMTNdLCBhWzE0XSwgYVsxNV0pO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSArIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV0gKiBzY2FsZTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF0gKiBzY2FsZTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV0gKiBzY2FsZTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl0gKiBzY2FsZTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM10gKiBzY2FsZTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF0gKiBzY2FsZTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XTtcbiAgdmFyIGE4ID0gYVs4XSxcbiAgICAgIGE5ID0gYVs5XSxcbiAgICAgIGExMCA9IGFbMTBdLFxuICAgICAgYTExID0gYVsxMV07XG4gIHZhciBhMTIgPSBhWzEyXSxcbiAgICAgIGExMyA9IGFbMTNdLFxuICAgICAgYTE0ID0gYVsxNF0sXG4gICAgICBhMTUgPSBhWzE1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgdmFyIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XTtcbiAgdmFyIGI4ID0gYls4XSxcbiAgICAgIGI5ID0gYls5XSxcbiAgICAgIGIxMCA9IGJbMTBdLFxuICAgICAgYjExID0gYlsxMV07XG4gIHZhciBiMTIgPSBiWzEyXSxcbiAgICAgIGIxMyA9IGJbMTNdLFxuICAgICAgYjE0ID0gYlsxNF0sXG4gICAgICBiMTUgPSBiWzE1XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpICYmIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE5KSwgTWF0aC5hYnMoYjkpKSAmJiBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMCksIE1hdGguYWJzKGIxMCkpICYmIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTExKSwgTWF0aC5hYnMoYjExKSkgJiYgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTIpLCBNYXRoLmFicyhiMTIpKSAmJiBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMyksIE1hdGguYWJzKGIxMykpICYmIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE0KSwgTWF0aC5hYnMoYjE0KSkgJiYgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTUpLCBNYXRoLmFicyhiMTUpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCAqIGFzIG1hdDMgZnJvbSBcIi4vbWF0My5qc1wiO1xuaW1wb3J0ICogYXMgdmVjMyBmcm9tIFwiLi92ZWMzLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL3ZlYzQuanNcIjtcbi8qKlxyXG4gKiBRdWF0ZXJuaW9uXHJcbiAqIEBtb2R1bGUgcXVhdFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG5cbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXHJcbiAqIHRoZW4gcmV0dXJucyBpdC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEF4aXNBbmdsZShvdXQsIGF4aXMsIHJhZCkge1xuICByYWQgPSByYWQgKiAwLjU7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICBvdXRbMl0gPSBzICogYXhpc1syXTtcbiAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSByb3RhdGlvbiBheGlzIGFuZCBhbmdsZSBmb3IgYSBnaXZlblxyXG4gKiAgcXVhdGVybmlvbi4gSWYgYSBxdWF0ZXJuaW9uIGlzIGNyZWF0ZWQgd2l0aFxyXG4gKiAgc2V0QXhpc0FuZ2xlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZVxyXG4gKiAgdmFsdWVzIGFzIHByb3ZpZGllZCBpbiB0aGUgb3JpZ2luYWwgcGFyYW1ldGVyIGxpc3RcclxuICogIE9SIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHZhbHVlcy5cclxuICogRXhhbXBsZTogVGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IGF4aXMgWzAsIDAsIDFdIGFuZFxyXG4gKiAgYW5nbGUgLTkwIGlzIHRoZSBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieVxyXG4gKiAgWzAsIDAsIDFdIGFuZCAyNzAuIFRoaXMgbWV0aG9kIGZhdm9ycyB0aGUgbGF0dGVyLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXRfYXhpcyAgVmVjdG9yIHJlY2VpdmluZyB0aGUgYXhpcyBvZiByb3RhdGlvblxyXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXR9IHEgICAgIFF1YXRlcm5pb24gdG8gYmUgZGVjb21wb3NlZFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBBbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIHJvdGF0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXhpc0FuZ2xlKG91dF9heGlzLCBxKSB7XG4gIHZhciByYWQgPSBNYXRoLmFjb3MocVszXSkgKiAyLjA7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkIC8gMi4wKTtcblxuICBpZiAocyA+IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICBvdXRfYXhpc1swXSA9IHFbMF0gLyBzO1xuICAgIG91dF9heGlzWzFdID0gcVsxXSAvIHM7XG4gICAgb3V0X2F4aXNbMl0gPSBxWzJdIC8gcztcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBzIGlzIHplcm8sIHJldHVybiBhbnkgYXhpcyAobm8gcm90YXRpb24gLSBheGlzIGRvZXMgbm90IG1hdHRlcilcbiAgICBvdXRfYXhpc1swXSA9IDE7XG4gICAgb3V0X2F4aXNbMV0gPSAwO1xuICAgIG91dF9heGlzWzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiByYWQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgYW5ndWxhciBkaXN0YW5jZSBiZXR3ZWVuIHR3byB1bml0IHF1YXRlcm5pb25zXHJcbiAqXHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdH0gYSAgICAgT3JpZ2luIHVuaXQgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXR9IGIgICAgIERlc3RpbmF0aW9uIHVuaXQgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBBbmdsZSwgaW4gcmFkaWFucywgYmV0d2VlbiB0aGUgdHdvIHF1YXRlcm5pb25zXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW5nbGUoYSwgYikge1xuICB2YXIgZG90cHJvZHVjdCA9IGRvdChhLCBiKTtcbiAgcmV0dXJuIE1hdGguYWNvcygyICogZG90cHJvZHVjdCAqIGRvdHByb2R1Y3QgLSAxKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBidyA9IGJbM107XG4gIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ4ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gIG91dFsxXSA9IGF5ICogYncgKyBheiAqIGJ4O1xuICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ5ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ6ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gIG91dFsxXSA9IGF5ICogYncgLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgVyBjb21wb25lbnQgb2YgYSBxdWF0IGZyb20gdGhlIFgsIFksIGFuZCBaIGNvbXBvbmVudHMuXHJcbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXHJcbiAqIEFueSBleGlzdGluZyBXIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlVyhvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gTWF0aC5zcXJ0KE1hdGguYWJzKDEuMCAtIHggKiB4IC0geSAqIHkgLSB6ICogeikpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2YgYSB1bml0IHF1YXRlcm5pb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cChvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXSxcbiAgICAgIHcgPSBhWzNdO1xuICB2YXIgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICB2YXIgZXQgPSBNYXRoLmV4cCh3KTtcbiAgdmFyIHMgPSByID4gMCA/IGV0ICogTWF0aC5zaW4ocikgLyByIDogMDtcbiAgb3V0WzBdID0geCAqIHM7XG4gIG91dFsxXSA9IHkgKiBzO1xuICBvdXRbMl0gPSB6ICogcztcbiAgb3V0WzNdID0gZXQgKiBNYXRoLmNvcyhyKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGEgdW5pdCBxdWF0ZXJuaW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsbihvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXSxcbiAgICAgIHcgPSBhWzNdO1xuICB2YXIgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICB2YXIgdCA9IHIgPiAwID8gTWF0aC5hdGFuMihyLCB3KSAvIHIgOiAwO1xuICBvdXRbMF0gPSB4ICogdDtcbiAgb3V0WzFdID0geSAqIHQ7XG4gIG91dFsyXSA9IHogKiB0O1xuICBvdXRbM10gPSAwLjUgKiBNYXRoLmxvZyh4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBzY2FsYXIgcG93ZXIgb2YgYSB1bml0IHF1YXRlcm5pb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2ZcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBxdWF0ZXJuaW9uIGJ5XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwb3cob3V0LCBhLCBiKSB7XG4gIGxuKG91dCwgYSk7XG4gIHNjYWxlKG91dCwgb3V0LCBiKTtcbiAgZXhwKG91dCwgb3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2xlcnAob3V0LCBhLCBiLCB0KSB7XG4gIC8vIGJlbmNobWFya3M6XG4gIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBidyA9IGJbM107XG4gIHZhciBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTsgLy8gY2FsYyBjb3NpbmVcblxuICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7IC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuXG4gIGlmIChjb3NvbSA8IDAuMCkge1xuICAgIGNvc29tID0gLWNvc29tO1xuICAgIGJ4ID0gLWJ4O1xuICAgIGJ5ID0gLWJ5O1xuICAgIGJ6ID0gLWJ6O1xuICAgIGJ3ID0gLWJ3O1xuICB9IC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcblxuXG4gIGlmICgxLjAgLSBjb3NvbSA+IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICBvbWVnYSA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgc2lub20gPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICB9IGVsc2Uge1xuICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2VcbiAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICBzY2FsZTEgPSB0O1xuICB9IC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcblxuXG4gIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHVuaXQgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQpIHtcbiAgLy8gSW1wbGVtZW50YXRpb24gb2YgaHR0cDovL3BsYW5uaW5nLmNzLnVpdWMuZWR1L25vZGUxOTguaHRtbFxuICAvLyBUT0RPOiBDYWxsaW5nIHJhbmRvbSAzIHRpbWVzIGlzIHByb2JhYmx5IG5vdCB0aGUgZmFzdGVzdCBzb2x1dGlvblxuICB2YXIgdTEgPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgdmFyIHUyID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIHZhciB1MyA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICB2YXIgc3FydDFNaW51c1UxID0gTWF0aC5zcXJ0KDEgLSB1MSk7XG4gIHZhciBzcXJ0VTEgPSBNYXRoLnNxcnQodTEpO1xuICBvdXRbMF0gPSBzcXJ0MU1pbnVzVTEgKiBNYXRoLnNpbigyLjAgKiBNYXRoLlBJICogdTIpO1xuICBvdXRbMV0gPSBzcXJ0MU1pbnVzVTEgKiBNYXRoLmNvcygyLjAgKiBNYXRoLlBJICogdTIpO1xuICBvdXRbMl0gPSBzcXJ0VTEgKiBNYXRoLnNpbigyLjAgKiBNYXRoLlBJICogdTMpO1xuICBvdXRbM10gPSBzcXJ0VTEgKiBNYXRoLmNvcygyLjAgKiBNYXRoLlBJICogdTMpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBkb3QgPSBhMCAqIGEwICsgYTEgKiBhMSArIGEyICogYTIgKyBhMyAqIGEzO1xuICB2YXIgaW52RG90ID0gZG90ID8gMS4wIC8gZG90IDogMDsgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICBvdXRbMF0gPSAtYTAgKiBpbnZEb3Q7XG4gIG91dFsxXSA9IC1hMSAqIGludkRvdDtcbiAgb3V0WzJdID0gLWEyICogaW52RG90O1xuICBvdXRbM10gPSBhMyAqIGludkRvdDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XHJcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmp1Z2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxyXG4gKlxyXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxyXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSByb3RhdGlvbiBtYXRyaXhcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0MyhvdXQsIG0pIHtcbiAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gIHZhciBmVHJhY2UgPSBtWzBdICsgbVs0XSArIG1bOF07XG4gIHZhciBmUm9vdDtcblxuICBpZiAoZlRyYWNlID4gMC4wKSB7XG4gICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEuMCk7IC8vIDJ3XG5cbiAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcbiAgICBmUm9vdCA9IDAuNSAvIGZSb290OyAvLyAxLyg0dylcblxuICAgIG91dFswXSA9IChtWzVdIC0gbVs3XSkgKiBmUm9vdDtcbiAgICBvdXRbMV0gPSAobVs2XSAtIG1bMl0pICogZlJvb3Q7XG4gICAgb3V0WzJdID0gKG1bMV0gLSBtWzNdKSAqIGZSb290O1xuICB9IGVsc2Uge1xuICAgIC8vIHx3fCA8PSAxLzJcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKG1bNF0gPiBtWzBdKSBpID0gMTtcbiAgICBpZiAobVs4XSA+IG1baSAqIDMgKyBpXSkgaSA9IDI7XG4gICAgdmFyIGogPSAoaSArIDEpICUgMztcbiAgICB2YXIgayA9IChpICsgMikgJSAzO1xuICAgIGZSb290ID0gTWF0aC5zcXJ0KG1baSAqIDMgKyBpXSAtIG1baiAqIDMgKyBqXSAtIG1bayAqIDMgKyBrXSArIDEuMCk7XG4gICAgb3V0W2ldID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcbiAgICBvdXRbM10gPSAobVtqICogMyArIGtdIC0gbVtrICogMyArIGpdKSAqIGZSb290O1xuICAgIG91dFtqXSA9IChtW2ogKiAzICsgaV0gKyBtW2kgKiAzICsgal0pICogZlJvb3Q7XG4gICAgb3V0W2tdID0gKG1bayAqIDMgKyBpXSArIG1baSAqIDMgKyBrXSkgKiBmUm9vdDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gZXVsZXIgYW5nbGUgeCwgeSwgei5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7eH0gQW5nbGUgdG8gcm90YXRlIGFyb3VuZCBYIGF4aXMgaW4gZGVncmVlcy5cclxuICogQHBhcmFtIHt5fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFkgYXhpcyBpbiBkZWdyZWVzLlxyXG4gKiBAcGFyYW0ge3p9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWiBheGlzIGluIGRlZ3JlZXMuXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV1bGVyKG91dCwgeCwgeSwgeikge1xuICB2YXIgaGFsZlRvUmFkID0gMC41ICogTWF0aC5QSSAvIDE4MC4wO1xuICB4ICo9IGhhbGZUb1JhZDtcbiAgeSAqPSBoYWxmVG9SYWQ7XG4gIHogKj0gaGFsZlRvUmFkO1xuICB2YXIgc3ggPSBNYXRoLnNpbih4KTtcbiAgdmFyIGN4ID0gTWF0aC5jb3MoeCk7XG4gIHZhciBzeSA9IE1hdGguc2luKHkpO1xuICB2YXIgY3kgPSBNYXRoLmNvcyh5KTtcbiAgdmFyIHN6ID0gTWF0aC5zaW4oeik7XG4gIHZhciBjeiA9IE1hdGguY29zKHopO1xuICBvdXRbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gIG91dFsxXSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcbiAgb3V0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICBvdXRbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwicXVhdChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcclxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGNsb25lID0gdmVjNC5jbG9uZTtcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBmcm9tVmFsdWVzID0gdmVjNC5mcm9tVmFsdWVzO1xuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBjb3B5ID0gdmVjNC5jb3B5O1xuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc2V0ID0gdmVjNC5zZXQ7XG4vKipcclxuICogQWRkcyB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgYWRkID0gdmVjNC5hZGQ7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzY2FsZSA9IHZlYzQuc2NhbGU7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZG90ID0gdmVjNC5kb3Q7XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlcnAgPSB2ZWM0LmxlcnA7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW5ndGggPSB2ZWM0Lmxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIFRoZSBzZWNvbmQgcXVhdGVybmlvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgdmFyIGV4YWN0RXF1YWxzID0gdmVjNC5leGFjdEVxdWFscztcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCB2YXIgZXF1YWxzID0gdmVjNC5lcXVhbHM7XG4vKipcclxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxyXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cclxuICpcclxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCB2YXIgcm90YXRpb25UbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICB2YXIgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsIDAsIDApO1xuICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApO1xuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcblxuICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeFVuaXRWZWMzLCBhKTtcbiAgICAgIGlmICh2ZWMzLmxlbih0bXB2ZWMzKSA8IDAuMDAwMDAxKSB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgIHNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICBvdXRbMF0gPSAwO1xuICAgICAgb3V0WzFdID0gMDtcbiAgICAgIG91dFsyXSA9IDA7XG4gICAgICBvdXRbM10gPSAxO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCBhLCBiKTtcbiAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XG4gICAgICBvdXRbMV0gPSB0bXB2ZWMzWzFdO1xuICAgICAgb3V0WzJdID0gdG1wdmVjM1syXTtcbiAgICAgIG91dFszXSA9IDEgKyBkb3Q7XG4gICAgICByZXR1cm4gbm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICB9XG4gIH07XG59KCk7XG4vKipcclxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYyB0aGUgdGhpcmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxbGVycCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlbXAxID0gY3JlYXRlKCk7XG4gIHZhciB0ZW1wMiA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICAgIHNsZXJwKHRlbXAxLCBhLCBkLCB0KTtcbiAgICBzbGVycCh0ZW1wMiwgYiwgYywgdCk7XG4gICAgc2xlcnAob3V0LCB0ZW1wMSwgdGVtcDIsIDIgKiB0ICogKDEgLSB0KSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0oKTtcbi8qKlxyXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxyXG4gKiBheGVzLiBFYWNoIGF4aXMgaXMgYSB2ZWMzIGFuZCBpcyBleHBlY3RlZCB0byBiZSB1bml0IGxlbmd0aCBhbmRcclxuICogcGVycGVuZGljdWxhciB0byBhbGwgb3RoZXIgc3BlY2lmaWVkIGF4ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2aWV3ICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdmlld2luZyBkaXJlY3Rpb25cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHJpZ2h0IHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInJpZ2h0XCIgZGlyZWN0aW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgdmFyIHNldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtYXRyID0gbWF0My5jcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIHZpZXcsIHJpZ2h0LCB1cCkge1xuICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICBtYXRyWzNdID0gcmlnaHRbMV07XG4gICAgbWF0cls2XSA9IHJpZ2h0WzJdO1xuICAgIG1hdHJbMV0gPSB1cFswXTtcbiAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgbWF0cls3XSA9IHVwWzJdO1xuICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICBtYXRyWzVdID0gLXZpZXdbMV07XG4gICAgbWF0cls4XSA9IC12aWV3WzJdO1xuICAgIHJldHVybiBub3JtYWxpemUob3V0LCBmcm9tTWF0MyhvdXQsIG1hdHIpKTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCAqIGFzIHF1YXQgZnJvbSBcIi4vcXVhdC5qc1wiO1xuaW1wb3J0ICogYXMgbWF0NCBmcm9tIFwiLi9tYXQ0LmpzXCI7XG4vKipcclxuICogRHVhbCBRdWF0ZXJuaW9uPGJyPlxyXG4gKiBGb3JtYXQ6IFtyZWFsLCBkdWFsXTxicj5cclxuICogUXVhdGVybmlvbiBmb3JtYXQ6IFhZWlc8YnI+XHJcbiAqIE1ha2Ugc3VyZSB0byBoYXZlIG5vcm1hbGl6ZWQgZHVhbCBxdWF0ZXJuaW9ucywgb3RoZXJ3aXNlIHRoZSBmdW5jdGlvbnMgbWF5IG5vdCB3b3JrIGFzIGludGVuZGVkLjxicj5cclxuICogQG1vZHVsZSBxdWF0MlxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgZHVhbCBxdWF0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gYSBuZXcgZHVhbCBxdWF0ZXJuaW9uIFtyZWFsIC0+IHJvdGF0aW9uLCBkdWFsIC0+IHRyYW5zbGF0aW9uXVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgZHFbMF0gPSAwO1xuICAgIGRxWzFdID0gMDtcbiAgICBkcVsyXSA9IDA7XG4gICAgZHFbNF0gPSAwO1xuICAgIGRxWzVdID0gMDtcbiAgICBkcVs2XSA9IDA7XG4gICAgZHFbN10gPSAwO1xuICB9XG5cbiAgZHFbM10gPSAxO1xuICByZXR1cm4gZHE7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0ZXJuaW9uIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBkcSA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDgpO1xuICBkcVswXSA9IGFbMF07XG4gIGRxWzFdID0gYVsxXTtcbiAgZHFbMl0gPSBhWzJdO1xuICBkcVszXSA9IGFbM107XG4gIGRxWzRdID0gYVs0XTtcbiAgZHFbNV0gPSBhWzVdO1xuICBkcVs2XSA9IGFbNl07XG4gIGRxWzddID0gYVs3XTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgZHVhbCBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcyIFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgxLCB5MSwgejEsIHcxLCB4MiwgeTIsIHoyLCB3Mikge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcbiAgZHFbMF0gPSB4MTtcbiAgZHFbMV0gPSB5MTtcbiAgZHFbMl0gPSB6MTtcbiAgZHFbM10gPSB3MTtcbiAgZHFbNF0gPSB4MjtcbiAgZHFbNV0gPSB5MjtcbiAgZHFbNl0gPSB6MjtcbiAgZHFbN10gPSB3MjtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgZHVhbCBxdWF0IGZyb20gdGhlIGdpdmVuIHZhbHVlcyAocXVhdCBhbmQgdHJhbnNsYXRpb24pXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MSBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geTEgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoxIFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MSBXIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geDIgWCBjb21wb25lbnQgKHRyYW5zbGF0aW9uKVxyXG4gKiBAcGFyYW0ge051bWJlcn0geTIgWSBjb21wb25lbnQgKHRyYW5zbGF0aW9uKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnQgKHRyYW5zbGF0aW9uKVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG5ldyBkdWFsIHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXMoeDEsIHkxLCB6MSwgdzEsIHgyLCB5MiwgejIpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG4gIGRxWzBdID0geDE7XG4gIGRxWzFdID0geTE7XG4gIGRxWzJdID0gejE7XG4gIGRxWzNdID0gdzE7XG4gIHZhciBheCA9IHgyICogMC41LFxuICAgICAgYXkgPSB5MiAqIDAuNSxcbiAgICAgIGF6ID0gejIgKiAwLjU7XG4gIGRxWzRdID0gYXggKiB3MSArIGF5ICogejEgLSBheiAqIHkxO1xuICBkcVs1XSA9IGF5ICogdzEgKyBheiAqIHgxIC0gYXggKiB6MTtcbiAgZHFbNl0gPSBheiAqIHcxICsgYXggKiB5MSAtIGF5ICogeDE7XG4gIGRxWzddID0gLWF4ICogeDEgLSBheSAqIHkxIC0gYXogKiB6MTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHF1YXRlcm5pb24gYW5kIGEgdHJhbnNsYXRpb25cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgYSBub3JtYWxpemVkIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHQgdHJhbmxhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB0KSB7XG4gIHZhciBheCA9IHRbMF0gKiAwLjUsXG4gICAgICBheSA9IHRbMV0gKiAwLjUsXG4gICAgICBheiA9IHRbMl0gKiAwLjUsXG4gICAgICBieCA9IHFbMF0sXG4gICAgICBieSA9IHFbMV0sXG4gICAgICBieiA9IHFbMl0sXG4gICAgICBidyA9IHFbM107XG4gIG91dFswXSA9IGJ4O1xuICBvdXRbMV0gPSBieTtcbiAgb3V0WzJdID0gYno7XG4gIG91dFszXSA9IGJ3O1xuICBvdXRbNF0gPSBheCAqIGJ3ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFs1XSA9IGF5ICogYncgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzZdID0gYXogKiBidyArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbN10gPSAtYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHRyYW5zbGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB0IHRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IHRbMF0gKiAwLjU7XG4gIG91dFs1XSA9IHRbMV0gKiAwLjU7XG4gIG91dFs2XSA9IHRbMl0gKiAwLjU7XG4gIG91dFs3XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIGR1YWwgcXVhdCBmcm9tIGEgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSB0aGUgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCBxKSB7XG4gIG91dFswXSA9IHFbMF07XG4gIG91dFsxXSA9IHFbMV07XG4gIG91dFsyXSA9IHFbMl07XG4gIG91dFszXSA9IHFbM107XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBkdWFsIHF1YXQgZnJvbSBhIG1hdHJpeCAoNHg0KVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gZHVhbCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICAvL1RPRE8gT3B0aW1pemUgdGhpc1xuICB2YXIgb3V0ZXIgPSBxdWF0LmNyZWF0ZSgpO1xuICBtYXQ0LmdldFJvdGF0aW9uKG91dGVyLCBhKTtcbiAgdmFyIHQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgbWF0NC5nZXRUcmFuc2xhdGlvbih0LCBhKTtcbiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBvdXRlciwgdCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIGR1YWwgcXVhdCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIHNvdXJjZSBkdWFsIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBkdWFsIHF1YXQgdG8gdGhlIGlkZW50aXR5IGR1YWwgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcyIFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgxLCB5MSwgejEsIHcxLCB4MiwgeTIsIHoyLCB3Mikge1xuICBvdXRbMF0gPSB4MTtcbiAgb3V0WzFdID0geTE7XG4gIG91dFsyXSA9IHoxO1xuICBvdXRbM10gPSB3MTtcbiAgb3V0WzRdID0geDI7XG4gIG91dFs1XSA9IHkyO1xuICBvdXRbNl0gPSB6MjtcbiAgb3V0WzddID0gdzI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgcmVhbCBwYXJ0IG9mIGEgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3F1YXR9IG91dCByZWFsIHBhcnRcclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cclxuICogQHJldHVybiB7cXVhdH0gcmVhbCBwYXJ0XHJcbiAqL1xuXG5leHBvcnQgdmFyIGdldFJlYWwgPSBxdWF0LmNvcHk7XG4vKipcclxuICogR2V0cyB0aGUgZHVhbCBwYXJ0IG9mIGEgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3F1YXR9IG91dCBkdWFsIHBhcnRcclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cclxuICogQHJldHVybiB7cXVhdH0gZHVhbCBwYXJ0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RHVhbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVs0XTtcbiAgb3V0WzFdID0gYVs1XTtcbiAgb3V0WzJdID0gYVs2XTtcbiAgb3V0WzNdID0gYVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIHJlYWwgY29tcG9uZW50IG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcmVhbCBwYXJ0XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzZXRSZWFsID0gcXVhdC5jb3B5O1xuLyoqXHJcbiAqIFNldCB0aGUgZHVhbCBjb21wb25lbnQgb2YgYSBkdWFsIHF1YXQgdG8gdGhlIGdpdmVuIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSBkdWFsIHBhcnRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0RHVhbChvdXQsIHEpIHtcbiAgb3V0WzRdID0gcVswXTtcbiAgb3V0WzVdID0gcVsxXTtcbiAgb3V0WzZdID0gcVsyXTtcbiAgb3V0WzddID0gcVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSB0cmFuc2xhdGlvbiBvZiBhIG5vcm1hbGl6ZWQgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3ZlYzN9IG91dCB0cmFuc2xhdGlvblxyXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXQyfSBhIER1YWwgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXHJcbiAqIEByZXR1cm4ge3ZlYzN9IHRyYW5zbGF0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBhKSB7XG4gIHZhciBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN10sXG4gICAgICBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM107XG4gIG91dFswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDI7XG4gIG91dFsxXSA9IChheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6KSAqIDI7XG4gIG91dFsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlcyBhIGR1YWwgcXVhdCBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGF4MSA9IGFbMF0sXG4gICAgICBheTEgPSBhWzFdLFxuICAgICAgYXoxID0gYVsyXSxcbiAgICAgIGF3MSA9IGFbM10sXG4gICAgICBieDEgPSB2WzBdICogMC41LFxuICAgICAgYnkxID0gdlsxXSAqIDAuNSxcbiAgICAgIGJ6MSA9IHZbMl0gKiAwLjUsXG4gICAgICBheDIgPSBhWzRdLFxuICAgICAgYXkyID0gYVs1XSxcbiAgICAgIGF6MiA9IGFbNl0sXG4gICAgICBhdzIgPSBhWzddO1xuICBvdXRbMF0gPSBheDE7XG4gIG91dFsxXSA9IGF5MTtcbiAgb3V0WzJdID0gYXoxO1xuICBvdXRbM10gPSBhdzE7XG4gIG91dFs0XSA9IGF3MSAqIGJ4MSArIGF5MSAqIGJ6MSAtIGF6MSAqIGJ5MSArIGF4MjtcbiAgb3V0WzVdID0gYXcxICogYnkxICsgYXoxICogYngxIC0gYXgxICogYnoxICsgYXkyO1xuICBvdXRbNl0gPSBhdzEgKiBiejEgKyBheDEgKiBieTEgLSBheTEgKiBieDEgKyBhejI7XG4gIG91dFs3XSA9IC1heDEgKiBieDEgLSBheTEgKiBieTEgLSBhejEgKiBiejEgKyBhdzI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgaG93IGZhciBzaG91bGQgdGhlIHJvdGF0aW9uIGJlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYXgxID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcbiAgICAgIGF5MSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosXG4gICAgICBhejEgPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgYXcxID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcXVhdC5yb3RhdGVYKG91dCwgYSwgcmFkKTtcbiAgYnggPSBvdXRbMF07XG4gIGJ5ID0gb3V0WzFdO1xuICBieiA9IG91dFsyXTtcbiAgYncgPSBvdXRbM107XG4gIG91dFs0XSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbNV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzZdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFs3XSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIHRoZSBZIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGhvdyBmYXIgc2hvdWxkIHRoZSByb3RhdGlvbiBiZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XSxcbiAgICAgIGF4MSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnksXG4gICAgICBheTEgPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LFxuICAgICAgYXoxID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCxcbiAgICAgIGF3MSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHF1YXQucm90YXRlWShvdXQsIGEsIHJhZCk7XG4gIGJ4ID0gb3V0WzBdO1xuICBieSA9IG91dFsxXTtcbiAgYnogPSBvdXRbMl07XG4gIGJ3ID0gb3V0WzNdO1xuICBvdXRbNF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzVdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFs2XSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbN10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCB0aGUgWiBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBob3cgZmFyIHNob3VsZCB0aGUgcm90YXRpb24gYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM10sXG4gICAgICBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN10sXG4gICAgICBheDEgPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LFxuICAgICAgYXkxID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieixcbiAgICAgIGF6MSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsXG4gICAgICBhdzEgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICBxdWF0LnJvdGF0ZVoob3V0LCBhLCByYWQpO1xuICBieCA9IG91dFswXTtcbiAgYnkgPSBvdXRbMV07XG4gIGJ6ID0gb3V0WzJdO1xuICBidyA9IG91dFszXTtcbiAgb3V0WzRdID0gYXgxICogYncgKyBhdzEgKiBieCArIGF5MSAqIGJ6IC0gYXoxICogYnk7XG4gIG91dFs1XSA9IGF5MSAqIGJ3ICsgYXcxICogYnkgKyBhejEgKiBieCAtIGF4MSAqIGJ6O1xuICBvdXRbNl0gPSBhejEgKiBidyArIGF3MSAqIGJ6ICsgYXgxICogYnkgLSBheTEgKiBieDtcbiAgb3V0WzddID0gYXcxICogYncgLSBheDEgKiBieCAtIGF5MSAqIGJ5IC0gYXoxICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBieSBhIGdpdmVuIHF1YXRlcm5pb24gKGEgKiBxKVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gcm90YXRlIGJ5XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlQnlRdWF0QXBwZW5kKG91dCwgYSwgcSkge1xuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdLFxuICAgICAgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCAqIHF3ICsgYXcgKiBxeCArIGF5ICogcXogLSBheiAqIHF5O1xuICBvdXRbMV0gPSBheSAqIHF3ICsgYXcgKiBxeSArIGF6ICogcXggLSBheCAqIHF6O1xuICBvdXRbMl0gPSBheiAqIHF3ICsgYXcgKiBxeiArIGF4ICogcXkgLSBheSAqIHF4O1xuICBvdXRbM10gPSBhdyAqIHF3IC0gYXggKiBxeCAtIGF5ICogcXkgLSBheiAqIHF6O1xuICBheCA9IGFbNF07XG4gIGF5ID0gYVs1XTtcbiAgYXogPSBhWzZdO1xuICBhdyA9IGFbN107XG4gIG91dFs0XSA9IGF4ICogcXcgKyBhdyAqIHF4ICsgYXkgKiBxeiAtIGF6ICogcXk7XG4gIG91dFs1XSA9IGF5ICogcXcgKyBhdyAqIHF5ICsgYXogKiBxeCAtIGF4ICogcXo7XG4gIG91dFs2XSA9IGF6ICogcXcgKyBhdyAqIHF6ICsgYXggKiBxeSAtIGF5ICogcXg7XG4gIG91dFs3XSA9IGF3ICogcXcgLSBheCAqIHF4IC0gYXkgKiBxeSAtIGF6ICogcXo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBieSBhIGdpdmVuIHF1YXRlcm5pb24gKHEgKiBhKVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlQnlRdWF0UHJlcGVuZChvdXQsIHEsIGEpIHtcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXSxcbiAgICAgIGJ4ID0gYVswXSxcbiAgICAgIGJ5ID0gYVsxXSxcbiAgICAgIGJ6ID0gYVsyXSxcbiAgICAgIGJ3ID0gYVszXTtcbiAgb3V0WzBdID0gcXggKiBidyArIHF3ICogYnggKyBxeSAqIGJ6IC0gcXogKiBieTtcbiAgb3V0WzFdID0gcXkgKiBidyArIHF3ICogYnkgKyBxeiAqIGJ4IC0gcXggKiBiejtcbiAgb3V0WzJdID0gcXogKiBidyArIHF3ICogYnogKyBxeCAqIGJ5IC0gcXkgKiBieDtcbiAgb3V0WzNdID0gcXcgKiBidyAtIHF4ICogYnggLSBxeSAqIGJ5IC0gcXogKiBiejtcbiAgYnggPSBhWzRdO1xuICBieSA9IGFbNV07XG4gIGJ6ID0gYVs2XTtcbiAgYncgPSBhWzddO1xuICBvdXRbNF0gPSBxeCAqIGJ3ICsgcXcgKiBieCArIHF5ICogYnogLSBxeiAqIGJ5O1xuICBvdXRbNV0gPSBxeSAqIGJ3ICsgcXcgKiBieSArIHF6ICogYnggLSBxeCAqIGJ6O1xuICBvdXRbNl0gPSBxeiAqIGJ3ICsgcXcgKiBieiArIHF4ICogYnkgLSBxeSAqIGJ4O1xuICBvdXRbN10gPSBxdyAqIGJ3IC0gcXggKiBieCAtIHF5ICogYnkgLSBxeiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIGEgZ2l2ZW4gYXhpcy4gRG9lcyB0aGUgbm9ybWFsaXNhdGlvbiBhdXRvbWF0aWNhbGx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIGhvdyBmYXIgdGhlIHJvdGF0aW9uIHNob3VsZCBiZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUFyb3VuZEF4aXMob3V0LCBhLCBheGlzLCByYWQpIHtcbiAgLy9TcGVjaWFsIGNhc2UgZm9yIHJhZCA9IDBcbiAgaWYgKE1hdGguYWJzKHJhZCkgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIGNvcHkob3V0LCBhKTtcbiAgfVxuXG4gIHZhciBheGlzTGVuZ3RoID0gTWF0aC5oeXBvdChheGlzWzBdLCBheGlzWzFdLCBheGlzWzJdKTtcbiAgcmFkID0gcmFkICogMC41O1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBieCA9IHMgKiBheGlzWzBdIC8gYXhpc0xlbmd0aDtcbiAgdmFyIGJ5ID0gcyAqIGF4aXNbMV0gLyBheGlzTGVuZ3RoO1xuICB2YXIgYnogPSBzICogYXhpc1syXSAvIGF4aXNMZW5ndGg7XG4gIHZhciBidyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBheDEgPSBhWzBdLFxuICAgICAgYXkxID0gYVsxXSxcbiAgICAgIGF6MSA9IGFbMl0sXG4gICAgICBhdzEgPSBhWzNdO1xuICBvdXRbMF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzFdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFsyXSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbM10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgdmFyIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XTtcbiAgb3V0WzRdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzVdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzZdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgb3V0WzddID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBkdWFsIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gZHVhbCBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBheDAgPSBhWzBdLFxuICAgICAgYXkwID0gYVsxXSxcbiAgICAgIGF6MCA9IGFbMl0sXG4gICAgICBhdzAgPSBhWzNdLFxuICAgICAgYngxID0gYls0XSxcbiAgICAgIGJ5MSA9IGJbNV0sXG4gICAgICBiejEgPSBiWzZdLFxuICAgICAgYncxID0gYls3XSxcbiAgICAgIGF4MSA9IGFbNF0sXG4gICAgICBheTEgPSBhWzVdLFxuICAgICAgYXoxID0gYVs2XSxcbiAgICAgIGF3MSA9IGFbN10sXG4gICAgICBieDAgPSBiWzBdLFxuICAgICAgYnkwID0gYlsxXSxcbiAgICAgIGJ6MCA9IGJbMl0sXG4gICAgICBidzAgPSBiWzNdO1xuICBvdXRbMF0gPSBheDAgKiBidzAgKyBhdzAgKiBieDAgKyBheTAgKiBiejAgLSBhejAgKiBieTA7XG4gIG91dFsxXSA9IGF5MCAqIGJ3MCArIGF3MCAqIGJ5MCArIGF6MCAqIGJ4MCAtIGF4MCAqIGJ6MDtcbiAgb3V0WzJdID0gYXowICogYncwICsgYXcwICogYnowICsgYXgwICogYnkwIC0gYXkwICogYngwO1xuICBvdXRbM10gPSBhdzAgKiBidzAgLSBheDAgKiBieDAgLSBheTAgKiBieTAgLSBhejAgKiBiejA7XG4gIG91dFs0XSA9IGF4MCAqIGJ3MSArIGF3MCAqIGJ4MSArIGF5MCAqIGJ6MSAtIGF6MCAqIGJ5MSArIGF4MSAqIGJ3MCArIGF3MSAqIGJ4MCArIGF5MSAqIGJ6MCAtIGF6MSAqIGJ5MDtcbiAgb3V0WzVdID0gYXkwICogYncxICsgYXcwICogYnkxICsgYXowICogYngxIC0gYXgwICogYnoxICsgYXkxICogYncwICsgYXcxICogYnkwICsgYXoxICogYngwIC0gYXgxICogYnowO1xuICBvdXRbNl0gPSBhejAgKiBidzEgKyBhdzAgKiBiejEgKyBheDAgKiBieTEgLSBheTAgKiBieDEgKyBhejEgKiBidzAgKyBhdzEgKiBiejAgKyBheDEgKiBieTAgLSBheTEgKiBieDA7XG4gIG91dFs3XSA9IGF3MCAqIGJ3MSAtIGF4MCAqIGJ4MSAtIGF5MCAqIGJ5MSAtIGF6MCAqIGJ6MSArIGF3MSAqIGJ3MCAtIGF4MSAqIGJ4MCAtIGF5MSAqIGJ5MCAtIGF6MSAqIGJ6MDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQyLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogU2NhbGVzIGEgZHVhbCBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXQgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBkdWFsIHF1YXQgYnlcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gZHVhbCBxdWF0J3MgKFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgcmVhbCBwYXJ0cylcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZG90ID0gcXVhdC5kb3Q7XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBkdWFsIHF1YXRzJ3NcclxuICogTk9URTogVGhlIHJlc3VsdGluZyBkdWFsIHF1YXRlcm5pb25zIHdvbid0IGFsd2F5cyBiZSBub3JtYWxpemVkIChUaGUgZXJyb3IgaXMgbW9zdCBub3RpY2VhYmxlIHdoZW4gdCA9IDAuNSlcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgbXQgPSAxIC0gdDtcbiAgaWYgKGRvdChhLCBiKSA8IDApIHQgPSAtdDtcbiAgb3V0WzBdID0gYVswXSAqIG10ICsgYlswXSAqIHQ7XG4gIG91dFsxXSA9IGFbMV0gKiBtdCArIGJbMV0gKiB0O1xuICBvdXRbMl0gPSBhWzJdICogbXQgKyBiWzJdICogdDtcbiAgb3V0WzNdID0gYVszXSAqIG10ICsgYlszXSAqIHQ7XG4gIG91dFs0XSA9IGFbNF0gKiBtdCArIGJbNF0gKiB0O1xuICBvdXRbNV0gPSBhWzVdICogbXQgKyBiWzVdICogdDtcbiAgb3V0WzZdID0gYVs2XSAqIG10ICsgYls2XSAqIHQ7XG4gIG91dFs3XSA9IGFbN10gKiBtdCArIGJbN10gKiB0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBkdWFsIHF1YXQuIElmIHRoZXkgYXJlIG5vcm1hbGl6ZWQsIGNvbmp1Z2F0ZSBpcyBjaGVhcGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgc3FsZW4gPSBzcXVhcmVkTGVuZ3RoKGEpO1xuICBvdXRbMF0gPSAtYVswXSAvIHNxbGVuO1xuICBvdXRbMV0gPSAtYVsxXSAvIHNxbGVuO1xuICBvdXRbMl0gPSAtYVsyXSAvIHNxbGVuO1xuICBvdXRbM10gPSBhWzNdIC8gc3FsZW47XG4gIG91dFs0XSA9IC1hWzRdIC8gc3FsZW47XG4gIG91dFs1XSA9IC1hWzVdIC8gc3FsZW47XG4gIG91dFs2XSA9IC1hWzZdIC8gc3FsZW47XG4gIG91dFs3XSA9IGFbN10gLyBzcWxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBkdWFsIHF1YXRcclxuICogSWYgdGhlIGR1YWwgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQyLmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29uanVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSAtYVs0XTtcbiAgb3V0WzVdID0gLWFbNV07XG4gIG91dFs2XSA9IC1hWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbmd0aCA9IHF1YXQubGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdDIubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgZHVhbCBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXQgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxdWFyZWRMZW5ndGggPSBxdWF0LnNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Mi5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSBkdWFsIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIG1hZ25pdHVkZSA9IHNxdWFyZWRMZW5ndGgoYSk7XG5cbiAgaWYgKG1hZ25pdHVkZSA+IDApIHtcbiAgICBtYWduaXR1ZGUgPSBNYXRoLnNxcnQobWFnbml0dWRlKTtcbiAgICB2YXIgYTAgPSBhWzBdIC8gbWFnbml0dWRlO1xuICAgIHZhciBhMSA9IGFbMV0gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGEyID0gYVsyXSAvIG1hZ25pdHVkZTtcbiAgICB2YXIgYTMgPSBhWzNdIC8gbWFnbml0dWRlO1xuICAgIHZhciBiMCA9IGFbNF07XG4gICAgdmFyIGIxID0gYVs1XTtcbiAgICB2YXIgYjIgPSBhWzZdO1xuICAgIHZhciBiMyA9IGFbN107XG4gICAgdmFyIGFfZG90X2IgPSBhMCAqIGIwICsgYTEgKiBiMSArIGEyICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFswXSA9IGEwO1xuICAgIG91dFsxXSA9IGExO1xuICAgIG91dFsyXSA9IGEyO1xuICAgIG91dFszXSA9IGEzO1xuICAgIG91dFs0XSA9IChiMCAtIGEwICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gICAgb3V0WzVdID0gKGIxIC0gYTEgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgICBvdXRbNl0gPSAoYjIgLSBhMiAqIGFfZG90X2IpIC8gbWFnbml0dWRlO1xuICAgIG91dFs3XSA9IChiMyAtIGEzICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBkdWFsIHF1YXRlbmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGR1YWwgcXVhdFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInF1YXQyKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBkdWFsIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBkdWFsIHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIGR1YWwgcXVhdGVybmlvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGR1YWwgcXVhdGVybmlvbnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGR1YWwgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGZpcnN0IGR1YWwgcXVhdC5cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgZHVhbCBxdWF0LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgZHVhbCBxdWF0cyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKTtcbn0iLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAyIERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzJcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjZWlsXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn1cbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXHJcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIG91dFswXSA9IG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXHJcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XHJcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXHJcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDJEIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzJcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIHZlYzIgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGIsIHJhZCkge1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHZhciBwMCA9IGFbMF0gLSBiWzBdLFxuICAgICAgcDEgPSBhWzFdIC0gYlsxXSxcbiAgICAgIHNpbkMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgY29zQyA9IE1hdGguY29zKHJhZCk7IC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSBwMCAqIGNvc0MgLSBwMSAqIHNpbkMgKyBiWzBdO1xuICBvdXRbMV0gPSBwMCAqIHNpbkMgKyBwMSAqIGNvc0MgKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gMkQgdmVjdG9yc1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciB4MSA9IGFbMF0sXG4gICAgICB5MSA9IGFbMV0sXG4gICAgICB4MiA9IGJbMF0sXG4gICAgICB5MiA9IGJbMV0sXG4gICAgICAvLyBtYWcgaXMgdGhlIHByb2R1Y3Qgb2YgdGhlIG1hZ25pdHVkZXMgb2YgYSBhbmQgYlxuICBtYWcgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpICogTWF0aC5zcXJ0KHgyICogeDIgKyB5MiAqIHkyKSxcbiAgICAgIC8vIG1hZyAmJi4uIHNob3J0IGNpcmN1aXRzIGlmIG1hZyA9PSAwXG4gIGNvc2luZSA9IG1hZyAmJiAoeDEgKiB4MiArIHkxICogeTIpIC8gbWFnOyAvLyBNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkgY2xhbXBzIHRoZSBjb3NpbmUgYmV0d2VlbiAtMSBhbmQgMVxuXG4gIHJldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpKTtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHplcm9cclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDI7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzNcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeik7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXTtcbiAgdmFyIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXTtcbiAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGhlcm1pdGUob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDE7XG4gIHZhciBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQ7XG4gIHZhciBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKTtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGJlemllciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgaW52ZXJzZUZhY3RvciA9IDEgLSB0O1xuICB2YXIgaW52ZXJzZUZhY3RvclRpbWVzVHdvID0gaW52ZXJzZUZhY3RvciAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yMiA9IDMgKiB0ICogaW52ZXJzZUZhY3RvclRpbWVzVHdvO1xuICB2YXIgZmFjdG9yMyA9IDMgKiBmYWN0b3JUaW1lczIgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgdmFyIHogPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAtIDEuMDtcbiAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cclxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICB2YXIgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgdyA9IHcgfHwgMS4wO1xuICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XHJcbiAqIENhbiBhbHNvIGJlIHVzZWQgZm9yIGR1YWwgcXVhdGVybmlvbnMuIChNdWx0aXBseSBpdCB3aXRoIHRoZSByZWFsIHBhcnQpXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIC8vIGJlbmNobWFya3M6IGh0dHBzOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9ucy1maXhlZFxuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdO1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdOyAvLyB2YXIgcXZlYyA9IFtxeCwgcXksIHF6XTtcbiAgLy8gdmFyIHV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgYSk7XG5cbiAgdmFyIHV2eCA9IHF5ICogeiAtIHF6ICogeSxcbiAgICAgIHV2eSA9IHF6ICogeCAtIHF4ICogeixcbiAgICAgIHV2eiA9IHF4ICogeSAtIHF5ICogeDsgLy8gdmFyIHV1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIHV2KTtcblxuICB2YXIgdXV2eCA9IHF5ICogdXZ6IC0gcXogKiB1dnksXG4gICAgICB1dXZ5ID0gcXogKiB1dnggLSBxeCAqIHV2eixcbiAgICAgIHV1dnogPSBxeCAqIHV2eSAtIHF5ICogdXZ4OyAvLyB2ZWMzLnNjYWxlKHV2LCB1diwgMiAqIHcpO1xuXG4gIHZhciB3MiA9IHF3ICogMjtcbiAgdXZ4ICo9IHcyO1xuICB1dnkgKj0gdzI7XG4gIHV2eiAqPSB3MjsgLy8gdmVjMy5zY2FsZSh1dXYsIHV1diwgMik7XG5cbiAgdXV2eCAqPSAyO1xuICB1dXZ5ICo9IDI7XG4gIHV1dnogKj0gMjsgLy8gcmV0dXJuIHZlYzMuYWRkKG91dCwgYSwgdmVjMy5hZGQob3V0LCB1diwgdXV2KSk7XG5cbiAgb3V0WzBdID0geCArIHV2eCArIHV1dng7XG4gIG91dFsxXSA9IHkgKyB1dnkgKyB1dXZ5O1xuICBvdXRbMl0gPSB6ICsgdXZ6ICsgdXV2ejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFswXTtcbiAgclsxXSA9IHBbMV0gKiBNYXRoLmNvcyhyYWQpIC0gcFsyXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMl0gPSBwWzFdICogTWF0aC5zaW4ocmFkKSArIHBbMl0gKiBNYXRoLmNvcyhyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFswXSAqIE1hdGguY29zKHJhZCkgLSBwWzFdICogTWF0aC5zaW4ocmFkKTtcbiAgclsxXSA9IHBbMF0gKiBNYXRoLnNpbihyYWQpICsgcFsxXSAqIE1hdGguY29zKHJhZCk7XG4gIHJbMl0gPSBwWzJdOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgbWFnMSA9IE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSArIGF6ICogYXopLFxuICAgICAgbWFnMiA9IE1hdGguc3FydChieCAqIGJ4ICsgYnkgKiBieSArIGJ6ICogYnopLFxuICAgICAgbWFnID0gbWFnMSAqIG1hZzIsXG4gICAgICBjb3NpbmUgPSBtYWcgJiYgZG90KGEsIGIpIC8gbWFnO1xuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzMoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDQgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBtb2R1bGUgdmVjNFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcclxuICpcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeiwgdykge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHosIHcpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICBvdXRbM10gPSBhWzNdICogYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNlaWxcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIG91dFszXSA9IE1hdGguY2VpbChhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gcm91bmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLnJvdW5kKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgdmFyIHcgPSBiWzNdIC0gYVszXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeiwgdyk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHZhciB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6LCB3KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gLWFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgb3V0WzNdID0gMS4wIC8gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSB4ICogbGVuO1xuICBvdXRbMV0gPSB5ICogbGVuO1xuICBvdXRbMl0gPSB6ICogbGVuO1xuICBvdXRbM10gPSB3ICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0aHJlZSB2ZWN0b3JzIGluIGEgNC1kaW1lbnNpb25hbCBzcGFjZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gcmVzdWx0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBVIHRoZSBmaXJzdCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFYgdGhlIHNlY29uZCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFcgdGhlIHRoaXJkIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gcmVzdWx0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCB1LCB2LCB3KSB7XG4gIHZhciBBID0gdlswXSAqIHdbMV0gLSB2WzFdICogd1swXSxcbiAgICAgIEIgPSB2WzBdICogd1syXSAtIHZbMl0gKiB3WzBdLFxuICAgICAgQyA9IHZbMF0gKiB3WzNdIC0gdlszXSAqIHdbMF0sXG4gICAgICBEID0gdlsxXSAqIHdbMl0gLSB2WzJdICogd1sxXSxcbiAgICAgIEUgPSB2WzFdICogd1szXSAtIHZbM10gKiB3WzFdLFxuICAgICAgRiA9IHZbMl0gKiB3WzNdIC0gdlszXSAqIHdbMl07XG4gIHZhciBHID0gdVswXTtcbiAgdmFyIEggPSB1WzFdO1xuICB2YXIgSSA9IHVbMl07XG4gIHZhciBKID0gdVszXTtcbiAgb3V0WzBdID0gSCAqIEYgLSBJICogRSArIEogKiBEO1xuICBvdXRbMV0gPSAtKEcgKiBGKSArIEkgKiBDIC0gSiAqIEI7XG4gIG91dFsyXSA9IEcgKiBFIC0gSCAqIEMgKyBKICogQTtcbiAgb3V0WzNdID0gLShHICogRCkgKyBIICogQiAtIEkgKiBBO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdO1xuICB2YXIgYXkgPSBhWzFdO1xuICB2YXIgYXogPSBhWzJdO1xuICB2YXIgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7IC8vIE1hcnNhZ2xpYSwgR2VvcmdlLiBDaG9vc2luZyBhIFBvaW50IGZyb20gdGhlIFN1cmZhY2Ugb2YgYVxuICAvLyBTcGhlcmUuIEFubi4gTWF0aC4gU3RhdGlzdC4gNDMgKDE5NzIpLCBuby4gMiwgNjQ1LS02NDYuXG4gIC8vIGh0dHA6Ly9wcm9qZWN0ZXVjbGlkLm9yZy9ldWNsaWQuYW9tcy8xMTc3NjkyNjQ0O1xuXG4gIHZhciB2MSwgdjIsIHYzLCB2NDtcbiAgdmFyIHMxLCBzMjtcblxuICBkbyB7XG4gICAgdjEgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHYyID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMSA9IHYxICogdjEgKyB2MiAqIHYyO1xuICB9IHdoaWxlIChzMSA+PSAxKTtcblxuICBkbyB7XG4gICAgdjMgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHY0ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMiA9IHYzICogdjMgKyB2NCAqIHY0O1xuICB9IHdoaWxlIChzMiA+PSAxKTtcblxuICB2YXIgZCA9IE1hdGguc3FydCgoMSAtIHMxKSAvIHMyKTtcbiAgb3V0WzBdID0gc2NhbGUgKiB2MTtcbiAgb3V0WzFdID0gc2NhbGUgKiB2MjtcbiAgb3V0WzJdID0gc2NhbGUgKiB2MyAqIGQ7XG4gIG91dFszXSA9IHNjYWxlICogdjQgKiBkO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXSxcbiAgICAgIHcgPSBhWzNdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM107IC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG5cbiAgdmFyIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICB2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gIHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgdmFyIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejsgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG4gIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICBvdXRbM10gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwidmVjNChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzRzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSA0O1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICB2ZWNbM10gPSBhW2kgKyAzXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgICBhW2kgKyAzXSA9IHZlY1szXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0cmluZ3MpIHtcclxuICBpZiAodHlwZW9mIHN0cmluZ3MgPT09ICdzdHJpbmcnKSBzdHJpbmdzID0gW3N0cmluZ3NdXHJcbiAgdmFyIGV4cHJzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSlcclxuICB2YXIgcGFydHMgPSBbXVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGgtMTsgaSsrKSB7XHJcbiAgICBwYXJ0cy5wdXNoKHN0cmluZ3NbaV0sIGV4cHJzW2ldIHx8ICcnKVxyXG4gIH1cclxuICBwYXJ0cy5wdXNoKHN0cmluZ3NbaV0pXHJcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXHJcbn1cclxuIiwiLyohXG4gKiBDU1NQbHVnaW4gMy4yLjZcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDA4LTIwMjAsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBnc2FwLCBfZ2V0UHJvcGVydHksIF9udW1FeHAsIF9udW1XaXRoVW5pdEV4cCwgZ2V0VW5pdCwgX2lzU3RyaW5nLCBfaXNVbmRlZmluZWQsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBfcmVsRXhwLCBfZm9yRWFjaE5hbWUsIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHksIF9jb2xvclN0cmluZ0ZpbHRlciwgX2NoZWNrUGx1Z2luLCBfcmVwbGFjZVJhbmRvbSwgX3BsdWdpbnMsIEdTQ2FjaGUsIFByb3BUd2VlbiwgX2NvbmZpZywgX3RpY2tlciwgX3JvdW5kLCBfbWlzc2luZ1BsdWdpbiwgX2dldFNldHRlciwgX2dldENhY2hlLCBfc2V0RGVmYXVsdHMsIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSAvL2ZvciB0aGUgY29tbWVudGVkLW91dCBjbGFzc05hbWUgZmVhdHVyZS5cbn0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5cbnZhciBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsZW1lbnQsXG4gICAgX3BsdWdpbkluaXR0ZWQsXG4gICAgX3RlbXBEaXYsXG4gICAgX3RlbXBEaXZTdHlsZXIsXG4gICAgX3JlY2VudFNldHRlclBsdWdpbixcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF90cmFuc2Zvcm1Qcm9wcyA9IHt9LFxuICAgIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcbiAgICBfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG4gICAgX2F0YW4yID0gTWF0aC5hdGFuMixcbiAgICBfYmlnTnVtID0gMWU4LFxuICAgIF9jYXBzRXhwID0gLyhbQS1aXSkvZyxcbiAgICBfaG9yaXpvbnRhbEV4cCA9IC8oPzpsZWZ0fHJpZ2h0fHdpZHRofG1hcmdpbnxwYWRkaW5nfHgpL2ksXG4gICAgX2NvbXBsZXhFeHAgPSAvW1xccyxcXChdXFxTLyxcbiAgICBfcHJvcGVydHlBbGlhc2VzID0ge1xuICBhdXRvQWxwaGE6IFwib3BhY2l0eSx2aXNpYmlsaXR5XCIsXG4gIHNjYWxlOiBcInNjYWxlWCxzY2FsZVlcIixcbiAgYWxwaGE6IFwib3BhY2l0eVwiXG59LFxuICAgIF9yZW5kZXJDU1NQcm9wID0gZnVuY3Rpb24gX3JlbmRlckNTU1Byb3AocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJQcm9wV2l0aEVuZCA9IGZ1bmN0aW9uIF9yZW5kZXJQcm9wV2l0aEVuZChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID09PSAxID8gZGF0YS5lIDogTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmcgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmcocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA/IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51IDogZGF0YS5iLCBkYXRhKTtcbn0sXG4gICAgLy9pZiB1bml0cyBjaGFuZ2UsIHdlIG5lZWQgYSB3YXkgdG8gcmVuZGVyIHRoZSBvcmlnaW5hbCB1bml0L3ZhbHVlIHdoZW4gdGhlIHR3ZWVuIGdvZXMgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nIChyYXRpbzowKVxuX3JlbmRlclJvdW5kZWRDU1NQcm9wID0gZnVuY3Rpb24gX3JlbmRlclJvdW5kZWRDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGEucyArIGRhdGEuYyAqIHJhdGlvO1xuICBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgfn4odmFsdWUgKyAodmFsdWUgPCAwID8gLS41IDogLjUpKSArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlID0gZnVuY3Rpb24gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYiwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kID0gZnVuY3Rpb24gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyAhPT0gMSA/IGRhdGEuYiA6IGRhdGEuZSwgZGF0YSk7XG59LFxuICAgIF9zZXR0ZXJDU1NTdHlsZSA9IGZ1bmN0aW9uIF9zZXR0ZXJDU1NTdHlsZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9zZXR0ZXJDU1NQcm9wKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbn0sXG4gICAgX3NldHRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9zZXR0ZXJUcmFuc2Zvcm0odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlclNjYWxlID0gZnVuY3Rpb24gX3NldHRlclNjYWxlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXAuc2NhbGVYID0gdGFyZ2V0Ll9nc2FwLnNjYWxlWSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyID0gZnVuY3Rpb24gX3NldHRlclNjYWxlV2l0aFJlbmRlcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSwgcmF0aW8pIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICBjYWNoZS5zY2FsZVggPSBjYWNoZS5zY2FsZVkgPSB2YWx1ZTtcbiAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKHJhdGlvLCBjYWNoZSk7XG59LFxuICAgIF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyID0gZnVuY3Rpb24gX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgY2FjaGVbcHJvcGVydHldID0gdmFsdWU7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcCA9IFwidHJhbnNmb3JtXCIsXG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCIsXG4gICAgX3N1cHBvcnRzM0QsXG4gICAgX2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudCh0eXBlLCBucykge1xuICB2YXIgZSA9IF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMoKG5zIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKS5yZXBsYWNlKC9eaHR0cHMvLCBcImh0dHBcIiksIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgc2VydmVycyBzd2FwIGluIGh0dHBzIGZvciBodHRwIGluIHRoZSBuYW1lc3BhY2Ugd2hpY2ggY2FuIGJyZWFrIHRoaW5ncywgbWFraW5nIFwic3R5bGVcIiBpbmFjY2Vzc2libGUuXG5cbiAgcmV0dXJuIGUuc3R5bGUgPyBlIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgZW52aXJvbm1lbnRzIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHdoZW4gY3JlYXRlZCB3aXRoIGEgbmFtZXNwYWNlIGluIHdoaWNoIGNhc2Ugd2UgZGVmYXVsdCB0byB0aGUgc3RhbmRhcmQgY3JlYXRlRWxlbWVudCgpIHRvIHdvcmsgYXJvdW5kIHRoZSBpc3N1ZS4gQWxzbyBub3RlIHRoYXQgd2hlbiBHU0FQIGlzIGVtYmVkZGVkIGRpcmVjdGx5IGluc2lkZSBhbiBTVkcgZmlsZSwgY3JlYXRlRWxlbWVudCgpIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgc3R5bGUgb2JqZWN0IGluIEZpcmVmb3ggKHNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIwMjE1LXByb2JsZW0tdXNpbmctdHdlZW5tYXgtaW4tc3RhbmRhbG9uZS1zZWxmLWNvbnRhaW5pbmctc3ZnLWZpbGUtZXJyLWNhbm5vdC1zZXQtcHJvcGVydHktY3NzdGV4dC1vZi11bmRlZmluZWQvKS5cbn0sXG4gICAgX2dldENvbXB1dGVkUHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBza2lwUHJlZml4RmFsbGJhY2spIHtcbiAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICByZXR1cm4gY3NbcHJvcGVydHldIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSkgfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSkgfHwgIXNraXBQcmVmaXhGYWxsYmFjayAmJiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHkpIHx8IHByb3BlcnR5LCAxKSB8fCBcIlwiOyAvL2NzcyB2YXJpYWJsZXMgbWF5IG5vdCBuZWVkIGNhcHMgc3dhcHBlZCBvdXQgZm9yIGRhc2hlcyBhbmQgbG93ZXJjYXNlLlxufSxcbiAgICBfcHJlZml4ZXMgPSBcIk8sTW96LG1zLE1zLFdlYmtpdFwiLnNwbGl0KFwiLFwiKSxcbiAgICBfY2hlY2tQcm9wUHJlZml4ID0gZnVuY3Rpb24gX2NoZWNrUHJvcFByZWZpeChwcm9wZXJ0eSwgZWxlbWVudCwgcHJlZmVyUHJlZml4KSB7XG4gIHZhciBlID0gZWxlbWVudCB8fCBfdGVtcERpdixcbiAgICAgIHMgPSBlLnN0eWxlLFxuICAgICAgaSA9IDU7XG5cbiAgaWYgKHByb3BlcnR5IGluIHMgJiYgIXByZWZlclByZWZpeCkge1xuICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgfVxuXG4gIHByb3BlcnR5ID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zdWJzdHIoMSk7XG5cbiAgd2hpbGUgKGktLSAmJiAhKF9wcmVmaXhlc1tpXSArIHByb3BlcnR5IGluIHMpKSB7fVxuXG4gIHJldHVybiBpIDwgMCA/IG51bGwgOiAoaSA9PT0gMyA/IFwibXNcIiA6IGkgPj0gMCA/IF9wcmVmaXhlc1tpXSA6IFwiXCIpICsgcHJvcGVydHk7XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZSgpIHtcbiAgaWYgKF93aW5kb3dFeGlzdHMoKSkge1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IF93aW4uZG9jdW1lbnQ7XG4gICAgX2RvY0VsZW1lbnQgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfdGVtcERpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpIHx8IHtcbiAgICAgIHN0eWxlOiB7fVxuICAgIH07XG4gICAgX3RlbXBEaXZTdHlsZXIgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1Byb3BQcmVmaXgoX3RyYW5zZm9ybVByb3ApO1xuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChfdHJhbnNmb3JtT3JpZ2luUHJvcCk7XG4gICAgX3RlbXBEaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyLXdpZHRoOjA7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjBcIjsgLy9tYWtlIHN1cmUgdG8gb3ZlcnJpZGUgY2VydGFpbiBwcm9wZXJ0aWVzIHRoYXQgbWF5IGNvbnRhbWluYXRlIG1lYXN1cmVtZW50cywgaW4gY2FzZSB0aGUgdXNlciBoYXMgb3ZlcnJlYWNoaW5nIHN0eWxlIHNoZWV0cy5cblxuICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XG4gICAgX3BsdWdpbkluaXR0ZWQgPSAxO1xuICB9XG59LFxuICAgIF9nZXRCQm94SGFjayA9IGZ1bmN0aW9uIF9nZXRCQm94SGFjayhzd2FwSWZQb3NzaWJsZSkge1xuICAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB0aGF0IGRvbid0IGNvcnJlY3RseSByZXBvcnQgZ2V0QkJveCgpIG9uIFNWRyBlbGVtZW50cyBpbnNpZGUgYSA8ZGVmcz4gZWxlbWVudCBhbmQvb3IgPG1hc2s+LiBXZSB0cnkgY3JlYXRpbmcgYW4gU1ZHLCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgdG9zcyB0aGUgZWxlbWVudCBpbiB0aGVyZSBzbyB0aGF0IGl0J3MgZGVmaW5pdGVseSBwYXJ0IG9mIHRoZSByZW5kZXJpbmcgdHJlZSwgdGhlbiBncmFiIHRoZSBiYm94IGFuZCBpZiBpdCB3b3Jrcywgd2UgYWN0dWFsbHkgc3dhcCBvdXQgdGhlIG9yaWdpbmFsIGdldEJCb3goKSBtZXRob2QgZm9yIG91ciBvd24gdGhhdCBkb2VzIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW5ldmVyIGdldEJCb3ggaXMgbmVlZGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHBlcmZvcm1hbmNlIGlzIG9wdGltYWwgKG9ubHkgZG8gYWxsIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuLi5tb3N0IGVsZW1lbnRzIGRvbid0IG5lZWQgaXQpLlxuICB2YXIgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgdGhpcy5vd25lclNWR0VsZW1lbnQgJiYgdGhpcy5vd25lclNWR0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcbiAgICAgIG9sZFBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSxcbiAgICAgIG9sZFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nLFxuICAgICAgb2xkQ1NTID0gdGhpcy5zdHlsZS5jc3NUZXh0LFxuICAgICAgYmJveDtcblxuICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZChzdmcpO1xuXG4gIHN2Zy5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gIGlmIChzd2FwSWZQb3NzaWJsZSkge1xuICAgIHRyeSB7XG4gICAgICBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICB0aGlzLl9nc2FwQkJveCA9IHRoaXMuZ2V0QkJveDsgLy9zdG9yZSB0aGUgb3JpZ2luYWxcblxuICAgICAgdGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0gZWxzZSBpZiAodGhpcy5fZ3NhcEJCb3gpIHtcbiAgICBiYm94ID0gdGhpcy5fZ3NhcEJCb3goKTtcbiAgfVxuXG4gIGlmIChvbGRQYXJlbnQpIHtcbiAgICBpZiAob2xkU2libGluZykge1xuICAgICAgb2xkUGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBvbGRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgdGhpcy5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICByZXR1cm4gYmJveDtcbn0sXG4gICAgX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyA9IGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBhdHRyaWJ1dGVzQXJyYXkpIHtcbiAgdmFyIGkgPSBhdHRyaWJ1dGVzQXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0QkJveCA9IGZ1bmN0aW9uIF9nZXRCQm94KHRhcmdldCkge1xuICB2YXIgYm91bmRzO1xuXG4gIHRyeSB7XG4gICAgYm91bmRzID0gdGFyZ2V0LmdldEJCb3goKTsgLy9GaXJlZm94IHRocm93cyBlcnJvcnMgaWYgeW91IHRyeSBjYWxsaW5nIGdldEJCb3goKSBvbiBhbiBTVkcgZWxlbWVudCB0aGF0J3Mgbm90IHJlbmRlcmVkIChsaWtlIGluIGEgPHN5bWJvbD4gb3IgPGRlZnM+KS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjEyMTE4XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKTtcbiAgfVxuXG4gIGJvdW5kcyAmJiAoYm91bmRzLndpZHRoIHx8IGJvdW5kcy5oZWlnaHQpIHx8IHRhcmdldC5nZXRCQm94ID09PSBfZ2V0QkJveEhhY2sgfHwgKGJvdW5kcyA9IF9nZXRCQm94SGFjay5jYWxsKHRhcmdldCwgdHJ1ZSkpOyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgbWlzcmVwb3J0IHRoZSBib3VuZHMgaWYgdGhlIGVsZW1lbnQgaGFzIHplcm8gd2lkdGggYW5kIGhlaWdodCAoaXQganVzdCBhc3N1bWVzIGl0J3MgYXQgeDowLCB5OjApLCB0aHVzIHdlIG5lZWQgdG8gbWFudWFsbHkgZ3JhYiB0aGUgcG9zaXRpb24gaW4gdGhhdCBjYXNlLlxuXG4gIHJldHVybiBib3VuZHMgJiYgIWJvdW5kcy53aWR0aCAmJiAhYm91bmRzLnggJiYgIWJvdW5kcy55ID8ge1xuICAgIHg6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieFwiLCBcImN4XCIsIFwieDFcIl0pIHx8IDAsXG4gICAgeTogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ5XCIsIFwiY3lcIiwgXCJ5MVwiXSkgfHwgMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSA6IGJvdW5kcztcbn0sXG4gICAgX2lzU1ZHID0gZnVuY3Rpb24gX2lzU1ZHKGUpIHtcbiAgcmV0dXJuICEhKGUuZ2V0Q1RNICYmICghZS5wYXJlbnROb2RlIHx8IGUub3duZXJTVkdFbGVtZW50KSAmJiBfZ2V0QkJveChlKSk7XG59LFxuICAgIC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5fcmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkpIHtcbiAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGU7XG5cbiAgICBpZiAocHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzKSB7XG4gICAgICBwcm9wZXJ0eSA9IF90cmFuc2Zvcm1Qcm9wO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS5yZW1vdmVQcm9wZXJ0eSkge1xuICAgICAgaWYgKHByb3BlcnR5LnN1YnN0cigwLCAyKSA9PT0gXCJtc1wiIHx8IHByb3BlcnR5LnN1YnN0cigwLCA2KSA9PT0gXCJ3ZWJraXRcIikge1xuICAgICAgICAvL01pY3Jvc29mdCBhbmQgc29tZSBXZWJraXQgYnJvd3NlcnMgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3RhbmRhcmQgb2YgY2FwaXRhbGl6aW5nIHRoZSBmaXJzdCBwcmVmaXggY2hhcmFjdGVyLCBzbyB3ZSBhZGp1c3Qgc28gdGhhdCB3aGVuIHdlIHByZWZpeCB0aGUgY2FwcyB3aXRoIGEgZGFzaCwgaXQncyBjb3JyZWN0IChvdGhlcndpc2UgaXQnZCBiZSBcIm1zLXRyYW5zZm9ybVwiIGluc3RlYWQgb2YgXCItbXMtdHJhbnNmb3JtXCIgZm9yIElFOSwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHByb3BlcnR5ID0gXCItXCIgKyBwcm9wZXJ0eTtcbiAgICAgIH1cblxuICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHVzZSBcInJlbW92ZUF0dHJpYnV0ZSgpXCIgaW5zdGVhZCBvZiBcInJlbW92ZVByb3BlcnR5KClcIlxuICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQgPSBmdW5jdGlvbiBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGJlZ2lubmluZywgZW5kLCBvbmx5U2V0QXRFbmQpIHtcbiAgdmFyIHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBvbmx5U2V0QXRFbmQgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKTtcbiAgcGx1Z2luLl9wdCA9IHB0O1xuICBwdC5iID0gYmVnaW5uaW5nO1xuICBwdC5lID0gZW5kO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfbm9uQ29udmVydGlibGVVbml0cyA9IHtcbiAgZGVnOiAxLFxuICByYWQ6IDEsXG4gIHR1cm46IDFcbn0sXG4gICAgLy90YWtlcyBhIHNpbmdsZSB2YWx1ZSBsaWtlIDIwcHggYW5kIGNvbnZlcnRzIGl0IHRvIHRoZSB1bml0IHNwZWNpZmllZCwgbGlrZSBcIiVcIiwgcmV0dXJuaW5nIG9ubHkgdGhlIG51bWVyaWMgYW1vdW50LlxuX2NvbnZlcnRUb1VuaXQgPSBmdW5jdGlvbiBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgdW5pdCkge1xuICB2YXIgY3VyVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwLFxuICAgICAgY3VyVW5pdCA9ICh2YWx1ZSArIFwiXCIpLnRyaW0oKS5zdWJzdHIoKGN1clZhbHVlICsgXCJcIikubGVuZ3RoKSB8fCBcInB4XCIsXG4gICAgICAvLyBzb21lIGJyb3dzZXJzIGxlYXZlIGV4dHJhIHdoaXRlc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiBDU1MgdmFyaWFibGVzLCBoZW5jZSB0aGUgbmVlZCB0byB0cmltKClcbiAgc3R5bGUgPSBfdGVtcERpdi5zdHlsZSxcbiAgICAgIGhvcml6b250YWwgPSBfaG9yaXpvbnRhbEV4cC50ZXN0KHByb3BlcnR5KSxcbiAgICAgIGlzUm9vdFNWRyA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIsXG4gICAgICBtZWFzdXJlUHJvcGVydHkgPSAoaXNSb290U1ZHID8gXCJjbGllbnRcIiA6IFwib2Zmc2V0XCIpICsgKGhvcml6b250YWwgPyBcIldpZHRoXCIgOiBcIkhlaWdodFwiKSxcbiAgICAgIGFtb3VudCA9IDEwMCxcbiAgICAgIHRvUGl4ZWxzID0gdW5pdCA9PT0gXCJweFwiLFxuICAgICAgdG9QZXJjZW50ID0gdW5pdCA9PT0gXCIlXCIsXG4gICAgICBweCxcbiAgICAgIHBhcmVudCxcbiAgICAgIGNhY2hlLFxuICAgICAgaXNTVkc7XG5cbiAgaWYgKHVuaXQgPT09IGN1clVuaXQgfHwgIWN1clZhbHVlIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW3VuaXRdIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW2N1clVuaXRdKSB7XG4gICAgcmV0dXJuIGN1clZhbHVlO1xuICB9XG5cbiAgY3VyVW5pdCAhPT0gXCJweFwiICYmICF0b1BpeGVscyAmJiAoY3VyVmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgXCJweFwiKSk7XG4gIGlzU1ZHID0gdGFyZ2V0LmdldENUTSAmJiBfaXNTVkcodGFyZ2V0KTtcblxuICBpZiAodG9QZXJjZW50ICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XG4gICAgLy90cmFuc2Zvcm1zIGFuZCBib3JkZXJSYWRpdXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGl0c2VsZiFcbiAgICByZXR1cm4gX3JvdW5kKGN1clZhbHVlIC8gKGlzU1ZHID8gdGFyZ2V0LmdldEJCb3goKVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gOiB0YXJnZXRbbWVhc3VyZVByb3BlcnR5XSkgKiBhbW91bnQpO1xuICB9XG5cbiAgc3R5bGVbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdID0gYW1vdW50ICsgKHRvUGl4ZWxzID8gY3VyVW5pdCA6IHVuaXQpO1xuICBwYXJlbnQgPSB+cHJvcGVydHkuaW5kZXhPZihcImFkaXVzXCIpIHx8IHVuaXQgPT09IFwiZW1cIiAmJiB0YXJnZXQuYXBwZW5kQ2hpbGQgJiYgIWlzUm9vdFNWRyA/IHRhcmdldCA6IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gIGlmIChpc1NWRykge1xuICAgIHBhcmVudCA9ICh0YXJnZXQub3duZXJTVkdFbGVtZW50IHx8IHt9KS5wYXJlbnROb2RlO1xuICB9XG5cbiAgaWYgKCFwYXJlbnQgfHwgcGFyZW50ID09PSBfZG9jIHx8ICFwYXJlbnQuYXBwZW5kQ2hpbGQpIHtcbiAgICBwYXJlbnQgPSBfZG9jLmJvZHk7XG4gIH1cblxuICBjYWNoZSA9IHBhcmVudC5fZ3NhcDtcblxuICBpZiAoY2FjaGUgJiYgdG9QZXJjZW50ICYmIGNhY2hlLndpZHRoICYmIGhvcml6b250YWwgJiYgY2FjaGUudGltZSA9PT0gX3RpY2tlci50aW1lKSB7XG4gICAgcmV0dXJuIF9yb3VuZChjdXJWYWx1ZSAvIGNhY2hlLndpZHRoICogYW1vdW50KTtcbiAgfSBlbHNlIHtcbiAgICAodG9QZXJjZW50IHx8IGN1clVuaXQgPT09IFwiJVwiKSAmJiAoc3R5bGUucG9zaXRpb24gPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIFwicG9zaXRpb25cIikpO1xuICAgIHBhcmVudCA9PT0gdGFyZ2V0ICYmIChzdHlsZS5wb3NpdGlvbiA9IFwic3RhdGljXCIpOyAvLyBsaWtlIGZvciBib3JkZXJSYWRpdXMsIGlmIGl0J3MgYSAlIHdlIG11c3QgaGF2ZSBpdCByZWxhdGl2ZSB0byB0aGUgdGFyZ2V0IGl0c2VsZiBidXQgdGhhdCBtYXkgbm90IGhhdmUgcG9zaXRpb246IHJlbGF0aXZlIG9yIHBvc2l0aW9uOiBhYnNvbHV0ZSBpbiB3aGljaCBjYXNlIGl0J2QgZ28gdXAgdGhlIGNoYWluIHVudGlsIGl0IGZpbmRzIGl0cyBvZmZzZXRQYXJlbnQgKGJhZCkuIHBvc2l0aW9uOiBzdGF0aWMgcHJvdGVjdHMgYWdhaW5zdCB0aGF0LlxuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKF90ZW1wRGl2KTtcbiAgICBweCA9IF90ZW1wRGl2W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKF90ZW1wRGl2KTtcbiAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblxuICAgIGlmIChob3Jpem9udGFsICYmIHRvUGVyY2VudCkge1xuICAgICAgY2FjaGUgPSBfZ2V0Q2FjaGUocGFyZW50KTtcbiAgICAgIGNhY2hlLnRpbWUgPSBfdGlja2VyLnRpbWU7XG4gICAgICBjYWNoZS53aWR0aCA9IHBhcmVudFttZWFzdXJlUHJvcGVydHldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfcm91bmQodG9QaXhlbHMgPyBweCAqIGN1clZhbHVlIC8gYW1vdW50IDogcHggJiYgY3VyVmFsdWUgPyBhbW91bnQgLyBweCAqIGN1clZhbHVlIDogMCk7XG59LFxuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcbiAgdmFyIHZhbHVlO1xuXG4gIGlmICghX3BsdWdpbkluaXR0ZWQpIHtcbiAgICBfaW5pdENvcmUoKTtcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcbiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoXCIsXCIpWzBdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKTtcbiAgICB2YWx1ZSA9IHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybU9yaWdpblwiID8gdmFsdWVbcHJvcGVydHldIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCB+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG4gICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApOyAvLyBub3RlOiBzb21lIGJyb3dzZXJzLCBsaWtlIEZpcmVmb3gsIGRvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5ISBJbnN0ZWFkLCBpdCBvbmx5IHJlcG9ydHMgZXZlcnkgY29ybmVyIGxpa2UgIGJvcmRlclRvcExlZnRSYWRpdXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pdCAmJiAhfih2YWx1ZSArIFwiXCIpLmluZGV4T2YoXCIgXCIpID8gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpICsgdW5pdCA6IHZhbHVlO1xufSxcbiAgICBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nID0gZnVuY3Rpb24gX3R3ZWVuQ29tcGxleENTU1N0cmluZyh0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQpIHtcbiAgLy9ub3RlOiB3ZSBjYWxsIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbChwbHVnaW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0ID09PSBcIm5vbmVcIikge1xuICAgIC8vIHNvbWUgYnJvd3NlcnMgbGlrZSBTYWZhcmkgYWN0dWFsbHkgUFJFRkVSIHRoZSBwcmVmaXhlZCBwcm9wZXJ0eSBhbmQgbWlzLXJlcG9ydCB0aGUgdW5wcmVmaXhlZCB2YWx1ZSBsaWtlIGNsaXBQYXRoIChCVUcpLiBJbiBvdGhlciB3b3JkcywgZXZlbiB0aG91Z2ggY2xpcFBhdGggZXhpc3RzIGluIHRoZSBzdHlsZSAoXCJjbGlwUGF0aFwiIGluIHRhcmdldC5zdHlsZSkgYW5kIGl0J3Mgc2V0IGluIHRoZSBDU1MgcHJvcGVybHkgKGFsb25nIHdpdGggLXdlYmtpdC1jbGlwLXBhdGgpLCBTYWZhcmkgcmVwb3J0cyBjbGlwUGF0aCBhcyBcIm5vbmVcIiB3aGVyZWFzIFdlYmtpdENsaXBQYXRoIHJlcG9ydHMgYWNjdXJhdGVseSBsaWtlIFwiZWxsaXBzZSgxMDAlIDAlIGF0IDUwJSAwJSlcIiwgc28gaW4gdGhpcyBjYXNlIHdlIG11c3QgU1dJVENIIHRvIHVzaW5nIHRoZSBwcmVmaXhlZCBwcm9wZXJ0eSBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8xODMxMC1jbGlwcGF0aC1kb2VzbnQtd29yay1vbi1pb3MvXG4gICAgdmFyIHAgPSBfY2hlY2tQcm9wUHJlZml4KHByb3AsIHRhcmdldCwgMSksXG4gICAgICAgIHMgPSBwICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcCwgMSk7XG5cbiAgICBpZiAocyAmJiBzICE9PSBzdGFydCkge1xuICAgICAgcHJvcCA9IHA7XG4gICAgICBzdGFydCA9IHM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LnN0eWxlLCBwcm9wLCAwLCAxLCBfcmVuZGVyQ29tcGxleFN0cmluZyksXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIGEsXG4gICAgICByZXN1bHQsXG4gICAgICBzdGFydFZhbHVlcyxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgY29sb3IsXG4gICAgICBzdGFydFZhbHVlLFxuICAgICAgZW5kVmFsdWUsXG4gICAgICBlbmROdW0sXG4gICAgICBjaHVuayxcbiAgICAgIGVuZFVuaXQsXG4gICAgICBzdGFydFVuaXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIGVuZFZhbHVlcztcbiAgcHQuYiA9IHN0YXJ0O1xuICBwdC5lID0gZW5kO1xuICBzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoZW5kID09PSBcImF1dG9cIikge1xuICAgIHRhcmdldC5zdHlsZVtwcm9wXSA9IGVuZDtcbiAgICBlbmQgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHx8IGVuZDtcbiAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBzdGFydDtcbiAgfVxuXG4gIGEgPSBbc3RhcnQsIGVuZF07XG5cbiAgX2NvbG9yU3RyaW5nRmlsdGVyKGEpOyAvL3Bhc3MgYW4gYXJyYXkgd2l0aCB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgYW5kIGxldCB0aGUgZmlsdGVyIGRvIHdoYXRldmVyIGl0IG5lZWRzIHRvIHRoZSB2YWx1ZXMuIElmIGNvbG9ycyBhcmUgZm91bmQsIGl0IHJldHVybnMgdHJ1ZSBhbmQgdGhlbiB3ZSBtdXN0IG1hdGNoIHdoZXJlIHRoZSBjb2xvciBzaG93cyB1cCBvcmRlci13aXNlIGJlY2F1c2UgZm9yIHRoaW5ncyBsaWtlIGJveFNoYWRvdywgc29tZXRpbWVzIHRoZSBicm93c2VyIHByb3ZpZGVzIHRoZSBjb21wdXRlZCB2YWx1ZXMgd2l0aCB0aGUgY29sb3IgRklSU1QsIGJ1dCB0aGUgdXNlciBwcm92aWRlcyBpdCB3aXRoIHRoZSBjb2xvciBMQVNULCBzbyBmbGlwIHRoZW0gaWYgbmVjZXNzYXJ5LiBTYW1lIGZvciBkcm9wLXNoYWRvdygpLlxuXG5cbiAgc3RhcnQgPSBhWzBdO1xuICBlbmQgPSBhWzFdO1xuICBzdGFydFZhbHVlcyA9IHN0YXJ0Lm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG4gIGVuZFZhbHVlcyA9IGVuZC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuXG4gIGlmIChlbmRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgd2hpbGUgKHJlc3VsdCA9IF9udW1XaXRoVW5pdEV4cC5leGVjKGVuZCkpIHtcbiAgICAgIGVuZFZhbHVlID0gcmVzdWx0WzBdO1xuICAgICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXG4gICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgY29sb3IgPSAoY29sb3IgKyAxKSAlIDU7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIiB8fCBjaHVuay5zdWJzdHIoLTUpID09PSBcImhzbGEoXCIpIHtcbiAgICAgICAgY29sb3IgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kVmFsdWUgIT09IChzdGFydFZhbHVlID0gc3RhcnRWYWx1ZXNbbWF0Y2hJbmRleCsrXSB8fCBcIlwiKSkge1xuICAgICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSkgfHwgMDtcbiAgICAgICAgc3RhcnRVbml0ID0gc3RhcnRWYWx1ZS5zdWJzdHIoKHN0YXJ0TnVtICsgXCJcIikubGVuZ3RoKTtcbiAgICAgICAgcmVsYXRpdmUgPSBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiID8gKyhlbmRWYWx1ZS5jaGFyQXQoMCkgKyBcIjFcIikgOiAwO1xuXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICAgIGVuZFVuaXQgPSBlbmRWYWx1ZS5zdWJzdHIoKGVuZE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgIGluZGV4ID0gX251bVdpdGhVbml0RXhwLmxhc3RJbmRleCAtIGVuZFVuaXQubGVuZ3RoO1xuXG4gICAgICAgIGlmICghZW5kVW5pdCkge1xuICAgICAgICAgIC8vaWYgc29tZXRoaW5nIGxpa2UgXCJwZXJzcGVjdGl2ZTozMDBcIiBpcyBwYXNzZWQgaW4gYW5kIHdlIG11c3QgYWRkIGEgdW5pdCB0byB0aGUgZW5kXG4gICAgICAgICAgZW5kVW5pdCA9IGVuZFVuaXQgfHwgX2NvbmZpZy51bml0c1twcm9wXSB8fCBzdGFydFVuaXQ7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IGVuZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVuZCArPSBlbmRVbml0O1xuICAgICAgICAgICAgcHQuZSArPSBlbmRVbml0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQpIHtcbiAgICAgICAgICBzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgfHwgMDtcbiAgICAgICAgfSAvL3RoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cblxuICAgICAgICBwdC5fcHQgPSB7XG4gICAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgICBwOiBjaHVuayB8fCBtYXRjaEluZGV4ID09PSAxID8gY2h1bmsgOiBcIixcIixcbiAgICAgICAgICAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgICBjOiByZWxhdGl2ZSA/IHJlbGF0aXZlICogZW5kTnVtIDogZW5kTnVtIC0gc3RhcnROdW0sXG4gICAgICAgICAgbTogY29sb3IgJiYgY29sb3IgPCA0ID8gTWF0aC5yb3VuZCA6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdC5jID0gaW5kZXggPCBlbmQubGVuZ3RoID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXG4gIH0gZWxzZSB7XG4gICAgcHQuciA9IHByb3AgPT09IFwiZGlzcGxheVwiICYmIGVuZCA9PT0gXCJub25lXCIgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlO1xuICB9XG5cbiAgaWYgKF9yZWxFeHAudGVzdChlbmQpKSB7XG4gICAgcHQuZSA9IDA7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cbiAgfVxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhbm90aGVyIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9rZXl3b3JkVG9QZXJjZW50ID0ge1xuICB0b3A6IFwiMCVcIixcbiAgYm90dG9tOiBcIjEwMCVcIixcbiAgbGVmdDogXCIwJVwiLFxuICByaWdodDogXCIxMDAlXCIsXG4gIGNlbnRlcjogXCI1MCVcIlxufSxcbiAgICBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyA9IGZ1bmN0aW9uIF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKHZhbHVlKSB7XG4gIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcbiAgICAgIHggPSBzcGxpdFswXSxcbiAgICAgIHkgPSBzcGxpdFsxXSB8fCBcIjUwJVwiO1xuXG4gIGlmICh4ID09PSBcInRvcFwiIHx8IHggPT09IFwiYm90dG9tXCIgfHwgeSA9PT0gXCJsZWZ0XCIgfHwgeSA9PT0gXCJyaWdodFwiKSB7XG4gICAgLy90aGUgdXNlciBwcm92aWRlZCB0aGVtIGluIHRoZSB3cm9uZyBvcmRlciwgc28gZmxpcCB0aGVtXG4gICAgdmFsdWUgPSB4O1xuICAgIHggPSB5O1xuICAgIHkgPSB2YWx1ZTtcbiAgfVxuXG4gIHNwbGl0WzBdID0gX2tleXdvcmRUb1BlcmNlbnRbeF0gfHwgeDtcbiAgc3BsaXRbMV0gPSBfa2V5d29yZFRvUGVyY2VudFt5XSB8fCB5O1xuICByZXR1cm4gc3BsaXQuam9pbihcIiBcIik7XG59LFxuICAgIF9yZW5kZXJDbGVhclByb3BzID0gZnVuY3Rpb24gX3JlbmRlckNsZWFyUHJvcHMocmF0aW8sIGRhdGEpIHtcbiAgaWYgKGRhdGEudHdlZW4gJiYgZGF0YS50d2Vlbi5fdGltZSA9PT0gZGF0YS50d2Vlbi5fZHVyKSB7XG4gICAgdmFyIHRhcmdldCA9IGRhdGEudCxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIHByb3BzID0gZGF0YS51LFxuICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgY2xlYXJUcmFuc2Zvcm1zLFxuICAgICAgICBpO1xuXG4gICAgaWYgKHByb3BzID09PSBcImFsbFwiIHx8IHByb3BzID09PSB0cnVlKSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gXCJcIjtcbiAgICAgIGNsZWFyVHJhbnNmb3JtcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1tpXTtcblxuICAgICAgICBpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICBwcm9wID0gcHJvcCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIiA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3RyYW5zZm9ybVByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XG4gICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5zdmcgJiYgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblxuICAgICAgICBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTsgLy8gZm9yY2UgYWxsIHRoZSBjYWNoZWQgdmFsdWVzIGJhY2sgdG8gXCJub3JtYWxcIi9pZGVudGl0eSwgb3RoZXJ3aXNlIGlmIHRoZXJlJ3MgYW5vdGhlciB0d2VlbiB0aGF0J3MgYWxyZWFkeSBzZXQgdG8gcmVuZGVyIHRyYW5zZm9ybXMgb24gdGhpcyBlbGVtZW50LCBpdCBjb3VsZCBkaXNwbGF5IHRoZSB3cm9uZyB2YWx1ZXMuXG5cblxuICAgICAgICBjYWNoZS51bmNhY2hlID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgLy8gbm90ZTogc3BlY2lhbFByb3BzIHNob3VsZCByZXR1cm4gMSBpZiAoYW5kIG9ubHkgaWYpIHRoZXkgaGF2ZSBhIG5vbi16ZXJvIHByaW9yaXR5LiBJdCBpbmRpY2F0ZXMgd2UgbmVlZCB0byBzb3J0IHRoZSBsaW5rZWQgbGlzdC5cbl9zcGVjaWFsUHJvcHMgPSB7XG4gIGNsZWFyUHJvcHM6IGZ1bmN0aW9uIGNsZWFyUHJvcHMocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgICBpZiAodHdlZW4uZGF0YSAhPT0gXCJpc0Zyb21TdGFydFwiKSB7XG4gICAgICB2YXIgcHQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAwLCBfcmVuZGVyQ2xlYXJQcm9wcyk7XG4gICAgICBwdC51ID0gZW5kVmFsdWU7XG4gICAgICBwdC5wciA9IC0xMDtcbiAgICAgIHB0LnR3ZWVuID0gdHdlZW47XG5cbiAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICAvKiBjbGFzc05hbWUgZmVhdHVyZSAoYWJvdXQgMC40a2IgZ3ppcHBlZCkuXG4gICwgY2xhc3NOYW1lKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gIFx0bGV0IF9yZW5kZXJDbGFzc05hbWUgPSAocmF0aW8sIGRhdGEpID0+IHtcbiAgXHRcdFx0ZGF0YS5jc3MucmVuZGVyKHJhdGlvLCBkYXRhLmNzcyk7XG4gIFx0XHRcdGlmICghcmF0aW8gfHwgcmF0aW8gPT09IDEpIHtcbiAgXHRcdFx0XHRsZXQgaW5saW5lID0gZGF0YS5ybXYsXG4gIFx0XHRcdFx0XHR0YXJnZXQgPSBkYXRhLnQsXG4gIFx0XHRcdFx0XHRwO1xuICBcdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYik7XG4gIFx0XHRcdFx0Zm9yIChwIGluIGlubGluZSkge1xuICBcdFx0XHRcdFx0X3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9LFxuICBcdFx0X2dldEFsbFN0eWxlcyA9ICh0YXJnZXQpID0+IHtcbiAgXHRcdFx0bGV0IHN0eWxlcyA9IHt9LFxuICBcdFx0XHRcdGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLFxuICBcdFx0XHRcdHA7XG4gIFx0XHRcdGZvciAocCBpbiBjb21wdXRlZCkge1xuICBcdFx0XHRcdGlmIChpc05hTihwKSAmJiBwICE9PSBcImNzc1RleHRcIiAmJiBwICE9PSBcImxlbmd0aFwiKSB7XG4gIFx0XHRcdFx0XHRzdHlsZXNbcF0gPSBjb21wdXRlZFtwXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdFx0X3NldERlZmF1bHRzKHN0eWxlcywgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSkpO1xuICBcdFx0XHRyZXR1cm4gc3R5bGVzO1xuICBcdFx0fSxcbiAgXHRcdHN0YXJ0Q2xhc3NMaXN0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLFxuICBcdFx0c3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gIFx0XHRjc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCxcbiAgXHRcdGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICBcdFx0Y2xhc3NQVCA9IGNhY2hlLmNsYXNzUFQsXG4gIFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kID0ge30sXG4gIFx0XHRkYXRhID0ge3Q6dGFyZ2V0LCBwbHVnaW46cGx1Z2luLCBybXY6aW5saW5lVG9SZW1vdmVBdEVuZCwgYjpzdGFydENsYXNzTGlzdCwgZTooZW5kVmFsdWUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlbmRWYWx1ZSA6IHN0YXJ0Q2xhc3NMaXN0LnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGVuZFZhbHVlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgOiBcIlwiKX0sXG4gIFx0XHRjaGFuZ2luZ1ZhcnMgPSB7fSxcbiAgXHRcdHN0YXJ0VmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0KSxcbiAgXHRcdHRyYW5zZm9ybVJlbGF0ZWQgPSAvKHRyYW5zZm9ybXxwZXJzcGVjdGl2ZSkvaSxcbiAgXHRcdGVuZFZhcnMsIHA7XG4gIFx0aWYgKGNsYXNzUFQpIHtcbiAgXHRcdGNsYXNzUFQucigxLCBjbGFzc1BULmQpO1xuICBcdFx0X3JlbW92ZUxpbmtlZExpc3RJdGVtKGNsYXNzUFQuZC5wbHVnaW4sIGNsYXNzUFQsIFwiX3B0XCIpO1xuICBcdH1cbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGF0YS5lKTtcbiAgXHRlbmRWYXJzID0gX2dldEFsbFN0eWxlcyh0YXJnZXQsIHRydWUpO1xuICBcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBzdGFydENsYXNzTGlzdCk7XG4gIFx0Zm9yIChwIGluIGVuZFZhcnMpIHtcbiAgXHRcdGlmIChlbmRWYXJzW3BdICE9PSBzdGFydFZhcnNbcF0gJiYgIXRyYW5zZm9ybVJlbGF0ZWQudGVzdChwKSkge1xuICBcdFx0XHRjaGFuZ2luZ1ZhcnNbcF0gPSBlbmRWYXJzW3BdO1xuICBcdFx0XHRpZiAoIXN0eWxlW3BdICYmIHN0eWxlW3BdICE9PSBcIjBcIikge1xuICBcdFx0XHRcdGlubGluZVRvUmVtb3ZlQXRFbmRbcF0gPSAxO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICBcdGNhY2hlLmNsYXNzUFQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIFwiY2xhc3NOYW1lXCIsIDAsIDAsIF9yZW5kZXJDbGFzc05hbWUsIGRhdGEsIDAsIC0xMSk7XG4gIFx0aWYgKHN0eWxlLmNzc1RleHQgIT09IGNzc1RleHQpIHsgLy9vbmx5IGFwcGx5IGlmIHRoaW5ncyBjaGFuZ2UuIE90aGVyd2lzZSwgaW4gY2FzZXMgbGlrZSBhIGJhY2tncm91bmQtaW1hZ2UgdGhhdCdzIHB1bGxlZCBkeW5hbWljYWxseSwgaXQgY291bGQgY2F1c2UgYSByZWZyZXNoLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDM2OC1wb3NzaWJsZS1nc2FwLWJ1Zy1zd2l0Y2hpbmctY2xhc3NuYW1lcy1pbi1jaHJvbWUvLlxuICBcdFx0c3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7IC8vd2UgcmVjb3JkZWQgY3NzVGV4dCBiZWZvcmUgd2Ugc3dhcHBlZCBjbGFzc2VzIGFuZCByYW4gX2dldEFsbFN0eWxlcygpIGJlY2F1c2UgaW4gY2FzZXMgd2hlbiBhIGNsYXNzTmFtZSB0d2VlbiBpcyBvdmVyd3JpdHRlbiwgd2UgcmVtb3ZlIGFsbCB0aGUgcmVsYXRlZCB0d2VlbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhhdCBjbGFzcyBjaGFuZ2UgKG90aGVyd2lzZSBjbGFzcy1zcGVjaWZpYyBzdHVmZiBjYW4ndCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdlJ3ZlIGRpcmVjdGx5IHNldCBvbiB0aGUgdGFyZ2V0J3Mgc3R5bGUgb2JqZWN0IGR1ZSB0byBzcGVjaWZpY2l0eSkuXG4gIFx0fVxuICBcdF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHRydWUpOyAvL3RvIGNsZWFyIHRoZSBjYWNoaW5nIG9mIHRyYW5zZm9ybXNcbiAgXHRkYXRhLmNzcyA9IG5ldyBnc2FwLnBsdWdpbnMuY3NzKCk7XG4gIFx0ZGF0YS5jc3MuaW5pdCh0YXJnZXQsIGNoYW5naW5nVmFycywgdHdlZW4pO1xuICBcdHBsdWdpbi5fcHJvcHMucHVzaCguLi5kYXRhLmNzcy5fcHJvcHMpO1xuICBcdHJldHVybiAxO1xuICB9XG4gICovXG5cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFJBTlNGT1JNU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX2lkZW50aXR5MkRNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF0sXG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzID0ge30sXG4gICAgX2lzTnVsbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9pc051bGxUcmFuc2Zvcm0odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiIHx8IHZhbHVlID09PSBcIm5vbmVcIiB8fCAhdmFsdWU7XG59LFxuICAgIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCkge1xuICB2YXIgbWF0cml4U3RyaW5nID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgcmV0dXJuIF9pc051bGxUcmFuc2Zvcm0obWF0cml4U3RyaW5nKSA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4U3RyaW5nLnN1YnN0cig3KS5tYXRjaChfbnVtRXhwKS5tYXAoX3JvdW5kKTtcbn0sXG4gICAgX2dldE1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRNYXRyaXgodGFyZ2V0LCBmb3JjZTJEKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpLFxuICAgICAgcGFyZW50LFxuICAgICAgbmV4dFNpYmxpbmcsXG4gICAgICB0ZW1wLFxuICAgICAgYWRkZWRUb0RPTTtcblxuICBpZiAoY2FjaGUuc3ZnICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICB0ZW1wID0gdGFyZ2V0LnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4OyAvL2Vuc3VyZXMgdGhhdCBldmVuIGNvbXBsZXggdmFsdWVzIGxpa2UgXCJ0cmFuc2xhdGUoNTAsNjApIHJvdGF0ZSgxMzUsMCwwKVwiIGFyZSBwYXJzZWQgYmVjYXVzZSBpdCBtYXNoZXMgaXQgaW50byBhIG1hdHJpeC5cblxuICAgIG1hdHJpeCA9IFt0ZW1wLmEsIHRlbXAuYiwgdGVtcC5jLCB0ZW1wLmQsIHRlbXAuZSwgdGVtcC5mXTtcbiAgICByZXR1cm4gbWF0cml4LmpvaW4oXCIsXCIpID09PSBcIjEsMCwwLDEsMCwwXCIgPyBfaWRlbnRpdHkyRE1hdHJpeCA6IG1hdHJpeDtcbiAgfSBlbHNlIGlmIChtYXRyaXggPT09IF9pZGVudGl0eTJETWF0cml4ICYmICF0YXJnZXQub2Zmc2V0UGFyZW50ICYmIHRhcmdldCAhPT0gX2RvY0VsZW1lbnQgJiYgIWNhY2hlLnN2Zykge1xuICAgIC8vbm90ZTogaWYgb2Zmc2V0UGFyZW50IGlzIG51bGwsIHRoYXQgbWVhbnMgdGhlIGVsZW1lbnQgaXNuJ3QgaW4gdGhlIG5vcm1hbCBkb2N1bWVudCBmbG93LCBsaWtlIGlmIGl0IGhhcyBkaXNwbGF5Om5vbmUgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGRpc3BsYXk6bm9uZSkuIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDb21wdXRlZFN0eWxlKCkgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYW4gaWZyYW1lIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gICAgLy9icm93c2VycyBkb24ndCByZXBvcnQgdHJhbnNmb3JtcyBhY2N1cmF0ZWx5IHVubGVzcyB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGFuZCBoYXMgYSBkaXNwbGF5IHZhbHVlIHRoYXQncyBub3QgXCJub25lXCIuIEZpcmVmb3ggYW5kIE1pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgcGFydGlhbCBidWcgd2hlcmUgdGhleSdsbCByZXBvcnQgdHJhbnNmb3JtcyBldmVuIGlmIGRpc3BsYXk6bm9uZSBCVVQgbm90IGFueSBwZXJjZW50YWdlLWJhc2VkIHZhbHVlcyBsaWtlIHRyYW5zbGF0ZSgtNTAlLCA4cHgpIHdpbGwgYmUgcmVwb3J0ZWQgYXMgaWYgaXQncyB0cmFuc2xhdGUoMCwgOHB4KS5cbiAgICB0ZW1wID0gc3R5bGUuZGlzcGxheTtcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXRhcmdldC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIGFkZGVkVG9ET00gPSAxOyAvL2ZsYWdcblxuICAgICAgbmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dFNpYmxpbmc7XG5cbiAgICAgIF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKHRhcmdldCk7IC8vd2UgbXVzdCBhZGQgaXQgdG8gdGhlIERPTSBpbiBvcmRlciB0byBnZXQgdmFsdWVzIHByb3Blcmx5XG5cbiAgICB9XG5cbiAgICBtYXRyaXggPSBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCk7XG5cbiAgICBpZiAodGVtcCkge1xuICAgICAgc3R5bGUuZGlzcGxheSA9IHRlbXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwiZGlzcGxheVwiKTtcbiAgICB9XG5cbiAgICBpZiAoYWRkZWRUb0RPTSkge1xuICAgICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZyk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcbn0sXG4gICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBtYXRyaXggPSBtYXRyaXhBcnJheSB8fCBfZ2V0TWF0cml4KHRhcmdldCwgdHJ1ZSksXG4gICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuICAgICAgeU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcbiAgICAgIHhPZmZzZXRPbGQgPSBjYWNoZS54T2Zmc2V0IHx8IDAsXG4gICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuICAgICAgYSA9IG1hdHJpeFswXSxcbiAgICAgIGIgPSBtYXRyaXhbMV0sXG4gICAgICBjID0gbWF0cml4WzJdLFxuICAgICAgZCA9IG1hdHJpeFszXSxcbiAgICAgIHR4ID0gbWF0cml4WzRdLFxuICAgICAgdHkgPSBtYXRyaXhbNV0sXG4gICAgICBvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG4gICAgICB4T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFswXSkgfHwgMCxcbiAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuICAgICAgYm91bmRzLFxuICAgICAgZGV0ZXJtaW5hbnQsXG4gICAgICB4LFxuICAgICAgeTtcblxuICBpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveCh0YXJnZXQpO1xuICAgIHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG4gICAgeU9yaWdpbiA9IGJvdW5kcy55ICsgKH4ob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpID8geU9yaWdpbiAvIDEwMCAqIGJvdW5kcy5oZWlnaHQgOiB5T3JpZ2luKTtcbiAgfSBlbHNlIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4ICYmIChkZXRlcm1pbmFudCA9IGEgKiBkIC0gYiAqIGMpKSB7XG4gICAgLy9pZiBpdCdzIHplcm8gKGxpa2UgaWYgc2NhbGVYIGFuZCBzY2FsZVkgYXJlIHplcm8pLCBza2lwIGl0IHRvIGF2b2lkIGVycm9ycyB3aXRoIGRpdmlkaW5nIGJ5IHplcm8uXG4gICAgeCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldGVybWluYW50O1xuICAgIHkgPSB4T3JpZ2luICogKC1iIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqIChhIC8gZGV0ZXJtaW5hbnQpIC0gKGEgKiB0eSAtIGIgKiB0eCkgLyBkZXRlcm1pbmFudDtcbiAgICB4T3JpZ2luID0geDtcbiAgICB5T3JpZ2luID0geTtcbiAgfVxuXG4gIGlmIChzbW9vdGggfHwgc21vb3RoICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGgpIHtcbiAgICB0eCA9IHhPcmlnaW4gLSB4T3JpZ2luT2xkO1xuICAgIHR5ID0geU9yaWdpbiAtIHlPcmlnaW5PbGQ7XG4gICAgY2FjaGUueE9mZnNldCA9IHhPZmZzZXRPbGQgKyAodHggKiBhICsgdHkgKiBjKSAtIHR4O1xuICAgIGNhY2hlLnlPZmZzZXQgPSB5T2Zmc2V0T2xkICsgKHR4ICogYiArIHR5ICogZCkgLSB0eTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIH1cblxuICBjYWNoZS54T3JpZ2luID0geE9yaWdpbjtcbiAgY2FjaGUueU9yaWdpbiA9IHlPcmlnaW47XG4gIGNhY2hlLnNtb290aCA9ICEhc21vb3RoO1xuICBjYWNoZS5vcmlnaW4gPSBvcmlnaW47XG4gIGNhY2hlLm9yaWdpbklzQWJzb2x1dGUgPSAhIW9yaWdpbklzQWJzb2x1dGU7XG4gIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBcIjBweCAwcHhcIjsgLy9vdGhlcndpc2UsIGlmIHNvbWVvbmUgc2V0cyAgYW4gb3JpZ2luIHZpYSBDU1MsIGl0IHdpbGwgbGlrZWx5IGludGVyZmVyZSB3aXRoIHRoZSBTVkcgdHJhbnNmb3JtIGF0dHJpYnV0ZSBvbmVzIChiZWNhdXNlIHJlbWVtYmVyLCB3ZSdyZSBiYWtpbmcgdGhlIG9yaWdpbiBpbnRvIHRoZSBtYXRyaXgoKSB2YWx1ZSkuXG5cbiAgaWYgKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvKSB7XG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInhPcmlnaW5cIiwgeE9yaWdpbk9sZCwgeE9yaWdpbik7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9yaWdpblwiLCB5T3JpZ2luT2xkLCB5T3JpZ2luKTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T2Zmc2V0XCIsIHhPZmZzZXRPbGQsIGNhY2hlLnhPZmZzZXQpO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPZmZzZXRcIiwgeU9mZnNldE9sZCwgY2FjaGUueU9mZnNldCk7XG4gIH1cblxuICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHhPcmlnaW4gKyBcIiBcIiArIHlPcmlnaW4pO1xufSxcbiAgICBfcGFyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBuZXcgR1NDYWNoZSh0YXJnZXQpO1xuXG4gIGlmIChcInhcIiBpbiBjYWNoZSAmJiAhdW5jYWNoZSAmJiAhY2FjaGUudW5jYWNoZSkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGludmVydGVkU2NhbGVYID0gY2FjaGUuc2NhbGVYIDwgMCxcbiAgICAgIHB4ID0gXCJweFwiLFxuICAgICAgZGVnID0gXCJkZWdcIixcbiAgICAgIG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgcm90YXRpb24sXG4gICAgICByb3RhdGlvblgsXG4gICAgICByb3RhdGlvblksXG4gICAgICBza2V3WCxcbiAgICAgIHNrZXdZLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICB4T3JpZ2luLFxuICAgICAgeU9yaWdpbixcbiAgICAgIG1hdHJpeCxcbiAgICAgIGFuZ2xlLFxuICAgICAgY29zLFxuICAgICAgc2luLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICB0MyxcbiAgICAgIGExMyxcbiAgICAgIGEyMyxcbiAgICAgIGEzMyxcbiAgICAgIGE0MixcbiAgICAgIGE0MyxcbiAgICAgIGEzMjtcbiAgeCA9IHkgPSB6ID0gcm90YXRpb24gPSByb3RhdGlvblggPSByb3RhdGlvblkgPSBza2V3WCA9IHNrZXdZID0gcGVyc3BlY3RpdmUgPSAwO1xuICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICBjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcbiAgbWF0cml4ID0gX2dldE1hdHJpeCh0YXJnZXQsIGNhY2hlLnN2Zyk7XG5cbiAgaWYgKGNhY2hlLnN2Zykge1xuICAgIHQxID0gIWNhY2hlLnVuY2FjaGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTtcblxuICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIHQxIHx8IG9yaWdpbiwgISF0MSB8fCBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlLCBjYWNoZS5zbW9vdGggIT09IGZhbHNlLCBtYXRyaXgpO1xuICB9XG5cbiAgeE9yaWdpbiA9IGNhY2hlLnhPcmlnaW4gfHwgMDtcbiAgeU9yaWdpbiA9IGNhY2hlLnlPcmlnaW4gfHwgMDtcblxuICBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkge1xuICAgIGEgPSBtYXRyaXhbMF07IC8vYTExXG5cbiAgICBiID0gbWF0cml4WzFdOyAvL2EyMVxuXG4gICAgYyA9IG1hdHJpeFsyXTsgLy9hMzFcblxuICAgIGQgPSBtYXRyaXhbM107IC8vYTQxXG5cbiAgICB4ID0gYTEyID0gbWF0cml4WzRdO1xuICAgIHkgPSBhMjIgPSBtYXRyaXhbNV07IC8vMkQgbWF0cml4XG5cbiAgICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgc2NhbGVZID0gTWF0aC5zcXJ0KGQgKiBkICsgYyAqIGMpO1xuICAgICAgcm90YXRpb24gPSBhIHx8IGIgPyBfYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXG5cbiAgICAgIHNrZXdYID0gYyB8fCBkID8gX2F0YW4yKGMsIGQpICogX1JBRDJERUcgKyByb3RhdGlvbiA6IDA7XG4gICAgICBza2V3WCAmJiAoc2NhbGVZICo9IE1hdGguY29zKHNrZXdYICogX0RFRzJSQUQpKTtcblxuICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICB4IC09IHhPcmlnaW4gLSAoeE9yaWdpbiAqIGEgKyB5T3JpZ2luICogYyk7XG4gICAgICAgIHkgLT0geU9yaWdpbiAtICh4T3JpZ2luICogYiArIHlPcmlnaW4gKiBkKTtcbiAgICAgIH0gLy8zRCBtYXRyaXhcblxuICAgIH0gZWxzZSB7XG4gICAgICBhMzIgPSBtYXRyaXhbNl07XG4gICAgICBhNDIgPSBtYXRyaXhbN107XG4gICAgICBhMTMgPSBtYXRyaXhbOF07XG4gICAgICBhMjMgPSBtYXRyaXhbOV07XG4gICAgICBhMzMgPSBtYXRyaXhbMTBdO1xuICAgICAgYTQzID0gbWF0cml4WzExXTtcbiAgICAgIHggPSBtYXRyaXhbMTJdO1xuICAgICAgeSA9IG1hdHJpeFsxM107XG4gICAgICB6ID0gbWF0cml4WzE0XTtcbiAgICAgIGFuZ2xlID0gX2F0YW4yKGEzMiwgYTMzKTtcbiAgICAgIHJvdGF0aW9uWCA9IGFuZ2xlICogX1JBRDJERUc7IC8vcm90YXRpb25YXG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICB0MSA9IGExMiAqIGNvcyArIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBhMjIgKiBjb3MgKyBhMjMgKiBzaW47XG4gICAgICAgIHQzID0gYTMyICogY29zICsgYTMzICogc2luO1xuICAgICAgICBhMTMgPSBhMTIgKiAtc2luICsgYTEzICogY29zO1xuICAgICAgICBhMjMgPSBhMjIgKiAtc2luICsgYTIzICogY29zO1xuICAgICAgICBhMzMgPSBhMzIgKiAtc2luICsgYTMzICogY29zO1xuICAgICAgICBhNDMgPSBhNDIgKiAtc2luICsgYTQzICogY29zO1xuICAgICAgICBhMTIgPSB0MTtcbiAgICAgICAgYTIyID0gdDI7XG4gICAgICAgIGEzMiA9IHQzO1xuICAgICAgfSAvL3JvdGF0aW9uWVxuXG5cbiAgICAgIGFuZ2xlID0gX2F0YW4yKC1jLCBhMzMpO1xuICAgICAgcm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgICAgIHQxID0gYSAqIGNvcyAtIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBiICogY29zIC0gYTIzICogc2luO1xuICAgICAgICB0MyA9IGMgKiBjb3MgLSBhMzMgKiBzaW47XG4gICAgICAgIGE0MyA9IGQgKiBzaW4gKyBhNDMgKiBjb3M7XG4gICAgICAgIGEgPSB0MTtcbiAgICAgICAgYiA9IHQyO1xuICAgICAgICBjID0gdDM7XG4gICAgICB9IC8vcm90YXRpb25aXG5cblxuICAgICAgYW5nbGUgPSBfYXRhbjIoYiwgYSk7XG4gICAgICByb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdDEgPSBhICogY29zICsgYiAqIHNpbjtcbiAgICAgICAgdDIgPSBhMTIgKiBjb3MgKyBhMjIgKiBzaW47XG4gICAgICAgIGIgPSBiICogY29zIC0gYSAqIHNpbjtcbiAgICAgICAgYTIyID0gYTIyICogY29zIC0gYTEyICogc2luO1xuICAgICAgICBhID0gdDE7XG4gICAgICAgIGExMiA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAocm90YXRpb25YICYmIE1hdGguYWJzKHJvdGF0aW9uWCkgKyBNYXRoLmFicyhyb3RhdGlvbikgPiAzNTkuOSkge1xuICAgICAgICAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cbiAgICAgICAgcm90YXRpb25YID0gcm90YXRpb24gPSAwO1xuICAgICAgICByb3RhdGlvblkgPSAxODAgLSByb3RhdGlvblk7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlWCA9IF9yb3VuZChNYXRoLnNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSk7XG4gICAgICBzY2FsZVkgPSBfcm91bmQoTWF0aC5zcXJ0KGEyMiAqIGEyMiArIGEzMiAqIGEzMikpO1xuICAgICAgYW5nbGUgPSBfYXRhbjIoYTEyLCBhMjIpO1xuICAgICAgc2tld1ggPSBNYXRoLmFicyhhbmdsZSkgPiAwLjAwMDIgPyBhbmdsZSAqIF9SQUQyREVHIDogMDtcbiAgICAgIHBlcnNwZWN0aXZlID0gYTQzID8gMSAvIChhNDMgPCAwID8gLWE0MyA6IGE0MykgOiAwO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgIC8vc2Vuc2UgaWYgdGhlcmUgYXJlIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQgb24gYW4gU1ZHIGVsZW1lbnQgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHdoZW4gcmVuZGVyaW5nLiBUaGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBpcyBtb3JlIHJlbGlhYmxlIGNyb3NzLWJyb3dzZXIsIGJ1dCB3ZSBjYW4ndCBqdXN0IHJlbW92ZSB0aGUgQ1NTIG9uZXMgYmVjYXVzZSB0aGV5IG1heSBiZSBhcHBsaWVkIGluIGEgQ1NTIHJ1bGUgc29tZXdoZXJlIChub3QganVzdCBpbmxpbmUpLlxuICAgICAgbWF0cml4ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgIGNhY2hlLmZvcmNlQ1NTID0gdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcIlwiKSB8fCAhX2lzTnVsbFRyYW5zZm9ybShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKSk7XG4gICAgICBtYXRyaXggJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBtYXRyaXgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcbiAgICBpZiAoaW52ZXJ0ZWRTY2FsZVgpIHtcbiAgICAgIHNjYWxlWCAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHJvdGF0aW9uIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgICAgcm90YXRpb24gKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlWSAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHNrZXdYIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlLnggPSAoKGNhY2hlLnhQZXJjZW50ID0geCAmJiBNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRXaWR0aCAvIDIpID09PSBNYXRoLnJvdW5kKC14KSA/IC01MCA6IDApID8gMCA6IHgpICsgcHg7XG4gIGNhY2hlLnkgPSAoKGNhY2hlLnlQZXJjZW50ID0geSAmJiBNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRIZWlnaHQgLyAyKSA9PT0gTWF0aC5yb3VuZCgteSkgPyAtNTAgOiAwKSA/IDAgOiB5KSArIHB4O1xuICBjYWNoZS56ID0geiArIHB4O1xuICBjYWNoZS5zY2FsZVggPSBfcm91bmQoc2NhbGVYKTtcbiAgY2FjaGUuc2NhbGVZID0gX3JvdW5kKHNjYWxlWSk7XG4gIGNhY2hlLnJvdGF0aW9uID0gX3JvdW5kKHJvdGF0aW9uKSArIGRlZztcbiAgY2FjaGUucm90YXRpb25YID0gX3JvdW5kKHJvdGF0aW9uWCkgKyBkZWc7XG4gIGNhY2hlLnJvdGF0aW9uWSA9IF9yb3VuZChyb3RhdGlvblkpICsgZGVnO1xuICBjYWNoZS5za2V3WCA9IHNrZXdYICsgZGVnO1xuICBjYWNoZS5za2V3WSA9IHNrZXdZICsgZGVnO1xuICBjYWNoZS50cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlICsgcHg7XG5cbiAgaWYgKGNhY2hlLnpPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpbi5zcGxpdChcIiBcIilbMl0pIHx8IDApIHtcbiAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBfZmlyc3RUd29Pbmx5KG9yaWdpbik7XG4gIH1cblxuICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIGNhY2hlLmZvcmNlM0QgPSBfY29uZmlnLmZvcmNlM0Q7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybSA9IGNhY2hlLnN2ZyA/IF9yZW5kZXJTVkdUcmFuc2Zvcm1zIDogX3N1cHBvcnRzM0QgPyBfcmVuZGVyQ1NTVHJhbnNmb3JtcyA6IF9yZW5kZXJOb24zRFRyYW5zZm9ybXM7XG4gIGNhY2hlLnVuY2FjaGUgPSAwO1xuICByZXR1cm4gY2FjaGU7XG59LFxuICAgIF9maXJzdFR3b09ubHkgPSBmdW5jdGlvbiBfZmlyc3RUd29Pbmx5KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgPSB2YWx1ZS5zcGxpdChcIiBcIikpWzBdICsgXCIgXCIgKyB2YWx1ZVsxXTtcbn0sXG4gICAgLy9mb3IgaGFuZGxpbmcgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcywgc3RyaXBwaW5nIG91dCB0aGUgM3JkIGRpbWVuc2lvblxuX2FkZFB4VHJhbnNsYXRlID0gZnVuY3Rpb24gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgc3RhcnQsIHZhbHVlKSB7XG4gIHZhciB1bml0ID0gZ2V0VW5pdChzdGFydCk7XG4gIHJldHVybiBfcm91bmQocGFyc2VGbG9hdChzdGFydCkgKyBwYXJzZUZsb2F0KF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHZhbHVlICsgXCJweFwiLCB1bml0KSkpICsgdW5pdDtcbn0sXG4gICAgX3JlbmRlck5vbjNEVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIGNhY2hlLnogPSBcIjBweFwiO1xuICBjYWNoZS5yb3RhdGlvblkgPSBjYWNoZS5yb3RhdGlvblggPSBcIjBkZWdcIjtcbiAgY2FjaGUuZm9yY2UzRCA9IDA7XG5cbiAgX3JlbmRlckNTU1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3plcm9EZWcgPSBcIjBkZWdcIixcbiAgICBfemVyb1B4ID0gXCIwcHhcIixcbiAgICBfZW5kUGFyZW50aGVzaXMgPSBcIikgXCIsXG4gICAgX3JlbmRlckNTU1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYgPSBjYWNoZSB8fCB0aGlzLFxuICAgICAgeFBlcmNlbnQgPSBfcmVmLnhQZXJjZW50LFxuICAgICAgeVBlcmNlbnQgPSBfcmVmLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB6ID0gX3JlZi56LFxuICAgICAgcm90YXRpb24gPSBfcmVmLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25ZID0gX3JlZi5yb3RhdGlvblksXG4gICAgICByb3RhdGlvblggPSBfcmVmLnJvdGF0aW9uWCxcbiAgICAgIHNrZXdYID0gX3JlZi5za2V3WCxcbiAgICAgIHNrZXdZID0gX3JlZi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZi5zY2FsZVksXG4gICAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IF9yZWYudHJhbnNmb3JtUGVyc3BlY3RpdmUsXG4gICAgICBmb3JjZTNEID0gX3JlZi5mb3JjZTNELFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB6T3JpZ2luID0gX3JlZi56T3JpZ2luLFxuICAgICAgdHJhbnNmb3JtcyA9IFwiXCIsXG4gICAgICB1c2UzRCA9IGZvcmNlM0QgPT09IFwiYXV0b1wiICYmIHJhdGlvICYmIHJhdGlvICE9PSAxIHx8IGZvcmNlM0QgPT09IHRydWU7IC8vIFNhZmFyaSBoYXMgYSBidWcgdGhhdCBjYXVzZXMgaXQgbm90IHRvIHJlbmRlciAzRCB0cmFuc2Zvcm0tb3JpZ2luIHZhbHVlcyBwcm9wZXJseSwgc28gd2UgZm9yY2UgdGhlIHogb3JpZ2luIHRvIDAsIHJlY29yZCBpdCBpbiB0aGUgY2FjaGUsIGFuZCB0aGVuIGRvIHRoZSBtYXRoIGhlcmUgdG8gb2Zmc2V0IHRoZSB0cmFuc2xhdGUgdmFsdWVzIGFjY29yZGluZ2x5IChiYXNpY2FsbHkgZG8gdGhlIDNEIHRyYW5zZm9ybS1vcmlnaW4gcGFydCBtYW51YWxseSlcblxuXG4gIGlmICh6T3JpZ2luICYmIChyb3RhdGlvblggIT09IF96ZXJvRGVnIHx8IHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpKSB7XG4gICAgdmFyIGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblkpICogX0RFRzJSQUQsXG4gICAgICAgIGExMyA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgYTMzID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBjb3M7XG5cbiAgICBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25YKSAqIF9ERUcyUkFEO1xuICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB4ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeCwgYTEzICogY29zICogLXpPcmlnaW4pO1xuICAgIHkgPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB5LCAtTWF0aC5zaW4oYW5nbGUpICogLXpPcmlnaW4pO1xuICAgIHogPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB6LCBhMzMgKiBjb3MgKiAtek9yaWdpbiArIHpPcmlnaW4pO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybVBlcnNwZWN0aXZlICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwidHJhbnNsYXRlKFwiICsgeFBlcmNlbnQgKyBcIiUsIFwiICsgeVBlcmNlbnQgKyBcIiUpIFwiO1xuICB9XG5cbiAgaWYgKHVzZTNEIHx8IHggIT09IF96ZXJvUHggfHwgeSAhPT0gX3plcm9QeCB8fCB6ICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSB6ICE9PSBfemVyb1B4IHx8IHVzZTNEID8gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIsIFwiICsgeiArIFwiKSBcIiA6IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb24gIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWShcIiArIHJvdGF0aW9uWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvblggIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVgoXCIgKyByb3RhdGlvblggKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoc2tld1ggIT09IF96ZXJvRGVnIHx8IHNrZXdZICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJza2V3KFwiICsgc2tld1ggKyBcIiwgXCIgKyBza2V3WSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsIFwiICsgc2NhbGVZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXMgfHwgXCJ0cmFuc2xhdGUoMCwgMClcIjtcbn0sXG4gICAgX3JlbmRlclNWR1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyU1ZHVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYyID0gY2FjaGUgfHwgdGhpcyxcbiAgICAgIHhQZXJjZW50ID0gX3JlZjIueFBlcmNlbnQsXG4gICAgICB5UGVyY2VudCA9IF9yZWYyLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYyLngsXG4gICAgICB5ID0gX3JlZjIueSxcbiAgICAgIHJvdGF0aW9uID0gX3JlZjIucm90YXRpb24sXG4gICAgICBza2V3WCA9IF9yZWYyLnNrZXdYLFxuICAgICAgc2tld1kgPSBfcmVmMi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYyLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWSxcbiAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHhPcmlnaW4gPSBfcmVmMi54T3JpZ2luLFxuICAgICAgeU9yaWdpbiA9IF9yZWYyLnlPcmlnaW4sXG4gICAgICB4T2Zmc2V0ID0gX3JlZjIueE9mZnNldCxcbiAgICAgIHlPZmZzZXQgPSBfcmVmMi55T2Zmc2V0LFxuICAgICAgZm9yY2VDU1MgPSBfcmVmMi5mb3JjZUNTUyxcbiAgICAgIHR4ID0gcGFyc2VGbG9hdCh4KSxcbiAgICAgIHR5ID0gcGFyc2VGbG9hdCh5KSxcbiAgICAgIGExMSxcbiAgICAgIGEyMSxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHRlbXA7XG5cbiAgcm90YXRpb24gPSBwYXJzZUZsb2F0KHJvdGF0aW9uKTtcbiAgc2tld1ggPSBwYXJzZUZsb2F0KHNrZXdYKTtcbiAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcblxuICBpZiAoc2tld1kpIHtcbiAgICAvL2ZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAxMCBkZWdyZWVzLlxuICAgIHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG4gICAgc2tld1ggKz0gc2tld1k7XG4gICAgcm90YXRpb24gKz0gc2tld1k7XG4gIH1cblxuICBpZiAocm90YXRpb24gfHwgc2tld1gpIHtcbiAgICByb3RhdGlvbiAqPSBfREVHMlJBRDtcbiAgICBza2V3WCAqPSBfREVHMlJBRDtcbiAgICBhMTEgPSBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVg7XG4gICAgYTIxID0gTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYO1xuICAgIGExMiA9IE1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogLXNjYWxlWTtcbiAgICBhMjIgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcblxuICAgIGlmIChza2V3WCkge1xuICAgICAgc2tld1kgKj0gX0RFRzJSQUQ7XG4gICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1ggLSBza2V3WSk7XG4gICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICBhMTIgKj0gdGVtcDtcbiAgICAgIGEyMiAqPSB0ZW1wO1xuXG4gICAgICBpZiAoc2tld1kpIHtcbiAgICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdZKTtcbiAgICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuICAgICAgICBhMTEgKj0gdGVtcDtcbiAgICAgICAgYTIxICo9IHRlbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYTExID0gX3JvdW5kKGExMSk7XG4gICAgYTIxID0gX3JvdW5kKGEyMSk7XG4gICAgYTEyID0gX3JvdW5kKGExMik7XG4gICAgYTIyID0gX3JvdW5kKGEyMik7XG4gIH0gZWxzZSB7XG4gICAgYTExID0gc2NhbGVYO1xuICAgIGEyMiA9IHNjYWxlWTtcbiAgICBhMjEgPSBhMTIgPSAwO1xuICB9XG5cbiAgaWYgKHR4ICYmICF+KHggKyBcIlwiKS5pbmRleE9mKFwicHhcIikgfHwgdHkgJiYgIX4oeSArIFwiXCIpLmluZGV4T2YoXCJweFwiKSkge1xuICAgIHR4ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgeCwgXCJweFwiKTtcbiAgICB0eSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ5XCIsIHksIFwicHhcIik7XG4gIH1cblxuICBpZiAoeE9yaWdpbiB8fCB5T3JpZ2luIHx8IHhPZmZzZXQgfHwgeU9mZnNldCkge1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlPcmlnaW4gLSAoeE9yaWdpbiAqIGEyMSArIHlPcmlnaW4gKiBhMjIpICsgeU9mZnNldCk7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICAvL1RoZSBTVkcgc3BlYyBkb2Vzbid0IHN1cHBvcnQgcGVyY2VudGFnZS1iYXNlZCB0cmFuc2xhdGlvbiBpbiB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHNvIHdlIG1lcmdlIGl0IGludG8gdGhlIHRyYW5zbGF0aW9uIHRvIHNpbXVsYXRlIGl0LlxuICAgIHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeFBlcmNlbnQgLyAxMDAgKiB0ZW1wLndpZHRoKTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlQZXJjZW50IC8gMTAwICogdGVtcC5oZWlnaHQpO1xuICB9XG5cbiAgdGVtcCA9IFwibWF0cml4KFwiICsgYTExICsgXCIsXCIgKyBhMjEgKyBcIixcIiArIGExMiArIFwiLFwiICsgYTIyICsgXCIsXCIgKyB0eCArIFwiLFwiICsgdHkgKyBcIilcIjtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0ZW1wKTtcblxuICBpZiAoZm9yY2VDU1MpIHtcbiAgICAvL3NvbWUgYnJvd3NlcnMgcHJpb3JpdGl6ZSBDU1MgdHJhbnNmb3JtcyBvdmVyIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlLiBXaGVuIHdlIHNlbnNlIHRoYXQgdGhlIHVzZXIgaGFzIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQsIHdlIG11c3Qgb3ZlcndyaXRlIHRoZW0gdGhpcyB3YXkgKG90aGVyd2lzZSBzb21lIGJyb3dzZXIgc2ltcGx5IHdvbid0IHJlbmRlciB0aGUgIHRyYW5zZm9ybSBhdHRyaWJ1dGUgY2hhbmdlcyEpXG4gICAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRlbXA7XG4gIH1cbn0sXG4gICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUm90YXRpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBlbmRWYWx1ZSwgcmVsYXRpdmUpIHtcbiAgdmFyIGNhcCA9IDM2MCxcbiAgICAgIGlzU3RyaW5nID0gX2lzU3RyaW5nKGVuZFZhbHVlKSxcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpICogKGlzU3RyaW5nICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFkXCIpID8gX1JBRDJERUcgOiAxKSxcbiAgICAgIGNoYW5nZSA9IHJlbGF0aXZlID8gZW5kTnVtICogcmVsYXRpdmUgOiBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgIGZpbmFsVmFsdWUgPSBzdGFydE51bSArIGNoYW5nZSArIFwiZGVnXCIsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBwdDtcblxuICBpZiAoaXNTdHJpbmcpIHtcbiAgICBkaXJlY3Rpb24gPSBlbmRWYWx1ZS5zcGxpdChcIl9cIilbMV07XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInNob3J0XCIpIHtcbiAgICAgIGNoYW5nZSAlPSBjYXA7XG5cbiAgICAgIGlmIChjaGFuZ2UgIT09IGNoYW5nZSAlIChjYXAgLyAyKSkge1xuICAgICAgICBjaGFuZ2UgKz0gY2hhbmdlIDwgMCA/IGNhcCA6IC1jYXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJjd1wiICYmIGNoYW5nZSA8IDApIHtcbiAgICAgIGNoYW5nZSA9IChjaGFuZ2UgKyBjYXAgKiBfYmlnTnVtKSAlIGNhcCAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwiY2N3XCIgJiYgY2hhbmdlID4gMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSAtIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9XG4gIH1cblxuICBwbHVnaW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBjaGFuZ2UsIF9yZW5kZXJQcm9wV2l0aEVuZCk7XG4gIHB0LmUgPSBmaW5hbFZhbHVlO1xuICBwdC51ID0gXCJkZWdcIjtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2FkZFJhd1RyYW5zZm9ybVBUcyA9IGZ1bmN0aW9uIF9hZGRSYXdUcmFuc2Zvcm1QVHMocGx1Z2luLCB0cmFuc2Zvcm1zLCB0YXJnZXQpIHtcbiAgLy9mb3IgaGFuZGxpbmcgY2FzZXMgd2hlcmUgc29tZW9uZSBwYXNzZXMgaW4gYSB3aG9sZSB0cmFuc2Zvcm0gc3RyaW5nLCBsaWtlIHRyYW5zZm9ybTogXCJzY2FsZSgyLCAzKSByb3RhdGUoMjBkZWcpIHRyYW5zbGF0ZVkoMzBlbSlcIlxuICB2YXIgc3R5bGUgPSBfdGVtcERpdlN0eWxlci5zdHlsZSxcbiAgICAgIHN0YXJ0Q2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBleGNsdWRlID0gXCJwZXJzcGVjdGl2ZSxmb3JjZTNELHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW5cIixcbiAgICAgIGVuZENhY2hlLFxuICAgICAgcCxcbiAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZSxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgZW5kTnVtLFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVW5pdDtcbiAgc3R5bGUuY3NzVGV4dCA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5jc3NUZXh0ICsgXCI7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jaztcIjsgLy8lLWJhc2VkIHRyYW5zbGF0aW9ucyB3aWxsIGZhaWwgdW5sZXNzIHdlIHNldCB0aGUgd2lkdGgvaGVpZ2h0IHRvIG1hdGNoIHRoZSBvcmlnaW5hbCB0YXJnZXQgKGFuZCBwYWRkaW5nL2JvcmRlcnMgY2FuIGFmZmVjdCBpdClcblxuICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zO1xuXG4gIF9kb2MuYm9keS5hcHBlbmRDaGlsZChfdGVtcERpdlN0eWxlcik7XG5cbiAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0oX3RlbXBEaXZTdHlsZXIsIDEpO1xuXG4gIGZvciAocCBpbiBfdHJhbnNmb3JtUHJvcHMpIHtcbiAgICBzdGFydFZhbHVlID0gc3RhcnRDYWNoZVtwXTtcbiAgICBlbmRWYWx1ZSA9IGVuZENhY2hlW3BdO1xuXG4gICAgaWYgKHN0YXJ0VmFsdWUgIT09IGVuZFZhbHVlICYmIGV4Y2x1ZGUuaW5kZXhPZihwKSA8IDApIHtcbiAgICAgIC8vdHdlZW5pbmcgdG8gbm8gcGVyc3BlY3RpdmUgZ2l2ZXMgdmVyeSB1bmludHVpdGl2ZSByZXN1bHRzIC0ganVzdCBrZWVwIHRoZSBzYW1lIHBlcnNwZWN0aXZlIGluIHRoYXQgY2FzZS5cbiAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSk7XG4gICAgICBzdGFydE51bSA9IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgOiBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCBzdGFydENhY2hlLCBwLCBzdGFydE51bSwgZW5kTnVtIC0gc3RhcnROdW0sIF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgIHBsdWdpbi5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgcGx1Z2luLl9wcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfVxuXG4gIF9kb2MuYm9keS5yZW1vdmVDaGlsZChfdGVtcERpdlN0eWxlcik7XG59OyAvLyBoYW5kbGUgc3BsaXR0aW5nIGFwYXJ0IHBhZGRpbmcsIG1hcmdpbiwgYm9yZGVyV2lkdGgsIGFuZCBib3JkZXJSYWRpdXMgaW50byB0aGVpciA0IGNvbXBvbmVudHMuIEZpcmVmb3gsIGZvciBleGFtcGxlLCB3b24ndCByZXBvcnQgYm9yZGVyUmFkaXVzIGNvcnJlY3RseSAtIGl0IHdpbGwgb25seSBkbyBib3JkZXJUb3BMZWZ0UmFkaXVzIGFuZCB0aGUgb3RoZXIgY29ybmVycy4gV2UgYWxzbyB3YW50IHRvIGhhbmRsZSBwYWRkaW5nVG9wLCBtYXJnaW5MZWZ0LCBib3JkZXJSaWdodFdpZHRoLCBldGMuXG5cblxuX2ZvckVhY2hOYW1lKFwicGFkZGluZyxtYXJnaW4sV2lkdGgsUmFkaXVzXCIsIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICB2YXIgdCA9IFwiVG9wXCIsXG4gICAgICByID0gXCJSaWdodFwiLFxuICAgICAgYiA9IFwiQm90dG9tXCIsXG4gICAgICBsID0gXCJMZWZ0XCIsXG4gICAgICBwcm9wcyA9IChpbmRleCA8IDMgPyBbdCwgciwgYiwgbF0gOiBbdCArIGwsIHQgKyByLCBiICsgciwgYiArIGxdKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gaW5kZXggPCAyID8gbmFtZSArIHNpZGUgOiBcImJvcmRlclwiICsgc2lkZSArIG5hbWU7XG4gIH0pO1xuXG4gIF9zcGVjaWFsUHJvcHNbaW5kZXggPiAxID8gXCJib3JkZXJcIiArIG5hbWUgOiBuYW1lXSA9IGZ1bmN0aW9uIChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBhLCB2YXJzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7XG4gICAgICAvLyBnZXR0ZXIsIHBhc3NlZCB0YXJnZXQsIHByb3BlcnR5LCBhbmQgdW5pdCAoZnJvbSBfZ2V0KCkpXG4gICAgICBhID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBsdWdpbiwgcHJvcCwgcHJvcGVydHkpO1xuICAgICAgfSk7XG4gICAgICB2YXJzID0gYS5qb2luKFwiIFwiKTtcbiAgICAgIHJldHVybiB2YXJzLnNwbGl0KGFbMF0pLmxlbmd0aCA9PT0gNSA/IGFbMF0gOiB2YXJzO1xuICAgIH1cblxuICAgIGEgPSAoZW5kVmFsdWUgKyBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgdmFycyA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgIHJldHVybiB2YXJzW3Byb3BdID0gYVtpXSA9IGFbaV0gfHwgYVsoaSAtIDEpIC8gMiB8IDBdO1xuICAgIH0pO1xuICAgIHBsdWdpbi5pbml0KHRhcmdldCwgdmFycywgdHdlZW4pO1xuICB9O1xufSk7XG5cbmV4cG9ydCB2YXIgQ1NTUGx1Z2luID0ge1xuICBuYW1lOiBcImNzc1wiLFxuICByZWdpc3RlcjogX2luaXRDb3JlLFxuICB0YXJnZXRUZXN0OiBmdW5jdGlvbiB0YXJnZXRUZXN0KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuc3R5bGUgJiYgdGFyZ2V0Lm5vZGVUeXBlO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5fcHJvcHMsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICBlbmRWYWx1ZSxcbiAgICAgICAgZW5kTnVtLFxuICAgICAgICBzdGFydE51bSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3BlY2lhbFByb3AsXG4gICAgICAgIHAsXG4gICAgICAgIHN0YXJ0VW5pdCxcbiAgICAgICAgZW5kVW5pdCxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCxcbiAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgc21vb3RoLFxuICAgICAgICBoYXNQcmlvcml0eTtcblxuICAgIGlmICghX3BsdWdpbkluaXR0ZWQpIHtcbiAgICAgIF9pbml0Q29yZSgpO1xuICAgIH1cblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBpZiAocCA9PT0gXCJhdXRvUm91bmRcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZW5kVmFsdWUgPSB2YXJzW3BdO1xuXG4gICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgX2NoZWNrUGx1Z2luKHAsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSkge1xuICAgICAgICAvL3BsdWdpbnNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICBzcGVjaWFsUHJvcCA9IF9zcGVjaWFsUHJvcHNbcF07XG5cbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW5kVmFsdWUgPSBlbmRWYWx1ZS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBlbmRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICAgIGVuZFZhbHVlID0gX3JlcGxhY2VSYW5kb20oZW5kVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlY2lhbFByb3ApIHtcbiAgICAgICAgaWYgKHNwZWNpYWxQcm9wKHRoaXMsIHRhcmdldCwgcCwgZW5kVmFsdWUsIHR3ZWVuKSkge1xuICAgICAgICAgIGhhc1ByaW9yaXR5ID0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiKSB7XG4gICAgICAgIC8vQ1NTIHZhcmlhYmxlXG4gICAgICAgIHRoaXMuYWRkKHN0eWxlLCBcInNldFByb3BlcnR5XCIsIGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5nZXRQcm9wZXJ0eVZhbHVlKHApICsgXCJcIiwgZW5kVmFsdWUgKyBcIlwiLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApO1xuICAgICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgIHJlbGF0aXZlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiID8gKyhlbmRWYWx1ZS5jaGFyQXQoMCkgKyBcIjFcIikgOiAwO1xuXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHAgaW4gX3Byb3BlcnR5QWxpYXNlcykge1xuICAgICAgICAgIGlmIChwID09PSBcImF1dG9BbHBoYVwiKSB7XG4gICAgICAgICAgICAvL3NwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjb250cm9sIHRoZSB2aXNpYmlsaXR5IGFsb25nIHdpdGggb3BhY2l0eS4gV2Ugc3RpbGwgYWxsb3cgdGhlIG9wYWNpdHkgdmFsdWUgdG8gcGFzcyB0aHJvdWdoIGFuZCBnZXQgdHdlZW5lZC5cbiAgICAgICAgICAgIGlmIChzdGFydE51bSA9PT0gMSAmJiBfZ2V0KHRhcmdldCwgXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiICYmIGVuZE51bSkge1xuICAgICAgICAgICAgICAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuICAgICAgICAgICAgICBzdGFydE51bSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBcInZpc2liaWxpdHlcIiwgc3RhcnROdW0gPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsIGVuZE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgIWVuZE51bSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgIT09IFwic2NhbGVcIiAmJiBwICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBwID0gX3Byb3BlcnR5QWxpYXNlc1twXTtcblxuICAgICAgICAgICAgaWYgKH5wLmluZGV4T2YoXCIsXCIpKSB7XG4gICAgICAgICAgICAgIHAgPSBwLnNwbGl0KFwiLFwiKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQgPSBwIGluIF90cmFuc2Zvcm1Qcm9wczsgLy8tLS0gVFJBTlNGT1JNLVJFTEFURUQgLS0tXG5cbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUmVsYXRlZCkge1xuICAgICAgICAgIGlmICghdHJhbnNmb3JtUHJvcFR3ZWVuKSB7XG4gICAgICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgICAgICAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSB8fCBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0KTsgLy8gaWYsIGZvciBleGFtcGxlLCBnc2FwLnNldCguLi4ge3RyYW5zZm9ybTpcInRyYW5zbGF0ZVgoNTB2dylcIn0pLCB0aGUgX2dldCgpIGNhbGwgZG9lc24ndCBwYXJzZSB0aGUgdHJhbnNmb3JtLCB0aHVzIGNhY2hlLnJlbmRlclRyYW5zZm9ybSB3b24ndCBiZSBzZXQgeWV0IHNvIGZvcmNlIHRoZSBwYXJzaW5nIG9mIHRoZSB0cmFuc2Zvcm0gaGVyZS5cblxuICAgICAgICAgICAgc21vb3RoID0gdmFycy5zbW9vdGhPcmlnaW4gIT09IGZhbHNlICYmIGNhY2hlLnNtb290aDtcbiAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2VlbiA9IHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgc3R5bGUsIF90cmFuc2Zvcm1Qcm9wLCAwLCAxLCBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0sIGNhY2hlLCAwLCAtMSk7IC8vdGhlIGZpcnN0IHRpbWUgdGhyb3VnaCwgY3JlYXRlIHRoZSByZW5kZXJpbmcgUHJvcFR3ZWVuIHNvIHRoYXQgaXQgcnVucyBMQVNUIChpbiB0aGUgbGlua2VkIGxpc3QsIHdlIGtlZXAgYWRkaW5nIHRvIHRoZSBiZWdpbm5pbmcpXG5cbiAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2Vlbi5kZXAgPSAxOyAvL2ZsYWcgaXQgYXMgZGVwZW5kZW50IHNvIHRoYXQgaWYgdGhpbmdzIGdldCBraWxsZWQvb3ZlcndyaXR0ZW4gYW5kIHRoaXMgaXMgdGhlIG9ubHkgUHJvcFR3ZWVuIGxlZnQsIHdlIGNhbiBzYWZlbHkga2lsbCB0aGUgd2hvbGUgdHdlZW4uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgPT09IFwic2NhbGVcIikge1xuICAgICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBjYWNoZSwgXCJzY2FsZVlcIiwgY2FjaGUuc2NhbGVZLCByZWxhdGl2ZSA/IHJlbGF0aXZlICogZW5kTnVtIDogZW5kTnVtIC0gY2FjaGUuc2NhbGVZKTtcbiAgICAgICAgICAgIHByb3BzLnB1c2goXCJzY2FsZVlcIiwgcCk7XG4gICAgICAgICAgICBwICs9IFwiWFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyhlbmRWYWx1ZSk7IC8vaW4gY2FzZSBzb21ldGhpbmcgbGlrZSBcImxlZnQgdG9wXCIgb3IgXCJib3R0b20gcmlnaHRcIiBpcyBwYXNzZWQgaW4uIENvbnZlcnQgdG8gcGVyY2VudGFnZXMuXG5cbiAgICAgICAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgICAgICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgZW5kVmFsdWUsIDAsIHNtb290aCwgMCwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmRVbml0ID0gcGFyc2VGbG9hdChlbmRWYWx1ZS5zcGxpdChcIiBcIilbMl0pIHx8IDA7IC8vaGFuZGxlIHRoZSB6T3JpZ2luIHNlcGFyYXRlbHkhXG5cbiAgICAgICAgICAgICAgaWYgKGVuZFVuaXQgIT09IGNhY2hlLnpPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJ6T3JpZ2luXCIsIGNhY2hlLnpPcmlnaW4sIGVuZFVuaXQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIHAsIF9maXJzdFR3b09ubHkoc3RhcnRWYWx1ZSksIF9maXJzdFR3b09ubHkoZW5kVmFsdWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInN2Z09yaWdpblwiKSB7XG4gICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMSwgc21vb3RoLCAwLCB0aGlzKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwIGluIF9yb3RhdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4odGhpcywgY2FjaGUsIHAsIHN0YXJ0TnVtLCBlbmRWYWx1ZSwgcmVsYXRpdmUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwic21vb3RoT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInNtb290aFwiLCBjYWNoZS5zbW9vdGgsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcImZvcmNlM0RcIikge1xuICAgICAgICAgICAgY2FjaGVbcF0gPSBlbmRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgX2FkZFJhd1RyYW5zZm9ybVBUcyh0aGlzLCBlbmRWYWx1ZSwgdGFyZ2V0KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICBwID0gX2NoZWNrUHJvcFByZWZpeChwKSB8fCBwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUmVsYXRlZCB8fCAoZW5kTnVtIHx8IGVuZE51bSA9PT0gMCkgJiYgKHN0YXJ0TnVtIHx8IHN0YXJ0TnVtID09PSAwKSAmJiAhX2NvbXBsZXhFeHAudGVzdChlbmRWYWx1ZSkgJiYgcCBpbiBzdHlsZSkge1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IChzdGFydFZhbHVlICsgXCJcIikuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgICAgZW5kTnVtIHx8IChlbmROdW0gPSAwKTsgLy8gcHJvdGVjdCBhZ2FpbnN0IE5hTlxuXG4gICAgICAgICAgZW5kVW5pdCA9IChlbmRWYWx1ZSArIFwiXCIpLnN1YnN0cigoZW5kTnVtICsgXCJcIikubGVuZ3RoKSB8fCAocCBpbiBfY29uZmlnLnVuaXRzID8gX2NvbmZpZy51bml0c1twXSA6IHN0YXJ0VW5pdCk7XG5cbiAgICAgICAgICBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSB7XG4gICAgICAgICAgICBzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBpc1RyYW5zZm9ybVJlbGF0ZWQgPyBjYWNoZSA6IHN0eWxlLCBwLCBzdGFydE51bSwgcmVsYXRpdmUgPyByZWxhdGl2ZSAqIGVuZE51bSA6IGVuZE51bSAtIHN0YXJ0TnVtLCBlbmRVbml0ID09PSBcInB4XCIgJiYgdmFycy5hdXRvUm91bmQgIT09IGZhbHNlICYmICFpc1RyYW5zZm9ybVJlbGF0ZWQgPyBfcmVuZGVyUm91bmRlZENTU1Byb3AgOiBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICAgICAgdGhpcy5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQpIHtcbiAgICAgICAgICAgIC8vd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIHdlIG5lZWQgdG8gcmV2ZXJ0IGl0IHRvIHRoZSBPTEQvT1JJR0lOQUwgdmFsdWUgKHdpdGggdGhvc2UgdW5pdHMpLiBXZSByZWNvcmQgdGhhdCBhcyBhIFwiYlwiIChiZWdpbm5pbmcpIHByb3BlcnR5IGFuZCBwb2ludCB0byBhIHJlbmRlciBtZXRob2QgdGhhdCBoYW5kbGVzIHRoYXQuIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG4gICAgICAgICAgICB0aGlzLl9wdC5iID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3B0LnIgPSBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICBpZiAocCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIC8vbWF5YmUgaXQncyBub3QgYSBzdHlsZSAtIGl0IGNvdWxkIGJlIGEgcHJvcGVydHkgYWRkZWQgZGlyZWN0bHkgdG8gYW4gZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlJ2xsIHRyeSB0byBhbmltYXRlIHRoYXQuXG4gICAgICAgICAgICB0aGlzLmFkZCh0YXJnZXQsIHAsIHRhcmdldFtwXSwgZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX21pc3NpbmdQbHVnaW4ocCwgZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHRoaXMsIHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHMucHVzaChwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzUHJpb3JpdHkpIHtcbiAgICAgIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodGhpcyk7XG4gICAgfVxuICB9LFxuICBnZXQ6IF9nZXQsXG4gIGFsaWFzZXM6IF9wcm9wZXJ0eUFsaWFzZXMsXG4gIGdldFNldHRlcjogZnVuY3Rpb24gZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHBsdWdpbikge1xuICAgIC8vcmV0dXJucyBhIHNldHRlciBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUgYW5kIGFwcGxpZXMgaXQgYWNjb3JkaW5nbHkuIFJlbWVtYmVyLCBwcm9wZXJ0aWVzIGxpa2UgXCJ4XCIgYXJlbid0IGFzIHNpbXBsZSBhcyB0YXJnZXQuc3R5bGUucHJvcGVydHkgPSB2YWx1ZSBiZWNhdXNlIHRoZXkndmUgZ290IHRvIGJlIGFwcGxpZWQgdG8gYSBwcm94eSBvYmplY3QgYW5kIHRoZW4gbWVyZ2VkIGludG8gYSB0cmFuc2Zvcm0gc3RyaW5nIGluIGEgcmVuZGVyZXIuXG4gICAgdmFyIHAgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcbiAgICBwICYmIHAuaW5kZXhPZihcIixcIikgPCAwICYmIChwcm9wZXJ0eSA9IHApO1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wICYmICh0YXJnZXQuX2dzYXAueCB8fCBfZ2V0KHRhcmdldCwgXCJ4XCIpKSA/IHBsdWdpbiAmJiBfcmVjZW50U2V0dGVyUGx1Z2luID09PSBwbHVnaW4gPyBwcm9wZXJ0eSA9PT0gXCJzY2FsZVwiID8gX3NldHRlclNjYWxlIDogX3NldHRlclRyYW5zZm9ybSA6IChfcmVjZW50U2V0dGVyUGx1Z2luID0gcGx1Z2luIHx8IHt9KSAmJiAocHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgOiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcikgOiB0YXJnZXQuc3R5bGUgJiYgIV9pc1VuZGVmaW5lZCh0YXJnZXQuc3R5bGVbcHJvcGVydHldKSA/IF9zZXR0ZXJDU1NTdHlsZSA6IH5wcm9wZXJ0eS5pbmRleE9mKFwiLVwiKSA/IF9zZXR0ZXJDU1NQcm9wIDogX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KTtcbiAgfSxcbiAgY29yZToge1xuICAgIF9yZW1vdmVQcm9wZXJ0eTogX3JlbW92ZVByb3BlcnR5LFxuICAgIF9nZXRNYXRyaXg6IF9nZXRNYXRyaXhcbiAgfVxufTtcbmdzYXAudXRpbHMuY2hlY2tQcmVmaXggPSBfY2hlY2tQcm9wUHJlZml4O1xuXG4oZnVuY3Rpb24gKHBvc2l0aW9uQW5kU2NhbGUsIHJvdGF0aW9uLCBvdGhlcnMsIGFsaWFzZXMpIHtcbiAgdmFyIGFsbCA9IF9mb3JFYWNoTmFtZShwb3NpdGlvbkFuZFNjYWxlICsgXCIsXCIgKyByb3RhdGlvbiArIFwiLFwiICsgb3RoZXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF90cmFuc2Zvcm1Qcm9wc1tuYW1lXSA9IDE7XG4gIH0pO1xuXG4gIF9mb3JFYWNoTmFtZShyb3RhdGlvbiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfY29uZmlnLnVuaXRzW25hbWVdID0gXCJkZWdcIjtcbiAgICBfcm90YXRpb25hbFByb3BlcnRpZXNbbmFtZV0gPSAxO1xuICB9KTtcblxuICBfcHJvcGVydHlBbGlhc2VzW2FsbFsxM11dID0gcG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb247XG5cbiAgX2ZvckVhY2hOYW1lKGFsaWFzZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNwbGl0ID0gbmFtZS5zcGxpdChcIjpcIik7XG4gICAgX3Byb3BlcnR5QWxpYXNlc1tzcGxpdFsxXV0gPSBhbGxbc3BsaXRbMF1dO1xuICB9KTtcbn0pKFwieCx5LHosc2NhbGUsc2NhbGVYLHNjYWxlWSx4UGVyY2VudCx5UGVyY2VudFwiLCBcInJvdGF0aW9uLHJvdGF0aW9uWCxyb3RhdGlvblksc2tld1gsc2tld1lcIiwgXCJ0cmFuc2Zvcm0sdHJhbnNmb3JtT3JpZ2luLHN2Z09yaWdpbixmb3JjZTNELHNtb290aE9yaWdpbix0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLCBcIjA6dHJhbnNsYXRlWCwxOnRyYW5zbGF0ZVksMjp0cmFuc2xhdGVaLDg6cm90YXRlLDg6cm90YXRpb25aLDg6cm90YXRlWiw5OnJvdGF0ZVgsMTA6cm90YXRlWVwiKTtcblxuX2ZvckVhY2hOYW1lKFwieCx5LHosdG9wLHJpZ2h0LGJvdHRvbSxsZWZ0LHdpZHRoLGhlaWdodCxmb250U2l6ZSxwYWRkaW5nLG1hcmdpbixwZXJzcGVjdGl2ZVwiLCBmdW5jdGlvbiAobmFtZSkge1xuICBfY29uZmlnLnVuaXRzW25hbWVdID0gXCJweFwiO1xufSk7XG5cbmdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKTtcbmV4cG9ydCB7IENTU1BsdWdpbiBhcyBkZWZhdWx0LCBfZ2V0QkJveCwgX2NyZWF0ZUVsZW1lbnQsIF9jaGVja1Byb3BQcmVmaXggYXMgY2hlY2tQcmVmaXggfTsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qIVxuICogR1NBUCAzLjIuNlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfY29uZmlnID0ge1xuICBhdXRvU2xlZXA6IDEyMCxcbiAgZm9yY2UzRDogXCJhdXRvXCIsXG4gIG51bGxUYXJnZXRXYXJuOiAxLFxuICB1bml0czoge1xuICAgIGxpbmVIZWlnaHQ6IFwiXCJcbiAgfVxufSxcbiAgICBfZGVmYXVsdHMgPSB7XG4gIGR1cmF0aW9uOiAuNSxcbiAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgZGVsYXk6IDBcbn0sXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfdGlueU51bSA9IDEgLyBfYmlnTnVtLFxuICAgIF8yUEkgPSBNYXRoLlBJICogMixcbiAgICBfSEFMRl9QSSA9IF8yUEkgLyA0LFxuICAgIF9nc0lEID0gMCxcbiAgICBfc3FydCA9IE1hdGguc3FydCxcbiAgICBfY29zID0gTWF0aC5jb3MsXG4gICAgX3NpbiA9IE1hdGguc2luLFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX2lzTnVtYmVyID0gZnVuY3Rpb24gX2lzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59LFxuICAgIF9pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIF9pc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn0sXG4gICAgX2lzTm90RmFsc2UgPSBmdW5jdGlvbiBfaXNOb3RGYWxzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IGZhbHNlO1xufSxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9pc0Z1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9pc0Z1bmNPclN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpIHx8IF9pc1N0cmluZyh2YWx1ZSk7XG59LFxuICAgIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICBfc3RyaWN0TnVtRXhwID0gLyg/Oi0/XFwuP1xcZHxcXC4pKy9naSxcbiAgICAvL29ubHkgbnVtYmVycyAoaW5jbHVkaW5nIG5lZ2F0aXZlcyBhbmQgZGVjaW1hbHMpIGJ1dCBOT1QgcmVsYXRpdmUgdmFsdWVzLlxuX251bUV4cCA9IC9bLSs9Ll0qXFxkK1suZVxcLStdKlxcZCpbZVxcLVxcK10qXFxkKi9nLFxuICAgIC8vZmluZHMgYW55IG51bWJlcnMsIGluY2x1ZGluZyBvbmVzIHRoYXQgc3RhcnQgd2l0aCArPSBvciAtPSwgbmVnYXRpdmUgbnVtYmVycywgYW5kIG9uZXMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlIDFlLTguXG5fbnVtV2l0aFVuaXRFeHAgPSAvWy0rPS5dKlxcZCtbLmUtXSpcXGQqW2EteiVdKi9nLFxuICAgIF9jb21wbGV4U3RyaW5nTnVtRXhwID0gL1stKz0uXSpcXGQrKD86XFwufGUtfGUpKlxcZCovZ2ksXG4gICAgLy9kdXBsaWNhdGUgc28gdGhhdCB3aGlsZSB3ZSdyZSBsb29waW5nIHRocm91Z2ggbWF0Y2hlcyBmcm9tIGV4ZWMoKSwgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgbGFzdEluZGV4IG9mIF9udW1FeHAgd2hpY2ggd2UgdXNlIHRvIHNlYXJjaCBmb3IgY29sb3JzIHRvby5cbl9wYXJlbnRoZXNlc0V4cCA9IC9cXCgoW14oKV0rKVxcKS9pLFxuICAgIC8vZmluZHMgdGhlIHN0cmluZyBiZXR3ZWVuIHBhcmVudGhlc2VzLlxuX3JlbEV4cCA9IC9bKy1dPS0/W1xcLlxcZF0rLyxcbiAgICBfZGVsaW1pdGVkVmFsdWVFeHAgPSAvWyNcXC0rLl0qXFxiW2EtelxcZC09KyUuXSsvZ2ksXG4gICAgX2dsb2JhbFRpbWVsaW5lLFxuICAgIF93aW4sXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF9kb2MsXG4gICAgX2dsb2JhbHMgPSB7fSxcbiAgICBfaW5zdGFsbFNjb3BlID0ge30sXG4gICAgX2NvcmVSZWFkeSxcbiAgICBfaW5zdGFsbCA9IGZ1bmN0aW9uIF9pbnN0YWxsKHNjb3BlKSB7XG4gIHJldHVybiAoX2luc3RhbGxTY29wZSA9IF9tZXJnZShzY29wZSwgX2dsb2JhbHMpKSAmJiBnc2FwO1xufSxcbiAgICBfbWlzc2luZ1BsdWdpbiA9IGZ1bmN0aW9uIF9taXNzaW5nUGx1Z2luKHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gY29uc29sZS53YXJuKFwiSW52YWxpZCBwcm9wZXJ0eVwiLCBwcm9wZXJ0eSwgXCJzZXQgdG9cIiwgdmFsdWUsIFwiTWlzc2luZyBwbHVnaW4/IGdzYXAucmVnaXN0ZXJQbHVnaW4oKVwiKTtcbn0sXG4gICAgX3dhcm4gPSBmdW5jdGlvbiBfd2FybihtZXNzYWdlLCBzdXBwcmVzcykge1xuICByZXR1cm4gIXN1cHByZXNzICYmIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn0sXG4gICAgX2FkZEdsb2JhbCA9IGZ1bmN0aW9uIF9hZGRHbG9iYWwobmFtZSwgb2JqKSB7XG4gIHJldHVybiBuYW1lICYmIChfZ2xvYmFsc1tuYW1lXSA9IG9iaikgJiYgX2luc3RhbGxTY29wZSAmJiAoX2luc3RhbGxTY29wZVtuYW1lXSA9IG9iaikgfHwgX2dsb2JhbHM7XG59LFxuICAgIF9lbXB0eUZ1bmMgPSBmdW5jdGlvbiBfZW1wdHlGdW5jKCkge1xuICByZXR1cm4gMDtcbn0sXG4gICAgX3Jlc2VydmVkUHJvcHMgPSB7fSxcbiAgICBfbGF6eVR3ZWVucyA9IFtdLFxuICAgIF9sYXp5TG9va3VwID0ge30sXG4gICAgX2xhc3RSZW5kZXJlZEZyYW1lLFxuICAgIF9wbHVnaW5zID0ge30sXG4gICAgX2VmZmVjdHMgPSB7fSxcbiAgICBfbmV4dEdDRnJhbWUgPSAzMCxcbiAgICBfaGFybmVzc1BsdWdpbnMgPSBbXSxcbiAgICBfY2FsbGJhY2tOYW1lcyA9IFwiXCIsXG4gICAgX2hhcm5lc3MgPSBmdW5jdGlvbiBfaGFybmVzcyh0YXJnZXRzKSB7XG4gIHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdLFxuICAgICAgaGFybmVzc1BsdWdpbixcbiAgICAgIGk7XG5cbiAgaWYgKCFfaXNPYmplY3QodGFyZ2V0KSAmJiAhX2lzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgIHRhcmdldHMgPSBbdGFyZ2V0c107XG4gIH1cblxuICBpZiAoIShoYXJuZXNzUGx1Z2luID0gKHRhcmdldC5fZ3NhcCB8fCB7fSkuaGFybmVzcykpIHtcbiAgICBpID0gX2hhcm5lc3NQbHVnaW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0gJiYgIV9oYXJuZXNzUGx1Z2luc1tpXS50YXJnZXRUZXN0KHRhcmdldCkpIHt9XG5cbiAgICBoYXJuZXNzUGx1Z2luID0gX2hhcm5lc3NQbHVnaW5zW2ldO1xuICB9XG5cbiAgaSA9IHRhcmdldHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB0YXJnZXRzW2ldICYmICh0YXJnZXRzW2ldLl9nc2FwIHx8ICh0YXJnZXRzW2ldLl9nc2FwID0gbmV3IEdTQ2FjaGUodGFyZ2V0c1tpXSwgaGFybmVzc1BsdWdpbikpKSB8fCB0YXJnZXRzLnNwbGljZShpLCAxKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRzO1xufSxcbiAgICBfZ2V0Q2FjaGUgPSBmdW5jdGlvbiBfZ2V0Q2FjaGUodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXAgfHwgX2hhcm5lc3ModG9BcnJheSh0YXJnZXQpKVswXS5fZ3NhcDtcbn0sXG4gICAgX2dldFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wZXJ0eV07XG4gIHJldHVybiBfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gdGFyZ2V0W3Byb3BlcnR5XSgpIDogX2lzVW5kZWZpbmVkKGN1cnJlbnRWYWx1ZSkgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShwcm9wZXJ0eSkgfHwgY3VycmVudFZhbHVlO1xufSxcbiAgICBfZm9yRWFjaE5hbWUgPSBmdW5jdGlvbiBfZm9yRWFjaE5hbWUobmFtZXMsIGZ1bmMpIHtcbiAgcmV0dXJuIChuYW1lcyA9IG5hbWVzLnNwbGl0KFwiLFwiKSkuZm9yRWFjaChmdW5jKSB8fCBuYW1lcztcbn0sXG4gICAgLy9zcGxpdCBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIG5hbWVzIGludG8gYW4gYXJyYXksIHRoZW4gcnVuIGEgZm9yRWFjaCgpIGZ1bmN0aW9uIGFuZCByZXR1cm4gdGhlIHNwbGl0IGFycmF5ICh0aGlzIGlzIGp1c3QgYSB3YXkgdG8gY29uc29saWRhdGUvc2hvcnRlbiBzb21lIGNvZGUpLlxuX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwO1xufSxcbiAgICBfYXJyYXlDb250YWluc0FueSA9IGZ1bmN0aW9uIF9hcnJheUNvbnRhaW5zQW55KHRvU2VhcmNoLCB0b0ZpbmQpIHtcbiAgLy9zZWFyY2hlcyBvbmUgYXJyYXkgdG8gZmluZCBtYXRjaGVzIGZvciBhbnkgb2YgdGhlIGl0ZW1zIGluIHRoZSB0b0ZpbmQgYXJyYXkuIEFzIHNvb24gYXMgb25lIGlzIGZvdW5kLCBpdCByZXR1cm5zIHRydWUuIEl0IGRvZXMgTk9UIHJldHVybiBhbGwgdGhlIG1hdGNoZXM7IGl0J3Mgc2ltcGx5IGEgYm9vbGVhbiBzZWFyY2guXG4gIHZhciBsID0gdG9GaW5kLmxlbmd0aCxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoOyB0b1NlYXJjaC5pbmRleE9mKHRvRmluZFtpXSkgPCAwICYmICsraSA8IGw7KSB7fVxuXG4gIHJldHVybiBpIDwgbDtcbn0sXG4gICAgX3BhcnNlVmFycyA9IGZ1bmN0aW9uIF9wYXJzZVZhcnMocGFyYW1zLCB0eXBlLCBwYXJlbnQpIHtcbiAgLy9yZWFkcyB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byBvbmUgb2YgdGhlIGtleSBtZXRob2RzIGFuZCBmaWd1cmVzIG91dCBpZiB0aGUgdXNlciBpcyBkZWZpbmluZyB0aGluZ3Mgd2l0aCB0aGUgT0xEL2xlZ2FjeSBzeW50YXggd2hlcmUgdGhlIGR1cmF0aW9uIGlzIHRoZSAybmQgcGFyYW1ldGVyLCBhbmQgdGhlbiBpdCBhZGp1c3RzIHRoaW5ncyBhY2NvcmRpbmdseSBhbmQgc3BpdHMgYmFjayB0aGUgY29ycmVjdGVkIHZhcnMgb2JqZWN0ICh3aXRoIHRoZSBkdXJhdGlvbiBhZGRlZCBpZiBuZWNlc3NhcnksIGFzIHdlbGwgYXMgcnVuQmFja3dhcmRzIG9yIHN0YXJ0QXQgb3IgaW1tZWRpYXRlUmVuZGVyKS4gdHlwZSAwID0gdG8oKS9zdGFnZ2VyVG8oKSwgMSA9IGZyb20oKS9zdGFnZ2VyRnJvbSgpLCAyID0gZnJvbVRvKCkvc3RhZ2dlckZyb21UbygpXG4gIHZhciBpc0xlZ2FjeSA9IF9pc051bWJlcihwYXJhbXNbMV0pLFxuICAgICAgdmFyc0luZGV4ID0gKGlzTGVnYWN5ID8gMiA6IDEpICsgKHR5cGUgPCAyID8gMCA6IDEpLFxuICAgICAgdmFycyA9IHBhcmFtc1t2YXJzSW5kZXhdLFxuICAgICAgaXJWYXJzO1xuXG4gIGlmIChpc0xlZ2FjeSkge1xuICAgIHZhcnMuZHVyYXRpb24gPSBwYXJhbXNbMV07XG4gIH1cblxuICB2YXJzLnBhcmVudCA9IHBhcmVudDtcblxuICBpZiAodHlwZSkge1xuICAgIGlyVmFycyA9IHZhcnM7XG5cbiAgICB3aGlsZSAocGFyZW50ICYmICEoXCJpbW1lZGlhdGVSZW5kZXJcIiBpbiBpclZhcnMpKSB7XG4gICAgICAvLyBpbmhlcml0YW5jZSBoYXNuJ3QgaGFwcGVuZWQgeWV0LCBidXQgc29tZW9uZSBtYXkgaGF2ZSBzZXQgYSBkZWZhdWx0IGluIGFuIGFuY2VzdG9yIHRpbWVsaW5lLiBXZSBjb3VsZCBkbyB2YXJzLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKF9pbmhlcml0RGVmYXVsdHModmFycykuaW1tZWRpYXRlUmVuZGVyKSBidXQgdGhhdCdkIGV4YWN0IGEgc2xpZ2h0IHBlcmZvcm1hbmNlIHBlbmFsdHkgYmVjYXVzZSBfaW5oZXJpdERlZmF1bHRzKCkgYWxzbyBydW5zIGluIHRoZSBUd2VlbiBjb25zdHJ1Y3Rvci4gV2UncmUgcGF5aW5nIGEgc21hbGwga2IgcHJpY2UgaGVyZSB0byBnYWluIHNwZWVkLlxuICAgICAgaXJWYXJzID0gcGFyZW50LnZhcnMuZGVmYXVsdHMgfHwge307XG4gICAgICBwYXJlbnQgPSBfaXNOb3RGYWxzZShwYXJlbnQudmFycy5pbmhlcml0KSAmJiBwYXJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UoaXJWYXJzLmltbWVkaWF0ZVJlbmRlcik7XG5cbiAgICBpZiAodHlwZSA8IDIpIHtcbiAgICAgIHZhcnMucnVuQmFja3dhcmRzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy5zdGFydEF0ID0gcGFyYW1zW3ZhcnNJbmRleCAtIDFdOyAvLyBcImZyb21cIiB2YXJzXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhcnM7XG59LFxuICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gIHZhciBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuICAgICAgYSA9IF9sYXp5VHdlZW5zLnNsaWNlKDApLFxuICAgICAgaSxcbiAgICAgIHR3ZWVuO1xuXG4gIF9sYXp5TG9va3VwID0ge307XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHR3ZWVuID0gYVtpXTtcblxuICAgIGlmICh0d2VlbiAmJiB0d2Vlbi5fbGF6eSkge1xuICAgICAgdHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwO1xuICAgIH1cbiAgfVxufSxcbiAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgaWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkge1xuICAgIF9sYXp5UmVuZGVyKCk7XG4gIH1cblxuICBhbmltYXRpb24ucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cbiAgaWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkge1xuICAgIC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cbiAgICBfbGF6eVJlbmRlcigpO1xuICB9XG59LFxuICAgIF9udW1lcmljSWZQb3NzaWJsZSA9IGZ1bmN0aW9uIF9udW1lcmljSWZQb3NzaWJsZSh2YWx1ZSkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICByZXR1cm4gKG4gfHwgbiA9PT0gMCkgJiYgKHZhbHVlICsgXCJcIikubWF0Y2goX2RlbGltaXRlZFZhbHVlRXhwKS5sZW5ndGggPCAyID8gbiA6IHZhbHVlO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2gocCkge1xuICByZXR1cm4gcDtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIGlmICghKHAgaW4gb2JqKSkge1xuICAgICAgb2JqW3BdID0gZGVmYXVsdHNbcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX3NldEtleWZyYW1lRGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0S2V5ZnJhbWVEZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoIShwIGluIG9iaikgJiYgcCAhPT0gXCJkdXJhdGlvblwiICYmIHAgIT09IFwiZWFzZVwiKSB7XG4gICAgICBvYmpbcF0gPSBkZWZhdWx0c1twXTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX21lcmdlID0gZnVuY3Rpb24gX21lcmdlKGJhc2UsIHRvTWVyZ2UpIHtcbiAgZm9yICh2YXIgcCBpbiB0b01lcmdlKSB7XG4gICAgYmFzZVtwXSA9IHRvTWVyZ2VbcF07XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX21lcmdlRGVlcCA9IGZ1bmN0aW9uIF9tZXJnZURlZXAoYmFzZSwgdG9NZXJnZSkge1xuICBmb3IgKHZhciBwIGluIHRvTWVyZ2UpIHtcbiAgICBiYXNlW3BdID0gX2lzT2JqZWN0KHRvTWVyZ2VbcF0pID8gX21lcmdlRGVlcChiYXNlW3BdIHx8IChiYXNlW3BdID0ge30pLCB0b01lcmdlW3BdKSA6IHRvTWVyZ2VbcF07XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX2NvcHlFeGNsdWRpbmcgPSBmdW5jdGlvbiBfY29weUV4Y2x1ZGluZyhvYmosIGV4Y2x1ZGluZykge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgaWYgKCEocCBpbiBleGNsdWRpbmcpKSB7XG4gICAgICBjb3B5W3BdID0gb2JqW3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfaW5oZXJpdERlZmF1bHRzID0gZnVuY3Rpb24gX2luaGVyaXREZWZhdWx0cyh2YXJzKSB7XG4gIHZhciBwYXJlbnQgPSB2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsXG4gICAgICBmdW5jID0gdmFycy5rZXlmcmFtZXMgPyBfc2V0S2V5ZnJhbWVEZWZhdWx0cyA6IF9zZXREZWZhdWx0cztcblxuICBpZiAoX2lzTm90RmFsc2UodmFycy5pbmhlcml0KSkge1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGZ1bmModmFycywgcGFyZW50LnZhcnMuZGVmYXVsdHMpO1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2FycmF5c01hdGNoID0gZnVuY3Rpb24gX2FycmF5c01hdGNoKGExLCBhMikge1xuICB2YXIgaSA9IGExLmxlbmd0aCxcbiAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gIHdoaWxlIChtYXRjaCAmJiBpLS0gJiYgYTFbaV0gPT09IGEyW2ldKSB7fVxuXG4gIHJldHVybiBpIDwgMDtcbn0sXG4gICAgX2FkZExpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX2FkZExpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3AsIHNvcnRCeSkge1xuICBpZiAoZmlyc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICB9XG5cbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgfVxuXG4gIHZhciBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHNvcnRCeSkge1xuICAgIHQgPSBjaGlsZFtzb3J0QnldO1xuXG4gICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgcHJldiA9IHByZXYuX3ByZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XG4gICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGlmIChjaGlsZC5fbmV4dCkge1xuICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2xhc3RQcm9wXSA9IGNoaWxkO1xuICB9XG5cbiAgY2hpbGQuX3ByZXYgPSBwcmV2O1xuICBjaGlsZC5wYXJlbnQgPSBjaGlsZC5fZHAgPSBwYXJlbnQ7XG4gIHJldHVybiBjaGlsZDtcbn0sXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX3JlbW92ZUxpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3ApIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gIH0gZWxzZSBpZiAocGFyZW50W2ZpcnN0UHJvcF0gPT09IGNoaWxkKSB7XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBwcmV2O1xuICB9XG5cbiAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7IC8vIGRvbid0IGRlbGV0ZSB0aGUgX2RwIGp1c3Qgc28gd2UgY2FuIHJldmVydCBpZiBuZWNlc3NhcnkuIEJ1dCBwYXJlbnQgc2hvdWxkIGJlIG51bGwgdG8gaW5kaWNhdGUgdGhlIGl0ZW0gaXNuJ3QgaW4gYSBsaW5rZWQgbGlzdC5cbn0sXG4gICAgX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCwgb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSkge1xuICBpZiAoY2hpbGQucGFyZW50ICYmICghb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSB8fCBjaGlsZC5wYXJlbnQuYXV0b1JlbW92ZUNoaWxkcmVuKSkge1xuICAgIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICB9XG5cbiAgY2hpbGQuX2FjdCA9IDA7XG59LFxuICAgIF91bmNhY2hlID0gZnVuY3Rpb24gX3VuY2FjaGUoYW5pbWF0aW9uKSB7XG4gIHZhciBhID0gYW5pbWF0aW9uO1xuXG4gIHdoaWxlIChhKSB7XG4gICAgYS5fZGlydHkgPSAxO1xuICAgIGEgPSBhLnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZWNhY2hlQW5jZXN0b3JzID0gZnVuY3Rpb24gX3JlY2FjaGVBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24ucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgIC8vc29tZXRpbWVzIHdlIG11c3QgZm9yY2UgYSByZS1zb3J0IG9mIGFsbCBjaGlsZHJlbiBhbmQgdXBkYXRlIHRoZSBkdXJhdGlvbi90b3RhbER1cmF0aW9uIG9mIGFsbCBhbmNlc3RvciB0aW1lbGluZXMgaW1tZWRpYXRlbHkgaW4gY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIgbG9vcCwgb25lIHR3ZWVuIGFsdGVycyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIHdoaWNoIHNob3ZlcyBpdHMgc3RhcnRUaW1lIGJlZm9yZSAwLCBmb3JjaW5nIHRoZSBwYXJlbnQgdGltZWxpbmUgdG8gc2hpZnQgYXJvdW5kIGFuZCBzaGlmdENoaWxkcmVuKCkgd2hpY2ggY291bGQgYWZmZWN0IHRoYXQgbmV4dCB0d2VlbidzIHJlbmRlciAoc3RhcnRUaW1lKS4gRG9lc24ndCBtYXR0ZXIgZm9yIHRoZSByb290IHRpbWVsaW5lIHRob3VnaC5cbiAgICBwYXJlbnQuX2RpcnR5ID0gMTtcbiAgICBwYXJlbnQudG90YWxEdXJhdGlvbigpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfaGFzTm9QYXVzZWRBbmNlc3RvcnMgPSBmdW5jdGlvbiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHJldHVybiAhYW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5fdHMgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbi5wYXJlbnQpO1xufSxcbiAgICBfZWxhcHNlZEN5Y2xlRHVyYXRpb24gPSBmdW5jdGlvbiBfZWxhcHNlZEN5Y2xlRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZShhbmltYXRpb24uX3RUaW1lLCBhbmltYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb24oKSArIGFuaW1hdGlvbi5fckRlbGF5KSAqIGFuaW1hdGlvbiA6IDA7XG59LFxuICAgIC8vIGZlZWQgaW4gdGhlIHRvdGFsVGltZSBhbmQgY3ljbGVEdXJhdGlvbiBhbmQgaXQnbGwgcmV0dXJuIHRoZSBjeWNsZSAoaXRlcmF0aW9uIG1pbnVzIDEpIGFuZCBpZiB0aGUgcGxheWhlYWQgaXMgZXhhY3RseSBhdCB0aGUgdmVyeSBFTkQsIGl0IHdpbGwgTk9UIGJ1bXAgdXAgdG8gdGhlIG5leHQgY3ljbGUuXG5fYW5pbWF0aW9uQ3ljbGUgPSBmdW5jdGlvbiBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIGN5Y2xlRHVyYXRpb24pIHtcbiAgcmV0dXJuICh0VGltZSAvPSBjeWNsZUR1cmF0aW9uKSAmJiB+fnRUaW1lID09PSB0VGltZSA/IH5+dFRpbWUgLSAxIDogfn50VGltZTtcbn0sXG4gICAgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUgPSBmdW5jdGlvbiBfcGFyZW50VG9DaGlsZFRvdGFsVGltZShwYXJlbnRUaW1lLCBjaGlsZCkge1xuICByZXR1cm4gKHBhcmVudFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzICsgKGNoaWxkLl90cyA+PSAwID8gMCA6IGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKTtcbn0sXG4gICAgX3NldEVuZCA9IGZ1bmN0aW9uIF9zZXRFbmQoYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX2VuZCA9IF9yb3VuZChhbmltYXRpb24uX3N0YXJ0ICsgKGFuaW1hdGlvbi5fdER1ciAvIE1hdGguYWJzKGFuaW1hdGlvbi5fdHMgfHwgYW5pbWF0aW9uLl9ydHMgfHwgX3RpbnlOdW0pIHx8IDApKTtcbn0sXG5cbi8qXG5fdG90YWxUaW1lVG9UaW1lID0gKGNsYW1wZWRUb3RhbFRpbWUsIGR1cmF0aW9uLCByZXBlYXQsIHJlcGVhdERlbGF5LCB5b3lvKSA9PiB7XG5cdGxldCBjeWNsZUR1cmF0aW9uID0gZHVyYXRpb24gKyByZXBlYXREZWxheSxcblx0XHR0aW1lID0gX3JvdW5kKGNsYW1wZWRUb3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uKTtcblx0aWYgKHRpbWUgPiBkdXJhdGlvbikge1xuXHRcdHRpbWUgPSBkdXJhdGlvbjtcblx0fVxuXHRyZXR1cm4gKHlveW8gJiYgKH5+KGNsYW1wZWRUb3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSAmIDEpKSA/IGR1cmF0aW9uIC0gdGltZSA6IHRpbWU7XG59LFxuKi9cbl9wb3N0QWRkQ2hlY2tzID0gZnVuY3Rpb24gX3Bvc3RBZGRDaGVja3ModGltZWxpbmUsIGNoaWxkKSB7XG4gIHZhciB0O1xuXG4gIGlmIChjaGlsZC5fdGltZSB8fCBjaGlsZC5faW5pdHRlZCAmJiAhY2hpbGQuX2R1cikge1xuICAgIC8vaW4gY2FzZSwgZm9yIGV4YW1wbGUsIHRoZSBfc3RhcnQgaXMgbW92ZWQgb24gYSB0d2VlbiB0aGF0IGhhcyBhbHJlYWR5IHJlbmRlcmVkLiBJbWFnaW5lIGl0J3MgYXQgaXRzIGVuZCBzdGF0ZSwgdGhlbiB0aGUgc3RhcnRUaW1lIGlzIG1vdmVkIFdBWSBsYXRlciAoYWZ0ZXIgdGhlIGVuZCBvZiB0aGlzIHRpbWVsaW5lKSwgaXQgc2hvdWxkIHJlbmRlciBhdCBpdHMgYmVnaW5uaW5nLlxuICAgIHQgPSBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aW1lbGluZS5yYXdUaW1lKCksIGNoaWxkKTtcblxuICAgIGlmICghY2hpbGQuX2R1ciB8fCBfY2xhbXAoMCwgY2hpbGQudG90YWxEdXJhdGlvbigpLCB0KSAtIGNoaWxkLl90VGltZSA+IF90aW55TnVtKSB7XG4gICAgICBjaGlsZC5yZW5kZXIodCwgdHJ1ZSk7XG4gICAgfVxuICB9IC8vaWYgdGhlIHRpbWVsaW5lIGhhcyBhbHJlYWR5IGVuZGVkIGJ1dCB0aGUgaW5zZXJ0ZWQgdHdlZW4vdGltZWxpbmUgZXh0ZW5kcyB0aGUgZHVyYXRpb24sIHdlIHNob3VsZCBlbmFibGUgdGhpcyB0aW1lbGluZSBhZ2FpbiBzbyB0aGF0IGl0IHJlbmRlcnMgcHJvcGVybHkuIFdlIHNob3VsZCBhbHNvIGFsaWduIHRoZSBwbGF5aGVhZCB3aXRoIHRoZSBwYXJlbnQgdGltZWxpbmUncyB3aGVuIGFwcHJvcHJpYXRlLlxuXG5cbiAgaWYgKF91bmNhY2hlKHRpbWVsaW5lKS5fZHAgJiYgdGltZWxpbmUuX2luaXR0ZWQgJiYgdGltZWxpbmUuX3RpbWUgPj0gdGltZWxpbmUuX2R1ciAmJiB0aW1lbGluZS5fdHMpIHtcbiAgICAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG4gICAgaWYgKHRpbWVsaW5lLl9kdXIgPCB0aW1lbGluZS5kdXJhdGlvbigpKSB7XG4gICAgICB0ID0gdGltZWxpbmU7XG5cbiAgICAgIHdoaWxlICh0Ll9kcCkge1xuICAgICAgICB0LnJhd1RpbWUoKSA+PSAwICYmIHQudG90YWxUaW1lKHQuX3RUaW1lKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuIElmIGl0J3MgY3VycmVudGx5IHplcm8sIHRob3VnaCwgaXQgbWF5IG5vdCBiZSBzY2hlZHVsZWQgdG8gcmVuZGVyIHVudGlsIGxhdGVyIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSBpdCB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHBsYXloZWFkIHBvc2l0aW9uLiBPbmx5IG1vdmUgdG8gY2F0Y2ggdXAgd2l0aCB0aGUgcGxheWhlYWQuXG5cbiAgICAgICAgdCA9IHQuX2RwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVsaW5lLl96VGltZSA9IC1fdGlueU51bTsgLy8gaGVscHMgZW5zdXJlIHRoYXQgdGhlIG5leHQgcmVuZGVyKCkgd2lsbCBiZSBmb3JjZWQgKGNyb3NzaW5nU3RhcnQgPSB0cnVlIGluIHJlbmRlcigpKSwgZXZlbiBpZiB0aGUgZHVyYXRpb24gaGFzbid0IGNoYW5nZWQgKHdlJ3JlIGFkZGluZyBhIGNoaWxkIHdoaWNoIHdvdWxkIG5lZWQgdG8gZ2V0IHJlbmRlcmVkKS4gRGVmaW5pdGVseSBhbiBlZGdlIGNhc2UuIE5vdGU6IHdlIE1VU1QgZG8gdGhpcyBBRlRFUiB0aGUgbG9vcCBhYm92ZSB3aGVyZSB0aGUgdG90YWxUaW1lKCkgbWlnaHQgdHJpZ2dlciBhIHJlbmRlcigpIGJlY2F1c2UgdGhpcyBfYWRkVG9UaW1lbGluZSgpIG1ldGhvZCBnZXRzIGNhbGxlZCBmcm9tIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIEJFRk9SRSB0d2VlbnMgZXZlbiByZWNvcmQgdGhlaXIgdGFyZ2V0cywgZXRjLiBzbyB3ZSB3b3VsZG4ndCB3YW50IHRoaW5ncyB0byBnZXQgdHJpZ2dlcmVkIGluIHRoZSB3cm9uZyBvcmRlci5cbiAgfVxufSxcbiAgICBfYWRkVG9UaW1lbGluZSA9IGZ1bmN0aW9uIF9hZGRUb1RpbWVsaW5lKHRpbWVsaW5lLCBjaGlsZCwgcG9zaXRpb24sIHNraXBDaGVja3MpIHtcbiAgY2hpbGQucGFyZW50ICYmIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgY2hpbGQuX3N0YXJ0ID0gX3JvdW5kKHBvc2l0aW9uICsgY2hpbGQuX2RlbGF5KTtcbiAgY2hpbGQuX2VuZCA9IF9yb3VuZChjaGlsZC5fc3RhcnQgKyAoY2hpbGQudG90YWxEdXJhdGlvbigpIC8gTWF0aC5hYnMoY2hpbGQudGltZVNjYWxlKCkpIHx8IDApKTtcblxuICBfYWRkTGlua2VkTGlzdEl0ZW0odGltZWxpbmUsIGNoaWxkLCBcIl9maXJzdFwiLCBcIl9sYXN0XCIsIHRpbWVsaW5lLl9zb3J0ID8gXCJfc3RhcnRcIiA6IDApO1xuXG4gIHRpbWVsaW5lLl9yZWNlbnQgPSBjaGlsZDtcbiAgc2tpcENoZWNrcyB8fCBfcG9zdEFkZENoZWNrcyh0aW1lbGluZSwgY2hpbGQpO1xuICByZXR1cm4gdGltZWxpbmU7XG59LFxuICAgIF9hdHRlbXB0SW5pdFR3ZWVuID0gZnVuY3Rpb24gX2F0dGVtcHRJbml0VHdlZW4odHdlZW4sIHRvdGFsVGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSB7XG4gIF9pbml0VHdlZW4odHdlZW4sIHRvdGFsVGltZSk7XG5cbiAgaWYgKCF0d2Vlbi5faW5pdHRlZCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKCFmb3JjZSAmJiB0d2Vlbi5fcHQgJiYgKHR3ZWVuLl9kdXIgJiYgdHdlZW4udmFycy5sYXp5ICE9PSBmYWxzZSB8fCAhdHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkpICYmIF9sYXN0UmVuZGVyZWRGcmFtZSAhPT0gX3RpY2tlci5mcmFtZSkge1xuICAgIF9sYXp5VHdlZW5zLnB1c2godHdlZW4pO1xuXG4gICAgdHdlZW4uX2xhenkgPSBbdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50c107XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0sXG4gICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuID0gZnVuY3Rpb24gX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICB2YXIgcHJldlJhdGlvID0gdHdlZW4uX3pUaW1lIDwgMCA/IDAgOiAxLFxuICAgICAgcmF0aW8gPSB0b3RhbFRpbWUgPCAwID8gMCA6IDEsXG4gICAgICByZXBlYXREZWxheSA9IHR3ZWVuLl9yRGVsYXksXG4gICAgICB0VGltZSA9IDAsXG4gICAgICBwdCxcbiAgICAgIGl0ZXJhdGlvbixcbiAgICAgIHByZXZJdGVyYXRpb247XG5cbiAgaWYgKHJlcGVhdERlbGF5ICYmIHR3ZWVuLl9yZXBlYXQpIHtcbiAgICAvL2luIGNhc2UgdGhlcmUncyBhIHplcm8tZHVyYXRpb24gdHdlZW4gdGhhdCBoYXMgYSByZXBlYXQgd2l0aCBhIHJlcGVhdERlbGF5XG4gICAgdFRpbWUgPSBfY2xhbXAoMCwgdHdlZW4uX3REdXIsIHRvdGFsVGltZSk7XG4gICAgaXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRUaW1lLCByZXBlYXREZWxheSk7XG4gICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0d2Vlbi5fdFRpbWUsIHJlcGVhdERlbGF5KTtcblxuICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgIHByZXZSYXRpbyA9IDEgLSByYXRpbztcblxuICAgICAgaWYgKHR3ZWVuLnZhcnMucmVwZWF0UmVmcmVzaCAmJiB0d2Vlbi5faW5pdHRlZCkge1xuICAgICAgICB0d2Vlbi5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0d2Vlbi5faW5pdHRlZCAmJiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpKSB7XG4gICAgLy9pZiB3ZSByZW5kZXIgdGhlIHZlcnkgYmVnaW5uaW5nICh0aW1lID09IDApIG9mIGEgZnJvbVRvKCksIHdlIG11c3QgZm9yY2UgdGhlIHJlbmRlciAobm9ybWFsIHR3ZWVucyB3b3VsZG4ndCBuZWVkIHRvIHJlbmRlciBhdCBhIHRpbWUgb2YgMCB3aGVuIHRoZSBwcmV2VGltZSB3YXMgYWxzbyAwKS4gVGhpcyBpcyBhbHNvIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgb3ZlcndyaXRpbmcga2lja3MgaW4gaW1tZWRpYXRlbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJhdGlvICE9PSBwcmV2UmF0aW8gfHwgZm9yY2UgfHwgdHdlZW4uX3pUaW1lID09PSBfdGlueU51bSB8fCAhdG90YWxUaW1lICYmIHR3ZWVuLl96VGltZSkge1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZSB8fCAoc3VwcHJlc3NFdmVudHMgPyBfdGlueU51bSA6IDApOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxuXG4gICAgdHdlZW4ucmF0aW8gPSByYXRpbztcblxuICAgIGlmICh0d2Vlbi5fZnJvbSkge1xuICAgICAgcmF0aW8gPSAxIC0gcmF0aW87XG4gICAgfVxuXG4gICAgdHdlZW4uX3RpbWUgPSAwO1xuICAgIHR3ZWVuLl90VGltZSA9IHRUaW1lO1xuICAgIHN1cHByZXNzRXZlbnRzIHx8IF9jYWxsYmFjayh0d2VlbiwgXCJvblN0YXJ0XCIpO1xuICAgIHB0ID0gdHdlZW4uX3B0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKCFyYXRpbyAmJiB0d2Vlbi5fc3RhcnRBdCAmJiAhdHdlZW4uX29uVXBkYXRlICYmIHR3ZWVuLl9zdGFydCkge1xuICAgICAgLy9pZiB0aGUgdHdlZW4gaXMgcG9zaXRpb25lZCBhdCB0aGUgVkVSWSBiZWdpbm5pbmcgKF9zdGFydCAwKSBvZiBpdHMgcGFyZW50IHRpbWVsaW5lLCBpdCdzIGlsbGVnYWwgZm9yIHRoZSBwbGF5aGVhZCB0byBnbyBiYWNrIGZ1cnRoZXIsIHNvIHdlIHNob3VsZCBub3QgcmVuZGVyIHRoZSByZWNvcmRlZCBzdGFydEF0IHZhbHVlcy5cbiAgICAgIHR3ZWVuLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIGZvcmNlKTtcbiAgICB9XG5cbiAgICB0d2Vlbi5fb25VcGRhdGUgJiYgKHN1cHByZXNzRXZlbnRzIHx8IF9jYWxsYmFjayh0d2VlbiwgXCJvblVwZGF0ZVwiKSk7XG5cbiAgICBpZiAodFRpbWUgJiYgdHdlZW4uX3JlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdHdlZW4ucGFyZW50KSB7XG4gICAgICBfY2FsbGJhY2sodHdlZW4sIFwib25SZXBlYXRcIik7XG4gICAgfVxuXG4gICAgaWYgKCh0b3RhbFRpbWUgPj0gdHdlZW4uX3REdXIgfHwgdG90YWxUaW1lIDwgMCkgJiYgdHdlZW4ucmF0aW8gPT09IHJhdGlvKSB7XG4gICAgICB0d2Vlbi5yYXRpbyAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0d2VlbiwgMSk7XG5cbiAgICAgIGlmICghc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHR3ZWVuLCB0d2Vlbi5yYXRpbyA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICB0d2Vlbi5fcHJvbSAmJiB0d2Vlbi5fcHJvbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbiAgICBfZmluZE5leHRQYXVzZVR3ZWVuID0gZnVuY3Rpb24gX2ZpbmROZXh0UGF1c2VUd2VlbihhbmltYXRpb24sIHByZXZUaW1lLCB0aW1lKSB7XG4gIHZhciBjaGlsZDtcblxuICBpZiAodGltZSA+IHByZXZUaW1lKSB7XG4gICAgY2hpbGQgPSBhbmltYXRpb24uX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA8PSB0aW1lKSB7XG4gICAgICBpZiAoIWNoaWxkLl9kdXIgJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0ID4gcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fbGFzdDtcblxuICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5fc3RhcnQgPj0gdGltZSkge1xuICAgICAgaWYgKCFjaGlsZC5fZHVyICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIGNoaWxkLl9zdGFydCA8IHByZXZUaW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fcHJldjtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3NldER1cmF0aW9uID0gZnVuY3Rpb24gX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgZHVyYXRpb24sIHNraXBVbmNhY2hlKSB7XG4gIHZhciByZXBlYXQgPSBhbmltYXRpb24uX3JlcGVhdCxcbiAgICAgIGR1ciA9IF9yb3VuZChkdXJhdGlvbikgfHwgMDtcbiAgYW5pbWF0aW9uLl9kdXIgPSBkdXI7XG4gIGFuaW1hdGlvbi5fdER1ciA9ICFyZXBlYXQgPyBkdXIgOiByZXBlYXQgPCAwID8gMWUxMiA6IF9yb3VuZChkdXIgKiAocmVwZWF0ICsgMSkgKyBhbmltYXRpb24uX3JEZWxheSAqIHJlcGVhdCk7XG5cbiAgaWYgKGFuaW1hdGlvbi5fdGltZSA+IGR1cikge1xuICAgIGFuaW1hdGlvbi5fdGltZSA9IGR1cjtcbiAgICBhbmltYXRpb24uX3RUaW1lID0gTWF0aC5taW4oYW5pbWF0aW9uLl90VGltZSwgYW5pbWF0aW9uLl90RHVyKTtcbiAgfVxuXG4gICFza2lwVW5jYWNoZSAmJiBfdW5jYWNoZShhbmltYXRpb24ucGFyZW50KTtcbiAgYW5pbWF0aW9uLnBhcmVudCAmJiBfc2V0RW5kKGFuaW1hdGlvbik7XG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uIGluc3RhbmNlb2YgVGltZWxpbmUgPyBfdW5jYWNoZShhbmltYXRpb24pIDogX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl9kdXIpO1xufSxcbiAgICBfemVyb1Bvc2l0aW9uID0ge1xuICBfc3RhcnQ6IDAsXG4gIGVuZFRpbWU6IF9lbXB0eUZ1bmNcbn0sXG4gICAgX3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbiBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uKSB7XG4gIHZhciBsYWJlbHMgPSBhbmltYXRpb24ubGFiZWxzLFxuICAgICAgcmVjZW50ID0gYW5pbWF0aW9uLl9yZWNlbnQgfHwgX3plcm9Qb3NpdGlvbixcbiAgICAgIGNsaXBwZWREdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpID49IF9iaWdOdW0gPyByZWNlbnQuZW5kVGltZShmYWxzZSkgOiBhbmltYXRpb24uX2R1cixcbiAgICAgIC8vaW4gY2FzZSB0aGVyZSdzIGEgY2hpbGQgdGhhdCBpbmZpbml0ZWx5IHJlcGVhdHMsIHVzZXJzIGFsbW9zdCBuZXZlciBpbnRlbmQgZm9yIHRoZSBpbnNlcnRpb24gcG9pbnQgb2YgYSBuZXcgY2hpbGQgdG8gYmUgYmFzZWQgb24gYSBTVVBFUiBsb25nIHZhbHVlIGxpa2UgdGhhdCBzbyB3ZSBjbGlwIGl0IGFuZCBhc3N1bWUgdGhlIG1vc3QgcmVjZW50bHktYWRkZWQgY2hpbGQncyBlbmRUaW1lIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gIGksXG4gICAgICBvZmZzZXQ7XG5cbiAgaWYgKF9pc1N0cmluZyhwb3NpdGlvbikgJiYgKGlzTmFOKHBvc2l0aW9uKSB8fCBwb3NpdGlvbiBpbiBsYWJlbHMpKSB7XG4gICAgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cbiAgICBpID0gcG9zaXRpb24uY2hhckF0KDApO1xuXG4gICAgaWYgKGkgPT09IFwiPFwiIHx8IGkgPT09IFwiPlwiKSB7XG4gICAgICByZXR1cm4gKGkgPT09IFwiPFwiID8gcmVjZW50Ll9zdGFydCA6IHJlY2VudC5lbmRUaW1lKHJlY2VudC5fcmVwZWF0ID49IDApKSArIChwYXJzZUZsb2F0KHBvc2l0aW9uLnN1YnN0cigxKSkgfHwgMCk7XG4gICAgfVxuXG4gICAgaSA9IHBvc2l0aW9uLmluZGV4T2YoXCI9XCIpO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBpZiAoIShwb3NpdGlvbiBpbiBsYWJlbHMpKSB7XG4gICAgICAgIGxhYmVsc1twb3NpdGlvbl0gPSBjbGlwcGVkRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYWJlbHNbcG9zaXRpb25dO1xuICAgIH1cblxuICAgIG9mZnNldCA9ICsocG9zaXRpb24uY2hhckF0KGkgLSAxKSArIHBvc2l0aW9uLnN1YnN0cihpICsgMSkpO1xuICAgIHJldHVybiBpID4gMSA/IF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24uc3Vic3RyKDAsIGkgLSAxKSkgKyBvZmZzZXQgOiBjbGlwcGVkRHVyYXRpb24gKyBvZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb24gPT0gbnVsbCA/IGNsaXBwZWREdXJhdGlvbiA6ICtwb3NpdGlvbjtcbn0sXG4gICAgX2NvbmRpdGlvbmFsUmV0dXJuID0gZnVuY3Rpb24gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jKSB7XG4gIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IGZ1bmModmFsdWUpIDogZnVuYztcbn0sXG4gICAgX2NsYW1wID0gZnVuY3Rpb24gX2NsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xufSxcbiAgICBnZXRVbml0ID0gZnVuY3Rpb24gZ2V0VW5pdCh2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlICsgXCJcIikuc3Vic3RyKChwYXJzZUZsb2F0KHZhbHVlKSArIFwiXCIpLmxlbmd0aCk7XG59LFxuICAgIGNsYW1wID0gZnVuY3Rpb24gY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIF9jbGFtcChtaW4sIG1heCwgdik7XG4gIH0pO1xufSxcbiAgICBfc2xpY2UgPSBbXS5zbGljZSxcbiAgICBfaXNBcnJheUxpa2UgPSBmdW5jdGlvbiBfaXNBcnJheUxpa2UodmFsdWUsIG5vbkVtcHR5KSB7XG4gIHJldHVybiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWUpICYmIFwibGVuZ3RoXCIgaW4gdmFsdWUgJiYgKCFub25FbXB0eSAmJiAhdmFsdWUubGVuZ3RoIHx8IHZhbHVlLmxlbmd0aCAtIDEgaW4gdmFsdWUgJiYgX2lzT2JqZWN0KHZhbHVlWzBdKSkgJiYgIXZhbHVlLm5vZGVUeXBlICYmIHZhbHVlICE9PSBfd2luO1xufSxcbiAgICBfZmxhdHRlbiA9IGZ1bmN0aW9uIF9mbGF0dGVuKGFyLCBsZWF2ZVN0cmluZ3MsIGFjY3VtdWxhdG9yKSB7XG4gIGlmIChhY2N1bXVsYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgYWNjdW11bGF0b3IgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBhci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBfYWNjdW11bGF0b3I7XG5cbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzIHx8IF9pc0FycmF5TGlrZSh2YWx1ZSwgMSkgPyAoX2FjY3VtdWxhdG9yID0gYWNjdW11bGF0b3IpLnB1c2guYXBwbHkoX2FjY3VtdWxhdG9yLCB0b0FycmF5KHZhbHVlKSkgOiBhY2N1bXVsYXRvci5wdXNoKHZhbHVlKTtcbiAgfSkgfHwgYWNjdW11bGF0b3I7XG59LFxuICAgIC8vdGFrZXMgYW55IHZhbHVlIGFuZCByZXR1cm5zIGFuIGFycmF5LiBJZiBpdCdzIGEgc3RyaW5nIChhbmQgbGVhdmVTdHJpbmdzIGlzbid0IHRydWUpLCBpdCdsbCB1c2UgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgpIGFuZCBjb252ZXJ0IHRoYXQgdG8gYW4gYXJyYXkuIEl0J2xsIGFsc28gYWNjZXB0IGl0ZXJhYmxlcyBsaWtlIGpRdWVyeSBvYmplY3RzLlxudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUsIGxlYXZlU3RyaW5ncykge1xuICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzICYmIChfY29yZUluaXR0ZWQgfHwgIV93YWtlKCkpID8gX3NsaWNlLmNhbGwoX2RvYy5xdWVyeVNlbGVjdG9yQWxsKHZhbHVlKSwgMCkgOiBfaXNBcnJheSh2YWx1ZSkgPyBfZmxhdHRlbih2YWx1ZSwgbGVhdmVTdHJpbmdzKSA6IF9pc0FycmF5TGlrZSh2YWx1ZSkgPyBfc2xpY2UuY2FsbCh2YWx1ZSwgMCkgOiB2YWx1ZSA/IFt2YWx1ZV0gOiBbXTtcbn0sXG4gICAgc2h1ZmZsZSA9IGZ1bmN0aW9uIHNodWZmbGUoYSkge1xuICByZXR1cm4gYS5zb3J0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gLjUgLSBNYXRoLnJhbmRvbSgpO1xuICB9KTtcbn0sXG4gICAgLy8gYWx0ZXJuYXRpdmUgdGhhdCdzIGEgYml0IGZhc3RlciBhbmQgbW9yZSByZWxpYWJseSBkaXZlcnNlIGJ1dCBiaWdnZXI6ICAgZm9yIChsZXQgaiwgdiwgaSA9IGEubGVuZ3RoOyBpOyBqID0gfn4oTWF0aC5yYW5kb20oKSAqIGkpLCB2ID0gYVstLWldLCBhW2ldID0gYVtqXSwgYVtqXSA9IHYpOyByZXR1cm4gYTtcbi8vZm9yIGRpc3RyaWJ1dGluZyB2YWx1ZXMgYWNyb3NzIGFuIGFycmF5LiBDYW4gYWNjZXB0IGEgbnVtYmVyLCBhIGZ1bmN0aW9uIG9yIChtb3N0IGNvbW1vbmx5KSBhIGZ1bmN0aW9uIHdoaWNoIGNhbiBjb250YWluIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczoge2Jhc2UsIGFtb3VudCwgZnJvbSwgZWFzZSwgZ3JpZCwgYXhpcywgbGVuZ3RoLCBlYWNofS4gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6IGluZGV4LCB0YXJnZXQsIGFycmF5LiBSZWNvZ25pemVzIHRoZSBmb2xsb3dpbmdcbmRpc3RyaWJ1dGUgPSBmdW5jdGlvbiBkaXN0cmlidXRlKHYpIHtcbiAgaWYgKF9pc0Z1bmN0aW9uKHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICB2YXIgdmFycyA9IF9pc09iamVjdCh2KSA/IHYgOiB7XG4gICAgZWFjaDogdlxuICB9LFxuICAgICAgLy9uOjEgaXMganVzdCB0byBpbmRpY2F0ZSB2IHdhcyBhIG51bWJlcjsgd2UgbGV2ZXJhZ2UgdGhhdCBsYXRlciB0byBzZXQgdiBhY2NvcmRpbmcgdG8gdGhlIGxlbmd0aCB3ZSBnZXQuIElmIGEgbnVtYmVyIGlzIHBhc3NlZCBpbiwgd2UgdHJlYXQgaXQgbGlrZSB0aGUgb2xkIHN0YWdnZXIgdmFsdWUgd2hlcmUgMC4xLCBmb3IgZXhhbXBsZSwgd291bGQgbWVhbiB0aGF0IHRoaW5ncyB3b3VsZCBiZSBkaXN0cmlidXRlZCB3aXRoIDAuMSBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgcmF0aGVyIHRoYW4gYSB0b3RhbCBcImFtb3VudFwiIHRoYXQncyBjaHVua2VkIG91dCBhbW9uZyB0aGVtIGFsbC5cbiAgZWFzZSA9IF9wYXJzZUVhc2UodmFycy5lYXNlKSxcbiAgICAgIGZyb20gPSB2YXJzLmZyb20gfHwgMCxcbiAgICAgIGJhc2UgPSBwYXJzZUZsb2F0KHZhcnMuYmFzZSkgfHwgMCxcbiAgICAgIGNhY2hlID0ge30sXG4gICAgICBpc0RlY2ltYWwgPSBmcm9tID4gMCAmJiBmcm9tIDwgMSxcbiAgICAgIHJhdGlvcyA9IGlzTmFOKGZyb20pIHx8IGlzRGVjaW1hbCxcbiAgICAgIGF4aXMgPSB2YXJzLmF4aXMsXG4gICAgICByYXRpb1ggPSBmcm9tLFxuICAgICAgcmF0aW9ZID0gZnJvbTtcblxuICBpZiAoX2lzU3RyaW5nKGZyb20pKSB7XG4gICAgcmF0aW9YID0gcmF0aW9ZID0ge1xuICAgICAgY2VudGVyOiAuNSxcbiAgICAgIGVkZ2VzOiAuNSxcbiAgICAgIGVuZDogMVxuICAgIH1bZnJvbV0gfHwgMDtcbiAgfSBlbHNlIGlmICghaXNEZWNpbWFsICYmIHJhdGlvcykge1xuICAgIHJhdGlvWCA9IGZyb21bMF07XG4gICAgcmF0aW9ZID0gZnJvbVsxXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaSwgdGFyZ2V0LCBhKSB7XG4gICAgdmFyIGwgPSAoYSB8fCB2YXJzKS5sZW5ndGgsXG4gICAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdLFxuICAgICAgICBvcmlnaW5YLFxuICAgICAgICBvcmlnaW5ZLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBkLFxuICAgICAgICBqLFxuICAgICAgICBtYXgsXG4gICAgICAgIG1pbixcbiAgICAgICAgd3JhcEF0O1xuXG4gICAgaWYgKCFkaXN0YW5jZXMpIHtcbiAgICAgIHdyYXBBdCA9IHZhcnMuZ3JpZCA9PT0gXCJhdXRvXCIgPyAwIDogKHZhcnMuZ3JpZCB8fCBbMSwgX2JpZ051bV0pWzFdO1xuXG4gICAgICBpZiAoIXdyYXBBdCkge1xuICAgICAgICBtYXggPSAtX2JpZ051bTtcblxuICAgICAgICB3aGlsZSAobWF4IDwgKG1heCA9IGFbd3JhcEF0KytdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICYmIHdyYXBBdCA8IGwpIHt9XG5cbiAgICAgICAgd3JhcEF0LS07XG4gICAgICB9XG5cbiAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdID0gW107XG4gICAgICBvcmlnaW5YID0gcmF0aW9zID8gTWF0aC5taW4od3JhcEF0LCBsKSAqIHJhdGlvWCAtIC41IDogZnJvbSAlIHdyYXBBdDtcbiAgICAgIG9yaWdpblkgPSByYXRpb3MgPyBsICogcmF0aW9ZIC8gd3JhcEF0IC0gLjUgOiBmcm9tIC8gd3JhcEF0IHwgMDtcbiAgICAgIG1heCA9IDA7XG4gICAgICBtaW4gPSBfYmlnTnVtO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIHggPSBqICUgd3JhcEF0IC0gb3JpZ2luWDtcbiAgICAgICAgeSA9IG9yaWdpblkgLSAoaiAvIHdyYXBBdCB8IDApO1xuICAgICAgICBkaXN0YW5jZXNbal0gPSBkID0gIWF4aXMgPyBfc3FydCh4ICogeCArIHkgKiB5KSA6IE1hdGguYWJzKGF4aXMgPT09IFwieVwiID8geSA6IHgpO1xuXG4gICAgICAgIGlmIChkID4gbWF4KSB7XG4gICAgICAgICAgbWF4ID0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkIDwgbWluKSB7XG4gICAgICAgICAgbWluID0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tID09PSBcInJhbmRvbVwiICYmIHNodWZmbGUoZGlzdGFuY2VzKTtcbiAgICAgIGRpc3RhbmNlcy5tYXggPSBtYXggLSBtaW47XG4gICAgICBkaXN0YW5jZXMubWluID0gbWluO1xuICAgICAgZGlzdGFuY2VzLnYgPSBsID0gKHBhcnNlRmxvYXQodmFycy5hbW91bnQpIHx8IHBhcnNlRmxvYXQodmFycy5lYWNoKSAqICh3cmFwQXQgPiBsID8gbCAtIDEgOiAhYXhpcyA/IE1hdGgubWF4KHdyYXBBdCwgbCAvIHdyYXBBdCkgOiBheGlzID09PSBcInlcIiA/IGwgLyB3cmFwQXQgOiB3cmFwQXQpIHx8IDApICogKGZyb20gPT09IFwiZWRnZXNcIiA/IC0xIDogMSk7XG4gICAgICBkaXN0YW5jZXMuYiA9IGwgPCAwID8gYmFzZSAtIGwgOiBiYXNlO1xuICAgICAgZGlzdGFuY2VzLnUgPSBnZXRVbml0KHZhcnMuYW1vdW50IHx8IHZhcnMuZWFjaCkgfHwgMDsgLy91bml0XG5cbiAgICAgIGVhc2UgPSBlYXNlICYmIGwgPCAwID8gX2ludmVydEVhc2UoZWFzZSkgOiBlYXNlO1xuICAgIH1cblxuICAgIGwgPSAoZGlzdGFuY2VzW2ldIC0gZGlzdGFuY2VzLm1pbikgLyBkaXN0YW5jZXMubWF4IHx8IDA7XG4gICAgcmV0dXJuIF9yb3VuZChkaXN0YW5jZXMuYiArIChlYXNlID8gZWFzZShsKSA6IGwpICogZGlzdGFuY2VzLnYpICsgZGlzdGFuY2VzLnU7IC8vcm91bmQgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gIH07XG59LFxuICAgIF9yb3VuZE1vZGlmaWVyID0gZnVuY3Rpb24gX3JvdW5kTW9kaWZpZXIodikge1xuICAvL3Bhc3MgaW4gMC4xIGdldCBhIGZ1bmN0aW9uIHRoYXQnbGwgcm91bmQgdG8gdGhlIG5lYXJlc3QgdGVudGgsIG9yIDUgdG8gcm91bmQgdG8gdGhlIGNsb3Nlc3QgNSwgb3IgMC4wMDEgdG8gdGhlIGNsb3Nlc3QgMTAwMHRoLCBldGMuXG4gIHZhciBwID0gdiA8IDEgPyBNYXRoLnBvdygxMCwgKHYgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDE7IC8vdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGxpa2UgMjQgKiAwLjEgPT0gMi40MDAwMDAwMDAwMDAwMDA0KSwgd2UgY2hvcCBvZmYgYXQgYSBzcGVjaWZpYyBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKG11Y2ggZmFzdGVyIHRoYW4gdG9GaXhlZCgpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyYXcpIHtcbiAgICByZXR1cm4gfn4oTWF0aC5yb3VuZChwYXJzZUZsb2F0KHJhdykgLyB2KSAqIHYgKiBwKSAvIHAgKyAoX2lzTnVtYmVyKHJhdykgPyAwIDogZ2V0VW5pdChyYXcpKTtcbiAgfTtcbn0sXG4gICAgc25hcCA9IGZ1bmN0aW9uIHNuYXAoc25hcFRvLCB2YWx1ZSkge1xuICB2YXIgaXNBcnJheSA9IF9pc0FycmF5KHNuYXBUbyksXG4gICAgICByYWRpdXMsXG4gICAgICBpczJEO1xuXG4gIGlmICghaXNBcnJheSAmJiBfaXNPYmplY3Qoc25hcFRvKSkge1xuICAgIHJhZGl1cyA9IGlzQXJyYXkgPSBzbmFwVG8ucmFkaXVzIHx8IF9iaWdOdW07XG5cbiAgICBpZiAoc25hcFRvLnZhbHVlcykge1xuICAgICAgc25hcFRvID0gdG9BcnJheShzbmFwVG8udmFsdWVzKTtcblxuICAgICAgaWYgKGlzMkQgPSAhX2lzTnVtYmVyKHNuYXBUb1swXSkpIHtcbiAgICAgICAgcmFkaXVzICo9IHJhZGl1czsgLy9wZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gc28gd2UgZG9uJ3QgaGF2ZSB0byBNYXRoLnNxcnQoKSBpbiB0aGUgbG9vcC5cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc25hcFRvID0gX3JvdW5kTW9kaWZpZXIoc25hcFRvLmluY3JlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgIWlzQXJyYXkgPyBfcm91bmRNb2RpZmllcihzbmFwVG8pIDogX2lzRnVuY3Rpb24oc25hcFRvKSA/IGZ1bmN0aW9uIChyYXcpIHtcbiAgICBpczJEID0gc25hcFRvKHJhdyk7XG4gICAgcmV0dXJuIE1hdGguYWJzKGlzMkQgLSByYXcpIDw9IHJhZGl1cyA/IGlzMkQgOiByYXc7XG4gIH0gOiBmdW5jdGlvbiAocmF3KSB7XG4gICAgdmFyIHggPSBwYXJzZUZsb2F0KGlzMkQgPyByYXcueCA6IHJhdyksXG4gICAgICAgIHkgPSBwYXJzZUZsb2F0KGlzMkQgPyByYXcueSA6IDApLFxuICAgICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgICBjbG9zZXN0ID0gMCxcbiAgICAgICAgaSA9IHNuYXBUby5sZW5ndGgsXG4gICAgICAgIGR4LFxuICAgICAgICBkeTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChpczJEKSB7XG4gICAgICAgIGR4ID0gc25hcFRvW2ldLnggLSB4O1xuICAgICAgICBkeSA9IHNuYXBUb1tpXS55IC0geTtcbiAgICAgICAgZHggPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gTWF0aC5hYnMoc25hcFRvW2ldIC0geCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkeCA8IG1pbikge1xuICAgICAgICBtaW4gPSBkeDtcbiAgICAgICAgY2xvc2VzdCA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VzdCA9ICFyYWRpdXMgfHwgbWluIDw9IHJhZGl1cyA/IHNuYXBUb1tjbG9zZXN0XSA6IHJhdztcbiAgICByZXR1cm4gaXMyRCB8fCBjbG9zZXN0ID09PSByYXcgfHwgX2lzTnVtYmVyKHJhdykgPyBjbG9zZXN0IDogY2xvc2VzdCArIGdldFVuaXQocmF3KTtcbiAgfSk7XG59LFxuICAgIHJhbmRvbSA9IGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgcm91bmRpbmdJbmNyZW1lbnQsIHJldHVybkZ1bmN0aW9uKSB7XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4oX2lzQXJyYXkobWluKSA/ICFtYXggOiByb3VuZGluZ0luY3JlbWVudCA9PT0gdHJ1ZSA/ICEhKHJvdW5kaW5nSW5jcmVtZW50ID0gMCkgOiAhcmV0dXJuRnVuY3Rpb24sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzQXJyYXkobWluKSA/IG1pblt+fihNYXRoLnJhbmRvbSgpICogbWluLmxlbmd0aCldIDogKHJvdW5kaW5nSW5jcmVtZW50ID0gcm91bmRpbmdJbmNyZW1lbnQgfHwgMWUtNSkgJiYgKHJldHVybkZ1bmN0aW9uID0gcm91bmRpbmdJbmNyZW1lbnQgPCAxID8gTWF0aC5wb3coMTAsIChyb3VuZGluZ0luY3JlbWVudCArIFwiXCIpLmxlbmd0aCAtIDIpIDogMSkgJiYgfn4oTWF0aC5yb3VuZCgobWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSAvIHJvdW5kaW5nSW5jcmVtZW50KSAqIHJvdW5kaW5nSW5jcmVtZW50ICogcmV0dXJuRnVuY3Rpb24pIC8gcmV0dXJuRnVuY3Rpb247XG4gIH0pO1xufSxcbiAgICBwaXBlID0gZnVuY3Rpb24gcGlwZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmN0aW9ucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHYsIGYpIHtcbiAgICAgIHJldHVybiBmKHYpO1xuICAgIH0sIHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgdW5pdGl6ZSA9IGZ1bmN0aW9uIHVuaXRpemUoZnVuYywgdW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmMocGFyc2VGbG9hdCh2YWx1ZSkpICsgKHVuaXQgfHwgZ2V0VW5pdCh2YWx1ZSkpO1xuICB9O1xufSxcbiAgICBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBtYXBSYW5nZShtaW4sIG1heCwgMCwgMSwgdmFsdWUpO1xufSxcbiAgICBfd3JhcEFycmF5ID0gZnVuY3Rpb24gX3dyYXBBcnJheShhLCB3cmFwcGVyLCB2YWx1ZSkge1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gYVt+fndyYXBwZXIoaW5kZXgpXTtcbiAgfSk7XG59LFxuICAgIHdyYXAgPSBmdW5jdGlvbiB3cmFwKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAvLyBOT1RFOiB3cmFwKCkgQ0FOTk9UIGJlIGFuIGFycm93IGZ1bmN0aW9uISBBIHZlcnkgb2RkIGNvbXBpbGluZyBidWcgY2F1c2VzIHByb2JsZW1zICh1bnJlbGF0ZWQgdG8gR1NBUCkuXG4gIHZhciByYW5nZSA9IG1heCAtIG1pbjtcbiAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcCgwLCBtaW4ubGVuZ3RoKSwgbWF4KSA6IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIChyYW5nZSArICh2YWx1ZSAtIG1pbikgJSByYW5nZSkgJSByYW5nZSArIG1pbjtcbiAgfSk7XG59LFxuICAgIHdyYXBZb3lvID0gZnVuY3Rpb24gd3JhcFlveW8obWluLCBtYXgsIHZhbHVlKSB7XG4gIHZhciByYW5nZSA9IG1heCAtIG1pbixcbiAgICAgIHRvdGFsID0gcmFuZ2UgKiAyO1xuICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwWW95bygwLCBtaW4ubGVuZ3RoIC0gMSksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhbHVlID0gKHRvdGFsICsgKHZhbHVlIC0gbWluKSAlIHRvdGFsKSAlIHRvdGFsO1xuICAgIHJldHVybiBtaW4gKyAodmFsdWUgPiByYW5nZSA/IHRvdGFsIC0gdmFsdWUgOiB2YWx1ZSk7XG4gIH0pO1xufSxcbiAgICBfcmVwbGFjZVJhbmRvbSA9IGZ1bmN0aW9uIF9yZXBsYWNlUmFuZG9tKHZhbHVlKSB7XG4gIC8vcmVwbGFjZXMgYWxsIG9jY3VycmVuY2VzIG9mIHJhbmRvbSguLi4pIGluIGEgc3RyaW5nIHdpdGggdGhlIGNhbGN1bGF0ZWQgcmFuZG9tIHZhbHVlLiBjYW4gYmUgYSByYW5nZSBsaWtlIHJhbmRvbSgtMTAwLCAxMDAsIDUpIG9yIGFuIGFycmF5IGxpa2UgcmFuZG9tKFswLCAxMDAsIDUwMF0pXG4gIHZhciBwcmV2ID0gMCxcbiAgICAgIHMgPSBcIlwiLFxuICAgICAgaSxcbiAgICAgIG51bXMsXG4gICAgICBlbmQsXG4gICAgICBpc0FycmF5O1xuXG4gIHdoaWxlICh+KGkgPSB2YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiLCBwcmV2KSkpIHtcbiAgICBlbmQgPSB2YWx1ZS5pbmRleE9mKFwiKVwiLCBpKTtcbiAgICBpc0FycmF5ID0gdmFsdWUuY2hhckF0KGkgKyA3KSA9PT0gXCJbXCI7XG4gICAgbnVtcyA9IHZhbHVlLnN1YnN0cihpICsgNywgZW5kIC0gaSAtIDcpLm1hdGNoKGlzQXJyYXkgPyBfZGVsaW1pdGVkVmFsdWVFeHAgOiBfc3RyaWN0TnVtRXhwKTtcbiAgICBzICs9IHZhbHVlLnN1YnN0cihwcmV2LCBpIC0gcHJldikgKyByYW5kb20oaXNBcnJheSA/IG51bXMgOiArbnVtc1swXSwgK251bXNbMV0sICtudW1zWzJdIHx8IDFlLTUpO1xuICAgIHByZXYgPSBlbmQgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHMgKyB2YWx1ZS5zdWJzdHIocHJldiwgdmFsdWUubGVuZ3RoIC0gcHJldik7XG59LFxuICAgIG1hcFJhbmdlID0gZnVuY3Rpb24gbWFwUmFuZ2UoaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCwgdmFsdWUpIHtcbiAgdmFyIGluUmFuZ2UgPSBpbk1heCAtIGluTWluLFxuICAgICAgb3V0UmFuZ2UgPSBvdXRNYXggLSBvdXRNaW47XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBvdXRNaW4gKyAodmFsdWUgLSBpbk1pbikgLyBpblJhbmdlICogb3V0UmFuZ2U7XG4gIH0pO1xufSxcbiAgICBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIGludGVycG9sYXRlKHN0YXJ0LCBlbmQsIHByb2dyZXNzLCBtdXRhdGUpIHtcbiAgdmFyIGZ1bmMgPSBpc05hTihzdGFydCArIGVuZCkgPyAwIDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gKDEgLSBwKSAqIHN0YXJ0ICsgcCAqIGVuZDtcbiAgfTtcblxuICBpZiAoIWZ1bmMpIHtcbiAgICB2YXIgaXNTdHJpbmcgPSBfaXNTdHJpbmcoc3RhcnQpLFxuICAgICAgICBtYXN0ZXIgPSB7fSxcbiAgICAgICAgcCxcbiAgICAgICAgaSxcbiAgICAgICAgaW50ZXJwb2xhdG9ycyxcbiAgICAgICAgbCxcbiAgICAgICAgaWw7XG5cbiAgICBwcm9ncmVzcyA9PT0gdHJ1ZSAmJiAobXV0YXRlID0gMSkgJiYgKHByb2dyZXNzID0gbnVsbCk7XG5cbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHN0YXJ0ID0ge1xuICAgICAgICBwOiBzdGFydFxuICAgICAgfTtcbiAgICAgIGVuZCA9IHtcbiAgICAgICAgcDogZW5kXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX2lzQXJyYXkoc3RhcnQpICYmICFfaXNBcnJheShlbmQpKSB7XG4gICAgICBpbnRlcnBvbGF0b3JzID0gW107XG4gICAgICBsID0gc3RhcnQubGVuZ3RoO1xuICAgICAgaWwgPSBsIC0gMjtcblxuICAgICAgZm9yIChpID0gMTsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnRlcnBvbGF0b3JzLnB1c2goaW50ZXJwb2xhdGUoc3RhcnRbaSAtIDFdLCBzdGFydFtpXSkpOyAvL2J1aWxkIHRoZSBpbnRlcnBvbGF0b3JzIHVwIGZyb250IGFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHNvIHRoYXQgd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG1hbnkgdGltZXMsIGl0IGNhbiBqdXN0IHJldXNlIHRoZW0uXG4gICAgICB9XG5cbiAgICAgIGwtLTtcblxuICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMocCkge1xuICAgICAgICBwICo9IGw7XG4gICAgICAgIHZhciBpID0gTWF0aC5taW4oaWwsIH5+cCk7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0b3JzW2ldKHAgLSBpKTtcbiAgICAgIH07XG5cbiAgICAgIHByb2dyZXNzID0gZW5kO1xuICAgIH0gZWxzZSBpZiAoIW11dGF0ZSkge1xuICAgICAgc3RhcnQgPSBfbWVyZ2UoX2lzQXJyYXkoc3RhcnQpID8gW10gOiB7fSwgc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICghaW50ZXJwb2xhdG9ycykge1xuICAgICAgZm9yIChwIGluIGVuZCkge1xuICAgICAgICBfYWRkUHJvcFR3ZWVuLmNhbGwobWFzdGVyLCBzdGFydCwgcCwgXCJnZXRcIiwgZW5kW3BdKTtcbiAgICAgIH1cblxuICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMocCkge1xuICAgICAgICByZXR1cm4gX3JlbmRlclByb3BUd2VlbnMocCwgbWFzdGVyKSB8fCAoaXNTdHJpbmcgPyBzdGFydC5wIDogc3RhcnQpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHByb2dyZXNzLCBmdW5jKTtcbn0sXG4gICAgX2dldExhYmVsSW5EaXJlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aW1lbGluZSwgZnJvbVRpbWUsIGJhY2t3YXJkKSB7XG4gIC8vdXNlZCBmb3IgbmV4dExhYmVsKCkgYW5kIHByZXZpb3VzTGFiZWwoKVxuICB2YXIgbGFiZWxzID0gdGltZWxpbmUubGFiZWxzLFxuICAgICAgbWluID0gX2JpZ051bSxcbiAgICAgIHAsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGxhYmVsO1xuXG4gIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICBkaXN0YW5jZSA9IGxhYmVsc1twXSAtIGZyb21UaW1lO1xuXG4gICAgaWYgKGRpc3RhbmNlIDwgMCA9PT0gISFiYWNrd2FyZCAmJiBkaXN0YW5jZSAmJiBtaW4gPiAoZGlzdGFuY2UgPSBNYXRoLmFicyhkaXN0YW5jZSkpKSB7XG4gICAgICBsYWJlbCA9IHA7XG4gICAgICBtaW4gPSBkaXN0YW5jZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFiZWw7XG59LFxuICAgIF9jYWxsYmFjayA9IGZ1bmN0aW9uIF9jYWxsYmFjayhhbmltYXRpb24sIHR5cGUsIGV4ZWN1dGVMYXp5Rmlyc3QpIHtcbiAgdmFyIHYgPSBhbmltYXRpb24udmFycyxcbiAgICAgIGNhbGxiYWNrID0gdlt0eXBlXSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHNjb3BlO1xuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwYXJhbXMgPSB2W3R5cGUgKyBcIlBhcmFtc1wiXTtcbiAgc2NvcGUgPSB2LmNhbGxiYWNrU2NvcGUgfHwgYW5pbWF0aW9uO1xuICBleGVjdXRlTGF6eUZpcnN0ICYmIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiBfbGF6eVJlbmRlcigpOyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uVXBkYXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblxuICByZXR1cm4gcGFyYW1zID8gY2FsbGJhY2suYXBwbHkoc2NvcGUsIHBhcmFtcykgOiBjYWxsYmFjay5jYWxsKHNjb3BlKTtcbn0sXG4gICAgX2ludGVycnVwdCA9IGZ1bmN0aW9uIF9pbnRlcnJ1cHQoYW5pbWF0aW9uKSB7XG4gIF9yZW1vdmVGcm9tUGFyZW50KGFuaW1hdGlvbik7XG5cbiAgaWYgKGFuaW1hdGlvbi5wcm9ncmVzcygpIDwgMSkge1xuICAgIF9jYWxsYmFjayhhbmltYXRpb24sIFwib25JbnRlcnJ1cHRcIik7XG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfcXVpY2tUd2VlbixcbiAgICBfY3JlYXRlUGx1Z2luID0gZnVuY3Rpb24gX2NyZWF0ZVBsdWdpbihjb25maWcpIHtcbiAgY29uZmlnID0gIWNvbmZpZy5uYW1lICYmIGNvbmZpZ1tcImRlZmF1bHRcIl0gfHwgY29uZmlnOyAvL1VNRCBwYWNrYWdpbmcgd3JhcHMgdGhpbmdzIG9kZGx5LCBzbyBmb3IgZXhhbXBsZSBNb3Rpb25QYXRoSGVscGVyIGJlY29tZXMge01vdGlvblBhdGhIZWxwZXI6TW90aW9uUGF0aEhlbHBlciwgZGVmYXVsdDpNb3Rpb25QYXRoSGVscGVyfS5cblxuICB2YXIgbmFtZSA9IGNvbmZpZy5uYW1lLFxuICAgICAgaXNGdW5jID0gX2lzRnVuY3Rpb24oY29uZmlnKSxcbiAgICAgIFBsdWdpbiA9IG5hbWUgJiYgIWlzRnVuYyAmJiBjb25maWcuaW5pdCA/IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm9wcyA9IFtdO1xuICB9IDogY29uZmlnLFxuICAgICAgLy9pbiBjYXNlIHNvbWVvbmUgcGFzc2VzIGluIGFuIG9iamVjdCB0aGF0J3Mgbm90IGEgcGx1Z2luLCBsaWtlIEN1c3RvbUVhc2VcbiAgaW5zdGFuY2VEZWZhdWx0cyA9IHtcbiAgICBpbml0OiBfZW1wdHlGdW5jLFxuICAgIHJlbmRlcjogX3JlbmRlclByb3BUd2VlbnMsXG4gICAgYWRkOiBfYWRkUHJvcFR3ZWVuLFxuICAgIGtpbGw6IF9raWxsUHJvcFR3ZWVuc09mLFxuICAgIG1vZGlmaWVyOiBfYWRkUGx1Z2luTW9kaWZpZXIsXG4gICAgcmF3VmFyczogMFxuICB9LFxuICAgICAgc3RhdGljcyA9IHtcbiAgICB0YXJnZXRUZXN0OiAwLFxuICAgIGdldDogMCxcbiAgICBnZXRTZXR0ZXI6IF9nZXRTZXR0ZXIsXG4gICAgYWxpYXNlczoge30sXG4gICAgcmVnaXN0ZXI6IDBcbiAgfTtcblxuICBfd2FrZSgpO1xuXG4gIGlmIChjb25maWcgIT09IFBsdWdpbikge1xuICAgIGlmIChfcGx1Z2luc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9zZXREZWZhdWx0cyhQbHVnaW4sIF9zZXREZWZhdWx0cyhfY29weUV4Y2x1ZGluZyhjb25maWcsIGluc3RhbmNlRGVmYXVsdHMpLCBzdGF0aWNzKSk7IC8vc3RhdGljIG1ldGhvZHNcblxuXG4gICAgX21lcmdlKFBsdWdpbi5wcm90b3R5cGUsIF9tZXJnZShpbnN0YW5jZURlZmF1bHRzLCBfY29weUV4Y2x1ZGluZyhjb25maWcsIHN0YXRpY3MpKSk7IC8vaW5zdGFuY2UgbWV0aG9kc1xuXG5cbiAgICBfcGx1Z2luc1tQbHVnaW4ucHJvcCA9IG5hbWVdID0gUGx1Z2luO1xuXG4gICAgaWYgKGNvbmZpZy50YXJnZXRUZXN0KSB7XG4gICAgICBfaGFybmVzc1BsdWdpbnMucHVzaChQbHVnaW4pO1xuXG4gICAgICBfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDE7XG4gICAgfVxuXG4gICAgbmFtZSA9IChuYW1lID09PSBcImNzc1wiID8gXCJDU1NcIiA6IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKSkgKyBcIlBsdWdpblwiOyAvL2ZvciB0aGUgZ2xvYmFsIG5hbWUuIFwibW90aW9uUGF0aFwiIHNob3VsZCBiZWNvbWUgTW90aW9uUGF0aFBsdWdpblxuICB9XG5cbiAgX2FkZEdsb2JhbChuYW1lLCBQbHVnaW4pO1xuXG4gIGlmIChjb25maWcucmVnaXN0ZXIpIHtcbiAgICBjb25maWcucmVnaXN0ZXIoZ3NhcCwgUGx1Z2luLCBQcm9wVHdlZW4pO1xuICB9XG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENPTE9SU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXzI1NSA9IDI1NSxcbiAgICBfY29sb3JMb29rdXAgPSB7XG4gIGFxdWE6IFswLCBfMjU1LCBfMjU1XSxcbiAgbGltZTogWzAsIF8yNTUsIDBdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgYmxhY2s6IFswLCAwLCAwXSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgYmx1ZTogWzAsIDAsIF8yNTVdLFxuICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgd2hpdGU6IFtfMjU1LCBfMjU1LCBfMjU1XSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIHllbGxvdzogW18yNTUsIF8yNTUsIDBdLFxuICBvcmFuZ2U6IFtfMjU1LCAxNjUsIDBdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICByZWQ6IFtfMjU1LCAwLCAwXSxcbiAgcGluazogW18yNTUsIDE5MiwgMjAzXSxcbiAgY3lhbjogWzAsIF8yNTUsIF8yNTVdLFxuICB0cmFuc3BhcmVudDogW18yNTUsIF8yNTUsIF8yNTUsIDBdXG59LFxuICAgIF9odWUgPSBmdW5jdGlvbiBfaHVlKGgsIG0xLCBtMikge1xuICBoID0gaCA8IDAgPyBoICsgMSA6IGggPiAxID8gaCAtIDEgOiBoO1xuICByZXR1cm4gKGggKiA2IDwgMSA/IG0xICsgKG0yIC0gbTEpICogaCAqIDYgOiBoIDwgLjUgPyBtMiA6IGggKiAzIDwgMiA/IG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2IDogbTEpICogXzI1NSArIC41IHwgMDtcbn0sXG4gICAgc3BsaXRDb2xvciA9IGZ1bmN0aW9uIHNwbGl0Q29sb3IodiwgdG9IU0wsIGZvcmNlQWxwaGEpIHtcbiAgdmFyIGEgPSAhdiA/IF9jb2xvckxvb2t1cC5ibGFjayA6IF9pc051bWJlcih2KSA/IFt2ID4+IDE2LCB2ID4+IDggJiBfMjU1LCB2ICYgXzI1NV0gOiAwLFxuICAgICAgcixcbiAgICAgIGcsXG4gICAgICBiLFxuICAgICAgaCxcbiAgICAgIHMsXG4gICAgICBsLFxuICAgICAgbWF4LFxuICAgICAgbWluLFxuICAgICAgZCxcbiAgICAgIHdhc0hTTDtcblxuICBpZiAoIWEpIHtcbiAgICBpZiAodi5zdWJzdHIoLTEpID09PSBcIixcIikge1xuICAgICAgLy9zb21ldGltZXMgYSB0cmFpbGluZyBjb21tYSBpcyBpbmNsdWRlZCBhbmQgd2Ugc2hvdWxkIGNob3AgaXQgb2ZmICh0eXBpY2FsbHkgZnJvbSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyBsaWtlIGEgdGV4dFNoYWRvdzpcIjJweCAycHggMnB4IGJsdWUsIDVweCA1cHggNXB4IHJnYigyNTUsMCwwKVwiIC0gaW4gdGhpcyBleGFtcGxlIFwiYmx1ZSxcIiBoYXMgYSB0cmFpbGluZyBjb21tYS4gV2UgY291bGQgc3RyaXAgaXQgb3V0IGluc2lkZSBwYXJzZUNvbXBsZXgoKSBidXQgd2UnZCBuZWVkIHRvIGRvIGl0IHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgcGx1cyBpdCB3b3VsZG4ndCBwcm92aWRlIHByb3RlY3Rpb24gZnJvbSBvdGhlciBwb3RlbnRpYWwgc2NlbmFyaW9zIGxpa2UgaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgc2ltaWxhciB2YWx1ZS5cbiAgICAgIHYgPSB2LnN1YnN0cigwLCB2Lmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmIChfY29sb3JMb29rdXBbdl0pIHtcbiAgICAgIGEgPSBfY29sb3JMb29rdXBbdl07XG4gICAgfSBlbHNlIGlmICh2LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgIGlmICh2Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAvL2ZvciBzaG9ydGhhbmQgbGlrZSAjOUYwXG4gICAgICAgIHIgPSB2LmNoYXJBdCgxKTtcbiAgICAgICAgZyA9IHYuY2hhckF0KDIpO1xuICAgICAgICBiID0gdi5jaGFyQXQoMyk7XG4gICAgICAgIHYgPSBcIiNcIiArIHIgKyByICsgZyArIGcgKyBiICsgYjtcbiAgICAgIH1cblxuICAgICAgdiA9IHBhcnNlSW50KHYuc3Vic3RyKDEpLCAxNik7XG4gICAgICBhID0gW3YgPj4gMTYsIHYgPj4gOCAmIF8yNTUsIHYgJiBfMjU1XTtcbiAgICB9IGVsc2UgaWYgKHYuc3Vic3RyKDAsIDMpID09PSBcImhzbFwiKSB7XG4gICAgICBhID0gd2FzSFNMID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKTtcblxuICAgICAgaWYgKCF0b0hTTCkge1xuICAgICAgICBoID0gK2FbMF0gJSAzNjAgLyAzNjA7XG4gICAgICAgIHMgPSArYVsxXSAvIDEwMDtcbiAgICAgICAgbCA9ICthWzJdIC8gMTAwO1xuICAgICAgICBnID0gbCA8PSAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgciA9IGwgKiAyIC0gZztcblxuICAgICAgICBpZiAoYS5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgYVszXSAqPSAxOyAvL2Nhc3QgYXMgbnVtYmVyXG4gICAgICAgIH1cblxuICAgICAgICBhWzBdID0gX2h1ZShoICsgMSAvIDMsIHIsIGcpO1xuICAgICAgICBhWzFdID0gX2h1ZShoLCByLCBnKTtcbiAgICAgICAgYVsyXSA9IF9odWUoaCAtIDEgLyAzLCByLCBnKTtcbiAgICAgIH0gZWxzZSBpZiAofnYuaW5kZXhPZihcIj1cIikpIHtcbiAgICAgICAgLy9pZiByZWxhdGl2ZSB2YWx1ZXMgYXJlIGZvdW5kLCBqdXN0IHJldHVybiB0aGUgcmF3IHN0cmluZ3Mgd2l0aCB0aGUgcmVsYXRpdmUgcHJlZml4ZXMgaW4gcGxhY2UuXG4gICAgICAgIGEgPSB2Lm1hdGNoKF9udW1FeHApO1xuICAgICAgICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IHYubWF0Y2goX3N0cmljdE51bUV4cCkgfHwgX2NvbG9yTG9va3VwLnRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgIGEgPSBhLm1hcChOdW1iZXIpO1xuICB9XG5cbiAgaWYgKHRvSFNMICYmICF3YXNIU0wpIHtcbiAgICByID0gYVswXSAvIF8yNTU7XG4gICAgZyA9IGFbMV0gLyBfMjU1O1xuICAgIGIgPSBhWzJdIC8gXzI1NTtcbiAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBoID0gcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBtYXggLSBtaW47XG4gICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICBoID0gbWF4ID09PSByID8gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCkgOiBtYXggPT09IGcgPyAoYiAtIHIpIC8gZCArIDIgOiAociAtIGcpIC8gZCArIDQ7XG4gICAgICBoICo9IDYwO1xuICAgIH1cblxuICAgIGFbMF0gPSB+fihoICsgLjUpO1xuICAgIGFbMV0gPSB+fihzICogMTAwICsgLjUpO1xuICAgIGFbMl0gPSB+fihsICogMTAwICsgLjUpO1xuICB9XG5cbiAgZm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcbiAgcmV0dXJuIGE7XG59LFxuICAgIF9jb2xvck9yZGVyRGF0YSA9IGZ1bmN0aW9uIF9jb2xvck9yZGVyRGF0YSh2KSB7XG4gIC8vIHN0cmlwcyBvdXQgdGhlIGNvbG9ycyBmcm9tIHRoZSBzdHJpbmcsIGZpbmRzIGFsbCB0aGUgbnVtZXJpYyBzbG90cyAod2l0aCB1bml0cykgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhvc2UuIFRoZSBBcnJheSBhbHNvIGhhcyBhIFwiY1wiIHByb3BlcnR5IHdoaWNoIGlzIGFuIEFycmF5IG9mIHRoZSBpbmRleCB2YWx1ZXMgd2hlcmUgdGhlIGNvbG9ycyBiZWxvbmcuIFRoaXMgaXMgdG8gaGVscCB3b3JrIGFyb3VuZCBpc3N1ZXMgd2hlcmUgdGhlcmUncyBhIG1pcy1tYXRjaGVkIG9yZGVyIG9mIGNvbG9yL251bWVyaWMgZGF0YSBsaWtlIGRyb3Atc2hhZG93KCNmMDAgMHB4IDFweCAycHgpIGFuZCBkcm9wLXNoYWRvdygweCAxcHggMnB4ICNmMDApLiBUaGlzIGlzIGJhc2ljYWxseSBhIGhlbHBlciBmdW5jdGlvbiB1c2VkIGluIF9mb3JtYXRDb2xvcnMoKVxuICB2YXIgdmFsdWVzID0gW10sXG4gICAgICBjID0gW10sXG4gICAgICBpID0gLTE7XG4gIHYuc3BsaXQoX2NvbG9yRXhwKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGEgPSB2Lm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG4gICAgdmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCBhKTtcbiAgICBjLnB1c2goaSArPSBhLmxlbmd0aCArIDEpO1xuICB9KTtcbiAgdmFsdWVzLmMgPSBjO1xuICByZXR1cm4gdmFsdWVzO1xufSxcbiAgICBfZm9ybWF0Q29sb3JzID0gZnVuY3Rpb24gX2Zvcm1hdENvbG9ycyhzLCB0b0hTTCwgb3JkZXJNYXRjaERhdGEpIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCIsXG4gICAgICBjb2xvcnMgPSAocyArIHJlc3VsdCkubWF0Y2goX2NvbG9yRXhwKSxcbiAgICAgIHR5cGUgPSB0b0hTTCA/IFwiaHNsYShcIiA6IFwicmdiYShcIixcbiAgICAgIGkgPSAwLFxuICAgICAgYyxcbiAgICAgIHNoZWxsLFxuICAgICAgZCxcbiAgICAgIGw7XG5cbiAgaWYgKCFjb2xvcnMpIHtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgcmV0dXJuIChjb2xvciA9IHNwbGl0Q29sb3IoY29sb3IsIHRvSFNMLCAxKSkgJiYgdHlwZSArICh0b0hTTCA/IGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiJSxcIiArIGNvbG9yWzJdICsgXCIlLFwiICsgY29sb3JbM10gOiBjb2xvci5qb2luKFwiLFwiKSkgKyBcIilcIjtcbiAgfSk7XG5cbiAgaWYgKG9yZGVyTWF0Y2hEYXRhKSB7XG4gICAgZCA9IF9jb2xvck9yZGVyRGF0YShzKTtcbiAgICBjID0gb3JkZXJNYXRjaERhdGEuYztcblxuICAgIGlmIChjLmpvaW4ocmVzdWx0KSAhPT0gZC5jLmpvaW4ocmVzdWx0KSkge1xuICAgICAgc2hlbGwgPSBzLnJlcGxhY2UoX2NvbG9yRXhwLCBcIjFcIikuc3BsaXQoX251bVdpdGhVbml0RXhwKTtcbiAgICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyAofmMuaW5kZXhPZihpKSA/IGNvbG9ycy5zaGlmdCgpIHx8IHR5cGUgKyBcIjAsMCwwLDApXCIgOiAoZC5sZW5ndGggPyBkIDogY29sb3JzLmxlbmd0aCA/IGNvbG9ycyA6IG9yZGVyTWF0Y2hEYXRhKS5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXNoZWxsKSB7XG4gICAgc2hlbGwgPSBzLnNwbGl0KF9jb2xvckV4cCk7XG4gICAgbCA9IHNoZWxsLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHNoZWxsW2ldICsgY29sb3JzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzaGVsbFtsXTtcbn0sXG4gICAgX2NvbG9yRXhwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcyA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMoPzpbMC05YS1mXXszfSl7MSwyfVxcXFxiXCIsXG4gICAgICAvL3dlJ2xsIGR5bmFtaWNhbGx5IGJ1aWxkIHRoaXMgUmVndWxhciBFeHByZXNzaW9uIHRvIGNvbnNlcnZlIGZpbGUgc2l6ZS4gQWZ0ZXIgYnVpbGRpbmcgaXQsIGl0IHdpbGwgYmUgYWJsZSB0byBmaW5kIHJnYigpLCByZ2JhKCksICMgKGhleGFkZWNpbWFsKSwgYW5kIG5hbWVkIGNvbG9yIHZhbHVlcyBsaWtlIHJlZCwgYmx1ZSwgcHVycGxlLCBldGMuLFxuICBwO1xuXG4gIGZvciAocCBpbiBfY29sb3JMb29rdXApIHtcbiAgICBzICs9IFwifFwiICsgcCArIFwiXFxcXGJcIjtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKHMgKyBcIilcIiwgXCJnaVwiKTtcbn0oKSxcbiAgICBfaHNsRXhwID0gL2hzbFthXT9cXCgvLFxuICAgIF9jb2xvclN0cmluZ0ZpbHRlciA9IGZ1bmN0aW9uIF9jb2xvclN0cmluZ0ZpbHRlcihhKSB7XG4gIHZhciBjb21iaW5lZCA9IGEuam9pbihcIiBcIiksXG4gICAgICB0b0hTTDtcbiAgX2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7XG5cbiAgaWYgKF9jb2xvckV4cC50ZXN0KGNvbWJpbmVkKSkge1xuICAgIHRvSFNMID0gX2hzbEV4cC50ZXN0KGNvbWJpbmVkKTtcbiAgICBhWzFdID0gX2Zvcm1hdENvbG9ycyhhWzFdLCB0b0hTTCk7XG4gICAgYVswXSA9IF9mb3JtYXRDb2xvcnMoYVswXSwgdG9IU0wsIF9jb2xvck9yZGVyRGF0YShhWzFdKSk7IC8vIG1ha2Ugc3VyZSB0aGUgb3JkZXIgb2YgbnVtYmVycy9jb2xvcnMgbWF0Y2ggd2l0aCB0aGUgRU5EIHZhbHVlLlxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVElDS0VSXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5fdGlja2VyQWN0aXZlLFxuICAgIF90aWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfZ2V0VGltZSA9IERhdGUubm93LFxuICAgICAgX2xhZ1RocmVzaG9sZCA9IDUwMCxcbiAgICAgIF9hZGp1c3RlZExhZyA9IDMzLFxuICAgICAgX3N0YXJ0VGltZSA9IF9nZXRUaW1lKCksXG4gICAgICBfbGFzdFVwZGF0ZSA9IF9zdGFydFRpbWUsXG4gICAgICBfZ2FwID0gMSAvIDI0MCxcbiAgICAgIF9uZXh0VGltZSA9IF9nYXAsXG4gICAgICBfbGlzdGVuZXJzID0gW10sXG4gICAgICBfaWQsXG4gICAgICBfcmVxLFxuICAgICAgX3JhZixcbiAgICAgIF9zZWxmLFxuICAgICAgX3RpY2sgPSBmdW5jdGlvbiBfdGljayh2KSB7XG4gICAgdmFyIGVsYXBzZWQgPSBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUsXG4gICAgICAgIG1hbnVhbCA9IHYgPT09IHRydWUsXG4gICAgICAgIG92ZXJsYXAsXG4gICAgICAgIGRpc3BhdGNoO1xuXG4gICAgaWYgKGVsYXBzZWQgPiBfbGFnVGhyZXNob2xkKSB7XG4gICAgICBfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWc7XG4gICAgfVxuXG4gICAgX2xhc3RVcGRhdGUgKz0gZWxhcHNlZDtcbiAgICBfc2VsZi50aW1lID0gKF9sYXN0VXBkYXRlIC0gX3N0YXJ0VGltZSkgLyAxMDAwO1xuICAgIG92ZXJsYXAgPSBfc2VsZi50aW1lIC0gX25leHRUaW1lO1xuXG4gICAgaWYgKG92ZXJsYXAgPiAwIHx8IG1hbnVhbCkge1xuICAgICAgX3NlbGYuZnJhbWUrKztcbiAgICAgIF9uZXh0VGltZSArPSBvdmVybGFwICsgKG92ZXJsYXAgPj0gX2dhcCA/IDAuMDA0IDogX2dhcCAtIG92ZXJsYXApO1xuICAgICAgZGlzcGF0Y2ggPSAxO1xuICAgIH1cblxuICAgIGlmICghbWFudWFsKSB7XG4gICAgICAvL21ha2Ugc3VyZSB0aGUgcmVxdWVzdCBpcyBtYWRlIGJlZm9yZSB3ZSBkaXNwYXRjaCB0aGUgXCJ0aWNrXCIgZXZlbnQgc28gdGhhdCB0aW1pbmcgaXMgbWFpbnRhaW5lZC4gT3RoZXJ3aXNlLCBpZiBwcm9jZXNzaW5nIHRoZSBcInRpY2tcIiByZXF1aXJlcyBhIGJ1bmNoIG9mIHRpbWUgKGxpa2UgMTVtcykgYW5kIHdlJ3JlIHVzaW5nIGEgc2V0VGltZW91dCgpIHRoYXQncyBiYXNlZCBvbiAxNi43bXMsIGl0J2QgdGVjaG5pY2FsbHkgdGFrZSAzMS43bXMgYmV0d2VlbiBmcmFtZXMgb3RoZXJ3aXNlLlxuICAgICAgX2lkID0gX3JlcShfdGljayk7XG4gICAgfVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBfbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgcmV0dXJuIGwoX3NlbGYudGltZSwgZWxhcHNlZCwgX3NlbGYuZnJhbWUsIHYpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9zZWxmID0ge1xuICAgIHRpbWU6IDAsXG4gICAgZnJhbWU6IDAsXG4gICAgdGljazogZnVuY3Rpb24gdGljaygpIHtcbiAgICAgIF90aWNrKHRydWUpO1xuICAgIH0sXG4gICAgd2FrZTogZnVuY3Rpb24gd2FrZSgpIHtcbiAgICAgIGlmIChfY29yZVJlYWR5KSB7XG4gICAgICAgIGlmICghX2NvcmVJbml0dGVkICYmIF93aW5kb3dFeGlzdHMoKSkge1xuICAgICAgICAgIF93aW4gPSBfY29yZUluaXR0ZWQgPSB3aW5kb3c7XG4gICAgICAgICAgX2RvYyA9IF93aW4uZG9jdW1lbnQgfHwge307XG4gICAgICAgICAgX2dsb2JhbHMuZ3NhcCA9IGdzYXA7XG4gICAgICAgICAgKF93aW4uZ3NhcFZlcnNpb25zIHx8IChfd2luLmdzYXBWZXJzaW9ucyA9IFtdKSkucHVzaChnc2FwLnZlcnNpb24pO1xuXG4gICAgICAgICAgX2luc3RhbGwoX2luc3RhbGxTY29wZSB8fCBfd2luLkdyZWVuU29ja0dsb2JhbHMgfHwgIV93aW4uZ3NhcCAmJiBfd2luIHx8IHt9KTtcblxuICAgICAgICAgIF9yYWYgPSBfd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9pZCAmJiBfc2VsZi5zbGVlcCgpO1xuXG4gICAgICAgIF9yZXEgPSBfcmFmIHx8IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZiwgKF9uZXh0VGltZSAtIF9zZWxmLnRpbWUpICogMTAwMCArIDEgfCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGlja2VyQWN0aXZlID0gMTtcblxuICAgICAgICBfdGljaygyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNsZWVwOiBmdW5jdGlvbiBzbGVlcCgpIHtcbiAgICAgIChfcmFmID8gX3dpbi5jYW5jZWxBbmltYXRpb25GcmFtZSA6IGNsZWFyVGltZW91dCkoX2lkKTtcbiAgICAgIF90aWNrZXJBY3RpdmUgPSAwO1xuICAgICAgX3JlcSA9IF9lbXB0eUZ1bmM7XG4gICAgfSxcbiAgICBsYWdTbW9vdGhpbmc6IGZ1bmN0aW9uIGxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG4gICAgICBfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDEgLyBfdGlueU51bTsgLy96ZXJvIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNpY2FsbHkgdW5saW1pdGVkXG5cbiAgICAgIF9hZGp1c3RlZExhZyA9IE1hdGgubWluKGFkanVzdGVkTGFnLCBfbGFnVGhyZXNob2xkLCAwKTtcbiAgICB9LFxuICAgIGZwczogZnVuY3Rpb24gZnBzKF9mcHMpIHtcbiAgICAgIF9nYXAgPSAxIC8gKF9mcHMgfHwgMjQwKTtcbiAgICAgIF9uZXh0VGltZSA9IF9zZWxmLnRpbWUgKyBfZ2FwO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoY2FsbGJhY2spIHtcbiAgICAgIF9saXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjaykgPCAwICYmIF9saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG5cbiAgICAgIF93YWtlKCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjYWxsYmFjaykge1xuICAgICAgdmFyIGk7XG4gICAgICB+KGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICB9LFxuICAgIF9saXN0ZW5lcnM6IF9saXN0ZW5lcnNcbiAgfTtcbiAgcmV0dXJuIF9zZWxmO1xufSgpLFxuICAgIF93YWtlID0gZnVuY3Rpb24gX3dha2UoKSB7XG4gIHJldHVybiAhX3RpY2tlckFjdGl2ZSAmJiBfdGlja2VyLndha2UoKTtcbn0sXG4gICAgLy9hbHNvIGVuc3VyZXMgdGhlIGNvcmUgY2xhc3NlcyBhcmUgaW5pdGlhbGl6ZWQuXG5cbi8qXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogRUFTSU5HXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG5fZWFzZU1hcCA9IHt9LFxuICAgIF9jdXN0b21FYXNlRXhwID0gL15bXFxkLlxcLU1dW1xcZC5cXC0sXFxzXS8sXG4gICAgX3F1b3Rlc0V4cCA9IC9bXCInXS9nLFxuICAgIF9wYXJzZU9iamVjdEluU3RyaW5nID0gZnVuY3Rpb24gX3BhcnNlT2JqZWN0SW5TdHJpbmcodmFsdWUpIHtcbiAgLy90YWtlcyBhIHN0cmluZyBsaWtlIFwie3dpZ2dsZXM6MTAsIHR5cGU6YW50aWNpcGF0ZX0pXCIgYW5kIHR1cm5zIGl0IGludG8gYSByZWFsIG9iamVjdC4gTm90aWNlIGl0IGVuZHMgaW4gXCIpXCIgYW5kIGluY2x1ZGVzIHRoZSB7fSB3cmFwcGVycy4gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yIHBhcnNpbmcgZWFzZSBjb25maWdzIGFuZCBwcmlvcml0aXplZCBvcHRpbWl6YXRpb24gcmF0aGVyIHRoYW4gcmV1c2FiaWxpdHkuXG4gIHZhciBvYmogPSB7fSxcbiAgICAgIHNwbGl0ID0gdmFsdWUuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aCAtIDMpLnNwbGl0KFwiOlwiKSxcbiAgICAgIGtleSA9IHNwbGl0WzBdLFxuICAgICAgaSA9IDEsXG4gICAgICBsID0gc3BsaXQubGVuZ3RoLFxuICAgICAgaW5kZXgsXG4gICAgICB2YWwsXG4gICAgICBwYXJzZWRWYWw7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICB2YWwgPSBzcGxpdFtpXTtcbiAgICBpbmRleCA9IGkgIT09IGwgLSAxID8gdmFsLmxhc3RJbmRleE9mKFwiLFwiKSA6IHZhbC5sZW5ndGg7XG4gICAgcGFyc2VkVmFsID0gdmFsLnN1YnN0cigwLCBpbmRleCk7XG4gICAgb2JqW2tleV0gPSBpc05hTihwYXJzZWRWYWwpID8gcGFyc2VkVmFsLnJlcGxhY2UoX3F1b3Rlc0V4cCwgXCJcIikudHJpbSgpIDogK3BhcnNlZFZhbDtcbiAgICBrZXkgPSB2YWwuc3Vic3RyKGluZGV4ICsgMSkudHJpbSgpO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nID0gZnVuY3Rpb24gX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nKG5hbWUpIHtcbiAgLy9uYW1lIGNhbiBiZSBhIHN0cmluZyBsaWtlIFwiZWxhc3RpYy5vdXQoMSwwLjUpXCIsIGFuZCBwYXNzIGluIF9lYXNlTWFwIGFzIG9iaiBhbmQgaXQnbGwgcGFyc2UgaXQgb3V0IGFuZCBjYWxsIHRoZSBhY3R1YWwgZnVuY3Rpb24gbGlrZSBfZWFzZU1hcC5FbGFzdGljLmVhc2VPdXQuY29uZmlnKDEsMC41KS4gSXQgd2lsbCBhbHNvIHBhcnNlIGN1c3RvbSBlYXNlIHN0cmluZ3MgYXMgbG9uZyBhcyBDdXN0b21FYXNlIGlzIGxvYWRlZCBhbmQgcmVnaXN0ZXJlZCAoaW50ZXJuYWxseSBhcyBfZWFzZU1hcC5fQ0UpLlxuICB2YXIgc3BsaXQgPSAobmFtZSArIFwiXCIpLnNwbGl0KFwiKFwiKSxcbiAgICAgIGVhc2UgPSBfZWFzZU1hcFtzcGxpdFswXV07XG4gIHJldHVybiBlYXNlICYmIHNwbGl0Lmxlbmd0aCA+IDEgJiYgZWFzZS5jb25maWcgPyBlYXNlLmNvbmZpZy5hcHBseShudWxsLCB+bmFtZS5pbmRleE9mKFwie1wiKSA/IFtfcGFyc2VPYmplY3RJblN0cmluZyhzcGxpdFsxXSldIDogX3BhcmVudGhlc2VzRXhwLmV4ZWMobmFtZSlbMV0uc3BsaXQoXCIsXCIpLm1hcChfbnVtZXJpY0lmUG9zc2libGUpKSA6IF9lYXNlTWFwLl9DRSAmJiBfY3VzdG9tRWFzZUV4cC50ZXN0KG5hbWUpID8gX2Vhc2VNYXAuX0NFKFwiXCIsIG5hbWUpIDogZWFzZTtcbn0sXG4gICAgX2ludmVydEVhc2UgPSBmdW5jdGlvbiBfaW52ZXJ0RWFzZShlYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZSgxIC0gcCk7XG4gIH07XG59LFxuICAgIC8vIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZSAtIGFsbG93IHlveW9FYXNlIHRvIGJlIHNldCBpbiBjaGlsZHJlbiBhbmQgaGF2ZSB0aG9zZSBhZmZlY3RlZCB3aGVuIHRoZSBwYXJlbnQvYW5jZXN0b3IgdGltZWxpbmUgeW95b3MuIE5vdCBzdXJlIGl0J3Mgd29ydGggdGhlIGtiLlxuLy8gX3Byb3BhZ2F0ZVlveW9FYXNlID0gKHRpbWVsaW5lLCBpc1lveW8pID0+IHtcbi8vIFx0bGV0IGNoaWxkID0gdGltZWxpbmUuX2ZpcnN0LCBlYXNlO1xuLy8gXHR3aGlsZSAoY2hpbGQpIHtcbi8vIFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBUaW1lbGluZSkge1xuLy8gXHRcdFx0X3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLCBpc1lveW8pO1xuLy8gXHRcdH0gZWxzZSBpZiAoY2hpbGQudmFycy55b3lvRWFzZSAmJiAoIWNoaWxkLl95b3lvIHx8ICFjaGlsZC5fcmVwZWF0KSAmJiBjaGlsZC5feW95byAhPT0gaXNZb3lvKSB7XG4vLyBcdFx0XHRpZiAoY2hpbGQudGltZWxpbmUpIHtcbi8vIFx0XHRcdFx0X3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLnRpbWVsaW5lLCBpc1lveW8pO1xuLy8gXHRcdFx0fSBlbHNlIHtcbi8vIFx0XHRcdFx0ZWFzZSA9IGNoaWxkLl9lYXNlO1xuLy8gXHRcdFx0XHRjaGlsZC5fZWFzZSA9IGNoaWxkLl95RWFzZTtcbi8vIFx0XHRcdFx0Y2hpbGQuX3lFYXNlID0gZWFzZTtcbi8vIFx0XHRcdFx0Y2hpbGQuX3lveW8gPSBpc1lveW87XG4vLyBcdFx0XHR9XG4vLyBcdFx0fVxuLy8gXHRcdGNoaWxkID0gY2hpbGQuX25leHQ7XG4vLyBcdH1cbi8vIH0sXG5fcGFyc2VFYXNlID0gZnVuY3Rpb24gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICByZXR1cm4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlO1xufSxcbiAgICBfaW5zZXJ0RWFzZSA9IGZ1bmN0aW9uIF9pbnNlcnRFYXNlKG5hbWVzLCBlYXNlSW4sIGVhc2VPdXQsIGVhc2VJbk91dCkge1xuICBpZiAoZWFzZU91dCA9PT0gdm9pZCAwKSB7XG4gICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgICAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHApO1xuICAgIH07XG4gIH1cblxuICBpZiAoZWFzZUluT3V0ID09PSB2b2lkIDApIHtcbiAgICBlYXNlSW5PdXQgPSBmdW5jdGlvbiBlYXNlSW5PdXQocCkge1xuICAgICAgcmV0dXJuIHAgPCAuNSA/IGVhc2VJbihwICogMikgLyAyIDogMSAtIGVhc2VJbigoMSAtIHApICogMikgLyAyO1xuICAgIH07XG4gIH1cblxuICB2YXIgZWFzZSA9IHtcbiAgICBlYXNlSW46IGVhc2VJbixcbiAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgIGVhc2VJbk91dDogZWFzZUluT3V0XG4gIH0sXG4gICAgICBsb3dlcmNhc2VOYW1lO1xuXG4gIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfZWFzZU1hcFtuYW1lXSA9IF9nbG9iYWxzW25hbWVdID0gZWFzZTtcbiAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGVhc2VPdXQ7XG5cbiAgICBmb3IgKHZhciBwIGluIGVhc2UpIHtcbiAgICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgKyAocCA9PT0gXCJlYXNlSW5cIiA/IFwiLmluXCIgOiBwID09PSBcImVhc2VPdXRcIiA/IFwiLm91dFwiIDogXCIuaW5PdXRcIildID0gX2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgcF0gPSBlYXNlW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2U7XG59LFxuICAgIF9lYXNlSW5PdXRGcm9tT3V0ID0gZnVuY3Rpb24gX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IC41ID8gKDEgLSBlYXNlT3V0KDEgLSBwICogMikpIC8gMiA6IC41ICsgZWFzZU91dCgocCAtIC41KSAqIDIpIC8gMjtcbiAgfTtcbn0sXG4gICAgX2NvbmZpZ0VsYXN0aWMgPSBmdW5jdGlvbiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICB2YXIgcDEgPSBhbXBsaXR1ZGUgPj0gMSA/IGFtcGxpdHVkZSA6IDEsXG4gICAgICAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuICBwMiA9IChwZXJpb2QgfHwgKHR5cGUgPyAuMyA6IC40NSkpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKSxcbiAgICAgIHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwID09PSAxID8gMSA6IHAxICogTWF0aC5wb3coMiwgLTEwICogcCkgKiBfc2luKChwIC0gcDMpICogcDIpICsgMTtcbiAgfSxcbiAgICAgIGVhc2UgPSB0eXBlID09PSBcIm91dFwiID8gZWFzZU91dCA6IHR5cGUgPT09IFwiaW5cIiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gIHAyID0gXzJQSSAvIHAyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgcmV0dXJuIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn0sXG4gICAgX2NvbmZpZ0JhY2sgPSBmdW5jdGlvbiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpIHtcbiAgaWYgKG92ZXJzaG9vdCA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnNob290ID0gMS43MDE1ODtcbiAgfVxuXG4gIHZhciBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPyAtLXAgKiBwICogKChvdmVyc2hvb3QgKyAxKSAqIHAgKyBvdmVyc2hvb3QpICsgMSA6IDA7XG4gIH0sXG4gICAgICBlYXNlID0gdHlwZSA9PT0gXCJvdXRcIiA/IGVhc2VPdXQgOiB0eXBlID09PSBcImluXCIgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0gOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblxuICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChvdmVyc2hvb3QpIHtcbiAgICByZXR1cm4gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn07IC8vIGEgY2hlYXBlciAoa2IgYW5kIGNwdSkgYnV0IG1vcmUgbWlsZCB3YXkgdG8gZ2V0IGEgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIGJ5IGZlZWRpbmcgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cbi8vIF93ZWlnaHRlZEVhc2UgPSByYXRpbyA9PiB7XG4vLyBcdGxldCB5ID0gMC41ICsgcmF0aW8gLyAyO1xuLy8gXHRyZXR1cm4gcCA9PiAoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcbi8vIH0sXG4vLyBhIHN0cm9uZ2VyIChidXQgbW9yZSBleHBlbnNpdmUga2IvY3B1KSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgdGhhdCBsZXRzIHlvdSBmZWVkIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG4vLyBfd2VpZ2h0ZWRFYXNlU3Ryb25nID0gcmF0aW8gPT4ge1xuLy8gXHRyYXRpbyA9IC41ICsgcmF0aW8gLyAyO1xuLy8gXHRsZXQgbyA9IDEgLyAzICogKHJhdGlvIDwgLjUgPyByYXRpbyA6IDEgLSByYXRpbyksXG4vLyBcdFx0YiA9IHJhdGlvIC0gbyxcbi8vIFx0XHRjID0gcmF0aW8gKyBvO1xuLy8gXHRyZXR1cm4gcCA9PiBwID09PSAxID8gcCA6IDMgKiBiICogKDEgLSBwKSAqICgxIC0gcCkgKiBwICsgMyAqIGMgKiAoMSAtIHApICogcCAqIHAgKyBwICogcCAqIHA7XG4vLyB9O1xuXG5cbl9mb3JFYWNoTmFtZShcIkxpbmVhcixRdWFkLEN1YmljLFF1YXJ0LFF1aW50LFN0cm9uZ1wiLCBmdW5jdGlvbiAobmFtZSwgaSkge1xuICB2YXIgcG93ZXIgPSBpIDwgNSA/IGkgKyAxIDogaTtcblxuICBfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocCwgcG93ZXIpO1xuICB9IDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSBwLCBwb3dlcik7XG4gIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCAuNSA/IE1hdGgucG93KHAgKiAyLCBwb3dlcikgLyAyIDogMSAtIE1hdGgucG93KCgxIC0gcCkgKiAyLCBwb3dlcikgLyAyO1xuICB9KTtcbn0pO1xuXG5fZWFzZU1hcC5MaW5lYXIuZWFzZU5vbmUgPSBfZWFzZU1hcC5ub25lID0gX2Vhc2VNYXAuTGluZWFyLmVhc2VJbjtcblxuX2luc2VydEVhc2UoXCJFbGFzdGljXCIsIF9jb25maWdFbGFzdGljKFwiaW5cIiksIF9jb25maWdFbGFzdGljKFwib3V0XCIpLCBfY29uZmlnRWxhc3RpYygpKTtcblxuKGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBuMSA9IDEgLyBjLFxuICAgICAgbjIgPSAyICogbjEsXG4gICAgICBuMyA9IDIuNSAqIG4xLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwIDwgbjEgPyBuICogcCAqIHAgOiBwIDwgbjIgPyBuICogTWF0aC5wb3cocCAtIDEuNSAvIGMsIDIpICsgLjc1IDogcCA8IG4zID8gbiAqIChwIC09IDIuMjUgLyBjKSAqIHAgKyAuOTM3NSA6IG4gKiBNYXRoLnBvdyhwIC0gMi42MjUgLyBjLCAyKSArIC45ODQzNzU7XG4gIH07XG5cbiAgX2luc2VydEVhc2UoXCJCb3VuY2VcIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9LCBlYXNlT3V0KTtcbn0pKDcuNTYyNSwgMi43NSk7XG5cbl9pbnNlcnRFYXNlKFwiRXhwb1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcCA/IE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQ2lyY1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gLShfc3FydCgxIC0gcCAqIHApIC0gMSk7XG59KTtcblxuX2luc2VydEVhc2UoXCJTaW5lXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiAtX2NvcyhwICogX0hBTEZfUEkpICsgMTtcbn0pO1xuXG5faW5zZXJ0RWFzZShcIkJhY2tcIiwgX2NvbmZpZ0JhY2soXCJpblwiKSwgX2NvbmZpZ0JhY2soXCJvdXRcIiksIF9jb25maWdCYWNrKCkpO1xuXG5fZWFzZU1hcC5TdGVwcGVkRWFzZSA9IF9lYXNlTWFwLnN0ZXBzID0gX2dsb2JhbHMuU3RlcHBlZEVhc2UgPSB7XG4gIGNvbmZpZzogZnVuY3Rpb24gY29uZmlnKHN0ZXBzLCBpbW1lZGlhdGVTdGFydCkge1xuICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGVwcyA9IDE7XG4gICAgfVxuXG4gICAgdmFyIHAxID0gMSAvIHN0ZXBzLFxuICAgICAgICBwMiA9IHN0ZXBzICsgKGltbWVkaWF0ZVN0YXJ0ID8gMCA6IDEpLFxuICAgICAgICBwMyA9IGltbWVkaWF0ZVN0YXJ0ID8gMSA6IDAsXG4gICAgICAgIG1heCA9IDEgLSBfdGlueU51bTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAoKHAyICogX2NsYW1wKDAsIG1heCwgcCkgfCAwKSArIHAzKSAqIHAxO1xuICAgIH07XG4gIH1cbn07XG5fZGVmYXVsdHMuZWFzZSA9IF9lYXNlTWFwW1wicXVhZC5vdXRcIl07XG5cbl9mb3JFYWNoTmFtZShcIm9uQ29tcGxldGUsb25VcGRhdGUsb25TdGFydCxvblJlcGVhdCxvblJldmVyc2VDb21wbGV0ZSxvbkludGVycnVwdFwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX2NhbGxiYWNrTmFtZXMgKz0gbmFtZSArIFwiLFwiICsgbmFtZSArIFwiUGFyYW1zLFwiO1xufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENBQ0hFXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuZXhwb3J0IHZhciBHU0NhY2hlID0gZnVuY3Rpb24gR1NDYWNoZSh0YXJnZXQsIGhhcm5lc3MpIHtcbiAgdGhpcy5pZCA9IF9nc0lEKys7XG4gIHRhcmdldC5fZ3NhcCA9IHRoaXM7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLmhhcm5lc3MgPSBoYXJuZXNzO1xuICB0aGlzLmdldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldCA6IF9nZXRQcm9wZXJ0eTtcbiAgdGhpcy5zZXQgPSBoYXJuZXNzID8gaGFybmVzcy5nZXRTZXR0ZXIgOiBfZ2V0U2V0dGVyO1xufTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQU5JTUFUSU9OXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmV4cG9ydCB2YXIgQW5pbWF0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5pbWF0aW9uKHZhcnMsIHRpbWUpIHtcbiAgICB2YXIgcGFyZW50ID0gdmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lO1xuICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgdGhpcy5fZGVsYXkgPSArdmFycy5kZWxheSB8fCAwO1xuXG4gICAgaWYgKHRoaXMuX3JlcGVhdCA9IHZhcnMucmVwZWF0IHx8IDApIHtcbiAgICAgIHRoaXMuX3JEZWxheSA9IHZhcnMucmVwZWF0RGVsYXkgfHwgMDtcbiAgICAgIHRoaXMuX3lveW8gPSAhIXZhcnMueW95byB8fCAhIXZhcnMueW95b0Vhc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fdHMgPSAxO1xuXG4gICAgX3NldER1cmF0aW9uKHRoaXMsICt2YXJzLmR1cmF0aW9uLCAxKTtcblxuICAgIHRoaXMuZGF0YSA9IHZhcnMuZGF0YTtcbiAgICBfdGlja2VyQWN0aXZlIHx8IF90aWNrZXIud2FrZSgpO1xuICAgIHBhcmVudCAmJiBfYWRkVG9UaW1lbGluZShwYXJlbnQsIHRoaXMsIHRpbWUgfHwgdGltZSA9PT0gMCA/IHRpbWUgOiBwYXJlbnQuX3RpbWUsIDEpO1xuICAgIHZhcnMucmV2ZXJzZWQgJiYgdGhpcy5yZXZlcnNlKCk7XG4gICAgdmFycy5wYXVzZWQgJiYgdGhpcy5wYXVzZWQodHJ1ZSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVsYXkgPSBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnQgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgIHRoaXMuX2RlbGF5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxEdXJhdGlvbih0aGlzLl9yZXBlYXQgPiAwID8gdmFsdWUgKyAodmFsdWUgKyB0aGlzLl9yRGVsYXkpICogdGhpcy5fcmVwZWF0IDogdmFsdWUpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgJiYgdGhpcy5fZHVyO1xuICB9O1xuXG4gIF9wcm90by50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3REdXI7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlydHkgPSAwO1xuICAgIHJldHVybiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fcmVwZWF0IDwgMCA/IHZhbHVlIDogKHZhbHVlIC0gdGhpcy5fcmVwZWF0ICogdGhpcy5fckRlbGF5KSAvICh0aGlzLl9yZXBlYXQgKyAxKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIF93YWtlKCk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiB0aGlzLl90cykge1xuICAgICAgLy8gaWYgKCFwYXJlbnQuX2RwICYmIHBhcmVudC5fdGltZSA9PT0gcGFyZW50Ll9kdXIpIHsgLy8gaWYgYSByb290IHRpbWVsaW5lIGNvbXBsZXRlcy4uLmFuZCB0aGVuIGEgd2hpbGUgbGF0ZXIgb25lIG9mIGl0cyBjaGlsZHJlbiByZXN1bWVzLCB3ZSBtdXN0IHNob290IHRoZSBwbGF5aGVhZCBmb3J3YXJkIHRvIHdoZXJlIGl0IHNob3VsZCBiZSByYXctd2lzZSwgb3RoZXJ3aXNlIHRoZSBjaGlsZCB3aWxsIGp1bXAgdG8gdGhlIGVuZC4gRG93biBzaWRlOiB0aGlzIGFzc3VtZXMgaXQncyB1c2luZyB0aGUgX3RpY2tlci50aW1lIGFzIGEgcmVmZXJlbmNlLlxuICAgICAgLy8gXHRwYXJlbnQuX3RpbWUgPSBfdGlja2VyLnRpbWUgLSBwYXJlbnQuX3N0YXJ0O1xuICAgICAgLy8gfVxuICAgICAgdGhpcy5fc3RhcnQgPSBfcm91bmQocGFyZW50Ll90aW1lIC0gKHRoaXMuX3RzID4gMCA/IF90b3RhbFRpbWUgLyB0aGlzLl90cyA6ICgodGhpcy5fZGlydHkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuX3REdXIpIC0gX3RvdGFsVGltZSkgLyAtdGhpcy5fdHMpKTtcblxuICAgICAgX3NldEVuZCh0aGlzKTtcblxuICAgICAgaWYgKCFwYXJlbnQuX2RpcnR5KSB7XG4gICAgICAgIC8vZm9yIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LiBJZiB0aGUgcGFyZW50J3MgY2FjaGUgaXMgYWxyZWFkeSBkaXJ0eSwgaXQgYWxyZWFkeSB0b29rIGNhcmUgb2YgbWFya2luZyB0aGUgYW5jZXN0b3JzIGFzIGRpcnR5IHRvbywgc28gc2tpcCB0aGUgZnVuY3Rpb24gY2FsbCBoZXJlLlxuICAgICAgICBfdW5jYWNoZShwYXJlbnQpO1xuICAgICAgfSAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvciB0aW1lbGluZXMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLCB3ZSBzaG91bGQgcmVzZXQgdGhlaXIgdG90YWxUaW1lKCkgd2hpY2ggd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZXkncmUgbGluZWQgdXAgcHJvcGVybHkgYW5kIGVuYWJsZWQuIFNraXAgZm9yIGFuaW1hdGlvbnMgdGhhdCBhcmUgb24gdGhlIHJvb3QgKHdhc3RlZnVsKS4gRXhhbXBsZTogYSBUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCgpIGlzIHBlcmZvcm1lZCB3aGVuIHRoZXJlJ3MgYSBwYXVzZWQgdHdlZW4gb24gdGhlIHJvb3QsIHRoZSBleHBvcnQgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhhdCB0d2VlbiBpcyB1bnBhdXNlZCwgYnV0IGltYWdpbmUgYSBjaGlsZCBnZXRzIHJlc3RhcnRlZCBsYXRlciwgYWZ0ZXIgYWxsIFt1bnBhdXNlZF0gdHdlZW5zIGhhdmUgY29tcGxldGVkLiBUaGUgc3RhcnQgb2YgdGhhdCBjaGlsZCB3b3VsZCBnZXQgcHVzaGVkIG91dCwgYnV0IG9uZSBvZiB0aGUgYW5jZXN0b3JzIG1heSBoYXZlIGNvbXBsZXRlZC5cblxuXG4gICAgICB3aGlsZSAocGFyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBhcmVudC5fdGltZSAhPT0gcGFyZW50Ll9zdGFydCArIChwYXJlbnQuX3RzID49IDAgPyBwYXJlbnQuX3RUaW1lIC8gcGFyZW50Ll90cyA6IChwYXJlbnQudG90YWxEdXJhdGlvbigpIC0gcGFyZW50Ll90VGltZSkgLyAtcGFyZW50Ll90cykpIHtcbiAgICAgICAgICBwYXJlbnQudG90YWxUaW1lKHBhcmVudC5fdFRpbWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLl9kcC5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcbiAgICAgICAgLy9pZiB0aGUgYW5pbWF0aW9uIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgcHV0IGl0IGJhY2sgaW50byBpdHMgbGFzdCBwYXJlbnQgKHJlY29yZGVkIGFzIF9kcCBmb3IgZXhhY3RseSBjYXNlcyBsaWtlIHRoaXMpLiBMaW1pdCB0byBwYXJlbnRzIHdpdGggYXV0b1JlbW92ZUNoaWxkcmVuIChsaWtlIGdsb2JhbFRpbWVsaW5lKSBzbyB0aGF0IGlmIHRoZSB1c2VyIG1hbnVhbGx5IHJlbW92ZXMgYW4gYW5pbWF0aW9uIGZyb20gYSB0aW1lbGluZSBhbmQgdGhlbiBhbHRlcnMgaXRzIHBsYXloZWFkLCBpdCBkb2Vzbid0IGdldCBhZGRlZCBiYWNrIGluLlxuICAgICAgICBfYWRkVG9UaW1lbGluZSh0aGlzLl9kcCwgdGhpcywgdGhpcy5fc3RhcnQgLSB0aGlzLl9kZWxheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RUaW1lICE9PSBfdG90YWxUaW1lIHx8ICF0aGlzLl9kdXIgJiYgIXN1cHByZXNzRXZlbnRzIHx8IHRoaXMuX2luaXR0ZWQgJiYgTWF0aC5hYnModGhpcy5felRpbWUpID09PSBfdGlueU51bSkge1xuICAgICAgdGhpcy5fdHMgfHwgKHRoaXMuX3BUaW1lID0gX3RvdGFsVGltZSk7IC8vIG90aGVyd2lzZSwgaWYgYW4gYW5pbWF0aW9uIGlzIHBhdXNlZCwgdGhlbiB0aGUgcGxheWhlYWQgaXMgbW92ZWQgYmFjayB0byB6ZXJvLCB0aGVuIHJlc3VtZWQsIGl0J2QgcmV2ZXJ0IGJhY2sgdG8gdGhlIG9yaWdpbmFsIHRpbWUgYXQgdGhlIHBhdXNlXG5cbiAgICAgIF9sYXp5U2FmZVJlbmRlcih0aGlzLCBfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRpbWUgPSBmdW5jdGlvbiB0aW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUoTWF0aC5taW4odGhpcy50b3RhbER1cmF0aW9uKCksIHZhbHVlICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpKSAlIHRoaXMuX2R1ciB8fCAodmFsdWUgPyB0aGlzLl9kdXIgOiAwKSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5fdGltZTsgLy8gbm90ZTogaWYgdGhlIG1vZHVsdXMgcmVzdWx0cyBpbiAwLCB0aGUgcGxheWhlYWQgY291bGQgYmUgZXhhY3RseSBhdCB0aGUgZW5kIG9yIHRoZSBiZWdpbm5pbmcsIGFuZCB3ZSBhbHdheXMgZGVmZXIgdG8gdGhlIEVORCB3aXRoIGEgbm9uLXplcm8gdmFsdWUsIG90aGVyd2lzZSBpZiB5b3Ugc2V0IHRoZSB0aW1lKCkgdG8gdGhlIHZlcnkgZW5kIChkdXJhdGlvbigpKSwgaXQgd291bGQgcmVuZGVyIGF0IHRoZSBTVEFSVCFcbiAgfTtcblxuICBfcHJvdG8udG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uIHRvdGFsUHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLnRvdGFsRHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RUaW1lIC8gdGhpcy5fdER1cikgOiB0aGlzLnJhdGlvO1xuICB9O1xuXG4gIF9wcm90by5wcm9ncmVzcyA9IGZ1bmN0aW9uIHByb2dyZXNzKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5kdXJhdGlvbigpICogKHRoaXMuX3lveW8gJiYgISh0aGlzLml0ZXJhdGlvbigpICYgMSkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcyksIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuZHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RpbWUgLyB0aGlzLl9kdXIpIDogdGhpcy5yYXRpbztcbiAgfTtcblxuICBfcHJvdG8uaXRlcmF0aW9uID0gZnVuY3Rpb24gaXRlcmF0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHZhciBjeWNsZUR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpICsgdGhpcy5fckRlbGF5O1xuXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLl90aW1lICsgKHZhbHVlIC0gMSkgKiBjeWNsZUR1cmF0aW9uLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl9yZXBlYXQgPyBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pICsgMSA6IDE7XG4gIH07XG5cbiAgX3Byb3RvLnRpbWVTY2FsZSA9IGZ1bmN0aW9uIHRpbWVTY2FsZSh2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J0cyA9PT0gLV90aW55TnVtID8gMCA6IHRoaXMuX3J0czsgLy8gcmVjb3JkZWQgdGltZVNjYWxlLiBTcGVjaWFsIGNhc2U6IGlmIHNvbWVvbmUgY2FsbHMgcmV2ZXJzZSgpIG9uIGFuIGFuaW1hdGlvbiB3aXRoIHRpbWVTY2FsZSBvZiAwLCB3ZSBhc3NpZ24gaXQgLV90aW55TnVtIHRvIHJlbWVtYmVyIGl0J3MgcmV2ZXJzZWQuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3J0cyA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciB0VGltZSA9IHRoaXMucGFyZW50ICYmIHRoaXMuX3RzID8gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGhpcy5wYXJlbnQuX3RpbWUsIHRoaXMpIDogdGhpcy5fdFRpbWU7IC8vIG1ha2Ugc3VyZSB0byBkbyB0aGUgcGFyZW50VG9DaGlsZFRvdGFsVGltZSgpIEJFRk9SRSBzZXR0aW5nIHRoZSBuZXcgX3RzIGJlY2F1c2UgdGhlIG9sZCBvbmUgbXVzdCBiZSB1c2VkIGluIHRoYXQgY2FsY3VsYXRpb24uXG4gICAgLy8gcHJpb3JpdGl6ZSByZW5kZXJpbmcgd2hlcmUgdGhlIHBhcmVudCdzIHBsYXloZWFkIGxpbmVzIHVwIGluc3RlYWQgb2YgdGhpcy5fdFRpbWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBhIHR3ZWVuIHRoYXQncyBhbmltYXRpbmcgYW5vdGhlciB0d2VlbidzIHRpbWVTY2FsZSBpbiB0aGUgc2FtZSByZW5kZXJpbmcgbG9vcCAoc2FtZSBwYXJlbnQpLCB0aHVzIGlmIHRoZSB0aW1lU2NhbGUgdHdlZW4gcmVuZGVycyBmaXJzdCwgaXQgd291bGQgYWx0ZXIgX3N0YXJ0IEJFRk9SRSBfdFRpbWUgd2FzIHNldCBvbiB0aGF0IHRpY2sgKGluIHRoZSByZW5kZXJpbmcgbG9vcCksIGVmZmVjdGl2ZWx5IGZyZWV6aW5nIGl0IHVudGlsIHRoZSB0aW1lU2NhbGUgdHdlZW4gZmluaXNoZXMuXG5cbiAgICB0aGlzLl9ydHMgPSArdmFsdWUgfHwgMDtcbiAgICB0aGlzLl90cyA9IHRoaXMuX3BzIHx8IHZhbHVlID09PSAtX3RpbnlOdW0gPyAwIDogdGhpcy5fcnRzOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlIHdoaWNoIHdvdWxkIGJlIDAgaWYgdGhlIGFuaW1hdGlvbiBpcyBwYXVzZWQuXG5cbiAgICByZXR1cm4gX3JlY2FjaGVBbmNlc3RvcnModGhpcy50b3RhbFRpbWUoX2NsYW1wKDAsIHRoaXMuX3REdXIsIHRUaW1lKSwgdHJ1ZSkpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZWQgPSBmdW5jdGlvbiBwYXVzZWQodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcyA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTsgLy8gaWYgdGhlIHBhdXNlIG9jY3VycyBkdXJpbmcgdGhlIGRlbGF5IHBoYXNlLCBtYWtlIHN1cmUgdGhhdCdzIGZhY3RvcmVkIGluIHdoZW4gcmVzdW1pbmcuXG5cbiAgICAgICAgdGhpcy5fdHMgPSB0aGlzLl9hY3QgPSAwOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlLCBzbyBhIHBhdXNlZCB0d2VlbiB3b3VsZCBlZmZlY3RpdmVseSBoYXZlIGEgdGltZVNjYWxlIG9mIDAuIFdlIHJlY29yZCB0aGUgXCJyZWFsXCIgdGltZVNjYWxlIGFzIF9ydHMgKHJlY29yZGVkIHRpbWUgc2NhbGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfd2FrZSgpO1xuXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzOyAvL29ubHkgZGVmZXIgdG8gX3BUaW1lIChwYXVzZVRpbWUpIGlmIHRUaW1lIGlzIHplcm8uIFJlbWVtYmVyLCBzb21lb25lIGNvdWxkIHBhdXNlKCkgYW4gYW5pbWF0aW9uLCB0aGVuIHNjcnViIHRoZSBwbGF5aGVhZCBhbmQgcmVzdW1lKCkuIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIHNtb290aENoaWxkVGltaW5nLCB3ZSByZW5kZXIgYXQgdGhlIHJhd1RpbWUoKSBiZWNhdXNlIHRoZSBzdGFydFRpbWUgd29uJ3QgZ2V0IHVwZGF0ZWQuXG5cbiAgICAgICAgdGhpcy50b3RhbFRpbWUodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nID8gdGhpcy5yYXdUaW1lKCkgOiB0aGlzLl90VGltZSB8fCB0aGlzLl9wVGltZSwgdGhpcy5wcm9ncmVzcygpID09PSAxICYmICh0aGlzLl90VGltZSAtPSBfdGlueU51bSkgJiYgTWF0aC5hYnModGhpcy5felRpbWUpICE9PSBfdGlueU51bSk7IC8vIGVkZ2UgY2FzZTogYW5pbWF0aW9uLnByb2dyZXNzKDEpLnBhdXNlKCkucGxheSgpIHdvdWxkbid0IHJlbmRlciBhZ2FpbiBiZWNhdXNlIHRoZSBwbGF5aGVhZCBpcyBhbHJlYWR5IGF0IHRoZSBlbmQsIGJ1dCB0aGUgY2FsbCB0byB0b3RhbFRpbWUoKSBiZWxvdyB3aWxsIGFkZCBpdCBiYWNrIHRvIGl0cyBwYXJlbnQuLi5hbmQgbm90IHJlbW92ZSBpdCBhZ2FpbiAoc2luY2UgcmVtb3Zpbmcgb25seSBoYXBwZW5zIHVwb24gcmVuZGVyaW5nIGF0IGEgbmV3IHRpbWUpLiBPZmZzZXR0aW5nIHRoZSBfdFRpbWUgc2xpZ2h0bHkgaXMgZG9uZSBzaW1wbHkgdG8gY2F1c2UgdGhlIGZpbmFsIHJlbmRlciBpbiB0b3RhbFRpbWUoKSB0aGF0J2xsIHBvcCBpdCBvZmYgaXRzIHRpbWVsaW5lIChpZiBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSwgb2YgY291cnNlKS4gQ2hlY2sgdG8gbWFrZSBzdXJlIF96VGltZSBpc24ndCAtX3RpbnlOdW0gdG8gYXZvaWQgYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBwdXNoZWQgdG8gdGhlIGVuZCBidXQgSU5TSURFIGEgdHdlZW4vY2FsbGJhY2ssIHRoZSB0aW1lbGluZSBpdHNlbGYgaXMgcGF1c2VkIHRodXMgaGFsdGluZyByZW5kZXJpbmcgYW5kIGxlYXZpbmcgYSBmZXcgdW5yZW5kZXJlZC4gV2hlbiByZXN1bWluZywgaXQgd291bGRuJ3QgcmVuZGVyIHRob3NlIG90aGVyd2lzZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gdmFsdWU7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG4gICAgICBwYXJlbnQgJiYgKHBhcmVudC5fc29ydCB8fCAhdGhpcy5wYXJlbnQpICYmIF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgdGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLmVuZFRpbWUgPSBmdW5jdGlvbiBlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgKF9pc05vdEZhbHNlKGluY2x1ZGVSZXBlYXRzKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIE1hdGguYWJzKHRoaXMuX3RzKTtcbiAgfTtcblxuICBfcHJvdG8ucmF3VGltZSA9IGZ1bmN0aW9uIHJhd1RpbWUod3JhcFJlcGVhdHMpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7IC8vIF9kcCA9IGRldGF0Y2hlZCBwYXJlbnRcblxuICAgIHJldHVybiAhcGFyZW50ID8gdGhpcy5fdFRpbWUgOiB3cmFwUmVwZWF0cyAmJiAoIXRoaXMuX3RzIHx8IHRoaXMuX3JlcGVhdCAmJiB0aGlzLl90aW1lICYmIHRoaXMudG90YWxQcm9ncmVzcygpIDwgMSkgPyB0aGlzLl90VGltZSAlICh0aGlzLl9kdXIgKyB0aGlzLl9yRGVsYXkpIDogIXRoaXMuX3RzID8gdGhpcy5fdFRpbWUgOiBfcGFyZW50VG9DaGlsZFRvdGFsVGltZShwYXJlbnQucmF3VGltZSh3cmFwUmVwZWF0cyksIHRoaXMpO1xuICB9IC8vIGdsb2JhbFRpbWUocmF3VGltZSkge1xuICAvLyBcdGxldCBhbmltYXRpb24gPSB0aGlzLFxuICAvLyBcdFx0dGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPyByYXdUaW1lIDogYW5pbWF0aW9uLnJhd1RpbWUoKTtcbiAgLy8gXHR3aGlsZSAoYW5pbWF0aW9uKSB7XG4gIC8vIFx0XHR0aW1lID0gYW5pbWF0aW9uLl9zdGFydCArIHRpbWUgLyAoYW5pbWF0aW9uLl90cyB8fCAxKTtcbiAgLy8gXHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5wYXJlbnQ7XG4gIC8vIFx0fVxuICAvLyBcdHJldHVybiB0aW1lO1xuICAvLyB9XG4gIDtcblxuICBfcHJvdG8ucmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3JlcGVhdCA9IHZhbHVlO1xuICAgICAgcmV0dXJuIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcGVhdDtcbiAgfTtcblxuICBfcHJvdG8ucmVwZWF0RGVsYXkgPSBmdW5jdGlvbiByZXBlYXREZWxheSh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9yRGVsYXkgPSB2YWx1ZTtcbiAgICAgIHJldHVybiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yRGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLnlveW8gPSBmdW5jdGlvbiB5b3lvKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3lveW8gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl95b3lvO1xuICB9O1xuXG4gIF9wcm90by5zZWVrID0gZnVuY3Rpb24gc2Vlayhwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICB9O1xuXG4gIF9wcm90by5yZXN0YXJ0ID0gZnVuY3Rpb24gcmVzdGFydChpbmNsdWRlRGVsYXksIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheSgpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICB9O1xuXG4gIF9wcm90by5wbGF5ID0gZnVuY3Rpb24gcGxheShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGlmIChmcm9tICE9IG51bGwpIHtcbiAgICAgIHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgaWYgKGZyb20gIT0gbnVsbCkge1xuICAgICAgdGhpcy5zZWVrKGZyb20gfHwgdGhpcy50b3RhbER1cmF0aW9uKCksIHN1cHByZXNzRXZlbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBpZiAoYXRUaW1lICE9IG51bGwpIHtcbiAgICAgIHRoaXMuc2VlayhhdFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5yZXZlcnNlZCA9IGZ1bmN0aW9uIHJldmVyc2VkKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICghIXZhbHVlICE9PSB0aGlzLnJldmVyc2VkKCkpIHtcbiAgICAgICAgdGhpcy50aW1lU2NhbGUoLXRoaXMuX3J0cyB8fCAodmFsdWUgPyAtX3RpbnlOdW0gOiAwKSk7IC8vIGluIGNhc2UgdGltZVNjYWxlIGlzIHplcm8sIHJldmVyc2luZyB3b3VsZCBoYXZlIG5vIGVmZmVjdCBzbyB3ZSB1c2UgX3RpbnlOdW0uXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9ydHMgPCAwO1xuICB9O1xuXG4gIF9wcm90by5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLl9pbml0dGVkID0gMDtcbiAgICB0aGlzLl96VGltZSA9IC1fdGlueU51bTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZShoYXNTdGFydGVkKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwLFxuICAgICAgICBzdGFydCA9IHRoaXMuX3N0YXJ0LFxuICAgICAgICByYXdUaW1lO1xuICAgIHJldHVybiAhISghcGFyZW50IHx8IHRoaXMuX3RzICYmICh0aGlzLl9pbml0dGVkIHx8ICFoYXNTdGFydGVkKSAmJiBwYXJlbnQuaXNBY3RpdmUoaGFzU3RhcnRlZCkgJiYgKHJhd1RpbWUgPSBwYXJlbnQucmF3VGltZSh0cnVlKSkgPj0gc3RhcnQgJiYgcmF3VGltZSA8IHRoaXMuZW5kVGltZSh0cnVlKSAtIF90aW55TnVtKTtcbiAgfTtcblxuICBfcHJvdG8uZXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIGV2ZW50Q2FsbGJhY2sodHlwZSwgY2FsbGJhY2ssIHBhcmFtcykge1xuICAgIHZhciB2YXJzID0gdGhpcy52YXJzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIGRlbGV0ZSB2YXJzW3R5cGVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyc1t0eXBlXSA9IGNhbGxiYWNrO1xuXG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICB2YXJzW3R5cGUgKyBcIlBhcmFtc1wiXSA9IHBhcmFtcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBcIm9uVXBkYXRlXCIpIHtcbiAgICAgICAgICB0aGlzLl9vblVwZGF0ZSA9IGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJzW3R5cGVdO1xuICB9O1xuXG4gIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHZhciBmID0gX2lzRnVuY3Rpb24ob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiBfcGFzc1Rocm91Z2gsXG4gICAgICAgICAgX3Jlc29sdmUgPSBmdW5jdGlvbiBfcmVzb2x2ZSgpIHtcbiAgICAgICAgdmFyIF90aGVuID0gc2VsZi50aGVuO1xuICAgICAgICBzZWxmLnRoZW4gPSBudWxsOyAvLyB0ZW1wb3JhcmlseSBudWxsIHRoZSB0aGVuKCkgbWV0aG9kIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzMyMilcblxuICAgICAgICBfaXNGdW5jdGlvbihmKSAmJiAoZiA9IGYoc2VsZikpICYmIChmLnRoZW4gfHwgZiA9PT0gc2VsZikgJiYgKHNlbGYudGhlbiA9IF90aGVuKTtcbiAgICAgICAgcmVzb2x2ZShmKTtcbiAgICAgICAgc2VsZi50aGVuID0gX3RoZW47XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2VsZi5faW5pdHRlZCAmJiBzZWxmLnRvdGFsUHJvZ3Jlc3MoKSA9PT0gMSAmJiBzZWxmLl90cyA+PSAwIHx8ICFzZWxmLl90VGltZSAmJiBzZWxmLl90cyA8IDApIHtcbiAgICAgICAgX3Jlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX3Byb20gPSBfcmVzb2x2ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ua2lsbCA9IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgX2ludGVycnVwdCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gQW5pbWF0aW9uO1xufSgpO1xuXG5fc2V0RGVmYXVsdHMoQW5pbWF0aW9uLnByb3RvdHlwZSwge1xuICBfdGltZTogMCxcbiAgX3N0YXJ0OiAwLFxuICBfZW5kOiAwLFxuICBfdFRpbWU6IDAsXG4gIF90RHVyOiAwLFxuICBfZGlydHk6IDAsXG4gIF9yZXBlYXQ6IDAsXG4gIF95b3lvOiBmYWxzZSxcbiAgcGFyZW50OiBudWxsLFxuICBfaW5pdHRlZDogZmFsc2UsXG4gIF9yRGVsYXk6IDAsXG4gIF90czogMSxcbiAgX2RwOiAwLFxuICByYXRpbzogMCxcbiAgX3pUaW1lOiAtX3RpbnlOdW0sXG4gIF9wcm9tOiAwLFxuICBfcHM6IGZhbHNlLFxuICBfcnRzOiAxXG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUSU1FTElORVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuZXhwb3J0IHZhciBUaW1lbGluZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0FuaW1hdGlvbikge1xuICBfaW5oZXJpdHNMb29zZShUaW1lbGluZSwgX0FuaW1hdGlvbik7XG5cbiAgZnVuY3Rpb24gVGltZWxpbmUodmFycywgdGltZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9BbmltYXRpb24uY2FsbCh0aGlzLCB2YXJzLCB0aW1lKSB8fCB0aGlzO1xuICAgIF90aGlzLmxhYmVscyA9IHt9O1xuICAgIF90aGlzLnNtb290aENoaWxkVGltaW5nID0gISF2YXJzLnNtb290aENoaWxkVGltaW5nO1xuICAgIF90aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9ICEhdmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW47XG4gICAgX3RoaXMuX3NvcnQgPSBfaXNOb3RGYWxzZSh2YXJzLnNvcnRDaGlsZHJlbik7XG4gICAgX3RoaXMucGFyZW50ICYmIF9wb3N0QWRkQ2hlY2tzKF90aGlzLnBhcmVudCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gVGltZWxpbmUucHJvdG90eXBlO1xuXG4gIF9wcm90bzIudG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCBfcGFyc2VWYXJzKGFyZ3VtZW50cywgMCwgdGhpcyksIF9wYXJzZVBvc2l0aW9uKHRoaXMsIF9pc051bWJlcih2YXJzKSA/IGFyZ3VtZW50c1szXSA6IHBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCBfcGFyc2VWYXJzKGFyZ3VtZW50cywgMSwgdGhpcyksIF9wYXJzZVBvc2l0aW9uKHRoaXMsIF9pc051bWJlcih2YXJzKSA/IGFyZ3VtZW50c1szXSA6IHBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycywgcG9zaXRpb24pIHtcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgX3BhcnNlVmFycyhhcmd1bWVudHMsIDIsIHRoaXMpLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBfaXNOdW1iZXIoZnJvbVZhcnMpID8gYXJndW1lbnRzWzRdIDogcG9zaXRpb24pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLnNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIHZhcnMuZHVyYXRpb24gPSAwO1xuICAgIHZhcnMucGFyZW50ID0gdGhpcztcbiAgICBfaW5oZXJpdERlZmF1bHRzKHZhcnMpLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuICAgIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gISF2YXJzLmltbWVkaWF0ZVJlbmRlcjtcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCAxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmNhbGwgPSBmdW5jdGlvbiBjYWxsKGNhbGxiYWNrLCBwYXJhbXMsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRoaXMsIFR3ZWVuLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMpLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbikpO1xuICB9IC8vT05MWSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSEgTWF5YmUgZGVsZXRlP1xuICA7XG5cbiAgX3Byb3RvMi5zdGFnZ2VyVG8gPSBmdW5jdGlvbiBzdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHZhcnMuc3RhZ2dlciA9IHZhcnMuc3RhZ2dlciB8fCBzdGFnZ2VyO1xuICAgIHZhcnMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVBbGw7XG4gICAgdmFycy5vbkNvbXBsZXRlUGFyYW1zID0gb25Db21wbGV0ZUFsbFBhcmFtcztcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5zdGFnZ2VyRnJvbSA9IGZ1bmN0aW9uIHN0YWdnZXJGcm9tKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHZhcnMucnVuQmFja3dhcmRzID0gMTtcbiAgICBfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKTtcbiAgfTtcblxuICBfcHJvdG8yLnN0YWdnZXJGcm9tVG8gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbVRvKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG4gICAgX2luaGVyaXREZWZhdWx0cyh0b1ZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgICB2YXIgcHJldlRpbWUgPSB0aGlzLl90aW1lLFxuICAgICAgICB0RHVyID0gdGhpcy5fZGlydHkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuX3REdXIsXG4gICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgdFRpbWUgPSB0aGlzICE9PSBfZ2xvYmFsVGltZWxpbmUgJiYgdG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmIHRvdGFsVGltZSA+PSAwID8gdER1ciA6IHRvdGFsVGltZSA8IF90aW55TnVtID8gMCA6IHRvdGFsVGltZSxcbiAgICAgICAgY3Jvc3NpbmdTdGFydCA9IHRoaXMuX3pUaW1lIDwgMCAhPT0gdG90YWxUaW1lIDwgMCAmJiAodGhpcy5faW5pdHRlZCB8fCAhZHVyKSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIG5leHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgcHJldlBhdXNlZCxcbiAgICAgICAgcGF1c2VUd2VlbixcbiAgICAgICAgdGltZVNjYWxlLFxuICAgICAgICBwcmV2U3RhcnQsXG4gICAgICAgIHByZXZJdGVyYXRpb24sXG4gICAgICAgIHlveW8sXG4gICAgICAgIGlzWW95bztcblxuICAgIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgZm9yY2UgfHwgY3Jvc3NpbmdTdGFydCkge1xuICAgICAgaWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmIGR1cikge1xuICAgICAgICAvL2lmIHRvdGFsRHVyYXRpb24oKSBmaW5kcyBhIGNoaWxkIHdpdGggYSBuZWdhdGl2ZSBzdGFydFRpbWUgYW5kIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHRoaW5ncyBnZXQgc2hpZnRlZCBhcm91bmQgaW50ZXJuYWxseSBzbyB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgdGltZSBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGlmIGEgdHdlZW4gc3RhcnRzIGF0IC0zMCB3ZSBtdXN0IHNoaWZ0IEVWRVJZVEhJTkcgZm9yd2FyZCAzMCBzZWNvbmRzIGFuZCBtb3ZlIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgYmFja3dhcmQgYnkgMzAgc2Vjb25kcyBzbyB0aGF0IHRoaW5ncyBhbGlnbiB3aXRoIHRoZSBwbGF5aGVhZCAobm8ganVtcCkuXG4gICAgICAgIHRUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgICAgdG90YWxUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgIH1cblxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgcHJldlN0YXJ0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICB0aW1lU2NhbGUgPSB0aGlzLl90cztcbiAgICAgIHByZXZQYXVzZWQgPSAhdGltZVNjYWxlO1xuXG4gICAgICBpZiAoY3Jvc3NpbmdTdGFydCkge1xuICAgICAgICBpZiAoIWR1cikge1xuICAgICAgICAgIHByZXZUaW1lID0gdGhpcy5felRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG90YWxUaW1lIHx8ICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICAgIC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUsIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuXG4gICAgICAgICAgdGhpcy5felRpbWUgPSB0b3RhbFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlcGVhdCkge1xuICAgICAgICAvL2FkanVzdCB0aGUgdGltZSBmb3IgcmVwZWF0cyBhbmQgeW95b3NcbiAgICAgICAgeW95byA9IHRoaXMuX3lveW87XG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yRGVsYXk7XG4gICAgICAgIHRpbWUgPSBfcm91bmQodFRpbWUgJSBjeWNsZUR1cmF0aW9uKTsgLy9yb3VuZCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnMuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblxuICAgICAgICBpZiAodGltZSA+IGR1ciB8fCB0RHVyID09PSB0VGltZSkge1xuICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRpb24gPSB+fih0VGltZSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSB0VGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcbiAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICAgIGl0ZXJhdGlvbi0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKHlveW8gJiYgaXRlcmF0aW9uICYgMSkge1xuICAgICAgICAgIHRpbWUgPSBkdXIgLSB0aW1lO1xuICAgICAgICAgIGlzWW95byA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgbWFrZSBzdXJlIGNoaWxkcmVuIGF0IHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSBhcmUgcmVuZGVyZWQgcHJvcGVybHkuIElmLCBmb3IgZXhhbXBsZSxcbiAgICAgICAgYSAzLXNlY29uZCBsb25nIHRpbWVsaW5lIHJlbmRlcmVkIGF0IDIuOSBzZWNvbmRzIHByZXZpb3VzbHksIGFuZCBub3cgcmVuZGVycyBhdCAzLjIgc2Vjb25kcyAod2hpY2hcbiAgICAgICAgd291bGQgZ2V0IHRyYW5zbGF0ZWQgdG8gMi44IHNlY29uZHMgaWYgdGhlIHRpbWVsaW5lIHlveW9zIG9yIDAuMiBzZWNvbmRzIGlmIGl0IGp1c3QgcmVwZWF0cyksIHRoZXJlXG4gICAgICAgIGNvdWxkIGJlIGEgY2FsbGJhY2sgb3IgYSBzaG9ydCB0d2VlbiB0aGF0J3MgYXQgMi45NSBvciAzIHNlY29uZHMgaW4gd2hpY2ggd291bGRuJ3QgcmVuZGVyLiBTb1xuICAgICAgICB3ZSBuZWVkIHRvIHB1c2ggdGhlIHRpbWVsaW5lIHRvIHRoZSBlbmQgKGFuZC9vciBiZWdpbm5pbmcgZGVwZW5kaW5nIG9uIGl0cyB5b3lvIHZhbHVlKS4gQWxzbyB3ZSBtdXN0XG4gICAgICAgIGVuc3VyZSB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIFRpbWVsaW5lIHdvcmsuXG4gICAgICAgICovXG5cblxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmICF0aGlzLl9sb2NrKSB7XG4gICAgICAgICAgdmFyIHJld2luZGluZyA9IHlveW8gJiYgcHJldkl0ZXJhdGlvbiAmIDEsXG4gICAgICAgICAgICAgIGRvZXNXcmFwID0gcmV3aW5kaW5nID09PSAoeW95byAmJiBpdGVyYXRpb24gJiAxKTtcblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gPCBwcmV2SXRlcmF0aW9uKSB7XG4gICAgICAgICAgICByZXdpbmRpbmcgPSAhcmV3aW5kaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gMCA6IGR1cjtcbiAgICAgICAgICB0aGlzLl9sb2NrID0gMTtcbiAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSwgc3VwcHJlc3NFdmVudHMsICFkdXIpLl9sb2NrID0gMDtcblxuICAgICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgKHRoaXMuaW52YWxpZGF0ZSgpLl9sb2NrID0gMSk7XG5cbiAgICAgICAgICBpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUgfHwgcHJldlBhdXNlZCAhPT0gIXRoaXMuX3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZG9lc1dyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2sgPSAyO1xuICAgICAgICAgICAgcHJldlRpbWUgPSByZXdpbmRpbmcgPyBkdXIgKyAwLjAwMDEgOiAtMC4wMDAxO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9sb2NrID0gMDtcblxuICAgICAgICAgIGlmICghdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gLy9pbiBvcmRlciBmb3IgeW95b0Vhc2UgdG8gd29yayBwcm9wZXJseSB3aGVuIHRoZXJlJ3MgYSBzdGFnZ2VyLCB3ZSBtdXN0IHN3YXAgb3V0IHRoZSBlYXNlIGluIGVhY2ggc3ViLXR3ZWVuLlxuICAgICAgICAgIC8vX3Byb3BhZ2F0ZVlveW9FYXNlKHRoaXMsIGlzWW95byk7XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faGFzUGF1c2UgJiYgIXRoaXMuX2ZvcmNpbmcgJiYgdGhpcy5fbG9jayA8IDIpIHtcbiAgICAgICAgcGF1c2VUd2VlbiA9IF9maW5kTmV4dFBhdXNlVHdlZW4odGhpcywgX3JvdW5kKHByZXZUaW1lKSwgX3JvdW5kKHRpbWUpKTtcblxuICAgICAgICBpZiAocGF1c2VUd2Vlbikge1xuICAgICAgICAgIHRUaW1lIC09IHRpbWUgLSAodGltZSA9IHBhdXNlVHdlZW4uX3N0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl90VGltZSA9IHRUaW1lO1xuICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgICB0aGlzLl9hY3QgPSAhdGltZVNjYWxlOyAvL2FzIGxvbmcgYXMgaXQncyBub3QgcGF1c2VkLCBmb3JjZSBpdCB0byBiZSBhY3RpdmUgc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGluZGVwZW5kZW50IG9mIHRoZSBwYXJlbnQgdGltZWxpbmUsIGl0J2xsIGJlIGZvcmNlZCB0byByZS1yZW5kZXIgb24gdGhlIG5leHQgdGljay5cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIHRoaXMuX29uVXBkYXRlID0gdGhpcy52YXJzLm9uVXBkYXRlO1xuICAgICAgICB0aGlzLl9pbml0dGVkID0gMTtcbiAgICAgICAgdGhpcy5felRpbWUgPSB0b3RhbFRpbWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghcHJldlRpbWUgJiYgdGltZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWUgPj0gcHJldlRpbWUgJiYgdG90YWxUaW1lID49IDApIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLl9maXJzdDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgdGltZSA+PSBjaGlsZC5fc3RhcnQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSArICh0aW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcbiAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgIG5leHQgJiYgKHRUaW1lICs9IHRoaXMuX3pUaW1lID0gLV90aW55TnVtKTsgLy8gaXQgZGlkbid0IGZpbmlzaCByZW5kZXJpbmcsIHNvIGZsYWcgelRpbWUgYXMgbmVnYXRpdmUgc28gdGhhdCBzbyB0aGF0IHRoZSBuZXh0IHRpbWUgcmVuZGVyKCkgaXMgY2FsbGVkIGl0J2xsIGJlIGZvcmNlZCAodG8gcmVuZGVyIGFueSByZW1haW5pbmcgY2hpbGRyZW4pXG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZCA9IHRoaXMuX2xhc3Q7XG4gICAgICAgIHZhciBhZGp1c3RlZFRpbWUgPSB0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZTsgLy93aGVuIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIGJleW9uZCB0aGUgc3RhcnQgb2YgdGhpcyB0aW1lbGluZSwgd2UgbXVzdCBwYXNzIHRoYXQgaW5mb3JtYXRpb24gZG93biB0byB0aGUgY2hpbGQgYW5pbWF0aW9ucyBzbyB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGtub3cgd2hldGhlciB0byByZW5kZXIgdGhlaXIgc3RhcnRpbmcgb3IgZW5kaW5nIHZhbHVlcy5cblxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBuZXh0ID0gY2hpbGQuX3ByZXY7XG5cbiAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgYWRqdXN0ZWRUaW1lIDw9IGNoaWxkLl9lbmQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cbiAgICAgICAgICAgIGlmICh0aW1lICE9PSB0aGlzLl90aW1lIHx8ICF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgICAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG4gICAgICAgICAgICAgIHBhdXNlVHdlZW4gPSAwO1xuICAgICAgICAgICAgICBuZXh0ICYmICh0VGltZSArPSB0aGlzLl96VGltZSA9IGFkanVzdGVkVGltZSA/IC1fdGlueU51bSA6IF90aW55TnVtKTsgLy8gaXQgZGlkbid0IGZpbmlzaCByZW5kZXJpbmcsIHNvIGFkanVzdCB6VGltZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhdXNlVHdlZW4gJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgcGF1c2VUd2Vlbi5yZW5kZXIodGltZSA+PSBwcmV2VGltZSA/IDAgOiAtX3RpbnlOdW0pLl96VGltZSA9IHRpbWUgPj0gcHJldlRpbWUgPyAxIDogLTE7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RzKSB7XG4gICAgICAgICAgLy90aGUgY2FsbGJhY2sgcmVzdW1lZCBwbGF5YmFjayEgU28gc2luY2Ugd2UgbWF5IGhhdmUgaGVsZCBiYWNrIHRoZSBwbGF5aGVhZCBkdWUgdG8gd2hlcmUgdGhlIHBhdXNlIGlzIHBvc2l0aW9uZWQsIGdvIGFoZWFkIGFuZCBqdW1wIHRvIHdoZXJlIGl0J3MgU1VQUE9TRUQgdG8gYmUgKGlmIG5vIHBhdXNlIGhhcHBlbmVkKS5cbiAgICAgICAgICB0aGlzLl9zdGFydCA9IHByZXZTdGFydDsgLy9pZiB0aGUgcGF1c2Ugd2FzIGF0IGFuIGVhcmxpZXIgdGltZSBhbmQgdGhlIHVzZXIgcmVzdW1lZCBpbiB0aGUgY2FsbGJhY2ssIGl0IGNvdWxkIHJlcG9zaXRpb24gdGhlIHRpbWVsaW5lIChjaGFuZ2luZyBpdHMgc3RhcnRUaW1lKSwgdGhyb3dpbmcgdGhpbmdzIG9mZiBzbGlnaHRseSwgc28gd2UgbWFrZSBzdXJlIHRoZSBfc3RhcnQgZG9lc24ndCBzaGlmdC5cblxuICAgICAgICAgIF9zZXRFbmQodGhpcyk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25VcGRhdGVcIiwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0VGltZSA9PT0gdER1ciAmJiB0RHVyID49IHRoaXMudG90YWxEdXJhdGlvbigpIHx8ICF0VGltZSAmJiB0aGlzLl90cyA8IDApIGlmIChwcmV2U3RhcnQgPT09IHRoaXMuX3N0YXJ0IHx8IE1hdGguYWJzKHRpbWVTY2FsZSkgIT09IE1hdGguYWJzKHRoaXMuX3RzKSkgaWYgKCF0aGlzLl9sb2NrKSB7XG4gICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRvdGFsVGltZSAmJiB0aGlzLl90cyA+IDAgfHwgIXRUaW1lICYmIHRoaXMuX3RzIDwgMCkgJiYgX3JlbW92ZUZyb21QYXJlbnQodGhpcywgMSk7IC8vIGRvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxuXG4gICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkpIHtcbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgdFRpbWUgPT09IHREdXIgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICB0aGlzLl9wcm9tICYmIHRoaXMuX3Byb20oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuYWRkID0gZnVuY3Rpb24gYWRkKGNoaWxkLCBwb3NpdGlvbikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKCFfaXNOdW1iZXIocG9zaXRpb24pKSB7XG4gICAgICBwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIEFuaW1hdGlvbikpIHtcbiAgICAgIGlmIChfaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5hZGQob2JqLCBwb3NpdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZExhYmVsKGNoaWxkLCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcyAhPT0gY2hpbGQgPyBfYWRkVG9UaW1lbGluZSh0aGlzLCBjaGlsZCwgcG9zaXRpb24pIDogdGhpczsgLy9kb24ndCBhbGxvdyBhIHRpbWVsaW5lIHRvIGJlIGFkZGVkIHRvIGl0c2VsZiBhcyBhIGNoaWxkIVxuICB9O1xuXG4gIF9wcm90bzIuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKG5lc3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0d2VlbnMgPT09IHZvaWQgMCkge1xuICAgICAgdHdlZW5zID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGltZWxpbmVzID09PSB2b2lkIDApIHtcbiAgICAgIHRpbWVsaW5lcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IC1fYmlnTnVtO1xuICAgIH1cblxuICAgIHZhciBhID0gW10sXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICAgIGlmICh0d2VlbnMpIHtcbiAgICAgICAgICAgIGEucHVzaChjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aW1lbGluZXMpIHtcbiAgICAgICAgICAgIGEucHVzaChjaGlsZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGNoaWxkLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRCeUlkID0gZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHZhciBhbmltYXRpb25zID0gdGhpcy5nZXRDaGlsZHJlbigxLCAxLCAxKSxcbiAgICAgICAgaSA9IGFuaW1hdGlvbnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGFuaW1hdGlvbnNbaV0udmFycy5pZCA9PT0gaWQpIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbnNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGNoaWxkKSB7XG4gICAgaWYgKF9pc1N0cmluZyhjaGlsZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZUxhYmVsKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5raWxsVHdlZW5zT2YoY2hpbGQpO1xuICAgIH1cblxuICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBjaGlsZCk7XG5cbiAgICBpZiAoY2hpbGQgPT09IHRoaXMuX3JlY2VudCkge1xuICAgICAgdGhpcy5fcmVjZW50ID0gdGhpcy5fbGFzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMi50b3RhbFRpbWUgPSBmdW5jdGlvbiB0b3RhbFRpbWUoX3RvdGFsVGltZTIsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdFRpbWU7XG4gICAgfVxuXG4gICAgdGhpcy5fZm9yY2luZyA9IDE7XG5cbiAgICBpZiAoIXRoaXMucGFyZW50ICYmICF0aGlzLl9kcCAmJiB0aGlzLl90cykge1xuICAgICAgLy9zcGVjaWFsIGNhc2UgZm9yIHRoZSBnbG9iYWwgdGltZWxpbmUgKG9yIGFueSBvdGhlciB0aGF0IGhhcyBubyBwYXJlbnQgb3IgZGV0YWNoZWQgcGFyZW50KS5cbiAgICAgIHRoaXMuX3N0YXJ0ID0gX3JvdW5kKF90aWNrZXIudGltZSAtICh0aGlzLl90cyA+IDAgPyBfdG90YWxUaW1lMiAvIHRoaXMuX3RzIDogKHRoaXMudG90YWxEdXJhdGlvbigpIC0gX3RvdGFsVGltZTIpIC8gLXRoaXMuX3RzKSk7XG4gICAgfVxuXG4gICAgX0FuaW1hdGlvbi5wcm90b3R5cGUudG90YWxUaW1lLmNhbGwodGhpcywgX3RvdGFsVGltZTIsIHN1cHByZXNzRXZlbnRzKTtcblxuICAgIHRoaXMuX2ZvcmNpbmcgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuYWRkTGFiZWwgPSBmdW5jdGlvbiBhZGRMYWJlbChsYWJlbCwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmxhYmVsc1tsYWJlbF0gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5yZW1vdmVMYWJlbCA9IGZ1bmN0aW9uIHJlbW92ZUxhYmVsKGxhYmVsKSB7XG4gICAgZGVsZXRlIHRoaXMubGFiZWxzW2xhYmVsXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZFBhdXNlID0gZnVuY3Rpb24gYWRkUGF1c2UocG9zaXRpb24sIGNhbGxiYWNrLCBwYXJhbXMpIHtcbiAgICB2YXIgdCA9IFR3ZWVuLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrIHx8IF9lbXB0eUZ1bmMsIHBhcmFtcyk7XG4gICAgdC5kYXRhID0gXCJpc1BhdXNlXCI7XG4gICAgdGhpcy5faGFzUGF1c2UgPSAxO1xuICAgIHJldHVybiBfYWRkVG9UaW1lbGluZSh0aGlzLCB0LCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbikpO1xuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlUGF1c2UgPSBmdW5jdGlvbiByZW1vdmVQYXVzZShwb3NpdGlvbikge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuICAgIHBvc2l0aW9uID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX3N0YXJ0ID09PSBwb3NpdGlvbiAmJiBjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIikge1xuICAgICAgICBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzIua2lsbFR3ZWVuc09mID0gZnVuY3Rpb24ga2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKSB7XG4gICAgdmFyIHR3ZWVucyA9IHRoaXMuZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSksXG4gICAgICAgIGkgPSB0d2VlbnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgX292ZXJ3cml0aW5nVHdlZW4gIT09IHR3ZWVuc1tpXSAmJiB0d2VlbnNbaV0ua2lsbCh0YXJnZXRzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRUd2VlbnNPZiA9IGZ1bmN0aW9uIGdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpIHtcbiAgICB2YXIgYSA9IFtdLFxuICAgICAgICBwYXJzZWRUYXJnZXRzID0gdG9BcnJheSh0YXJnZXRzKSxcbiAgICAgICAgY2hpbGQgPSB0aGlzLl9maXJzdCxcbiAgICAgICAgY2hpbGRyZW47XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuKSB7XG4gICAgICAgIGlmIChfYXJyYXlDb250YWluc0FueShjaGlsZC5fdGFyZ2V0cywgcGFyc2VkVGFyZ2V0cykgJiYgKCFvbmx5QWN0aXZlIHx8IGNoaWxkLmlzQWN0aXZlKG9ubHlBY3RpdmUgPT09IFwic3RhcnRlZFwiKSkpIHtcbiAgICAgICAgICBhLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChjaGlsZHJlbiA9IGNoaWxkLmdldFR3ZWVuc09mKHBhcnNlZFRhcmdldHMsIG9ubHlBY3RpdmUpKS5sZW5ndGgpIHtcbiAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBfcHJvdG8yLnR3ZWVuVG8gPSBmdW5jdGlvbiB0d2VlblRvKHBvc2l0aW9uLCB2YXJzKSB7XG4gICAgdmFycyA9IHZhcnMgfHwge307XG5cbiAgICB2YXIgdGwgPSB0aGlzLFxuICAgICAgICBlbmRUaW1lID0gX3BhcnNlUG9zaXRpb24odGwsIHBvc2l0aW9uKSxcbiAgICAgICAgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBzdGFydEF0ID0gX3ZhcnMuc3RhcnRBdCxcbiAgICAgICAgX29uU3RhcnQgPSBfdmFycy5vblN0YXJ0LFxuICAgICAgICBvblN0YXJ0UGFyYW1zID0gX3ZhcnMub25TdGFydFBhcmFtcyxcbiAgICAgICAgdHdlZW4gPSBUd2Vlbi50byh0bCwgX3NldERlZmF1bHRzKHZhcnMsIHtcbiAgICAgIGVhc2U6IFwibm9uZVwiLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICB0aW1lOiBlbmRUaW1lLFxuICAgICAgZHVyYXRpb246IHZhcnMuZHVyYXRpb24gfHwgTWF0aC5hYnMoKGVuZFRpbWUgLSAoc3RhcnRBdCAmJiBcInRpbWVcIiBpbiBzdGFydEF0ID8gc3RhcnRBdC50aW1lIDogdGwuX3RpbWUpKSAvIHRsLnRpbWVTY2FsZSgpKSB8fCBfdGlueU51bSxcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIHRsLnBhdXNlKCk7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHZhcnMuZHVyYXRpb24gfHwgTWF0aC5hYnMoKGVuZFRpbWUgLSB0bC5fdGltZSkgLyB0bC50aW1lU2NhbGUoKSk7XG5cbiAgICAgICAgaWYgKHR3ZWVuLl9kdXIgIT09IGR1cmF0aW9uKSB7XG4gICAgICAgICAgX3NldER1cmF0aW9uKHR3ZWVuLCBkdXJhdGlvbikucmVuZGVyKHR3ZWVuLl90aW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfb25TdGFydCkge1xuICAgICAgICAgIC8vaW4gY2FzZSB0aGUgdXNlciBoYWQgYW4gb25TdGFydCBpbiB0aGUgdmFycyAtIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIGl0LlxuICAgICAgICAgIF9vblN0YXJ0LmFwcGx5KHR3ZWVuLCBvblN0YXJ0UGFyYW1zIHx8IFtdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJldHVybiB0d2VlbjtcbiAgfTtcblxuICBfcHJvdG8yLnR3ZWVuRnJvbVRvID0gZnVuY3Rpb24gdHdlZW5Gcm9tVG8oZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uLCB2YXJzKSB7XG4gICAgcmV0dXJuIHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgc3RhcnRBdDoge1xuICAgICAgICB0aW1lOiBfcGFyc2VQb3NpdGlvbih0aGlzLCBmcm9tUG9zaXRpb24pXG4gICAgICB9XG4gICAgfSwgdmFycykpO1xuICB9O1xuXG4gIF9wcm90bzIucmVjZW50ID0gZnVuY3Rpb24gcmVjZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWNlbnQ7XG4gIH07XG5cbiAgX3Byb3RvMi5uZXh0TGFiZWwgPSBmdW5jdGlvbiBuZXh0TGFiZWwoYWZ0ZXJUaW1lKSB7XG4gICAgaWYgKGFmdGVyVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBhZnRlclRpbWUgPSB0aGlzLl90aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBhZnRlclRpbWUpKTtcbiAgfTtcblxuICBfcHJvdG8yLnByZXZpb3VzTGFiZWwgPSBmdW5jdGlvbiBwcmV2aW91c0xhYmVsKGJlZm9yZVRpbWUpIHtcbiAgICBpZiAoYmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBiZWZvcmVUaW1lID0gdGhpcy5fdGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldExhYmVsSW5EaXJlY3Rpb24odGhpcywgX3BhcnNlUG9zaXRpb24odGhpcywgYmVmb3JlVGltZSksIDEpO1xuICB9O1xuXG4gIF9wcm90bzIuY3VycmVudExhYmVsID0gZnVuY3Rpb24gY3VycmVudExhYmVsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnNlZWsodmFsdWUsIHRydWUpIDogdGhpcy5wcmV2aW91c0xhYmVsKHRoaXMuX3RpbWUgKyBfdGlueU51bSk7XG4gIH07XG5cbiAgX3Byb3RvMi5zaGlmdENoaWxkcmVuID0gZnVuY3Rpb24gc2hpZnRDaGlsZHJlbihhbW91bnQsIGFkanVzdExhYmVscywgaWdub3JlQmVmb3JlVGltZSkge1xuICAgIGlmIChpZ25vcmVCZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAwO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBsYWJlbHMgPSB0aGlzLmxhYmVscyxcbiAgICAgICAgcDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgIGNoaWxkLl9zdGFydCArPSBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKGFkanVzdExhYmVscykge1xuICAgICAgZm9yIChwIGluIGxhYmVscykge1xuICAgICAgICBpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgICBsYWJlbHNbcF0gKz0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG4gICAgdGhpcy5fbG9jayA9IDA7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLmludmFsaWRhdGUoKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoaW5jbHVkZUxhYmVscykge1xuICAgIGlmIChpbmNsdWRlTGFiZWxzID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGVMYWJlbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBuZXh0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG4gICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICBjaGlsZCA9IG5leHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fdGltZSA9IHRoaXMuX3RUaW1lID0gMDtcblxuICAgIGlmIChpbmNsdWRlTGFiZWxzKSB7XG4gICAgICB0aGlzLmxhYmVscyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiB0b3RhbER1cmF0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG1heCA9IDAsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBjaGlsZCA9IHNlbGYuX2xhc3QsXG4gICAgICAgIHByZXZTdGFydCA9IF9iaWdOdW0sXG4gICAgICAgIHByZXYsXG4gICAgICAgIGVuZCxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHBhcmVudDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2VsZi50aW1lU2NhbGUoKHNlbGYuX3JlcGVhdCA8IDAgPyBzZWxmLmR1cmF0aW9uKCkgOiBzZWxmLnRvdGFsRHVyYXRpb24oKSkgLyAoc2VsZi5yZXZlcnNlZCgpID8gLXZhbHVlIDogdmFsdWUpKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fZGlydHkpIHtcbiAgICAgIHBhcmVudCA9IHNlbGYucGFyZW50O1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgcHJldiA9IGNoaWxkLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXG5cbiAgICAgICAgaWYgKGNoaWxkLl9kaXJ0eSkge1xuICAgICAgICAgIGNoaWxkLnRvdGFsRHVyYXRpb24oKTsgLy9jb3VsZCBjaGFuZ2UgdGhlIHR3ZWVuLl9zdGFydFRpbWUsIHNvIG1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uJ3MgY2FjaGUgaXMgY2xlYW4gYmVmb3JlIGFuYWx5emluZyBpdC5cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gY2hpbGQuX3N0YXJ0O1xuXG4gICAgICAgIGlmIChzdGFydCA+IHByZXZTdGFydCAmJiBzZWxmLl9zb3J0ICYmIGNoaWxkLl90cyAmJiAhc2VsZi5fbG9jaykge1xuICAgICAgICAgIC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICBzZWxmLl9sb2NrID0gMTsgLy9wcmV2ZW50IGVuZGxlc3MgcmVjdXJzaXZlIGNhbGxzIC0gdGhlcmUgYXJlIG1ldGhvZHMgdGhhdCBnZXQgdHJpZ2dlcmVkIHRoYXQgY2hlY2sgZHVyYXRpb24vdG90YWxEdXJhdGlvbiB3aGVuIHdlIGFkZCgpLlxuXG4gICAgICAgICAgX2FkZFRvVGltZWxpbmUoc2VsZiwgY2hpbGQsIHN0YXJ0IC0gY2hpbGQuX2RlbGF5LCAxKS5fbG9jayA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldlN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgPCAwICYmIGNoaWxkLl90cykge1xuICAgICAgICAgIC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXG4gICAgICAgICAgbWF4IC09IHN0YXJ0O1xuXG4gICAgICAgICAgaWYgKCFwYXJlbnQgJiYgIXNlbGYuX2RwIHx8IHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0YXJ0ICs9IHN0YXJ0IC8gc2VsZi5fdHM7XG4gICAgICAgICAgICBzZWxmLl90aW1lIC09IHN0YXJ0O1xuICAgICAgICAgICAgc2VsZi5fdFRpbWUgLT0gc3RhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5zaGlmdENoaWxkcmVuKC1zdGFydCwgZmFsc2UsIC0xZTIwKTtcbiAgICAgICAgICBwcmV2U3RhcnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kID0gX3NldEVuZChjaGlsZCk7XG5cbiAgICAgICAgaWYgKGVuZCA+IG1heCAmJiBjaGlsZC5fdHMpIHtcbiAgICAgICAgICBtYXggPSBlbmQ7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHByZXY7XG4gICAgICB9XG5cbiAgICAgIF9zZXREdXJhdGlvbihzZWxmLCBzZWxmID09PSBfZ2xvYmFsVGltZWxpbmUgJiYgc2VsZi5fdGltZSA+IG1heCA/IHNlbGYuX3RpbWUgOiBNYXRoLm1pbihfYmlnTnVtLCBtYXgpLCAxKTtcblxuICAgICAgc2VsZi5fZGlydHkgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLl90RHVyO1xuICB9O1xuXG4gIFRpbWVsaW5lLnVwZGF0ZVJvb3QgPSBmdW5jdGlvbiB1cGRhdGVSb290KHRpbWUpIHtcbiAgICBpZiAoX2dsb2JhbFRpbWVsaW5lLl90cykge1xuICAgICAgX2xhenlTYWZlUmVuZGVyKF9nbG9iYWxUaW1lbGluZSwgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGltZSwgX2dsb2JhbFRpbWVsaW5lKSk7XG5cbiAgICAgIF9sYXN0UmVuZGVyZWRGcmFtZSA9IF90aWNrZXIuZnJhbWU7XG4gICAgfVxuXG4gICAgaWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7XG4gICAgICBfbmV4dEdDRnJhbWUgKz0gX2NvbmZpZy5hdXRvU2xlZXAgfHwgMTIwO1xuICAgICAgdmFyIGNoaWxkID0gX2dsb2JhbFRpbWVsaW5lLl9maXJzdDtcbiAgICAgIGlmICghY2hpbGQgfHwgIWNoaWxkLl90cykgaWYgKF9jb25maWcuYXV0b1NsZWVwICYmIF90aWNrZXIuX2xpc3RlbmVycy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHdoaWxlIChjaGlsZCAmJiAhY2hpbGQuX3RzKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICBfdGlja2VyLnNsZWVwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVsaW5lO1xufShBbmltYXRpb24pO1xuXG5fc2V0RGVmYXVsdHMoVGltZWxpbmUucHJvdG90eXBlLCB7XG4gIF9sb2NrOiAwLFxuICBfaGFzUGF1c2U6IDAsXG4gIF9mb3JjaW5nOiAwXG59KTtcblxudmFyIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKSB7XG4gIC8vbm90ZTogd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cbiAgdmFyIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCAwLCAxLCBfcmVuZGVyQ29tcGxleFN0cmluZywgbnVsbCwgc2V0dGVyKSxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnROdW1zLFxuICAgICAgY29sb3IsXG4gICAgICBlbmROdW0sXG4gICAgICBjaHVuayxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgaGFzUmFuZG9tLFxuICAgICAgYTtcbiAgcHQuYiA9IHN0YXJ0O1xuICBwdC5lID0gZW5kO1xuICBzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoaGFzUmFuZG9tID0gfmVuZC5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gIH1cblxuICBpZiAoc3RyaW5nRmlsdGVyKSB7XG4gICAgYSA9IFtzdGFydCwgZW5kXTtcbiAgICBzdHJpbmdGaWx0ZXIoYSwgdGFyZ2V0LCBwcm9wKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLlxuXG4gICAgc3RhcnQgPSBhWzBdO1xuICAgIGVuZCA9IGFbMV07XG4gIH1cblxuICBzdGFydE51bXMgPSBzdGFydC5tYXRjaChfY29tcGxleFN0cmluZ051bUV4cCkgfHwgW107XG5cbiAgd2hpbGUgKHJlc3VsdCA9IF9jb21wbGV4U3RyaW5nTnVtRXhwLmV4ZWMoZW5kKSkge1xuICAgIGVuZE51bSA9IHJlc3VsdFswXTtcbiAgICBjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XG4gICAgICBjb2xvciA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGVuZE51bSAhPT0gc3RhcnROdW1zW21hdGNoSW5kZXgrK10pIHtcbiAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydE51bXNbbWF0Y2hJbmRleCAtIDFdKSB8fCAwOyAvL3RoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cbiAgICAgIHB0Ll9wdCA9IHtcbiAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXG4gICAgICAgIC8vbm90ZTogU1ZHIHNwZWMgYWxsb3dzIG9taXNzaW9uIG9mIGNvbW1hL3NwYWNlIHdoZW4gYSBuZWdhdGl2ZSBzaWduIGlzIHdlZGdlZCBiZXR3ZWVuIHR3byBudW1iZXJzLCBsaWtlIDIuNS01LjMgaW5zdGVhZCBvZiAyLjUsLTUuMyBidXQgd2hlbiB0d2VlbmluZywgdGhlIG5lZ2F0aXZlIHZhbHVlIG1heSBzd2l0Y2ggdG8gcG9zaXRpdmUsIHNvIHdlIGluc2VydCB0aGUgY29tbWEganVzdCBpbiBjYXNlLlxuICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgYzogZW5kTnVtLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyBwYXJzZUZsb2F0KGVuZE51bS5zdWJzdHIoMikpICogKGVuZE51bS5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSA6IHBhcnNlRmxvYXQoZW5kTnVtKSAtIHN0YXJ0TnVtLFxuICAgICAgICBtOiBjb2xvciAmJiBjb2xvciA8IDQgPyBNYXRoLnJvdW5kIDogMFxuICAgICAgfTtcbiAgICAgIGluZGV4ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAubGFzdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBzdHJpbmcgKGFmdGVyIHRoZSBsYXN0IG51bWJlcilcblxuICBwdC5mcCA9IGZ1bmNQYXJhbTtcblxuICBpZiAoX3JlbEV4cC50ZXN0KGVuZCkgfHwgaGFzUmFuZG9tKSB7XG4gICAgcHQuZSA9IDA7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cbiAgfVxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgaW5kZXgsIHRhcmdldHMsIG1vZGlmaWVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICBpZiAoX2lzRnVuY3Rpb24oZW5kKSkge1xuICAgIGVuZCA9IGVuZChpbmRleCB8fCAwLCB0YXJnZXQsIHRhcmdldHMpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXSxcbiAgICAgIHBhcnNlZFN0YXJ0ID0gc3RhcnQgIT09IFwiZ2V0XCIgPyBzdGFydCA6ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gY3VycmVudFZhbHVlIDogZnVuY1BhcmFtID8gdGFyZ2V0W3Byb3AuaW5kZXhPZihcInNldFwiKSB8fCAhX2lzRnVuY3Rpb24odGFyZ2V0W1wiZ2V0XCIgKyBwcm9wLnN1YnN0cigzKV0pID8gcHJvcCA6IFwiZ2V0XCIgKyBwcm9wLnN1YnN0cigzKV0oZnVuY1BhcmFtKSA6IHRhcmdldFtwcm9wXSgpLFxuICAgICAgc2V0dGVyID0gIV9pc0Z1bmN0aW9uKGN1cnJlbnRWYWx1ZSkgPyBfc2V0dGVyUGxhaW4gOiBmdW5jUGFyYW0gPyBfc2V0dGVyRnVuY1dpdGhQYXJhbSA6IF9zZXR0ZXJGdW5jLFxuICAgICAgcHQ7XG5cbiAgaWYgKF9pc1N0cmluZyhlbmQpKSB7XG4gICAgaWYgKH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKGVuZC5jaGFyQXQoMSkgPT09IFwiPVwiKSB7XG4gICAgICBlbmQgPSBwYXJzZUZsb2F0KHBhcnNlZFN0YXJ0KSArIHBhcnNlRmxvYXQoZW5kLnN1YnN0cigyKSkgKiAoZW5kLmNoYXJBdCgwKSA9PT0gXCItXCIgPyAtMSA6IDEpICsgKGdldFVuaXQocGFyc2VkU3RhcnQpIHx8IDApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJzZWRTdGFydCAhPT0gZW5kKSB7XG4gICAgaWYgKCFpc05hTihwYXJzZWRTdGFydCArIGVuZCkpIHtcbiAgICAgIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCArcGFyc2VkU3RhcnQgfHwgMCwgZW5kIC0gKHBhcnNlZFN0YXJ0IHx8IDApLCB0eXBlb2YgY3VycmVudFZhbHVlID09PSBcImJvb2xlYW5cIiA/IF9yZW5kZXJCb29sZWFuIDogX3JlbmRlclBsYWluLCAwLCBzZXR0ZXIpO1xuXG4gICAgICBpZiAoZnVuY1BhcmFtKSB7XG4gICAgICAgIHB0LmZwID0gZnVuY1BhcmFtO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgcHQubW9kaWZpZXIobW9kaWZpZXIsIHRoaXMsIHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9wdCA9IHB0O1xuICAgIH1cblxuICAgICFjdXJyZW50VmFsdWUgJiYgIShwcm9wIGluIHRhcmdldCkgJiYgX21pc3NpbmdQbHVnaW4ocHJvcCwgZW5kKTtcbiAgICByZXR1cm4gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0aGlzLCB0YXJnZXQsIHByb3AsIHBhcnNlZFN0YXJ0LCBlbmQsIHNldHRlciwgc3RyaW5nRmlsdGVyIHx8IF9jb25maWcuc3RyaW5nRmlsdGVyLCBmdW5jUGFyYW0pO1xuICB9XG59LFxuICAgIC8vY3JlYXRlcyBhIGNvcHkgb2YgdGhlIHZhcnMgb2JqZWN0IGFuZCBwcm9jZXNzZXMgYW55IGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyAocHV0dGluZyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBkaXJlY3RseSBpbnRvIHRoZSBjb3B5KSBhcyB3ZWxsIGFzIHN0cmluZ3Mgd2l0aCBcInJhbmRvbSgpXCIgaW4gdGhlbS4gSXQgZG9lcyBOT1QgcHJvY2VzcyByZWxhdGl2ZSB2YWx1ZXMuXG5fcHJvY2Vzc1ZhcnMgPSBmdW5jdGlvbiBfcHJvY2Vzc1ZhcnModmFycywgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pIHtcbiAgaWYgKF9pc0Z1bmN0aW9uKHZhcnMpKSB7XG4gICAgdmFycyA9IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gIH1cblxuICBpZiAoIV9pc09iamVjdCh2YXJzKSB8fCB2YXJzLnN0eWxlICYmIHZhcnMubm9kZVR5cGUgfHwgX2lzQXJyYXkodmFycykpIHtcbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhcnMpID8gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHZhcnM7XG4gIH1cblxuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gdmFycykge1xuICAgIGNvcHlbcF0gPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFyc1twXSwgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9jaGVja1BsdWdpbiA9IGZ1bmN0aW9uIF9jaGVja1BsdWdpbihwcm9wZXJ0eSwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgdmFyIHBsdWdpbiwgcHQsIHB0TG9va3VwLCBpO1xuXG4gIGlmIChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twcm9wZXJ0eV0oKSkuaW5pdCh0YXJnZXQsIHBsdWdpbi5yYXdWYXJzID8gdmFyc1twcm9wZXJ0eV0gOiBfcHJvY2Vzc1ZhcnModmFyc1twcm9wZXJ0eV0sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICB0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cbiAgICBpZiAodHdlZW4gIT09IF9xdWlja1R3ZWVuKSB7XG4gICAgICBwdExvb2t1cCA9IHR3ZWVuLl9wdExvb2t1cFt0d2Vlbi5fdGFyZ2V0cy5pbmRleE9mKHRhcmdldCldOyAvL25vdGU6IHdlIGNhbid0IHVzZSB0d2Vlbi5fcHRMb29rdXBbaW5kZXhdIGJlY2F1c2UgZm9yIHN0YWdnZXJlZCB0d2VlbnMsIHRoZSBpbmRleCBmcm9tIHRoZSBmdWxsVGFyZ2V0cyBhcnJheSB3b24ndCBtYXRjaCB3aGF0IGl0IGlzIGluIGVhY2ggaW5kaXZpZHVhbCB0d2VlbiB0aGF0IHNwYXducyBmcm9tIHRoZSBzdGFnZ2VyLlxuXG4gICAgICBpID0gcGx1Z2luLl9wcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcHRMb29rdXBbcGx1Z2luLl9wcm9wc1tpXV0gPSBwdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGx1Z2luO1xufSxcbiAgICBfb3ZlcndyaXRpbmdUd2VlbixcbiAgICAvL3N0b3JlIGEgcmVmZXJlbmNlIHRlbXBvcmFyaWx5IHNvIHdlIGNhbiBhdm9pZCBvdmVyd3JpdGluZyBpdHNlbGYuXG5faW5pdFR3ZWVuID0gZnVuY3Rpb24gX2luaXRUd2Vlbih0d2VlbiwgdGltZSkge1xuICB2YXIgdmFycyA9IHR3ZWVuLnZhcnMsXG4gICAgICBlYXNlID0gdmFycy5lYXNlLFxuICAgICAgc3RhcnRBdCA9IHZhcnMuc3RhcnRBdCxcbiAgICAgIGltbWVkaWF0ZVJlbmRlciA9IHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgbGF6eSA9IHZhcnMubGF6eSxcbiAgICAgIG9uVXBkYXRlID0gdmFycy5vblVwZGF0ZSxcbiAgICAgIG9uVXBkYXRlUGFyYW1zID0gdmFycy5vblVwZGF0ZVBhcmFtcyxcbiAgICAgIGNhbGxiYWNrU2NvcGUgPSB2YXJzLmNhbGxiYWNrU2NvcGUsXG4gICAgICBydW5CYWNrd2FyZHMgPSB2YXJzLnJ1bkJhY2t3YXJkcyxcbiAgICAgIHlveW9FYXNlID0gdmFycy55b3lvRWFzZSxcbiAgICAgIGtleWZyYW1lcyA9IHZhcnMua2V5ZnJhbWVzLFxuICAgICAgYXV0b1JldmVydCA9IHZhcnMuYXV0b1JldmVydCxcbiAgICAgIGR1ciA9IHR3ZWVuLl9kdXIsXG4gICAgICBwcmV2U3RhcnRBdCA9IHR3ZWVuLl9zdGFydEF0LFxuICAgICAgdGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuICAgICAgcGFyZW50ID0gdHdlZW4ucGFyZW50LFxuICAgICAgZnVsbFRhcmdldHMgPSBwYXJlbnQgJiYgcGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIgPyBwYXJlbnQucGFyZW50Ll90YXJnZXRzIDogdGFyZ2V0cyxcbiAgICAgIGF1dG9PdmVyd3JpdGUgPSB0d2Vlbi5fb3ZlcndyaXRlID09PSBcImF1dG9cIixcbiAgICAgIHRsID0gdHdlZW4udGltZWxpbmUsXG4gICAgICBjbGVhblZhcnMsXG4gICAgICBpLFxuICAgICAgcCxcbiAgICAgIHB0LFxuICAgICAgdGFyZ2V0LFxuICAgICAgaGFzUHJpb3JpdHksXG4gICAgICBnc0RhdGEsXG4gICAgICBoYXJuZXNzLFxuICAgICAgcGx1Z2luLFxuICAgICAgcHRMb29rdXAsXG4gICAgICBpbmRleCxcbiAgICAgIGhhcm5lc3NWYXJzO1xuXG4gIGlmICh0bCAmJiAoIWtleWZyYW1lcyB8fCAhZWFzZSkpIHtcbiAgICBlYXNlID0gXCJub25lXCI7XG4gIH1cblxuICB0d2Vlbi5fZWFzZSA9IF9wYXJzZUVhc2UoZWFzZSwgX2RlZmF1bHRzLmVhc2UpO1xuICB0d2Vlbi5feUVhc2UgPSB5b3lvRWFzZSA/IF9pbnZlcnRFYXNlKF9wYXJzZUVhc2UoeW95b0Vhc2UgPT09IHRydWUgPyBlYXNlIDogeW95b0Vhc2UsIF9kZWZhdWx0cy5lYXNlKSkgOiAwO1xuXG4gIGlmICh5b3lvRWFzZSAmJiB0d2Vlbi5feW95byAmJiAhdHdlZW4uX3JlcGVhdCkge1xuICAgIC8vdGhlcmUgbXVzdCBoYXZlIGJlZW4gYSBwYXJlbnQgdGltZWxpbmUgd2l0aCB5b3lvOnRydWUgdGhhdCBpcyBjdXJyZW50bHkgaW4gaXRzIHlveW8gcGhhc2UsIHNvIGZsaXAgdGhlIGVhc2VzLlxuICAgIHlveW9FYXNlID0gdHdlZW4uX3lFYXNlO1xuICAgIHR3ZWVuLl95RWFzZSA9IHR3ZWVuLl9lYXNlO1xuICAgIHR3ZWVuLl9lYXNlID0geW95b0Vhc2U7XG4gIH1cblxuICBpZiAoIXRsKSB7XG4gICAgLy9pZiB0aGVyZSdzIGFuIGludGVybmFsIHRpbWVsaW5lLCBza2lwIGFsbCB0aGUgcGFyc2luZyBiZWNhdXNlIHdlIHBhc3NlZCB0aGF0IHRhc2sgZG93biB0aGUgY2hhaW4uXG4gICAgaWYgKHByZXZTdGFydEF0KSB7XG4gICAgICBwcmV2U3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpLmtpbGwoKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRBdCkge1xuICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgX3NldERlZmF1bHRzKHtcbiAgICAgICAgZGF0YTogXCJpc1N0YXJ0XCIsXG4gICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IHRydWUsXG4gICAgICAgIGxhenk6IF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICBzdGFydEF0OiBudWxsLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlLFxuICAgICAgICBvblVwZGF0ZVBhcmFtczogb25VcGRhdGVQYXJhbXMsXG4gICAgICAgIGNhbGxiYWNrU2NvcGU6IGNhbGxiYWNrU2NvcGUsXG4gICAgICAgIHN0YWdnZXI6IDBcbiAgICAgIH0sIHN0YXJ0QXQpKSk7IC8vY29weSB0aGUgcHJvcGVydGllcy92YWx1ZXMgaW50byBhIG5ldyBvYmplY3QgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSB2YXIgdG8gPSB7eDowfSwgZnJvbSA9IHt4OjUwMH07IHRpbWVsaW5lLmZyb21UbyhlLCBmcm9tLCB0bykuZnJvbVRvKGUsIHRvLCBmcm9tKTtcblxuXG4gICAgICBpZiAoaW1tZWRpYXRlUmVuZGVyKSB7XG4gICAgICAgIGlmICh0aW1lID4gMCkge1xuICAgICAgICAgICFhdXRvUmV2ZXJ0ICYmICh0d2Vlbi5fc3RhcnRBdCA9IDApOyAvL3R3ZWVucyB0aGF0IHJlbmRlciBpbW1lZGlhdGVseSAobGlrZSBtb3N0IGZyb20oKSBhbmQgZnJvbVRvKCkgdHdlZW5zKSBzaG91bGRuJ3QgcmV2ZXJ0IHdoZW4gdGhlaXIgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSBzdGFydFRpbWUgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgY291bGQgaGF2ZSBoYXBwZW5lZCBhbnl0aW1lIGFuZCBpdCBzaG91bGRuJ3QgYmUgZGlyZWN0bHkgY29ycmVsYXRlZCB0byB0aGlzIHR3ZWVuJ3Mgc3RhcnRUaW1lLiBJbWFnaW5lIHNldHRpbmcgdXAgYSBjb21wbGV4IGFuaW1hdGlvbiB3aGVyZSB0aGUgYmVnaW5uaW5nIHN0YXRlcyBvZiB2YXJpb3VzIG9iamVjdHMgYXJlIHJlbmRlcmVkIGltbWVkaWF0ZWx5IGJ1dCB0aGUgdHdlZW4gZG9lc24ndCBoYXBwZW4gZm9yIHF1aXRlIHNvbWUgdGltZSAtIGlmIHdlIHJldmVydCB0byB0aGUgc3RhcnRpbmcgdmFsdWVzIGFzIHNvb24gYXMgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgdHdlZW4ncyBzdGFydFRpbWUsIGl0IHdpbGwgdGhyb3cgdGhpbmdzIG9mZiB2aXN1YWxseS4gUmV2ZXJzaW9uIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBUaW1lbGluZSBpbnN0YW5jZXMgd2hlcmUgaW1tZWRpYXRlUmVuZGVyIHdhcyBmYWxzZSBvciB3aGVuIGF1dG9SZXZlcnQgaXMgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZS5cbiAgICAgICAgfSBlbHNlIGlmIChkdXIpIHtcbiAgICAgICAgICByZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmUsIHRoZSBsYXN0IG9uZSBjcmVhdGVkIHdvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lcyBiZWNhdXNlIHRoZXkgZGlkbid0IGdldCBwbGFjZWQgaW50byB0aGUgdGltZWxpbmUgeWV0IGJlZm9yZSB0aGUgZmlyc3QgcmVuZGVyIG9jY3VycyBhbmQga2lja3MgaW4gb3ZlcndyaXRpbmcuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJ1bkJhY2t3YXJkcyAmJiBkdXIpIHtcbiAgICAgIC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcbiAgICAgIGlmIChwcmV2U3RhcnRBdCkge1xuICAgICAgICAhYXV0b1JldmVydCAmJiAodHdlZW4uX3N0YXJ0QXQgPSAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcbiAgICAgICAgICBpbW1lZGlhdGVSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW1vdmVGcm9tUGFyZW50KHR3ZWVuLl9zdGFydEF0ID0gVHdlZW4uc2V0KHRhcmdldHMsIF9tZXJnZShfY29weUV4Y2x1ZGluZyh2YXJzLCBfcmVzZXJ2ZWRQcm9wcyksIHtcbiAgICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICAgIGRhdGE6IFwiaXNGcm9tU3RhcnRcIixcbiAgICAgICAgICAvL3dlIHRhZyB0aGUgdHdlZW4gd2l0aCBhcyBcImlzRnJvbVN0YXJ0XCIgc28gdGhhdCBpZiBbaW5zaWRlIGEgcGx1Z2luXSB3ZSBuZWVkIHRvIG9ubHkgZG8gc29tZXRoaW5nIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuLCB3ZSBoYXZlIGEgd2F5IG9mIGlkZW50aWZ5aW5nIHRoaXMgdHdlZW4gYXMgbWVyZWx5IHRoZSBvbmUgdGhhdCdzIHNldHRpbmcgdGhlIGJlZ2lubmluZyB2YWx1ZXMgZm9yIGEgXCJmcm9tKClcIiB0d2Vlbi4gRm9yIGV4YW1wbGUsIGNsZWFyUHJvcHMgaW4gQ1NTUGx1Z2luIHNob3VsZCBvbmx5IGdldCBhcHBsaWVkIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuIGFuZCB3aXRob3V0IHRoaXMgdGFnLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbi5cbiAgICAgICAgICBsYXp5OiBpbW1lZGlhdGVSZW5kZXIgJiYgX2lzTm90RmFsc2UobGF6eSksXG4gICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiBpbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgICAgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyByZW5kZXIgaW1tZWRpYXRlbHkgYnkgZGVmYXVsdCwgYnV0IGlmIHdlJ3JlIG5vdCBzcGVjaWZpY2FsbHkgaW5zdHJ1Y3RlZCB0byByZW5kZXIgdGhpcyB0d2VlbiBpbW1lZGlhdGVseSwgd2Ugc2hvdWxkIHNraXAgdGhpcyBhbmQgbWVyZWx5IF9pbml0KCkgdG8gcmVjb3JkIHRoZSBzdGFydGluZyB2YWx1ZXMgKHJlbmRlcmluZyB0aGVtIGltbWVkaWF0ZWx5IHdvdWxkIHB1c2ggdGhlbSB0byBjb21wbGV0aW9uIHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoYXQgY2FzZSAtIHdlJ2QgaGF2ZSB0byByZW5kZXIoLTEpIGltbWVkaWF0ZWx5IGFmdGVyKVxuICAgICAgICAgIHN0YWdnZXI6IDAsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQgLy9lbnN1cmVzIHRoYXQgbmVzdGVkIHR3ZWVucyB0aGF0IGhhZCBhIHN0YWdnZXIgYXJlIGhhbmRsZWQgcHJvcGVybHksIGxpa2UgZ3NhcC5mcm9tKFwiLmNsYXNzXCIsIHt5OmdzYXAudXRpbHMud3JhcChbLTEwMCwxMDBdKX0pXG5cbiAgICAgICAgfSkpKTtcblxuICAgICAgICBpZiAoIWltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICAgIF9pbml0VHdlZW4odHdlZW4uX3N0YXJ0QXQsIF90aW55TnVtKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgdmFsdWVzIGFyZSByZWNvcmRlZFxuXG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhblZhcnMgPSBfY29weUV4Y2x1ZGluZyh2YXJzLCBfcmVzZXJ2ZWRQcm9wcyk7XG4gICAgdHdlZW4uX3B0ID0gMDtcbiAgICBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMDtcbiAgICBoYXJuZXNzVmFycyA9IGhhcm5lc3MgJiYgdmFyc1toYXJuZXNzLnByb3BdOyAvL3NvbWVvbmUgbWF5IG5lZWQgdG8gc3BlY2lmeSBDU1Mtc3BlY2lmaWMgdmFsdWVzIEFORCBub24tQ1NTIHZhbHVlcywgbGlrZSBpZiB0aGUgZWxlbWVudCBoYXMgYW4gXCJ4XCIgcHJvcGVydHkgcGx1cyBpdCdzIGEgc3RhbmRhcmQgRE9NIGVsZW1lbnQuIFdlIGFsbG93IHBlb3BsZSB0byBkaXN0aW5ndWlzaCBieSB3cmFwcGluZyBwbHVnaW4tc3BlY2lmaWMgc3R1ZmYgaW4gYSBjc3M6e30gb2JqZWN0IGZvciBleGFtcGxlLlxuXG4gICAgbGF6eSA9IGR1ciAmJiBfaXNOb3RGYWxzZShsYXp5KSB8fCBsYXp5ICYmICFkdXI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgIGdzRGF0YSA9IHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0YXJnZXRzKVtpXS5fZ3NhcDtcbiAgICAgIHR3ZWVuLl9wdExvb2t1cFtpXSA9IHB0TG9va3VwID0ge307XG5cbiAgICAgIGlmIChfbGF6eUxvb2t1cFtnc0RhdGEuaWRdKSB7XG4gICAgICAgIF9sYXp5UmVuZGVyKCk7IC8vaWYgb3RoZXIgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldCBoYXZlIHJlY2VudGx5IGluaXR0ZWQgYnV0IGhhdmVuJ3QgcmVuZGVyZWQgeWV0LCB3ZSd2ZSBnb3QgdG8gZm9yY2UgdGhlIHJlbmRlciBzbyB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZXMgYXJlIGNvcnJlY3QgKGltYWdpbmUgcG9wdWxhdGluZyBhIHRpbWVsaW5lIHdpdGggYSBidW5jaCBvZiBzZXF1ZW50aWFsIHR3ZWVucyBhbmQgdGhlbiBqdW1waW5nIHRvIHRoZSBlbmQpXG5cbiAgICAgIH1cblxuICAgICAgaW5kZXggPSBmdWxsVGFyZ2V0cyA9PT0gdGFyZ2V0cyA/IGkgOiBmdWxsVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgIGlmIChoYXJuZXNzICYmIChwbHVnaW4gPSBuZXcgaGFybmVzcygpKS5pbml0KHRhcmdldCwgaGFybmVzc1ZhcnMgfHwgY2xlYW5WYXJzLCB0d2VlbiwgaW5kZXgsIGZ1bGxUYXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdHdlZW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHR3ZWVuLl9wdCwgdGFyZ2V0LCBwbHVnaW4ubmFtZSwgMCwgMSwgcGx1Z2luLnJlbmRlciwgcGx1Z2luLCAwLCBwbHVnaW4ucHJpb3JpdHkpO1xuXG4gICAgICAgIHBsdWdpbi5fcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHB0TG9va3VwW25hbWVdID0gcHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwbHVnaW4ucHJpb3JpdHkpIHtcbiAgICAgICAgICBoYXNQcmlvcml0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXJuZXNzIHx8IGhhcm5lc3NWYXJzKSB7XG4gICAgICAgIGZvciAocCBpbiBjbGVhblZhcnMpIHtcbiAgICAgICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgKHBsdWdpbiA9IF9jaGVja1BsdWdpbihwLCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCBmdWxsVGFyZ2V0cykpKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgIGhhc1ByaW9yaXR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHRMb29rdXBbcF0gPSBwdCA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0d2VlbiwgdGFyZ2V0LCBwLCBcImdldFwiLCBjbGVhblZhcnNbcF0sIGluZGV4LCBmdWxsVGFyZ2V0cywgMCwgdmFycy5zdHJpbmdGaWx0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHdlZW4uX29wICYmIHR3ZWVuLl9vcFtpXSkge1xuICAgICAgICB0d2Vlbi5raWxsKHRhcmdldCwgdHdlZW4uX29wW2ldKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF1dG9PdmVyd3JpdGUgJiYgdHdlZW4uX3B0KSB7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gdHdlZW47XG5cbiAgICAgICAgX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXQsIHB0TG9va3VwLCBcInN0YXJ0ZWRcIik7IC8vQWxzbyBtYWtlIHN1cmUgdGhlIG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb3ZlcndyaXRlIFRISVMgdHdlZW4hISFcblxuXG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR3ZWVuLl9wdCAmJiBsYXp5KSB7XG4gICAgICAgIF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQcmlvcml0eSkge1xuICAgICAgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0d2Vlbik7XG4gICAgfVxuXG4gICAgaWYgKHR3ZWVuLl9vbkluaXQpIHtcbiAgICAgIC8vcGx1Z2lucyBsaWtlIFJvdW5kUHJvcHMgbXVzdCB3YWl0IHVudGlsIEFMTCBvZiB0aGUgUHJvcFR3ZWVucyBhcmUgaW5zdGFudGlhdGVkLiBJbiB0aGUgcGx1Z2luJ3MgaW5pdCgpIGZ1bmN0aW9uLCBpdCBzZXRzIHRoZSBfb25Jbml0IG9uIHRoZSB0d2VlbiBpbnN0YW5jZS4gTWF5IG5vdCBiZSBwcmV0dHkvaW50dWl0aXZlLCBidXQgaXQncyBmYXN0IGFuZCBrZWVwcyBmaWxlIHNpemUgZG93bi5cbiAgICAgIHR3ZWVuLl9vbkluaXQodHdlZW4pO1xuICAgIH1cbiAgfVxuXG4gIHR3ZWVuLl9mcm9tID0gIXRsICYmICEhdmFycy5ydW5CYWNrd2FyZHM7IC8vbmVzdGVkIHRpbWVsaW5lcyBzaG91bGQgbmV2ZXIgcnVuIGJhY2t3YXJkcyAtIHRoZSBiYWNrd2FyZHMtbmVzcyBpcyBpbiB0aGUgY2hpbGQgdHdlZW5zLlxuXG4gIHR3ZWVuLl9vblVwZGF0ZSA9IG9uVXBkYXRlO1xuICB0d2Vlbi5faW5pdHRlZCA9IDE7XG59LFxuICAgIF9hZGRBbGlhc2VzVG9WYXJzID0gZnVuY3Rpb24gX2FkZEFsaWFzZXNUb1ZhcnModGFyZ2V0cywgdmFycykge1xuICB2YXIgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDAsXG4gICAgICBwcm9wZXJ0eUFsaWFzZXMgPSBoYXJuZXNzICYmIGhhcm5lc3MuYWxpYXNlcyxcbiAgICAgIGNvcHksXG4gICAgICBwLFxuICAgICAgaSxcbiAgICAgIGFsaWFzZXM7XG5cbiAgaWYgKCFwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICByZXR1cm4gdmFycztcbiAgfVxuXG4gIGNvcHkgPSBfbWVyZ2Uoe30sIHZhcnMpO1xuXG4gIGZvciAocCBpbiBwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICBpZiAocCBpbiBjb3B5KSB7XG4gICAgICBhbGlhc2VzID0gcHJvcGVydHlBbGlhc2VzW3BdLnNwbGl0KFwiLFwiKTtcbiAgICAgIGkgPSBhbGlhc2VzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb3B5W2FsaWFzZXNbaV1dID0gY29weVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX3BhcnNlRnVuY09yU3RyaW5nID0gZnVuY3Rpb24gX3BhcnNlRnVuY09yU3RyaW5nKHZhbHVlLCB0d2VlbiwgaSwgdGFyZ2V0LCB0YXJnZXRzKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKHR3ZWVuLCBpLCB0YXJnZXQsIHRhcmdldHMpIDogX2lzU3RyaW5nKHZhbHVlKSAmJiB+dmFsdWUuaW5kZXhPZihcInJhbmRvbShcIikgPyBfcmVwbGFjZVJhbmRvbSh2YWx1ZSkgOiB2YWx1ZTtcbn0sXG4gICAgX3N0YWdnZXJUd2VlblByb3BzID0gX2NhbGxiYWNrTmFtZXMgKyBcInJlcGVhdCxyZXBlYXREZWxheSx5b3lvLHJlcGVhdFJlZnJlc2gseW95b0Vhc2VcIixcbiAgICBfc3RhZ2dlclByb3BzVG9Ta2lwID0gKF9zdGFnZ2VyVHdlZW5Qcm9wcyArIFwiLGlkLHN0YWdnZXIsZGVsYXksZHVyYXRpb24scGF1c2VkXCIpLnNwbGl0KFwiLFwiKTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFdFRU5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIFR3ZWVuID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQW5pbWF0aW9uMikge1xuICBfaW5oZXJpdHNMb29zZShUd2VlbiwgX0FuaW1hdGlvbjIpO1xuXG4gIGZ1bmN0aW9uIFR3ZWVuKHRhcmdldHMsIHZhcnMsIHRpbWUsIHNraXBJbmhlcml0KSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIGlmICh0eXBlb2YgdmFycyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGltZS5kdXJhdGlvbiA9IHZhcnM7XG4gICAgICB2YXJzID0gdGltZTtcbiAgICAgIHRpbWUgPSBudWxsO1xuICAgIH1cblxuICAgIF90aGlzMyA9IF9BbmltYXRpb24yLmNhbGwodGhpcywgc2tpcEluaGVyaXQgPyB2YXJzIDogX2luaGVyaXREZWZhdWx0cyh2YXJzKSwgdGltZSkgfHwgdGhpcztcbiAgICB2YXIgX3RoaXMzJHZhcnMgPSBfdGhpczMudmFycyxcbiAgICAgICAgZHVyYXRpb24gPSBfdGhpczMkdmFycy5kdXJhdGlvbixcbiAgICAgICAgZGVsYXkgPSBfdGhpczMkdmFycy5kZWxheSxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3RoaXMzJHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBzdGFnZ2VyID0gX3RoaXMzJHZhcnMuc3RhZ2dlcixcbiAgICAgICAgb3ZlcndyaXRlID0gX3RoaXMzJHZhcnMub3ZlcndyaXRlLFxuICAgICAgICBrZXlmcmFtZXMgPSBfdGhpczMkdmFycy5rZXlmcmFtZXMsXG4gICAgICAgIGRlZmF1bHRzID0gX3RoaXMzJHZhcnMuZGVmYXVsdHMsXG4gICAgICAgIHBhcmVudCA9IF90aGlzMy5wYXJlbnQsXG4gICAgICAgIHBhcnNlZFRhcmdldHMgPSAoX2lzQXJyYXkodGFyZ2V0cykgPyBfaXNOdW1iZXIodGFyZ2V0c1swXSkgOiBcImxlbmd0aFwiIGluIHZhcnMpID8gW3RhcmdldHNdIDogdG9BcnJheSh0YXJnZXRzKSxcbiAgICAgICAgdGwsXG4gICAgICAgIGksXG4gICAgICAgIGNvcHksXG4gICAgICAgIGwsXG4gICAgICAgIHAsXG4gICAgICAgIGN1clRhcmdldCxcbiAgICAgICAgc3RhZ2dlckZ1bmMsXG4gICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZTtcbiAgICBfdGhpczMuX3RhcmdldHMgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aCA/IF9oYXJuZXNzKHBhcnNlZFRhcmdldHMpIDogX3dhcm4oXCJHU0FQIHRhcmdldCBcIiArIHRhcmdldHMgKyBcIiBub3QgZm91bmQuIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVwiLCAhX2NvbmZpZy5udWxsVGFyZ2V0V2FybikgfHwgW107XG4gICAgX3RoaXMzLl9wdExvb2t1cCA9IFtdOyAvL1Byb3BUd2VlbiBsb29rdXAuIEFuIGFycmF5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IGZvciBlYWNoIHRhcmdldCwgaGF2aW5nIGtleXMgZm9yIGVhY2ggdHdlZW5pbmcgcHJvcGVydHlcblxuICAgIF90aGlzMy5fb3ZlcndyaXRlID0gb3ZlcndyaXRlO1xuXG4gICAgaWYgKGtleWZyYW1lcyB8fCBzdGFnZ2VyIHx8IF9pc0Z1bmNPclN0cmluZyhkdXJhdGlvbikgfHwgX2lzRnVuY09yU3RyaW5nKGRlbGF5KSkge1xuICAgICAgdmFycyA9IF90aGlzMy52YXJzO1xuICAgICAgdGwgPSBfdGhpczMudGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICAgICAgICBkYXRhOiBcIm5lc3RlZFwiLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMgfHwge31cbiAgICAgIH0pO1xuICAgICAgdGwua2lsbCgpO1xuICAgICAgdGwucGFyZW50ID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuXG4gICAgICBpZiAoa2V5ZnJhbWVzKSB7XG4gICAgICAgIF9zZXREZWZhdWx0cyh0bC52YXJzLmRlZmF1bHRzLCB7XG4gICAgICAgICAgZWFzZTogXCJub25lXCJcbiAgICAgICAgfSk7XG5cbiAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRsLnRvKHBhcnNlZFRhcmdldHMsIGZyYW1lLCBcIj5cIik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbCA9IHBhcnNlZFRhcmdldHMubGVuZ3RoO1xuICAgICAgICBzdGFnZ2VyRnVuYyA9IHN0YWdnZXIgPyBkaXN0cmlidXRlKHN0YWdnZXIpIDogX2VtcHR5RnVuYztcblxuICAgICAgICBpZiAoX2lzT2JqZWN0KHN0YWdnZXIpKSB7XG4gICAgICAgICAgLy91c2VycyBjYW4gcGFzcyBpbiBjYWxsYmFja3MgbGlrZSBvblN0YXJ0L29uQ29tcGxldGUgaW4gdGhlIHN0YWdnZXIgb2JqZWN0LiBUaGVzZSBzaG91bGQgZmlyZSB3aXRoIGVhY2ggaW5kaXZpZHVhbCB0d2Vlbi5cbiAgICAgICAgICBmb3IgKHAgaW4gc3RhZ2dlcikge1xuICAgICAgICAgICAgaWYgKH5fc3RhZ2dlclR3ZWVuUHJvcHMuaW5kZXhPZihwKSkge1xuICAgICAgICAgICAgICBpZiAoIXN0YWdnZXJWYXJzVG9NZXJnZSkge1xuICAgICAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZSA9IHt9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlW3BdID0gc3RhZ2dlcltwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29weSA9IHt9O1xuXG4gICAgICAgICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgICAgICAgIGlmIChfc3RhZ2dlclByb3BzVG9Ta2lwLmluZGV4T2YocCkgPCAwKSB7XG4gICAgICAgICAgICAgIGNvcHlbcF0gPSB2YXJzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvcHkuc3RhZ2dlciA9IDA7XG5cbiAgICAgICAgICBpZiAoc3RhZ2dlclZhcnNUb01lcmdlKSB7XG4gICAgICAgICAgICBfbWVyZ2UoY29weSwgc3RhZ2dlclZhcnNUb01lcmdlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFycy55b3lvRWFzZSAmJiAhdmFycy5yZXBlYXQpIHtcbiAgICAgICAgICAgIC8vc28gdGhhdCBwcm9wYWdhdGlvbiB3b3JrcyBwcm9wZXJseSB3aGVuIGEgYW5jZXN0b3IgdGltZWxpbmUgeW95b3NcbiAgICAgICAgICAgIGNvcHkueW95b0Vhc2UgPSB2YXJzLnlveW9FYXNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1clRhcmdldCA9IHBhcnNlZFRhcmdldHNbaV07IC8vZG9uJ3QganVzdCBjb3B5IGR1cmF0aW9uIG9yIGRlbGF5IGJlY2F1c2UgaWYgdGhleSdyZSBhIHN0cmluZyBvciBmdW5jdGlvbiwgd2UnZCBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIF9pc0Z1bmNPclN0cmluZygpIHdvdWxkIGV2YWx1YXRlIGFzIHRydWUgaW4gdGhlIGNoaWxkIHR3ZWVucywgZW50ZXJpbmcgdGhpcyBsb29wLCBldGMuIFNvIHdlIHBhcnNlIHRoZSB2YWx1ZSBzdHJhaWdodCBmcm9tIHZhcnMgYW5kIGRlZmF1bHQgdG8gMC5cblxuICAgICAgICAgIGNvcHkuZHVyYXRpb24gPSArX3BhcnNlRnVuY09yU3RyaW5nKGR1cmF0aW9uLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cyk7XG4gICAgICAgICAgY29weS5kZWxheSA9ICgrX3BhcnNlRnVuY09yU3RyaW5nKGRlbGF5LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykgfHwgMCkgLSBfdGhpczMuX2RlbGF5O1xuXG4gICAgICAgICAgaWYgKCFzdGFnZ2VyICYmIGwgPT09IDEgJiYgY29weS5kZWxheSkge1xuICAgICAgICAgICAgLy8gaWYgc29tZW9uZSBkb2VzIGRlbGF5OlwicmFuZG9tKDEsIDUpXCIsIHJlcGVhdDotMSwgZm9yIGV4YW1wbGUsIHRoZSBkZWxheSBzaG91bGRuJ3QgYmUgaW5zaWRlIHRoZSByZXBlYXQuXG4gICAgICAgICAgICBfdGhpczMuX2RlbGF5ID0gZGVsYXkgPSBjb3B5LmRlbGF5O1xuICAgICAgICAgICAgX3RoaXMzLl9zdGFydCArPSBkZWxheTtcbiAgICAgICAgICAgIGNvcHkuZGVsYXkgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRsLnRvKGN1clRhcmdldCwgY29weSwgc3RhZ2dlckZ1bmMoaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkdXJhdGlvbiA9IGRlbGF5ID0gMDtcbiAgICAgIH1cblxuICAgICAgZHVyYXRpb24gfHwgX3RoaXMzLmR1cmF0aW9uKGR1cmF0aW9uID0gdGwuZHVyYXRpb24oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzMy50aW1lbGluZSA9IDA7IC8vc3BlZWQgb3B0aW1pemF0aW9uLCBmYXN0ZXIgbG9va3VwcyAobm8gZ29pbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbilcbiAgICB9XG5cbiAgICBpZiAob3ZlcndyaXRlID09PSB0cnVlKSB7XG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKTtcblxuICAgICAgX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZihwYXJzZWRUYXJnZXRzKTtcblxuICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuICAgIH1cblxuICAgIHBhcmVudCAmJiBfcG9zdEFkZENoZWNrcyhwYXJlbnQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSk7XG5cbiAgICBpZiAoaW1tZWRpYXRlUmVuZGVyIHx8ICFkdXJhdGlvbiAmJiAha2V5ZnJhbWVzICYmIF90aGlzMy5fc3RhcnQgPT09IHBhcmVudC5fdGltZSAmJiBfaXNOb3RGYWxzZShpbW1lZGlhdGVSZW5kZXIpICYmIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMykpICYmIHBhcmVudC5kYXRhICE9PSBcIm5lc3RlZFwiKSB7XG4gICAgICBfdGhpczMuX3RUaW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblxuICAgICAgX3RoaXMzLnJlbmRlcihNYXRoLm1heCgwLCAtZGVsYXkpKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlXG5cbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBUd2Vlbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgICB2YXIgcHJldlRpbWUgPSB0aGlzLl90aW1lLFxuICAgICAgICB0RHVyID0gdGhpcy5fdER1cixcbiAgICAgICAgZHVyID0gdGhpcy5fZHVyLFxuICAgICAgICB0VGltZSA9IHRvdGFsVGltZSA+IHREdXIgLSBfdGlueU51bSAmJiB0b3RhbFRpbWUgPj0gMCA/IHREdXIgOiB0b3RhbFRpbWUgPCBfdGlueU51bSA/IDAgOiB0b3RhbFRpbWUsXG4gICAgICAgIHRpbWUsXG4gICAgICAgIHB0LFxuICAgICAgICBpdGVyYXRpb24sXG4gICAgICAgIGN5Y2xlRHVyYXRpb24sXG4gICAgICAgIHByZXZJdGVyYXRpb24sXG4gICAgICAgIGlzWW95byxcbiAgICAgICAgcmF0aW8sXG4gICAgICAgIHRpbWVsaW5lLFxuICAgICAgICB5b3lvRWFzZTtcblxuICAgIGlmICghZHVyKSB7XG4gICAgICBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4odGhpcywgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgIH0gZWxzZSBpZiAodFRpbWUgIT09IHRoaXMuX3RUaW1lIHx8ICF0b3RhbFRpbWUgfHwgZm9yY2UgfHwgdGhpcy5fc3RhcnRBdCAmJiB0aGlzLl96VGltZSA8IDAgIT09IHRvdGFsVGltZSA8IDApIHtcbiAgICAgIC8vdGhpcyBzZW5zZXMgaWYgd2UncmUgY3Jvc3Npbmcgb3ZlciB0aGUgc3RhcnQgdGltZSwgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IHJlY29yZCBfelRpbWUgYW5kIGZvcmNlIHRoZSByZW5kZXIsIGJ1dCB3ZSBkbyBpdCBpbiB0aGlzIGxlbmd0aHkgY29uZGl0aW9uYWwgd2F5IGZvciBwZXJmb3JtYW5jZSByZWFzb25zICh1c3VhbGx5IHdlIGNhbiBza2lwIHRoZSBjYWxjdWxhdGlvbnMpOiB0aGlzLl9pbml0dGVkICYmICh0aGlzLl96VGltZSA8IDApICE9PSAodG90YWxUaW1lIDwgMClcbiAgICAgIHRpbWUgPSB0VGltZTtcbiAgICAgIHRpbWVsaW5lID0gdGhpcy50aW1lbGluZTtcblxuICAgICAgaWYgKHRoaXMuX3JlcGVhdCkge1xuICAgICAgICAvL2FkanVzdCB0aGUgdGltZSBmb3IgcmVwZWF0cyBhbmQgeW95b3NcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JEZWxheTtcbiAgICAgICAgdGltZSA9IF9yb3VuZCh0VGltZSAlIGN5Y2xlRHVyYXRpb24pOyAvL3JvdW5kIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9ycy4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXG4gICAgICAgIGlmICh0aW1lID4gZHVyIHx8IHREdXIgPT09IHRUaW1lKSB7XG4gICAgICAgICAgLy8gdGhlIHREdXIgPT09IHRUaW1lIGlzIGZvciBlZGdlIGNhc2VzIHdoZXJlIHRoZXJlJ3MgYSBsZW5ndGh5IGRlY2ltYWwgb24gdGhlIGR1cmF0aW9uIGFuZCBpdCBtYXkgcmVhY2ggdGhlIHZlcnkgZW5kIGJ1dCB0aGUgdGltZSBpcyByZW5kZXJlZCBhcyBub3QtcXVpdGUtdGhlcmUgKHJlbWVtYmVyLCB0RHVyIGlzIHJvdW5kZWQgdG8gNCBkZWNpbWFscyB3aGVyZWFzIGR1ciBpc24ndClcbiAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlcmF0aW9uID0gfn4odFRpbWUgLyBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXRlcmF0aW9uICYmIGl0ZXJhdGlvbiA9PT0gdFRpbWUgLyBjeWNsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgICBpdGVyYXRpb24tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzWW95byA9IHRoaXMuX3lveW8gJiYgaXRlcmF0aW9uICYgMTtcblxuICAgICAgICBpZiAoaXNZb3lvKSB7XG4gICAgICAgICAgeW95b0Vhc2UgPSB0aGlzLl95RWFzZTtcbiAgICAgICAgICB0aW1lID0gZHVyIC0gdGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmICh0aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UgJiYgdGhpcy5faW5pdHRlZCkge1xuICAgICAgICAgIC8vY291bGQgYmUgZHVyaW5nIHRoZSByZXBlYXREZWxheSBwYXJ0LiBObyBuZWVkIHRvIHJlbmRlciBhbmQgZmlyZSBjYWxsYmFja3MuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uKSB7XG4gICAgICAgICAgLy90aW1lbGluZSAmJiB0aGlzLl95RWFzZSAmJiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95byk7XG4gICAgICAgICAgLy9yZXBlYXRSZWZyZXNoIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgICBpZiAodGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiAhdGhpcy5fbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IGZvcmNlID0gMTsgLy9mb3JjZSwgb3RoZXJ3aXNlIGlmIGxhenkgaXMgdHJ1ZSwgdGhlIF9hdHRlbXB0SW5pdFR3ZWVuKCkgd2lsbCByZXR1cm4gYW5kIHdlJ2xsIGp1bXAgb3V0IGFuZCBnZXQgY2F1Z2h0IGJvdW5jaW5nIG9uIGVhY2ggdGljay5cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoY3ljbGVEdXJhdGlvbiAqIGl0ZXJhdGlvbiwgdHJ1ZSkuaW52YWxpZGF0ZSgpLl9sb2NrID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIGlmIChfYXR0ZW1wdEluaXRUd2Vlbih0aGlzLCB0aW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpKSB7XG4gICAgICAgICAgdGhpcy5fdFRpbWUgPSAwOyAvLyBpbiBjb25zdHJ1Y3RvciBpZiBpbW1lZGlhdGVSZW5kZXIgaXMgdHJ1ZSwgd2Ugc2V0IF90VGltZSB0byAtX3RpbnlOdW0gdG8gaGF2ZSB0aGUgcGxheWhlYWQgY3Jvc3MgdGhlIHN0YXJ0aW5nIHBvaW50IGJ1dCB3ZSBjYW4ndCBsZWF2ZSBfdFRpbWUgYXMgYSBuZWdhdGl2ZSBudW1iZXIuXG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkdXIgIT09IHRoaXMuX2R1cikge1xuICAgICAgICAgIC8vIHdoaWxlIGluaXR0aW5nLCBhIHBsdWdpbiBsaWtlIEluZXJ0aWFQbHVnaW4gbWlnaHQgYWx0ZXIgdGhlIGR1cmF0aW9uLCBzbyByZXJ1biBmcm9tIHRoZSBzdGFydCB0byBlbnN1cmUgZXZlcnl0aGluZyByZW5kZXJzIGFzIGl0IHNob3VsZC5cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgaWYgKCF0aGlzLl9hY3QgJiYgdGhpcy5fdHMpIHtcbiAgICAgICAgdGhpcy5fYWN0ID0gMTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICAgICAgdGhpcy5fbGF6eSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9ICh5b3lvRWFzZSB8fCB0aGlzLl9lYXNlKSh0aW1lIC8gZHVyKTtcblxuICAgICAgaWYgKHRoaXMuX2Zyb20pIHtcbiAgICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXByZXZUaW1lICYmIHRpbWUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uU3RhcnRcIik7XG4gICAgICB9XG5cbiAgICAgIHB0ID0gdGhpcy5fcHQ7XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgdGltZWxpbmUgJiYgdGltZWxpbmUucmVuZGVyKHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiAhdGltZSAmJiBpc1lveW8gPyAtX3RpbnlOdW0gOiB0aW1lbGluZS5fZHVyICogcmF0aW8sIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkgfHwgdGhpcy5fc3RhcnRBdCAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuXG4gICAgICBpZiAodGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIGlmICh0b3RhbFRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQpIHtcbiAgICAgICAgICB0aGlzLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblxuICAgICAgICB9XG5cbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25VcGRhdGVcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yZXBlYXQpIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgdGhpcy52YXJzLm9uUmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCkge1xuICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCh0VGltZSA9PT0gdGhpcy5fdER1ciB8fCAhdFRpbWUpICYmIHRoaXMuX3RUaW1lID09PSB0VGltZSkge1xuICAgICAgICBpZiAodG90YWxUaW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSkge1xuICAgICAgICAgIHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgZm9yY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgKHRvdGFsVGltZSB8fCAhZHVyKSAmJiAodG90YWxUaW1lICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHdlJ3JlIHJlbmRlcmluZyBhdCBleGFjdGx5IGEgdGltZSBvZiAwLCBhcyB0aGVyZSBjb3VsZCBiZSBhdXRvUmV2ZXJ0IHZhbHVlcyB0aGF0IHNob3VsZCBnZXQgc2V0IG9uIHRoZSBuZXh0IHRpY2sgKGlmIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIGJleW9uZCB0aGUgc3RhcnRUaW1lLCBuZWdhdGl2ZSB0b3RhbFRpbWUpLiBEb24ndCByZW1vdmUgaWYgdGhlIHRpbWVsaW5lIGlzIHJldmVyc2VkIGFuZCB0aGUgcGxheWhlYWQgaXNuJ3QgYXQgMCwgb3RoZXJ3aXNlIHRsLnByb2dyZXNzKDEpLnJldmVyc2UoKSB3b24ndCB3b3JrLiBPbmx5IHJlbW92ZSBpZiB0aGUgcGxheWhlYWQgaXMgYXQgdGhlIGVuZCBhbmQgdGltZVNjYWxlIGlzIHBvc2l0aXZlLCBvciBpZiB0aGUgcGxheWhlYWQgaXMgYXQgMCBhbmQgdGhlIHRpbWVTY2FsZSBpcyBuZWdhdGl2ZS5cblxuICAgICAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICEodG90YWxUaW1lIDwgMCAmJiAhcHJldlRpbWUpICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSkge1xuICAgICAgICAgIF9jYWxsYmFjayh0aGlzLCB0VGltZSA9PT0gdER1ciA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICAgIHRoaXMuX3Byb20gJiYgdGhpcy5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMy50YXJnZXRzID0gZnVuY3Rpb24gdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cztcbiAgfTtcblxuICBfcHJvdG8zLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuX3B0ID0gdGhpcy5fb3AgPSB0aGlzLl9zdGFydEF0ID0gdGhpcy5fb25VcGRhdGUgPSB0aGlzLl9hY3QgPSB0aGlzLl9sYXp5ID0gMDtcbiAgICB0aGlzLl9wdExvb2t1cCA9IFtdO1xuICAgIHRoaXMudGltZWxpbmUgJiYgdGhpcy50aW1lbGluZS5pbnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIF9BbmltYXRpb24yLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMy5raWxsID0gZnVuY3Rpb24ga2lsbCh0YXJnZXRzLCB2YXJzKSB7XG4gICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xuICAgICAgdmFycyA9IFwiYWxsXCI7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRzICYmICghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSkge1xuICAgICAgdGhpcy5fbGF6eSA9IDA7XG5cbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gX2ludGVycnVwdCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy50aW1lbGluZSkge1xuICAgICAgdGhpcy50aW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgdmFycywgX292ZXJ3cml0aW5nVHdlZW4gJiYgX292ZXJ3cml0aW5nVHdlZW4udmFycy5vdmVyd3JpdGUgIT09IHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZFRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuICAgICAgICBraWxsaW5nVGFyZ2V0cyA9IHRhcmdldHMgPyB0b0FycmF5KHRhcmdldHMpIDogcGFyc2VkVGFyZ2V0cyxcbiAgICAgICAgcHJvcFR3ZWVuTG9va3VwID0gdGhpcy5fcHRMb29rdXAsXG4gICAgICAgIGZpcnN0UFQgPSB0aGlzLl9wdCxcbiAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wcyxcbiAgICAgICAgY3VyTG9va3VwLFxuICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHAsXG4gICAgICAgIHB0LFxuICAgICAgICBpO1xuXG4gICAgaWYgKCghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSAmJiBfYXJyYXlzTWF0Y2gocGFyc2VkVGFyZ2V0cywga2lsbGluZ1RhcmdldHMpKSB7XG4gICAgICByZXR1cm4gX2ludGVycnVwdCh0aGlzKTtcbiAgICB9XG5cbiAgICBvdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3AgPSB0aGlzLl9vcCB8fCBbXTtcblxuICAgIGlmICh2YXJzICE9PSBcImFsbFwiKSB7XG4gICAgICAvL3NvIHBlb3BsZSBjYW4gcGFzcyBpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzXG4gICAgICBpZiAoX2lzU3RyaW5nKHZhcnMpKSB7XG4gICAgICAgIHAgPSB7fTtcblxuICAgICAgICBfZm9yRWFjaE5hbWUodmFycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcFtuYW1lXSA9IDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhcnMgPSBwO1xuICAgICAgfVxuXG4gICAgICB2YXJzID0gX2FkZEFsaWFzZXNUb1ZhcnMocGFyc2VkVGFyZ2V0cywgdmFycyk7XG4gICAgfVxuXG4gICAgaSA9IHBhcnNlZFRhcmdldHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKH5raWxsaW5nVGFyZ2V0cy5pbmRleE9mKHBhcnNlZFRhcmdldHNbaV0pKSB7XG4gICAgICAgIGN1ckxvb2t1cCA9IHByb3BUd2Vlbkxvb2t1cFtpXTtcblxuICAgICAgICBpZiAodmFycyA9PT0gXCJhbGxcIikge1xuICAgICAgICAgIG92ZXJ3cml0dGVuUHJvcHNbaV0gPSB2YXJzO1xuICAgICAgICAgIHByb3BzID0gY3VyTG9va3VwO1xuICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMgPSBvdmVyd3JpdHRlblByb3BzW2ldID0gb3ZlcndyaXR0ZW5Qcm9wc1tpXSB8fCB7fTtcbiAgICAgICAgICBwcm9wcyA9IHZhcnM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHAgaW4gcHJvcHMpIHtcbiAgICAgICAgICBwdCA9IGN1ckxvb2t1cCAmJiBjdXJMb29rdXBbcF07XG5cbiAgICAgICAgICBpZiAocHQpIHtcbiAgICAgICAgICAgIGlmICghKFwia2lsbFwiIGluIHB0LmQpIHx8IHB0LmQua2lsbChwKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgcHQsIFwiX3B0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgY3VyTG9va3VwW3BdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJPdmVyd3JpdGVQcm9wcyAhPT0gXCJhbGxcIikge1xuICAgICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHNbcF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbml0dGVkICYmICF0aGlzLl9wdCAmJiBmaXJzdFBUKSB7XG4gICAgICAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGFyZSBraWxsZWQsIGtpbGwgdGhlIHR3ZWVuLiBXaXRob3V0IHRoaXMgbGluZSwgaWYgdGhlcmUncyBhIHR3ZWVuIHdpdGggbXVsdGlwbGUgdGFyZ2V0cyBhbmQgdGhlbiB5b3Uga2lsbFR3ZWVuc09mKCkgZWFjaCB0YXJnZXQgaW5kaXZpZHVhbGx5LCB0aGUgdHdlZW4gd291bGQgdGVjaG5pY2FsbHkgc3RpbGwgcmVtYWluIGFjdGl2ZSBhbmQgZmlyZSBpdHMgb25Db21wbGV0ZSBldmVuIHRob3VnaCB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgcHJvcGVydGllcyB0d2VlbmluZy5cbiAgICAgIF9pbnRlcnJ1cHQodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgVHdlZW4udG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBhcmd1bWVudHNbMl0pO1xuICB9O1xuXG4gIFR3ZWVuLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRhcmdldHMsIHZhcnMpIHtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKHRhcmdldHMsIF9wYXJzZVZhcnMoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgVHdlZW4uZGVsYXllZENhbGwgPSBmdW5jdGlvbiBkZWxheWVkQ2FsbChkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKGNhbGxiYWNrLCAwLCB7XG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgb25Db21wbGV0ZTogY2FsbGJhY2ssXG4gICAgICBvblJldmVyc2VDb21wbGV0ZTogY2FsbGJhY2ssXG4gICAgICBvbkNvbXBsZXRlUGFyYW1zOiBwYXJhbXMsXG4gICAgICBvblJldmVyc2VDb21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgY2FsbGJhY2tTY29wZTogc2NvcGVcbiAgICB9KTtcbiAgfTtcblxuICBUd2Vlbi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycykge1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgX3BhcnNlVmFycyhhcmd1bWVudHMsIDIpKTtcbiAgfTtcblxuICBUd2Vlbi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycykge1xuICAgIHZhcnMuZHVyYXRpb24gPSAwO1xuICAgIHZhcnMucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzKTtcbiAgfTtcblxuICBUd2Vlbi5raWxsVHdlZW5zT2YgPSBmdW5jdGlvbiBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSk7XG4gIH07XG5cbiAgcmV0dXJuIFR3ZWVuO1xufShBbmltYXRpb24pO1xuXG5fc2V0RGVmYXVsdHMoVHdlZW4ucHJvdG90eXBlLCB7XG4gIF90YXJnZXRzOiBbXSxcbiAgX2xhenk6IDAsXG4gIF9zdGFydEF0OiAwLFxuICBfb3A6IDAsXG4gIF9vbkluaXQ6IDBcbn0pOyAvL2FkZCB0aGUgcGVydGluZW50IHRpbWVsaW5lIG1ldGhvZHMgdG8gVHdlZW4gaW5zdGFuY2VzIHNvIHRoYXQgdXNlcnMgY2FuIGNoYWluIGNvbnZlbmllbnRseSBhbmQgY3JlYXRlIGEgdGltZWxpbmUgYXV0b21hdGljYWxseS4gKHJlbW92ZWQgZHVlIHRvIGNvbmNlcm5zIHRoYXQgaXQnZCB1bHRpbWF0ZWx5IGFkZCB0byBtb3JlIGNvbmZ1c2lvbiBlc3BlY2lhbGx5IGZvciBiZWdpbm5lcnMpXG4vLyBfZm9yRWFjaE5hbWUoXCJ0byxmcm9tLGZyb21UbyxzZXQsY2FsbCxhZGQsYWRkTGFiZWwsYWRkUGF1c2VcIiwgbmFtZSA9PiB7XG4vLyBcdFR3ZWVuLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuLy8gXHRcdGxldCB0bCA9IG5ldyBUaW1lbGluZSgpO1xuLy8gXHRcdHJldHVybiBfYWRkVG9UaW1lbGluZSh0bCwgdGhpcylbbmFtZV0uYXBwbHkodGwsIHRvQXJyYXkoYXJndW1lbnRzKSk7XG4vLyBcdH1cbi8vIH0pO1xuLy9mb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gTGV2ZXJhZ2UgdGhlIHRpbWVsaW5lIGNhbGxzLlxuXG5cbl9mb3JFYWNoTmFtZShcInN0YWdnZXJUbyxzdGFnZ2VyRnJvbSxzdGFnZ2VyRnJvbVRvXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFR3ZWVuW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0bCA9IG5ldyBUaW1lbGluZSgpLFxuICAgICAgICBwYXJhbXMgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcGFyYW1zLnNwbGljZShuYW1lID09PSBcInN0YWdnZXJGcm9tVG9cIiA/IDUgOiA0LCAwLCAwKTtcbiAgICByZXR1cm4gdGxbbmFtZV0uYXBwbHkodGwsIHBhcmFtcyk7XG4gIH07XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUFJPUFRXRUVOXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxudmFyIF9zZXR0ZXJQbGFpbiA9IGZ1bmN0aW9uIF9zZXR0ZXJQbGFpbih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyRnVuYyA9IGZ1bmN0aW9uIF9zZXR0ZXJGdW5jKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldKHZhbHVlKTtcbn0sXG4gICAgX3NldHRlckZ1bmNXaXRoUGFyYW0gPSBmdW5jdGlvbiBfc2V0dGVyRnVuY1dpdGhQYXJhbSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XShkYXRhLmZwLCB2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfc2V0dGVyQXR0cmlidXRlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCB2YWx1ZSk7XG59LFxuICAgIF9nZXRTZXR0ZXIgPSBmdW5jdGlvbiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHRhcmdldFtwcm9wZXJ0eV0pID8gX3NldHRlckZ1bmMgOiBfaXNVbmRlZmluZWQodGFyZ2V0W3Byb3BlcnR5XSkgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZSA/IF9zZXR0ZXJBdHRyaWJ1dGUgOiBfc2V0dGVyUGxhaW47XG59LFxuICAgIF9yZW5kZXJQbGFpbiA9IGZ1bmN0aW9uIF9yZW5kZXJQbGFpbihyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckJvb2xlYW4gPSBmdW5jdGlvbiBfcmVuZGVyQm9vbGVhbihyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsICEhKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJDb21wbGV4U3RyaW5nID0gZnVuY3Rpb24gX3JlbmRlckNvbXBsZXhTdHJpbmcocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHB0ID0gZGF0YS5fcHQsXG4gICAgICBzID0gXCJcIjtcblxuICBpZiAoIXJhdGlvICYmIGRhdGEuYikge1xuICAgIC8vYiA9IGJlZ2lubmluZyBzdHJpbmdcbiAgICBzID0gZGF0YS5iO1xuICB9IGVsc2UgaWYgKHJhdGlvID09PSAxICYmIGRhdGEuZSkge1xuICAgIC8vZSA9IGVuZGluZyBzdHJpbmdcbiAgICBzID0gZGF0YS5lO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChwdCkge1xuICAgICAgcyA9IHB0LnAgKyAocHQubSA/IHB0Lm0ocHQucyArIHB0LmMgKiByYXRpbykgOiBNYXRoLnJvdW5kKChwdC5zICsgcHQuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwKSArIHM7IC8vd2UgdXNlIHRoZSBcInBcIiBwcm9wZXJ0eSBmb3IgdGhlIHRleHQgaW5iZXR3ZWVuIChsaWtlIGEgc3VmZml4KS4gQW5kIGluIHRoZSBjb250ZXh0IG9mIGEgY29tcGxleCBzdHJpbmcsIHRoZSBtb2RpZmllciAobSkgaXMgdHlwaWNhbGx5IGp1c3QgTWF0aC5yb3VuZCgpLCBsaWtlIGZvciBSR0IgY29sb3JzLlxuXG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHMgKz0gZGF0YS5jOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgY2h1bmsgb2Ygbm9uLW51bWVyaWMgdGV4dC5cbiAgfVxuXG4gIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBzLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlclByb3BUd2VlbnMgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFR3ZWVucyhyYXRpbywgZGF0YSkge1xuICB2YXIgcHQgPSBkYXRhLl9wdDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICBwdCA9IHB0Ll9uZXh0O1xuICB9XG59LFxuICAgIF9hZGRQbHVnaW5Nb2RpZmllciA9IGZ1bmN0aW9uIF9hZGRQbHVnaW5Nb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgdmFyIHB0ID0gdGhpcy5fcHQsXG4gICAgICBuZXh0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcblxuICAgIGlmIChwdC5wID09PSBwcm9wZXJ0eSkge1xuICAgICAgcHQubW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQpO1xuICAgIH1cblxuICAgIHB0ID0gbmV4dDtcbiAgfVxufSxcbiAgICBfa2lsbFByb3BUd2VlbnNPZiA9IGZ1bmN0aW9uIF9raWxsUHJvcFR3ZWVuc09mKHByb3BlcnR5KSB7XG4gIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nLFxuICAgICAgbmV4dDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG5cbiAgICBpZiAocHQucCA9PT0gcHJvcGVydHkgJiYgIXB0Lm9wIHx8IHB0Lm9wID09PSBwcm9wZXJ0eSkge1xuICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICB9IGVsc2UgaWYgKCFwdC5kZXApIHtcbiAgICAgIGhhc05vbkRlcGVuZGVudFJlbWFpbmluZyA9IDE7XG4gICAgfVxuXG4gICAgcHQgPSBuZXh0O1xuICB9XG5cbiAgcmV0dXJuICFoYXNOb25EZXBlbmRlbnRSZW1haW5pbmc7XG59LFxuICAgIF9zZXR0ZXJXaXRoTW9kaWZpZXIgPSBmdW5jdGlvbiBfc2V0dGVyV2l0aE1vZGlmaWVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhKSB7XG4gIGRhdGEubVNldCh0YXJnZXQsIHByb3BlcnR5LCBkYXRhLm0uY2FsbChkYXRhLnR3ZWVuLCB2YWx1ZSwgZGF0YS5tdCksIGRhdGEpO1xufSxcbiAgICBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5ID0gZnVuY3Rpb24gX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eShwYXJlbnQpIHtcbiAgdmFyIHB0ID0gcGFyZW50Ll9wdCxcbiAgICAgIG5leHQsXG4gICAgICBwdDIsXG4gICAgICBmaXJzdCxcbiAgICAgIGxhc3Q7IC8vc29ydHMgdGhlIFByb3BUd2VlbiBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwcmlvcml0eSBiZWNhdXNlIHNvbWUgcGx1Z2lucyBuZWVkIHRvIGRvIHRoZWlyIHdvcmsgYWZ0ZXIgQUxMIG9mIHRoZSBQcm9wVHdlZW5zIHdlcmUgY3JlYXRlZCAobGlrZSBSb3VuZFByb3BzUGx1Z2luIGFuZCBNb2RpZmllcnNQbHVnaW4pXG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuICAgIHB0MiA9IGZpcnN0O1xuXG4gICAgd2hpbGUgKHB0MiAmJiBwdDIucHIgPiBwdC5wcikge1xuICAgICAgcHQyID0gcHQyLl9uZXh0O1xuICAgIH1cblxuICAgIGlmIChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpIHtcbiAgICAgIHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0ID0gcHQ7XG4gICAgfVxuXG4gICAgaWYgKHB0Ll9uZXh0ID0gcHQyKSB7XG4gICAgICBwdDIuX3ByZXYgPSBwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IHB0O1xuICAgIH1cblxuICAgIHB0ID0gbmV4dDtcbiAgfVxuXG4gIHBhcmVudC5fcHQgPSBmaXJzdDtcbn07IC8vUHJvcFR3ZWVuIGtleTogdCA9IHRhcmdldCwgcCA9IHByb3AsIHIgPSByZW5kZXJlciwgZCA9IGRhdGEsIHMgPSBzdGFydCwgYyA9IGNoYW5nZSwgb3AgPSBvdmVyd3JpdGVQcm9wZXJ0eSAoT05MWSBwb3B1bGF0ZWQgd2hlbiBpdCdzIGRpZmZlcmVudCB0aGFuIHApLCBwciA9IHByaW9yaXR5LCBfbmV4dC9fcHJldiBmb3IgdGhlIGxpbmtlZCBsaXN0IHNpYmxpbmdzLCBzZXQgPSBzZXR0ZXIsIG0gPSBtb2RpZmllciwgbVNldCA9IG1vZGlmaWVyU2V0dGVyICh0aGUgb3JpZ2luYWwgc2V0dGVyLCBiZWZvcmUgYSBtb2RpZmllciB3YXMgYWRkZWQpXG5cblxuZXhwb3J0IHZhciBQcm9wVHdlZW4gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9wVHdlZW4obmV4dCwgdGFyZ2V0LCBwcm9wLCBzdGFydCwgY2hhbmdlLCByZW5kZXJlciwgZGF0YSwgc2V0dGVyLCBwcmlvcml0eSkge1xuICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICB0aGlzLnMgPSBzdGFydDtcbiAgICB0aGlzLmMgPSBjaGFuZ2U7XG4gICAgdGhpcy5wID0gcHJvcDtcbiAgICB0aGlzLnIgPSByZW5kZXJlciB8fCBfcmVuZGVyUGxhaW47XG4gICAgdGhpcy5kID0gZGF0YSB8fCB0aGlzO1xuICAgIHRoaXMuc2V0ID0gc2V0dGVyIHx8IF9zZXR0ZXJQbGFpbjtcbiAgICB0aGlzLnByID0gcHJpb3JpdHkgfHwgMDtcbiAgICB0aGlzLl9uZXh0ID0gbmV4dDtcblxuICAgIGlmIChuZXh0KSB7XG4gICAgICBuZXh0Ll9wcmV2ID0gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvNCA9IFByb3BUd2Vlbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNC5tb2RpZmllciA9IGZ1bmN0aW9uIG1vZGlmaWVyKGZ1bmMsIHR3ZWVuLCB0YXJnZXQpIHtcbiAgICB0aGlzLm1TZXQgPSB0aGlzLm1TZXQgfHwgdGhpcy5zZXQ7IC8vaW4gY2FzZSBpdCB3YXMgYWxyZWFkeSBzZXQgKGEgUHJvcFR3ZWVuIGNhbiBvbmx5IGhhdmUgb25lIG1vZGlmaWVyKVxuXG4gICAgdGhpcy5zZXQgPSBfc2V0dGVyV2l0aE1vZGlmaWVyO1xuICAgIHRoaXMubSA9IGZ1bmM7XG4gICAgdGhpcy5tdCA9IHRhcmdldDsgLy9tb2RpZmllciB0YXJnZXRcblxuICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcbiAgfTtcblxuICByZXR1cm4gUHJvcFR3ZWVuO1xufSgpOyAvL0luaXRpYWxpemF0aW9uIHRhc2tzXG5cbl9mb3JFYWNoTmFtZShfY2FsbGJhY2tOYW1lcyArIFwicGFyZW50LGR1cmF0aW9uLGVhc2UsZGVsYXksb3ZlcndyaXRlLHJ1bkJhY2t3YXJkcyxzdGFydEF0LHlveW8saW1tZWRpYXRlUmVuZGVyLHJlcGVhdCxyZXBlYXREZWxheSxkYXRhLHBhdXNlZCxyZXZlcnNlZCxsYXp5LGNhbGxiYWNrU2NvcGUsc3RyaW5nRmlsdGVyLGlkLHlveW9FYXNlLHN0YWdnZXIsaW5oZXJpdCxyZXBlYXRSZWZyZXNoLGtleWZyYW1lcyxhdXRvUmV2ZXJ0XCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDE7XG59KTtcblxuX2dsb2JhbHMuVHdlZW5NYXggPSBfZ2xvYmFscy5Ud2VlbkxpdGUgPSBUd2Vlbjtcbl9nbG9iYWxzLlRpbWVsaW5lTGl0ZSA9IF9nbG9iYWxzLlRpbWVsaW5lTWF4ID0gVGltZWxpbmU7XG5fZ2xvYmFsVGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICBzb3J0Q2hpbGRyZW46IGZhbHNlLFxuICBkZWZhdWx0czogX2RlZmF1bHRzLFxuICBhdXRvUmVtb3ZlQ2hpbGRyZW46IHRydWUsXG4gIGlkOiBcInJvb3RcIixcbiAgc21vb3RoQ2hpbGRUaW1pbmc6IHRydWVcbn0pO1xuX2NvbmZpZy5zdHJpbmdGaWx0ZXIgPSBfY29sb3JTdHJpbmdGaWx0ZXI7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEdTQVBcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxudmFyIF9nc2FwID0ge1xuICByZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4oKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlUGx1Z2luKGNvbmZpZyk7XG4gICAgfSk7XG4gIH0sXG4gIHRpbWVsaW5lOiBmdW5jdGlvbiB0aW1lbGluZSh2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lbGluZSh2YXJzKTtcbiAgfSxcbiAgZ2V0VHdlZW5zT2Y6IGZ1bmN0aW9uIGdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpO1xuICB9LFxuICBnZXRQcm9wZXJ0eTogZnVuY3Rpb24gZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgIGlmIChfaXNTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgLy9pbiBjYXNlIHNlbGVjdG9yIHRleHQgb3IgYW4gYXJyYXkgaXMgcGFzc2VkIGluXG4gICAgICB0YXJnZXQgPSB0b0FycmF5KHRhcmdldClbMF07XG4gICAgfVxuXG4gICAgdmFyIGdldHRlciA9IF9nZXRDYWNoZSh0YXJnZXQgfHwge30pLmdldCxcbiAgICAgICAgZm9ybWF0ID0gdW5pdCA/IF9wYXNzVGhyb3VnaCA6IF9udW1lcmljSWZQb3NzaWJsZTtcblxuICAgIGlmICh1bml0ID09PSBcIm5hdGl2ZVwiKSB7XG4gICAgICB1bml0ID0gXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gIXRhcmdldCA/IHRhcmdldCA6ICFwcm9wZXJ0eSA/IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgICAgcmV0dXJuIGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gICAgfSA6IGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gIH0sXG4gIHF1aWNrU2V0dGVyOiBmdW5jdGlvbiBxdWlja1NldHRlcih0YXJnZXQsIHByb3BlcnR5LCB1bml0KSB7XG4gICAgdGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpO1xuXG4gICAgaWYgKHRhcmdldC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgc2V0dGVycyA9IHRhcmdldC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIGdzYXAucXVpY2tTZXR0ZXIodCwgcHJvcGVydHksIHVuaXQpO1xuICAgICAgfSksXG4gICAgICAgICAgbCA9IHNldHRlcnMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IGw7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHNldHRlcnNbaV0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldFswXSB8fCB7fTtcblxuICAgIHZhciBQbHVnaW4gPSBfcGx1Z2luc1twcm9wZXJ0eV0sXG4gICAgICAgIGNhY2hlID0gX2dldENhY2hlKHRhcmdldCksXG4gICAgICAgIHNldHRlciA9IFBsdWdpbiA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHAgPSBuZXcgUGx1Z2luKCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgPSAwO1xuICAgICAgcC5pbml0KHRhcmdldCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBfcXVpY2tUd2VlbiwgMCwgW3RhcmdldF0pO1xuICAgICAgcC5yZW5kZXIoMSwgcCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgJiYgX3JlbmRlclByb3BUd2VlbnMoMSwgX3F1aWNrVHdlZW4pO1xuICAgIH0gOiBjYWNoZS5zZXQodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICByZXR1cm4gUGx1Z2luID8gc2V0dGVyIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gc2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgY2FjaGUsIDEpO1xuICAgIH07XG4gIH0sXG4gIGlzVHdlZW5pbmc6IGZ1bmN0aW9uIGlzVHdlZW5pbmcodGFyZ2V0cykge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0VHdlZW5zT2YodGFyZ2V0cywgdHJ1ZSkubGVuZ3RoID4gMDtcbiAgfSxcbiAgZGVmYXVsdHM6IGZ1bmN0aW9uIGRlZmF1bHRzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmVhc2UpIHtcbiAgICAgIHZhbHVlLmVhc2UgPSBfcGFyc2VFYXNlKHZhbHVlLmVhc2UsIF9kZWZhdWx0cy5lYXNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX21lcmdlRGVlcChfZGVmYXVsdHMsIHZhbHVlIHx8IHt9KTtcbiAgfSxcbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcodmFsdWUpIHtcbiAgICByZXR1cm4gX21lcmdlRGVlcChfY29uZmlnLCB2YWx1ZSB8fCB7fSk7XG4gIH0sXG4gIHJlZ2lzdGVyRWZmZWN0OiBmdW5jdGlvbiByZWdpc3RlckVmZmVjdChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVmZmVjdCA9IF9yZWYuZWZmZWN0LFxuICAgICAgICBwbHVnaW5zID0gX3JlZi5wbHVnaW5zLFxuICAgICAgICBkZWZhdWx0cyA9IF9yZWYuZGVmYXVsdHMsXG4gICAgICAgIGV4dGVuZFRpbWVsaW5lID0gX3JlZi5leHRlbmRUaW1lbGluZTtcbiAgICAocGx1Z2lucyB8fCBcIlwiKS5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xuICAgICAgcmV0dXJuIHBsdWdpbk5hbWUgJiYgIV9wbHVnaW5zW3BsdWdpbk5hbWVdICYmICFfZ2xvYmFsc1twbHVnaW5OYW1lXSAmJiBfd2FybihuYW1lICsgXCIgZWZmZWN0IHJlcXVpcmVzIFwiICsgcGx1Z2luTmFtZSArIFwiIHBsdWdpbi5cIik7XG4gICAgfSk7XG5cbiAgICBfZWZmZWN0c1tuYW1lXSA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzLCB0bCkge1xuICAgICAgcmV0dXJuIGVmZmVjdCh0b0FycmF5KHRhcmdldHMpLCBfc2V0RGVmYXVsdHModmFycyB8fCB7fSwgZGVmYXVsdHMpLCB0bCk7XG4gICAgfTtcblxuICAgIGlmIChleHRlbmRUaW1lbGluZSkge1xuICAgICAgVGltZWxpbmUucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChfZWZmZWN0c1tuYW1lXSh0YXJnZXRzLCBfaXNPYmplY3QodmFycykgPyB2YXJzIDogKHBvc2l0aW9uID0gdmFycykgJiYge30sIHRoaXMpLCBwb3NpdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgcmVnaXN0ZXJFYXNlOiBmdW5jdGlvbiByZWdpc3RlckVhc2UobmFtZSwgZWFzZSkge1xuICAgIF9lYXNlTWFwW25hbWVdID0gX3BhcnNlRWFzZShlYXNlKTtcbiAgfSxcbiAgcGFyc2VFYXNlOiBmdW5jdGlvbiBwYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF9wYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIDogX2Vhc2VNYXA7XG4gIH0sXG4gIGdldEJ5SWQ6IGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldEJ5SWQoaWQpO1xuICB9LFxuICBleHBvcnRSb290OiBmdW5jdGlvbiBleHBvcnRSb290KHZhcnMsIGluY2x1ZGVEZWxheWVkQ2FsbHMpIHtcbiAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXJzID0ge307XG4gICAgfVxuXG4gICAgdmFyIHRsID0gbmV3IFRpbWVsaW5lKHZhcnMpLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgbmV4dDtcbiAgICB0bC5zbW9vdGhDaGlsZFRpbWluZyA9IF9pc05vdEZhbHNlKHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcpO1xuXG4gICAgX2dsb2JhbFRpbWVsaW5lLnJlbW92ZSh0bCk7XG5cbiAgICB0bC5fZHAgPSAwOyAvL290aGVyd2lzZSBpdCdsbCBnZXQgcmUtYWN0aXZhdGVkIHdoZW4gYWRkaW5nIGNoaWxkcmVuIGFuZCBiZSByZS1pbnRyb2R1Y2VkIGludG8gX2dsb2JhbFRpbWVsaW5lJ3MgbGlua2VkIGxpc3QgKHRoZW4gYWRkZWQgdG8gaXRzZWxmKS5cblxuICAgIHRsLl90aW1lID0gdGwuX3RUaW1lID0gX2dsb2JhbFRpbWVsaW5lLl90aW1lO1xuICAgIGNoaWxkID0gX2dsb2JhbFRpbWVsaW5lLl9maXJzdDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gICAgICBpZiAoaW5jbHVkZURlbGF5ZWRDYWxscyB8fCAhKCFjaGlsZC5fZHVyICYmIGNoaWxkIGluc3RhbmNlb2YgVHdlZW4gJiYgY2hpbGQudmFycy5vbkNvbXBsZXRlID09PSBjaGlsZC5fdGFyZ2V0c1swXSkpIHtcbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGwsIGNoaWxkLCBjaGlsZC5fc3RhcnQgLSBjaGlsZC5fZGVsYXkpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IG5leHQ7XG4gICAgfVxuXG4gICAgX2FkZFRvVGltZWxpbmUoX2dsb2JhbFRpbWVsaW5lLCB0bCwgMCk7XG5cbiAgICByZXR1cm4gdGw7XG4gIH0sXG4gIHV0aWxzOiB7XG4gICAgd3JhcDogd3JhcCxcbiAgICB3cmFwWW95bzogd3JhcFlveW8sXG4gICAgZGlzdHJpYnV0ZTogZGlzdHJpYnV0ZSxcbiAgICByYW5kb206IHJhbmRvbSxcbiAgICBzbmFwOiBzbmFwLFxuICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICAgIGdldFVuaXQ6IGdldFVuaXQsXG4gICAgY2xhbXA6IGNsYW1wLFxuICAgIHNwbGl0Q29sb3I6IHNwbGl0Q29sb3IsXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBtYXBSYW5nZTogbWFwUmFuZ2UsXG4gICAgcGlwZTogcGlwZSxcbiAgICB1bml0aXplOiB1bml0aXplLFxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICBzaHVmZmxlOiBzaHVmZmxlXG4gIH0sXG4gIGluc3RhbGw6IF9pbnN0YWxsLFxuICBlZmZlY3RzOiBfZWZmZWN0cyxcbiAgdGlja2VyOiBfdGlja2VyLFxuICB1cGRhdGVSb290OiBUaW1lbGluZS51cGRhdGVSb290LFxuICBwbHVnaW5zOiBfcGx1Z2lucyxcbiAgZ2xvYmFsVGltZWxpbmU6IF9nbG9iYWxUaW1lbGluZSxcbiAgY29yZToge1xuICAgIFByb3BUd2VlbjogUHJvcFR3ZWVuLFxuICAgIGdsb2JhbHM6IF9hZGRHbG9iYWwsXG4gICAgVHdlZW46IFR3ZWVuLFxuICAgIFRpbWVsaW5lOiBUaW1lbGluZSxcbiAgICBBbmltYXRpb246IEFuaW1hdGlvbixcbiAgICBnZXRDYWNoZTogX2dldENhY2hlLFxuICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbTogX3JlbW92ZUxpbmtlZExpc3RJdGVtXG4gIH1cbn07XG5cbl9mb3JFYWNoTmFtZShcInRvLGZyb20sZnJvbVRvLGRlbGF5ZWRDYWxsLHNldCxraWxsVHdlZW5zT2ZcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9nc2FwW25hbWVdID0gVHdlZW5bbmFtZV07XG59KTtcblxuX3RpY2tlci5hZGQoVGltZWxpbmUudXBkYXRlUm9vdCk7XG5cbl9xdWlja1R3ZWVuID0gX2dzYXAudG8oe30sIHtcbiAgZHVyYXRpb246IDBcbn0pOyAvLyAtLS0tIEVYVFJBIFBMVUdJTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIF9nZXRQbHVnaW5Qcm9wVHdlZW4gPSBmdW5jdGlvbiBfZ2V0UGx1Z2luUHJvcFR3ZWVuKHBsdWdpbiwgcHJvcCkge1xuICB2YXIgcHQgPSBwbHVnaW4uX3B0O1xuXG4gIHdoaWxlIChwdCAmJiBwdC5wICE9PSBwcm9wICYmIHB0Lm9wICE9PSBwcm9wICYmIHB0LmZwICE9PSBwcm9wKSB7XG4gICAgcHQgPSBwdC5fbmV4dDtcbiAgfVxuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2FkZE1vZGlmaWVycyA9IGZ1bmN0aW9uIF9hZGRNb2RpZmllcnModHdlZW4sIG1vZGlmaWVycykge1xuICB2YXIgdGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuICAgICAgcCxcbiAgICAgIGksXG4gICAgICBwdDtcblxuICBmb3IgKHAgaW4gbW9kaWZpZXJzKSB7XG4gICAgaSA9IHRhcmdldHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcHQgPSB0d2Vlbi5fcHRMb29rdXBbaV1bcF07XG5cbiAgICAgIGlmIChwdCAmJiAocHQgPSBwdC5kKSkge1xuICAgICAgICBpZiAocHQuX3B0KSB7XG4gICAgICAgICAgLy8gaXMgYSBwbHVnaW5cbiAgICAgICAgICBwdCA9IF9nZXRQbHVnaW5Qcm9wVHdlZW4ocHQsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcHQgJiYgcHQubW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXJzW3BdLCB0d2VlbiwgdGFyZ2V0c1tpXSwgcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxuICAgIF9idWlsZE1vZGlmaWVyUGx1Z2luID0gZnVuY3Rpb24gX2J1aWxkTW9kaWZpZXJQbHVnaW4obmFtZSwgbW9kaWZpZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJhd1ZhcnM6IDEsXG4gICAgLy9kb24ndCBwcmUtcHJvY2VzcyBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgb3IgXCJyYW5kb20oKVwiIHN0cmluZ3MuXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKSB7XG4gICAgICB0d2Vlbi5fb25Jbml0ID0gZnVuY3Rpb24gKHR3ZWVuKSB7XG4gICAgICAgIHZhciB0ZW1wLCBwO1xuXG4gICAgICAgIGlmIChfaXNTdHJpbmcodmFycykpIHtcbiAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICBfZm9yRWFjaE5hbWUodmFycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wW25hbWVdID0gMTtcbiAgICAgICAgICB9KTsgLy9pZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyB0byByb3VuZFByb3BzLCBsaWtlIFwieCx5XCIsIHdlIHJvdW5kIHRvIHdob2xlIG51bWJlcnMuXG5cblxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICAgICAgdGVtcCA9IHt9O1xuXG4gICAgICAgICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgICAgICAgIHRlbXBbcF0gPSBtb2RpZmllcih2YXJzW3BdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXJzID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9hZGRNb2RpZmllcnModHdlZW4sIHZhcnMpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59OyAvL3JlZ2lzdGVyIGNvcmUgcGx1Z2luc1xuXG5cbmV4cG9ydCB2YXIgZ3NhcCA9IF9nc2FwLnJlZ2lzdGVyUGx1Z2luKHtcbiAgbmFtZTogXCJhdHRyXCIsXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICBmb3IgKHZhciBwIGluIHZhcnMpIHtcbiAgICAgIHRoaXMuYWRkKHRhcmdldCwgXCJzZXRBdHRyaWJ1dGVcIiwgKHRhcmdldC5nZXRBdHRyaWJ1dGUocCkgfHwgMCkgKyBcIlwiLCB2YXJzW3BdLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7IC8vdGhpcy5hZGQodGFyZ2V0LCBcInNldEF0dHJpYnV0ZVwiLCAodGFyZ2V0LmdldEF0dHJpYnV0ZSgocCBpbiB0YXJnZXQuZGF0YXNldCA/IChwID0gXCJkYXRhLVwiICsgcCkgOiBwKSkgfHwgMCkgKyBcIlwiLCB2YXJzW3BdLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG5cbiAgICAgIHRoaXMuX3Byb3BzLnB1c2gocCk7XG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6IFwiZW5kQXJyYXlcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmFkZCh0YXJnZXQsIGksIHRhcmdldFtpXSB8fCAwLCB2YWx1ZVtpXSk7XG4gICAgfVxuICB9XG59LCBfYnVpbGRNb2RpZmllclBsdWdpbihcInJvdW5kUHJvcHNcIiwgX3JvdW5kTW9kaWZpZXIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcIm1vZGlmaWVyc1wiKSwgX2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJzbmFwXCIsIHNuYXApKSB8fCBfZ3NhcDsgLy90byBwcmV2ZW50IHRoZSBjb3JlIHBsdWdpbnMgZnJvbSBiZWluZyBkcm9wcGVkIHZpYSBhZ2dyZXNzaXZlIHRyZWUgc2hha2luZywgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGluIHRoaXMgd2F5LlxuXG5Ud2Vlbi52ZXJzaW9uID0gVGltZWxpbmUudmVyc2lvbiA9IGdzYXAudmVyc2lvbiA9IFwiMy4yLjZcIjtcbl9jb3JlUmVhZHkgPSAxO1xuXG5pZiAoX3dpbmRvd0V4aXN0cygpKSB7XG4gIF93YWtlKCk7XG59XG5cbnZhciBQb3dlcjAgPSBfZWFzZU1hcC5Qb3dlcjAsXG4gICAgUG93ZXIxID0gX2Vhc2VNYXAuUG93ZXIxLFxuICAgIFBvd2VyMiA9IF9lYXNlTWFwLlBvd2VyMixcbiAgICBQb3dlcjMgPSBfZWFzZU1hcC5Qb3dlcjMsXG4gICAgUG93ZXI0ID0gX2Vhc2VNYXAuUG93ZXI0LFxuICAgIExpbmVhciA9IF9lYXNlTWFwLkxpbmVhcixcbiAgICBRdWFkID0gX2Vhc2VNYXAuUXVhZCxcbiAgICBDdWJpYyA9IF9lYXNlTWFwLkN1YmljLFxuICAgIFF1YXJ0ID0gX2Vhc2VNYXAuUXVhcnQsXG4gICAgUXVpbnQgPSBfZWFzZU1hcC5RdWludCxcbiAgICBTdHJvbmcgPSBfZWFzZU1hcC5TdHJvbmcsXG4gICAgRWxhc3RpYyA9IF9lYXNlTWFwLkVsYXN0aWMsXG4gICAgQmFjayA9IF9lYXNlTWFwLkJhY2ssXG4gICAgU3RlcHBlZEVhc2UgPSBfZWFzZU1hcC5TdGVwcGVkRWFzZSxcbiAgICBCb3VuY2UgPSBfZWFzZU1hcC5Cb3VuY2UsXG4gICAgU2luZSA9IF9lYXNlTWFwLlNpbmUsXG4gICAgRXhwbyA9IF9lYXNlTWFwLkV4cG8sXG4gICAgQ2lyYyA9IF9lYXNlTWFwLkNpcmM7XG5leHBvcnQgeyBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMgfTtcbmV4cG9ydCB7IFR3ZWVuIGFzIFR3ZWVuTWF4LCBUd2VlbiBhcyBUd2VlbkxpdGUsIFRpbWVsaW5lIGFzIFRpbWVsaW5lTWF4LCBUaW1lbGluZSBhcyBUaW1lbGluZUxpdGUsIGdzYXAgYXMgZGVmYXVsdCwgd3JhcCwgd3JhcFlveW8sIGRpc3RyaWJ1dGUsIHJhbmRvbSwgc25hcCwgbm9ybWFsaXplLCBnZXRVbml0LCBjbGFtcCwgc3BsaXRDb2xvciwgdG9BcnJheSwgbWFwUmFuZ2UsIHBpcGUsIHVuaXRpemUsIGludGVycG9sYXRlLCBzaHVmZmxlIH07IC8vZXhwb3J0IHNvbWUgaW50ZXJuYWwgbWV0aG9kcy9vcm9qZWN0cyBmb3IgdXNlIGluIENTU1BsdWdpbiBzbyB0aGF0IHdlIGNhbiBleHRlcm5hbGl6ZSB0aGF0IGZpbGUgYW5kIGFsbG93IGN1c3RvbSBidWlsZHMgdGhhdCBleGNsdWRlIGl0LlxuXG5leHBvcnQgeyBfZ2V0UHJvcGVydHksIF9udW1FeHAsIF9udW1XaXRoVW5pdEV4cCwgX2lzU3RyaW5nLCBfaXNVbmRlZmluZWQsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBfcmVsRXhwLCBfc2V0RGVmYXVsdHMsIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSwgX2ZvckVhY2hOYW1lLCBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5LCBfY29sb3JTdHJpbmdGaWx0ZXIsIF9yZXBsYWNlUmFuZG9tLCBfY2hlY2tQbHVnaW4sIF9wbHVnaW5zLCBfdGlja2VyLCBfY29uZmlnLCBfcm91bmRNb2RpZmllciwgX3JvdW5kLCBfbWlzc2luZ1BsdWdpbiwgX2dldFNldHRlciwgX2dldENhY2hlIH07IiwiaW1wb3J0IHsgZ3NhcCwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjLCBUd2VlbkxpdGUsIFRpbWVsaW5lTGl0ZSwgVGltZWxpbmVNYXggfSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcbmltcG9ydCB7IENTU1BsdWdpbiB9IGZyb20gXCIuL0NTU1BsdWdpbi5qc1wiO1xudmFyIGdzYXBXaXRoQ1NTID0gZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NQbHVnaW4pIHx8IGdzYXAsXG4gICAgLy8gdG8gcHJvdGVjdCBmcm9tIHRyZWUgc2hha2luZ1xuVHdlZW5NYXhXaXRoQ1NTID0gZ3NhcFdpdGhDU1MuY29yZS5Ud2VlbjtcbmV4cG9ydCB7IGdzYXBXaXRoQ1NTIGFzIGdzYXAsIGdzYXBXaXRoQ1NTIGFzIGRlZmF1bHQsIENTU1BsdWdpbiwgVHdlZW5NYXhXaXRoQ1NTIGFzIFR3ZWVuTWF4LCBUd2VlbkxpdGUsIFRpbWVsaW5lTWF4LCBUaW1lbGluZUxpdGUsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYyB9OyIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaGV4Q2hhcmFjdGVycyA9ICdhLWZcXFxcZCc7XG5jb25zdCBtYXRjaDNvcjRIZXggPSBgIz9bJHtoZXhDaGFyYWN0ZXJzfV17M31bJHtoZXhDaGFyYWN0ZXJzfV0/YDtcbmNvbnN0IG1hdGNoNm9yOEhleCA9IGAjP1ske2hleENoYXJhY3RlcnN9XXs2fShbJHtoZXhDaGFyYWN0ZXJzfV17Mn0pP2A7XG5jb25zdCBub25IZXhDaGFycyA9IG5ldyBSZWdFeHAoYFteIyR7aGV4Q2hhcmFjdGVyc31dYCwgJ2dpJyk7XG5jb25zdCB2YWxpZEhleFNpemUgPSBuZXcgUmVnRXhwKGBeJHttYXRjaDNvcjRIZXh9JHxeJHttYXRjaDZvcjhIZXh9JGAsICdpJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGhleCwgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJyB8fCBub25IZXhDaGFycy50ZXN0KGhleCkgfHwgIXZhbGlkSGV4U2l6ZS50ZXN0KGhleCkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHZhbGlkIGhleCBzdHJpbmcnKTtcblx0fVxuXG5cdGhleCA9IGhleC5yZXBsYWNlKC9eIy8sICcnKTtcblx0bGV0IGFscGhhID0gMTtcblxuXHRpZiAoaGV4Lmxlbmd0aCA9PT0gOCkge1xuXHRcdGFscGhhID0gcGFyc2VJbnQoaGV4LnNsaWNlKDYsIDgpLCAxNikgLyAyNTU7XG5cdFx0aGV4ID0gaGV4LnNsaWNlKDAsIDYpO1xuXHR9XG5cblx0aWYgKGhleC5sZW5ndGggPT09IDQpIHtcblx0XHRhbHBoYSA9IHBhcnNlSW50KGhleC5zbGljZSgzLCA0KS5yZXBlYXQoMiksIDE2KSAvIDI1NTtcblx0XHRoZXggPSBoZXguc2xpY2UoMCwgMyk7XG5cdH1cblxuXHRpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xuXHRcdGhleCA9IGhleFswXSArIGhleFswXSArIGhleFsxXSArIGhleFsxXSArIGhleFsyXSArIGhleFsyXTtcblx0fVxuXG5cdGNvbnN0IG51bSA9IHBhcnNlSW50KGhleCwgMTYpO1xuXHRjb25zdCByZWQgPSBudW0gPj4gMTY7XG5cdGNvbnN0IGdyZWVuID0gKG51bSA+PiA4KSAmIDI1NTtcblx0Y29uc3QgYmx1ZSA9IG51bSAmIDI1NTtcblxuXHRyZXR1cm4gb3B0aW9ucy5mb3JtYXQgPT09ICdhcnJheScgP1xuXHRcdFtyZWQsIGdyZWVuLCBibHVlLCBhbHBoYV0gOlxuXHRcdHtyZWQsIGdyZWVuLCBibHVlLCBhbHBoYX07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBNaW5pU2lnbmFsQmluZGluZyA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1pbmlTaWduYWxCaW5kaW5nKGZuLCBvbmNlLCB0aGlzQXJnKSB7XG4gICAgaWYgKG9uY2UgPT09IHVuZGVmaW5lZCkgb25jZSA9IGZhbHNlO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1pbmlTaWduYWxCaW5kaW5nKTtcblxuICAgIHRoaXMuX2ZuID0gZm47XG4gICAgdGhpcy5fb25jZSA9IG9uY2U7XG4gICAgdGhpcy5fdGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgdGhpcy5fbmV4dCA9IHRoaXMuX3ByZXYgPSB0aGlzLl9vd25lciA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWluaVNpZ25hbEJpbmRpbmcsIFt7XG4gICAga2V5OiAnZGV0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgaWYgKHRoaXMuX293bmVyID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLl9vd25lci5kZXRhY2godGhpcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWluaVNpZ25hbEJpbmRpbmc7XG59KSgpO1xuXG5mdW5jdGlvbiBfYWRkTWluaVNpZ25hbEJpbmRpbmcoc2VsZiwgbm9kZSkge1xuICBpZiAoIXNlbGYuX2hlYWQpIHtcbiAgICBzZWxmLl9oZWFkID0gbm9kZTtcbiAgICBzZWxmLl90YWlsID0gbm9kZTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLl90YWlsLl9uZXh0ID0gbm9kZTtcbiAgICBub2RlLl9wcmV2ID0gc2VsZi5fdGFpbDtcbiAgICBzZWxmLl90YWlsID0gbm9kZTtcbiAgfVxuXG4gIG5vZGUuX293bmVyID0gc2VsZjtcblxuICByZXR1cm4gbm9kZTtcbn1cblxudmFyIE1pbmlTaWduYWwgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNaW5pU2lnbmFsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNaW5pU2lnbmFsKTtcblxuICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1pbmlTaWduYWwsIFt7XG4gICAga2V5OiAnaGFuZGxlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVycygpIHtcbiAgICAgIHZhciBleGlzdHMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuXG4gICAgICBpZiAoZXhpc3RzKSByZXR1cm4gISFub2RlO1xuXG4gICAgICB2YXIgZWUgPSBbXTtcblxuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgZWUucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUuX25leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMobm9kZSkge1xuICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIE1pbmlTaWduYWxCaW5kaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pbmlTaWduYWwjaGFzKCk6IEZpcnN0IGFyZyBtdXN0IGJlIGEgTWluaVNpZ25hbEJpbmRpbmcgb2JqZWN0LicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5fb3duZXIgPT09IHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzcGF0Y2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5faGVhZDtcblxuICAgICAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLl9vbmNlKSB0aGlzLmRldGFjaChub2RlKTtcbiAgICAgICAgbm9kZS5fZm4uYXBwbHkobm9kZS5fdGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICAgICAgbm9kZSA9IG5vZGUuX25leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChmbikge1xuICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWluaVNpZ25hbCNhZGQoKTogRmlyc3QgYXJnIG11c3QgYmUgYSBGdW5jdGlvbi4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfYWRkTWluaVNpZ25hbEJpbmRpbmcodGhpcywgbmV3IE1pbmlTaWduYWxCaW5kaW5nKGZuLCBmYWxzZSwgdGhpc0FyZykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaW5pU2lnbmFsI29uY2UoKTogRmlyc3QgYXJnIG11c3QgYmUgYSBGdW5jdGlvbi4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfYWRkTWluaVNpZ25hbEJpbmRpbmcodGhpcywgbmV3IE1pbmlTaWduYWxCaW5kaW5nKGZuLCB0cnVlLCB0aGlzQXJnKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGV0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcbiAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBNaW5pU2lnbmFsQmluZGluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaW5pU2lnbmFsI2RldGFjaCgpOiBGaXJzdCBhcmcgbXVzdCBiZSBhIE1pbmlTaWduYWxCaW5kaW5nIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLl9vd25lciAhPT0gdGhpcykgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChub2RlLl9wcmV2KSBub2RlLl9wcmV2Ll9uZXh0ID0gbm9kZS5fbmV4dDtcbiAgICAgIGlmIChub2RlLl9uZXh0KSBub2RlLl9uZXh0Ll9wcmV2ID0gbm9kZS5fcHJldjtcblxuICAgICAgaWYgKG5vZGUgPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgdGhpcy5faGVhZCA9IG5vZGUuX25leHQ7XG4gICAgICAgIGlmIChub2RlLl9uZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICB0aGlzLl90YWlsID0gbm9kZS5fcHJldjtcbiAgICAgICAgdGhpcy5fdGFpbC5fbmV4dCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuX293bmVyID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RldGFjaEFsbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaEFsbCgpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5faGVhZDtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gbnVsbDtcblxuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgbm9kZS5fb3duZXIgPSBudWxsO1xuICAgICAgICBub2RlID0gbm9kZS5fbmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNaW5pU2lnbmFsO1xufSkoKTtcblxuTWluaVNpZ25hbC5NaW5pU2lnbmFsQmluZGluZyA9IE1pbmlTaWduYWxCaW5kaW5nO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBNaW5pU2lnbmFsO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsIi8vIEFsbCB2YWx1ZXMgYW5kIHN0cnVjdHVyZXMgcmVmZXJlbmNlZCBmcm9tOlxuLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2JiOTQzOTkxLmFzcHgvXG4vL1xuLy8gRFgxMCBDdWJlbWFwIHN1cHBvcnQgYmFzZWQgb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJpb21hbmVza3UvY21mdC9pc3N1ZXMvNyNpc3N1ZWNvbW1lbnQtNjk1MTY4NDRcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2JiOTQzOTgzKHY9dnMuODUpLmFzcHhcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbGF5Y2FudmFzL2VuZ2luZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL3Jlc291cmNlc190ZXh0dXJlLmpzXG5cbnZhciBERFNfTUFHSUMgPSAweDIwNTM0NDQ0XG52YXIgRERTRF9NSVBNQVBDT1VOVCA9IDB4MjAwMDBcbnZhciBERFBGX0ZPVVJDQyA9IDB4NFxuXG52YXIgRk9VUkNDX0RYVDEgPSBmb3VyQ0NUb0ludDMyKCdEWFQxJylcbnZhciBGT1VSQ0NfRFhUMyA9IGZvdXJDQ1RvSW50MzIoJ0RYVDMnKVxudmFyIEZPVVJDQ19EWFQ1ID0gZm91ckNDVG9JbnQzMignRFhUNScpXG52YXIgRk9VUkNDX0RYMTAgPSBmb3VyQ0NUb0ludDMyKCdEWDEwJylcbnZhciBGT1VSQ0NfRlAzMkYgPSAxMTYgLy8gRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX0ZMT0FUXG5cbnZhciBERFNDQVBTMl9DVUJFTUFQID0gMHgyMDBcbnZhciBEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT05fVEVYVFVSRTJEID0gM1xudmFyIERYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVCA9IDJcblxuLy8gVGhlIGhlYWRlciBsZW5ndGggaW4gMzIgYml0IGludHNcbnZhciBoZWFkZXJMZW5ndGhJbnQgPSAzMVxuXG4vLyBPZmZzZXRzIGludG8gdGhlIGhlYWRlciBhcnJheVxudmFyIG9mZl9tYWdpYyA9IDBcbnZhciBvZmZfc2l6ZSA9IDFcbnZhciBvZmZfZmxhZ3MgPSAyXG52YXIgb2ZmX2hlaWdodCA9IDNcbnZhciBvZmZfd2lkdGggPSA0XG52YXIgb2ZmX21pcG1hcENvdW50ID0gN1xudmFyIG9mZl9wZkZsYWdzID0gMjBcbnZhciBvZmZfcGZGb3VyQ0MgPSAyMVxudmFyIG9mZl9jYXBzMiA9IDI4XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VIZWFkZXJzXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyAoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIGhlYWRlciA9IG5ldyBJbnQzMkFycmF5KGFycmF5QnVmZmVyLCAwLCBoZWFkZXJMZW5ndGhJbnQpXG5cbiAgaWYgKGhlYWRlcltvZmZfbWFnaWNdICE9PSBERFNfTUFHSUMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFnaWMgbnVtYmVyIGluIEREUyBoZWFkZXInKVxuICB9XG5cbiAgaWYgKCFoZWFkZXJbb2ZmX3BmRmxhZ3NdICYgRERQRl9GT1VSQ0MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGZvcm1hdCwgbXVzdCBjb250YWluIGEgRm91ckNDIGNvZGUnKVxuICB9XG5cbiAgdmFyIGJsb2NrQnl0ZXNcbiAgdmFyIGZvcm1hdFxuICB2YXIgZm91ckNDID0gaGVhZGVyW29mZl9wZkZvdXJDQ11cbiAgc3dpdGNoIChmb3VyQ0MpIHtcbiAgICBjYXNlIEZPVVJDQ19EWFQxOlxuICAgICAgYmxvY2tCeXRlcyA9IDhcbiAgICAgIGZvcm1hdCA9ICdkeHQxJ1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEZPVVJDQ19EWFQzOlxuICAgICAgYmxvY2tCeXRlcyA9IDE2XG4gICAgICBmb3JtYXQgPSAnZHh0MydcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBGT1VSQ0NfRFhUNTpcbiAgICAgIGJsb2NrQnl0ZXMgPSAxNlxuICAgICAgZm9ybWF0ID0gJ2R4dDUnXG4gICAgICBicmVha1xuICAgIGNhc2UgRk9VUkNDX0ZQMzJGOlxuICAgICAgZm9ybWF0ID0gJ3JnYmEzMmYnXG4gICAgICBicmVha1xuICAgIGNhc2UgRk9VUkNDX0RYMTA6XG4gICAgICB2YXIgZHgxMEhlYWRlciA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1ZmZlci5zbGljZSgxMjgsIDEyOCArIDIwKSlcbiAgICAgIGZvcm1hdCA9IGR4MTBIZWFkZXJbMF1cbiAgICAgIHZhciByZXNvdXJjZURpbWVuc2lvbiA9IGR4MTBIZWFkZXJbMV1cbiAgICAgIHZhciBtaXNjRmxhZyA9IGR4MTBIZWFkZXJbMl1cbiAgICAgIHZhciBhcnJheVNpemUgPSBkeDEwSGVhZGVyWzNdXG4gICAgICB2YXIgbWlzY0ZsYWdzMiA9IGR4MTBIZWFkZXJbNF1cblxuICAgICAgaWYgKHJlc291cmNlRGltZW5zaW9uID09PSBEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT05fVEVYVFVSRTJEICYmIGZvcm1hdCA9PT0gRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX0ZMT0FUKSB7XG4gICAgICAgIGZvcm1hdCA9ICdyZ2JhMzJmJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBEWDEwIHRleHR1cmUgZm9ybWF0ICcgKyBmb3JtYXQpXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEZvdXJDQyBjb2RlOiAnICsgaW50MzJUb0ZvdXJDQyhmb3VyQ0MpKVxuICB9XG5cbiAgdmFyIGZsYWdzID0gaGVhZGVyW29mZl9mbGFnc11cbiAgdmFyIG1pcG1hcENvdW50ID0gMVxuXG4gIGlmIChmbGFncyAmIEREU0RfTUlQTUFQQ09VTlQpIHtcbiAgICBtaXBtYXBDb3VudCA9IE1hdGgubWF4KDEsIGhlYWRlcltvZmZfbWlwbWFwQ291bnRdKVxuICB9XG5cbiAgdmFyIGN1YmVtYXAgPSBmYWxzZVxuICB2YXIgY2FwczIgPSBoZWFkZXJbb2ZmX2NhcHMyXVxuICBpZiAoY2FwczIgJiBERFNDQVBTMl9DVUJFTUFQKSB7XG4gICAgY3ViZW1hcCA9IHRydWVcbiAgfVxuXG4gIHZhciB3aWR0aCA9IGhlYWRlcltvZmZfd2lkdGhdXG4gIHZhciBoZWlnaHQgPSBoZWFkZXJbb2ZmX2hlaWdodF1cbiAgdmFyIGRhdGFPZmZzZXQgPSBoZWFkZXJbb2ZmX3NpemVdICsgNFxuICB2YXIgdGV4V2lkdGggPSB3aWR0aFxuICB2YXIgdGV4SGVpZ2h0ID0gaGVpZ2h0XG4gIHZhciBpbWFnZXMgPSBbXVxuICB2YXIgZGF0YUxlbmd0aFxuXG4gIGlmIChmb3VyQ0MgPT09IEZPVVJDQ19EWDEwKSB7XG4gICAgZGF0YU9mZnNldCArPSAyMFxuICB9XG5cbiAgaWYgKGN1YmVtYXApIHtcbiAgICBmb3IgKHZhciBmID0gMDsgZiA8IDY7IGYrKykge1xuICAgICAgaWYgKGZvcm1hdCAhPT0gJ3JnYmEzMmYnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBSR0JBMzJmIGN1YmVtYXBzIGFyZSBzdXBwb3J0ZWQnKVxuICAgICAgfVxuICAgICAgdmFyIGJwcCA9IDQgKiAzMiAvIDhcblxuICAgICAgd2lkdGggPSB0ZXhXaWR0aFxuICAgICAgaGVpZ2h0ID0gdGV4SGVpZ2h0XG5cbiAgICAgIC8vIGN1YmVtYXAgc2hvdWxkIGhhdmUgYWxsIG1pcG1hcCBsZXZlbHMgZGVmaW5lZFxuICAgICAgLy8gTWF0aC5sb2cyKHdpZHRoKSArIDFcbiAgICAgIHZhciByZXF1aXJlZE1pcExldmVscyA9IE1hdGgubG9nKHdpZHRoKSAvIE1hdGgubG9nKDIpICsgMVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXVpcmVkTWlwTGV2ZWxzOyBpKyspIHtcbiAgICAgICAgZGF0YUxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogYnBwXG4gICAgICAgIGltYWdlcy5wdXNoKHtcbiAgICAgICAgICBvZmZzZXQ6IGRhdGFPZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoOiBkYXRhTGVuZ3RoLFxuICAgICAgICAgIHNoYXBlOiBbIHdpZHRoLCBoZWlnaHQgXVxuICAgICAgICB9KVxuICAgICAgICAvLyBSZXVzZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzIGxldmVsIGlmIHdlIGFyZSBiZXlvbmQgbWlwbWFwQ291bnRcbiAgICAgICAgLy8gVGhpcyBpcyBoYWNrIGZvciBDTUZUIG5vdCBwdWJsaXNoaW5nIGZ1bGwgbWlwbWFwIGNoYWluIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJpb21hbmVza3UvY21mdC9pc3N1ZXMvMTBcbiAgICAgICAgaWYgKGkgPCBtaXBtYXBDb3VudCkge1xuICAgICAgICAgIGRhdGFPZmZzZXQgKz0gZGF0YUxlbmd0aFxuICAgICAgICB9XG4gICAgICAgIHdpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAvIDIpXG4gICAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gMilcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXBtYXBDb3VudDsgaSsrKSB7XG4gICAgICBkYXRhTGVuZ3RoID0gTWF0aC5tYXgoNCwgd2lkdGgpIC8gNCAqIE1hdGgubWF4KDQsIGhlaWdodCkgLyA0ICogYmxvY2tCeXRlc1xuXG4gICAgICBpbWFnZXMucHVzaCh7XG4gICAgICAgIG9mZnNldDogZGF0YU9mZnNldCxcbiAgICAgICAgbGVuZ3RoOiBkYXRhTGVuZ3RoLFxuICAgICAgICBzaGFwZTogWyB3aWR0aCwgaGVpZ2h0IF1cbiAgICAgIH0pXG4gICAgICBkYXRhT2Zmc2V0ICs9IGRhdGFMZW5ndGhcbiAgICAgIHdpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAvIDIpXG4gICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAvIDIpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzaGFwZTogWyB0ZXhXaWR0aCwgdGV4SGVpZ2h0IF0sXG4gICAgaW1hZ2VzOiBpbWFnZXMsXG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgZmxhZ3M6IGZsYWdzLFxuICAgIGN1YmVtYXA6IGN1YmVtYXBcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3VyQ0NUb0ludDMyICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKSArXG4gICAgKHZhbHVlLmNoYXJDb2RlQXQoMSkgPDwgOCkgK1xuICAgICh2YWx1ZS5jaGFyQ29kZUF0KDIpIDw8IDE2KSArXG4gICAgKHZhbHVlLmNoYXJDb2RlQXQoMykgPDwgMjQpXG59XG5cbmZ1bmN0aW9uIGludDMyVG9Gb3VyQ0MgKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgIHZhbHVlICYgMHhmZixcbiAgICAodmFsdWUgPj4gOCkgJiAweGZmLFxuICAgICh2YWx1ZSA+PiAxNikgJiAweGZmLFxuICAgICh2YWx1ZSA+PiAyNCkgJiAweGZmXG4gIClcbn1cbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzIFBldGthIEFudG9ub3ZcbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOjwvcD5cbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIFF1ZXJ5U3RyaW5nU2VyaWFsaXplciA9IHJlcXVpcmUoXCIuL3F1ZXJ5c3RyaW5nc2VyaWFsaXplci5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gUXVlcnlTdHJpbmdQYXJzZXI7XG5cbnZhciBycGx1cyA9IC9cXCsvZztcbnZhciByaW50ID0gL15bMC05XSskLztcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBoYXZlUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5zU3BhcnNlID0gZmFsc2U7XG4gICAgdGhpcy5jYWNoZUtleSA9IFwiXCI7XG4gICAgdGhpcy5jYWNoZVZhbCA9IG51bGw7XG59XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLm1heExlbmd0aCA9IDMyNzY4O1xuUXVlcnlTdHJpbmdQYXJzZXIubWF4RGVwdGggPSA0O1xuUXVlcnlTdHJpbmdQYXJzZXIubWF4S2V5cyA9IDI1NjtcblxuUXVlcnlTdHJpbmdQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRQYXJzZShzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgbWF4TGVuZ3RoID0gUXVlcnlTdHJpbmdQYXJzZXIubWF4TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJzdHIgaXMgdG9vIGxhcmdlIChcIiArXG4gICAgICAgICAgICAgICAgXCJRdWVyeVN0cmluZ1BhcnNlci5tYXhMZW5ndGg9XCIgKyBtYXhMZW5ndGggKyBcIilcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IFF1ZXJ5U3RyaW5nUGFyc2VyKCk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VTdHJpbmcoc3RyLCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0ciAhPT0gbnVsbCAmJiB0eXBlb2Ygc3RyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgUXVlcnlTdHJpbmdQYXJzZXIoKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZU9iamVjdChzdHIpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5zdHJpbmdpZnkgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkU3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgdmFyIHNlcmlhbGl6ZXIgPSBuZXcgUXVlcnlTdHJpbmdTZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZXIuc2VyaWFsaXplKHZhbHVlKTtcbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnByb3RvdHlwZS5kZWNvZGUgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkZGVjb2RlKHN0ciwgc2hvdWxkRGVjb2RlLCBjb250YWluc1BsdXMpIHtcbiAgICBpZiAoc2hvdWxkRGVjb2RlID09PSBmYWxzZSkgcmV0dXJuIHN0cjtcbiAgICBpZiAoY29udGFpbnNQbHVzID09PSB0cnVlKSBzdHIgPSBzdHIucmVwbGFjZShycGx1cywgXCIgXCIpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUubWF5YmVBcnJheUluZGV4ID1cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJG1heWJlQXJyYXlJbmRleChzdHIsIGFycmF5TGVuZ3RoKSB7XG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMZW5ndGg7XG4gICAgfVxuICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KDApO1xuXG4gICAgaWYgKGNoID09PSA0OCkge1xuICAgICAgICByZXR1cm4gbGVuID4gMSA/IC0xIDogMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoNDggPD0gY2ggJiYgY2ggPD0gNTcpIHtcbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoIC0gNDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmludC50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gICAgICAgICAgICBpZiAoMCA8IHYgJiYgdiA8PSAxMDczNzQxODIyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLmdldFNsb3QgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkZ2V0U2xvdChkaWN0aW9uYXJ5LCBwcmV2S2V5LCBjdXJLZXkpIHtcbiAgICB2YXIgc2xvdDtcbiAgICBpZiAoIShoYXZlUHJvcC5jYWxsKGRpY3Rpb25hcnksIHByZXZLZXkpKSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm1heWJlQXJyYXlJbmRleChjdXJLZXksIDApO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgc2xvdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2xvdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRpY3Rpb25hcnlbcHJldktleV0gPSBzbG90O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2xvdCA9IGRpY3Rpb25hcnlbcHJldktleV07XG4gICAgfVxuICAgIHJldHVybiBzbG90O1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLnBsYWNlTmVzdGVkVmFsdWUgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkcGxhY2VOZXN0ZWRWYWx1ZVxuKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIGksIHByZXZLZXksIGN1cktleSkge1xuICAgIHZhciBzbG90ID0gdGhpcy5nZXRTbG90KGRpY3Rpb25hcnksIHByZXZLZXksIGN1cktleSk7XG4gICAgdmFyIGluZGV4ID0gLTE7XG5cbiAgICBpZiAoaXNBcnJheShzbG90KSkge1xuICAgICAgICBpbmRleCA9IHRoaXMubWF5YmVBcnJheUluZGV4KGN1cktleSwgc2xvdC5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIHZhciBkZXB0aCA9IDI7XG4gICAgdmFyIG1heERlcHRoID0gUXVlcnlTdHJpbmdQYXJzZXIubWF4RGVwdGg7XG4gICAgdmFyIHN0YXJ0ID0gLTE7XG4gICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSA5MSkge1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gOTMgJiZcbiAgICAgICAgICAgICAgICBzdGFydCA+IC0xKSB7XG4gICAgICAgICAgICBwcmV2S2V5ID0gY3VyS2V5O1xuICAgICAgICAgICAgY3VyS2V5ID0gc3RhcnQgPT09IGkgPyBcIlwiIDoga2V5LnN1YnN0cmluZyhzdGFydCwgaSk7XG4gICAgICAgICAgICBzdGFydCA9IC0xO1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIGlmIChkZXB0aCA+IG1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOZXN0aW5nIGRlcHRoIG9mIGtleXMgaXMgdG9vIGxhcmdlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIoUXVlcnlTdHJpbmdQYXJzZXIubWF4RGVwdGg9XCIrbWF4RGVwdGgrXCIpXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNsb3QgPSB0aGlzLmdldFNsb3Qoc2xvdCwgcHJldktleSwgY3VyS2V5KTtcblxuICAgICAgICAgICAgaW5kZXggPSBpc0FycmF5KHNsb3QpXG4gICAgICAgICAgICAgICAgPyB0aGlzLm1heWJlQXJyYXlJbmRleChjdXJLZXksIHNsb3QubGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihpbmRleCA+IC0xKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBzbG90Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNsb3QucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5zU3BhcnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzbG90W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmluc2VydChzbG90LCBjdXJLZXksIHZhbHVlKTtcbiAgICB9XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUuaW5zZXJ0ID1cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJGluc2VydChkaWN0aW9uYXJ5LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJldCA9IG51bGw7XG4gICAgaWYgKGhhdmVQcm9wLmNhbGwoZGljdGlvbmFyeSwga2V5KSkge1xuICAgICAgICB2YXIgcHJldiA9IGRpY3Rpb25hcnlba2V5XTtcbiAgICAgICAgaWYoIGlzQXJyYXkocHJldikgKSB7XG4gICAgICAgICAgICBwcmV2LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmV0ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IFtwcmV2LCB2YWx1ZV07XG4gICAgICAgICAgICBkaWN0aW9uYXJ5W2tleV0gPSByZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRpY3Rpb25hcnlba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLnB1c2ggPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkcHVzaChkaWN0aW9uYXJ5LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJldCA9IG51bGw7XG4gICAgaWYgKGhhdmVQcm9wLmNhbGwoZGljdGlvbmFyeSwga2V5KSkge1xuICAgICAgICB2YXIgcHJldiA9IGRpY3Rpb25hcnlba2V5XTtcbiAgICAgICAgcHJldi5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0ID0gcHJldjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldCA9IFt2YWx1ZV07XG4gICAgICAgIGRpY3Rpb25hcnlba2V5XSA9IHJldDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnByb3RvdHlwZS5tYXliZVBsYWNlTmVzdGVkVmFsdWUgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkbWF5YmVQbGFjZU5lc3RlZFZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBpZiAoa2V5LmNoYXJDb2RlQXQobGVuIC0gMSkgIT09IDkzKSB7XG4gICAgICAgIHRoaXMucGxhY2VWYWx1ZShkaWN0aW9uYXJ5LCBrZXksIHZhbHVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gLTE7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGN1cktleTtcbiAgICB2YXIgcHJldktleTtcblxuICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0ga2V5LmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSA5MSkge1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIHByZXZLZXkgPSBrZXkuc2xpY2UoMCwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDkzKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZVZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJLZXkgPSBzdGFydCA9PT0gaSA/IFwiXCIgOiBrZXkuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VyS2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5wbGFjZVZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjdXJLZXkgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIgJiYgaSA9PT0gbGVuKSB7XG4gICAgICAgIGlmIChrZXkgPT09IHRoaXMuY2FjaGVLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVWYWwucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlS2V5ID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5jYWNoZVZhbCA9IHRoaXMucHVzaChkaWN0aW9uYXJ5LCBwcmV2S2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMucGxhY2VOZXN0ZWRWYWx1ZShkaWN0aW9uYXJ5LCBrZXksIHZhbHVlLCBpLCBwcmV2S2V5LCBjdXJLZXkpO1xuICAgIH1cbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnByb3RvdHlwZS5wbGFjZVZhbHVlID1cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJHBsYWNlVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSwgcG9zc2libHlOZXN0ZWQpIHtcbiAgICBpZiAocG9zc2libHlOZXN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVBsYWNlTmVzdGVkVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gdGhpcy5jYWNoZUtleSkge1xuICAgICAgICB0aGlzLmNhY2hlVmFsLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IHRoaXMuaW5zZXJ0KGRpY3Rpb25hcnksIGtleSwgdmFsdWUpO1xuICAgIGlmIChjYWNoZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNhY2hlS2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmNhY2hlVmFsID0gY2FjaGU7XG4gICAgfVxufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLmNvbXBhY3QgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkY29tcGFjdChvYmopIHtcbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IoIHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSApIHtcbiAgICAgICAgICAgIHJldC5wdXNoKG9ialtrZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciggdmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpICkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBvYmpba2V5XSA9IHRoaXMuY29tcGFjdChvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0ID1cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJHBhcnNlT2JqZWN0KG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGxlbi0tO1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIHZhciBrZXk7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZW47ICsraSApIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0ICs9IGtleSArIFwiPVwiICsgb2JqW2tleV0gKyBcIiZcIjtcbiAgICB9XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICByZXQgKz0ga2V5ICsgXCI9XCIgKyBvYmpba2V5XTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZyhyZXQsIHRydWUpO1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID1cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJHBhcnNlU3RyaW5nKHN0ciwgbm9EZWNvZGUpIHtcbiAgICB2YXIgbWF4S2V5cyA9IFF1ZXJ5U3RyaW5nUGFyc2VyLm1heEtleXM7XG4gICAgdmFyIGtleXMgPSAwO1xuICAgIHZhciBkZWNvZGVLZXkgPSBmYWxzZTtcbiAgICB2YXIgZGVjb2RlVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgcG9zc2libHlOZXN0ZWQgPSBmYWxzZTtcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGRpY3Rpb25hcnkgPSB7fTtcbiAgICB2YXIga2V5U3RhcnQgPSAwO1xuICAgIHZhciBrZXlFbmQgPSAwO1xuICAgIHZhciB2YWx1ZVN0YXJ0ID0gMDtcbiAgICB2YXIgdmFsdWVFbmQgPSAwO1xuICAgIHZhciBsZWZ0ID0gMDtcbiAgICB2YXIgbGFzdEluZGV4ID0gbGVuIC0gMTtcbiAgICB2YXIgY29udGFpbnNQbHVzID0gZmFsc2U7XG5cblxuICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSA5MSkge1xuICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlZnQgPiAwICYmIGNoID09PSA5Mykge1xuICAgICAgICAgICAgcG9zc2libHlOZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGVmdC0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlZnQgPT09IDAgJiYgY2ggPT09IDYxKSB7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuXG4gICAgICAgICAgICBrZXlFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgIHZhbHVlRW5kID0gdmFsdWVTdGFydCA9IGo7XG4gICAgICAgICAgICB2YXIga2V5ID0gc3RyLnNsaWNlKGtleVN0YXJ0LCBrZXlFbmQgKyAxKTtcbiAgICAgICAgICAgIGtleSA9IHRoaXMuZGVjb2RlKGtleSwgZGVjb2RlS2V5LCBjb250YWluc1BsdXMpO1xuICAgICAgICAgICAgZGVjb2RlS2V5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgICAgICAgIGlmICgoY2ggPT09IDQzIHx8IGNoID09PSAzNykgJiYgIW5vRGVjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNDMpIGNvbnRhaW5zUGx1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAzOCB8fCBqID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVFbmQgPSBqO1xuICAgICAgICAgICAgICAgICAgICBpID0gajtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDM4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVuZC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RyLnNsaWNlKHZhbHVlU3RhcnQsIHZhbHVlRW5kICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5kZWNvZGUodmFsdWUsIGRlY29kZVZhbHVlLCBjb250YWluc1BsdXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxhY2VWYWx1ZShkaWN0aW9uYXJ5LCBrZXksIHZhbHVlLCBwb3NzaWJseU5lc3RlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnNQbHVzID0gZGVjb2RlVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libHlOZXN0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBrZXlTdGFydCA9IGogKyAxO1xuICAgICAgICAgICAgICAgICAgICBrZXlzKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzID4gbWF4S2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBbW91bnQgb2Yga2V5cyBpcyB0b28gbGFyZ2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFF1ZXJ5U3RyaW5nUGFyc2VyLm1heEtleXM9XCIgKyBtYXhLZXlzICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY2ggPT09IDQzIHx8IGNoID09PSAzNykgJiYgIW5vRGVjb2RlKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDQzKSBjb250YWluc1BsdXMgPSB0cnVlO1xuICAgICAgICAgICAgZGVjb2RlS2V5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5U3RhcnQgIT09IGxlbikge1xuICAgICAgICB2YXIgdmFsdWUgPSBcIlwiO1xuICAgICAgICB2YXIga2V5ID0gc3RyLnNsaWNlKGtleVN0YXJ0LCBsZW4pO1xuICAgICAgICBrZXkgPSB0aGlzLmRlY29kZShrZXksIGRlY29kZUtleSwgY29udGFpbnNQbHVzKTtcbiAgICAgICAgdGhpcy5wbGFjZVZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIHBvc3NpYmx5TmVzdGVkKTtcbiAgICB9XG5cblxuICAgIGlmICh0aGlzLmNvbnRhaW5zU3BhcnNlKSB7XG4gICAgICAgIHRoaXMuY29tcGFjdChkaWN0aW9uYXJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGljdGlvbmFyeTtcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMyBQZXRrYSBBbnRvbm92XG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczo8L3A+XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUXVlcnlTdHJpbmdTZXJpYWxpemVyO1xudmFyIGVuYyA9IGVuY29kZVVSSUNvbXBvbmVudDtcbnZhciBBUlJBWSA9IFtdO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9Qcm90byA9IGdldFByb3RvKHt9KTtcblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHByb3RvID0gZ2V0UHJvdG8ob2JqKTtcblxuICAgIHJldHVybiBwcm90byA9PT0gb1Byb3RvIHx8IHByb3RvID09PSBudWxsO1xufVxuXG5mdW5jdGlvbiBRdWVyeVN0cmluZ1NlcmlhbGl6ZXIoKSB7XG5cbn1cblxuUXVlcnlTdHJpbmdTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemUgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdTZXJpYWxpemVyJHNlcmlhbGl6ZShvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBvYmogdG8gc3RyaW5naWZ5IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgIH1cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBhcnJheSA9IEFSUkFZO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgY3VyID0gb2JqO1xuICAgIHZhciBrZXlQcmVmaXggPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cyA9PT0gYXJyYXkgPyBpIDoga2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gY3VyW2tleV07XG4gICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goa2V5UHJlZml4LCBjdXIsIGtleXMsIGxlbiwgaSk7XG5cbiAgICAgICAgICAgIGlmIChrZXlQcmVmaXggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBrZXlQcmVmaXggPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlQcmVmaXggPSBrZXlQcmVmaXggKyBcIltcIiArIGVuYyhrZXkpICsgXCJdXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGtleXMgPSBhcnJheTtcbiAgICAgICAgICAgICAgICBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICAgICAgICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgY3VyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkS2V5ID0ga2V5UHJlZml4ID09PSBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZW5jKGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBrZXlQcmVmaXggKyBcIltcIiArIGVuYyhrZXkpICsgXCJdXCI7XG4gICAgICAgICAgICByZXQucHVzaChzZXJpYWxpemVkS2V5ICsgXCI9XCIgKyBlbmModmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGkgPT09IGxlbiAtIDEgJiYgc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgbGVuID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBrZXlzID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjdXIgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGtleVByZWZpeCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldC5qb2luKFwiJlwiKTtcbn07XG4iLCIvLyBTY2hlZHVsZXIuanNcbmNvbnN0IEZSQU1FUkFURSA9IDYwO1xuXG5jbGFzcyBTY2hlZHVsZXIge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX2RlbGF5VGFza3MgPSBbXTtcblx0XHR0aGlzLl9uZXh0VGFza3MgPSBbXTtcblx0XHR0aGlzLl9kZWZlclRhc2tzID0gW107XG5cdFx0dGhpcy5faGlnaFRhc2tzID0gW107XG5cdFx0dGhpcy5fdXN1cnBUYXNrID0gW107XG5cdFx0dGhpcy5fZW50ZXJmcmFtZVRhc2tzID0gW107XG5cdFx0dGhpcy5faWRUYWJsZSA9IDA7XG5cblx0XHR0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuXHRcdHRoaXMuX2RlbHRhVGltZSA9IDA7XG5cdFx0dGhpcy5faW50ZXJuYWxUaW1lID0gMDtcblx0XHR0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuXG5cblx0XHR0aGlzLl9sb29wKCk7XG5cdH1cblxuXG5cdC8vICBQVUJMSUMgTUVUSE9EU1xuXG5cdGFkZEVGKGZ1bmMsIHBhcmFtcykge1xuXHRcdHBhcmFtcyA9IHBhcmFtcyB8fCBbXTtcblx0XHRjb25zdCBpZCA9IHRoaXMuX2lkVGFibGU7XG5cdFx0dGhpcy5fZW50ZXJmcmFtZVRhc2tzW2lkXSA9IHsgZnVuYywgcGFyYW1zIH07XG5cdFx0dGhpcy5faWRUYWJsZSArKztcblx0XHRyZXR1cm4gaWQ7XG5cdH1cblxuXHRyZW1vdmVFRihpZCkge1xuXHRcdGlmICh0aGlzLl9lbnRlcmZyYW1lVGFza3NbaWRdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX2VudGVyZnJhbWVUYXNrc1tpZF0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH1cblxuXHRkZWxheShmdW5jLCBwYXJhbXMsIGRlbGF5KSB7XG5cdFx0Y29uc3QgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdGNvbnN0IHQgPSB7IGZ1bmMsIHBhcmFtcywgZGVsYXksIHRpbWUgfTtcblx0XHR0aGlzLl9kZWxheVRhc2tzLnB1c2godCk7XG5cdH1cblxuXHRkZWZlcihmdW5jLCBwYXJhbXMpIHtcblx0XHRjb25zdCB0ID0geyBmdW5jLCBwYXJhbXMgfTtcblx0XHR0aGlzLl9kZWZlclRhc2tzLnB1c2godCk7XG5cdH1cblxuXHRuZXh0KGZ1bmMsIHBhcmFtcykge1xuXHRcdGNvbnN0IHQgPSB7IGZ1bmMsIHBhcmFtcyB9O1xuXHRcdHRoaXMuX25leHRUYXNrcy5wdXNoKHQpO1xuXHR9XG5cblx0dXN1cnAoZnVuYywgcGFyYW1zKSB7XG5cdFx0Y29uc3QgdCA9IHsgZnVuYywgcGFyYW1zIH07XG5cdFx0dGhpcy5fdXN1cnBUYXNrLnB1c2godCk7XG5cdH1cblxuXG5cdHBhdXNlKCkge1xuXHRcdHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcblx0fVxuXG5cblx0YWR2YW5jZSgpIHtcblx0XHR0aGlzLl9pbnRlcm5hbFRpbWUgKz0gMSAvIEZSQU1FUkFURTtcblx0fVxuXG5cblx0cmVzdW1lKCkge1xuXHRcdHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG5cdH1cblxuXHQvLyAgUFJJVkFURSBNRVRIT0RTXG5cblx0X3Byb2Nlc3MoKSB7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGxldCB0YXNrO1xuXHRcdGxldCBpbnRlcnZhbDtcblx0XHRsZXQgY3VycmVudDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fZW50ZXJmcmFtZVRhc2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0YXNrID0gdGhpcy5fZW50ZXJmcmFtZVRhc2tzW2ldO1xuXHRcdFx0aWYgKHRhc2sgIT09IG51bGwgJiYgdGFzayAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRhc2suZnVuYyh0YXNrLnBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0d2hpbGUgKHRoaXMuX2hpZ2hUYXNrcy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0YXNrID0gdGhpcy5faGlnaFRhc2tzLnBvcCgpO1xuXHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHR9XG5cblxuXHRcdGxldCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRsZXQgX3N0YXJ0VGltZSA9IHRoaXMuX2RlbHRhVGltZTtcblx0XHR0aGlzLl9kZWx0YVRpbWUgPSAoc3RhcnRUaW1lIC0gdGhpcy5fc3RhcnRUaW1lKS8xMDAwO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuX2RlbGF5VGFza3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRhc2sgPSB0aGlzLl9kZWxheVRhc2tzW2ldO1xuXHRcdFx0aWYgKHN0YXJ0VGltZSAtIHRhc2sudGltZSA+IHRhc2suZGVsYXkpIHtcblx0XHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHRcdFx0dGhpcy5fZGVsYXlUYXNrcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0dGhpcy5fZGVsdGFUaW1lID0gKHN0YXJ0VGltZSAtIHRoaXMuX3N0YXJ0VGltZSkvMTAwMDtcblx0XHRpbnRlcnZhbCA9IDEwMDAgLyBGUkFNRVJBVEU7XG5cdFx0d2hpbGUgKHRoaXMuX2RlZmVyVGFza3MubGVuZ3RoID4gMCkge1xuXHRcdFx0dGFzayA9IHRoaXMuX2RlZmVyVGFza3Muc2hpZnQoKTtcblx0XHRcdGN1cnJlbnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdGlmIChjdXJyZW50IC0gc3RhcnRUaW1lIDwgaW50ZXJ2YWwpIHtcblx0XHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2RlZmVyVGFza3MudW5zaGlmdCh0YXNrKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHR0aGlzLl9kZWx0YVRpbWUgPSAoc3RhcnRUaW1lIC0gdGhpcy5fc3RhcnRUaW1lKS8xMDAwO1xuXHRcdGludGVydmFsID0gMTAwMCAvIEZSQU1FUkFURTtcblx0XHR3aGlsZSAodGhpcy5fdXN1cnBUYXNrLmxlbmd0aCA+IDApIHtcblx0XHRcdHRhc2sgPSB0aGlzLl91c3VycFRhc2suc2hpZnQoKTtcblx0XHRcdGN1cnJlbnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdGlmIChjdXJyZW50IC0gc3RhcnRUaW1lIDwgaW50ZXJ2YWwpIHtcblx0XHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9oaWdoVGFza3MgPSB0aGlzLl9oaWdoVGFza3MuY29uY2F0KHRoaXMuX25leHRUYXNrcyk7XG5cdFx0dGhpcy5fbmV4dFRhc2tzID0gW107XG5cdFx0dGhpcy5fdXN1cnBUYXNrID0gW107XG5cblx0XHRpZighdGhpcy5faXNQYXVzZWQpIHtcblx0XHRcdHRoaXMuX2ludGVybmFsVGltZSArPSB0aGlzLl9kZWx0YVRpbWUgLSBfc3RhcnRUaW1lO1xuXHRcdH1cblx0fVxuXG5cblx0X2xvb3AoKSB7XG5cdFx0dGhpcy5fcHJvY2VzcygpO1xuXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5fbG9vcCgpKTtcblx0fVxuXG5cdGdldCBpbnRlcnZhbFRpbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludGVybmFsVGltZTtcblx0fVxuXG5cdGdldCBkZWx0YVRpbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlbHRhVGltZTtcblx0fVxufVxuXG5jb25zdCBzY2hlZHVsZXIgPSBuZXcgU2NoZWR1bGVyKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHNjaGVkdWxlcjtcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCl7XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBwYXJlbnQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEF0LmJlZm9yZSwgdGFyZ2V0KTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRpZihvcHRpb25zLmF0dHJzLm5vbmNlID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuXHRcdGlmIChub25jZSkge1xuXHRcdFx0b3B0aW9ucy5hdHRycy5ub25jZSA9IG5vbmNlO1xuXHRcdH1cblx0fVxuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vbmNlKCkge1xuXHRpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIF9fd2VicGFja19ub25jZV9fO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdCA/IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpIFxuXHRcdCA6IG9wdGlvbnMudHJhbnNmb3JtLmRlZmF1bHQob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG4iLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsIi8vIEFzc2V0cy5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMQ3ViZVRleHR1cmUsIEdMVGV4dHVyZSwgTWVzaCwgT2JqTG9hZGVyIH0gZnJvbSAnYWxmcmlkJztcblxuY29uc3QgQXNzZXRzID0ge307XG5sZXQgX2Fzc2V0cyA9IFtdO1xubGV0IGFzc2V0cztcbmxldCB0ZXh0dXJlcyA9IFtdO1xuXG5jb25zdCBnZXRBc3NldCA9IGZ1bmN0aW9uKGlkKSB7XG5cdFxuXHRyZXR1cm4gYXNzZXRzLmZpbmQoIChhKSA9PiBhLmlkID09PSBpZCkuZmlsZTtcbn1cblxuY29uc3QgZ2V0RXh0ZW5zaW9uID0gZnVuY3Rpb24obUZpbGUpIHtcblx0Y29uc3QgYXJ5ID0gbUZpbGUuc3BsaXQoJy4nKTtcblx0cmV0dXJuIGFyeVthcnkubGVuZ3RoIC0gMV07XG59XG5cbkFzc2V0cy5pbml0ID0gZnVuY3Rpb24obUFzc2V0cywgYXNzZXRzVG9Mb2FkKSB7XG5cdFxuXHRhc3NldHMgPSBtQXNzZXRzO1xuXHRsZXQgaGRyQ3ViZW1hcHMgPSB7fTtcblx0X2Fzc2V0cyA9IGFzc2V0c1RvTG9hZC5tYXAoKG8pPT4ge1xuXHRcdGNvbnN0IGV4dCA9IGdldEV4dGVuc2lvbihvLnVybCk7XG5cdFx0XG5cdFx0Y29uc3QgZmlsZSA9IGdldEFzc2V0KG8uaWQpO1xuXHRcdGxldCB0ZXh0dXJlO1xuXG5cdFx0c3dpdGNoKGV4dCkge1xuXG5cdFx0XHRcblx0XHRcdGNhc2UgJ2pwZyc6XG5cdFx0XHRjYXNlICdwbmcnOlxuXHRcdFx0XHR0ZXh0dXJlID0gbmV3IEdMVGV4dHVyZShmaWxlKTtcblx0XHRcdFx0dGV4dHVyZXMucHVzaCh0ZXh0dXJlKVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlkOm8uaWQsXG5cdFx0XHRcdFx0ZmlsZTp0ZXh0dXJlXG5cdFx0XHRcdH07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdoZHInOlxuXHRcdFx0XHRsZXQgY3ViZW1hcE5hbWUgPSBvLmlkLnNwbGl0KCdfJylbMF07XG5cdFx0XHRcdHRleHR1cmUgPSBhbGZyaWQuSERSTG9hZGVyLnBhcnNlKGZpbGUpO1xuXG5cdFx0XHRcdGNvbnN0IG9Bc3NldCA9IHtcblx0XHRcdFx0XHRpZDpvLmlkLFxuXHRcdFx0XHRcdGZpbGU6dGV4dHVyZVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmKCFoZHJDdWJlbWFwc1tjdWJlbWFwTmFtZV0pIHtcblx0XHRcdFx0XHRoZHJDdWJlbWFwc1tjdWJlbWFwTmFtZV0gPSBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGhkckN1YmVtYXBzW2N1YmVtYXBOYW1lXS5wdXNoKG9Bc3NldCk7XG5cdFx0XHRcdHJldHVybiBvQXNzZXQ7XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkZHMnOlxuXHRcdFx0XHR0ZXh0dXJlID0gR0xDdWJlVGV4dHVyZS5wYXJzZUREUyhmaWxlKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpZDpvLmlkLFxuXHRcdFx0XHRcdGZpbGU6dGV4dHVyZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnb2JqJzpcblx0XHRcdFx0Y29uc3QgbWVzaCA9IE9iakxvYWRlci5wYXJzZShmaWxlKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpZDpvLmlkLFxuXHRcdFx0XHRcdGZpbGU6bWVzaFxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc29sZS5sb2coJ2Vycm9yIHdpdGggZXh0ZW5zaW9uJywgZXh0KVxuXHRcdH1cblxuXHR9KTtcblxuXHRmb3IobGV0IHMgaW4gaGRyQ3ViZW1hcHMpIHtcblx0XHRpZihoZHJDdWJlbWFwc1tzXS5sZW5ndGggPT0gNikge1xuXHRcdFx0Y29uc29sZS5sb2coJ0dlbmVyYXRlIEN1YmVtYXAgOicsIHMpO1xuXG5cdFx0XHRjb25zdCBhcnkgPSBbXG5cdFx0XHRcdEFzc2V0cy5nZXQoYCR7c31fcG9zeGApLFxuXHRcdFx0XHRBc3NldHMuZ2V0KGAke3N9X25lZ3hgKSxcblx0XHRcdFx0QXNzZXRzLmdldChgJHtzfV9wb3N5YCksXG5cdFx0XHRcdEFzc2V0cy5nZXQoYCR7c31fbmVneWApLFxuXHRcdFx0XHRBc3NldHMuZ2V0KGAke3N9X3Bvc3pgKSxcblx0XHRcdFx0QXNzZXRzLmdldChgJHtzfV9uZWd6YClcblx0XHRcdF07XG5cblx0XHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgYWxmcmlkLkdMQ3ViZVRleHR1cmUoYXJ5KTtcblx0XHRcdF9hc3NldHMucHVzaCh7XG5cdFx0XHRcdGlkOnMsXG5cdFx0XHRcdGZpbGU6dGV4dHVyZVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblxuXHRjb25zb2xlLmxvZygnX2Fzc2V0cycsIF9hc3NldHMpXG5cblx0aWYoX2Fzc2V0cy5sZW5ndGggPiAwKSB7XG5cdFx0Y29uc29sZS5kZWJ1ZygnQVNTRVRTOicpO1xuXHRcdGNvbnNvbGUudGFibGUoX2Fzc2V0cyk7XHRcblx0fVxuXHRcbn1cblxuQXNzZXRzLmRlc3Ryb3kgPSAoZ2wpID0+IHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuXHRcdGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZXNbaV0uX3RleHR1cmUpO1xuXHR9XG5cblx0dGV4dHVyZXMubGVuZ3RoID0gMDtcbn1cblxuQXNzZXRzLmdldCA9IGZ1bmN0aW9uKG1JZCkge1xuXHRyZXR1cm4gX2Fzc2V0cy5maW5kKChhKSA9PiB7XG5cdFx0cmV0dXJuIGEuaWQgPT09IG1JZDtcblx0fSkuZmlsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQXNzZXRzOyIsImV4cG9ydCBjb25zdCBhZGREcm9wU3VwcG9ydCA9IChtQ0IpID0+IHtcblx0Y29uc3QgZHJvcEFyZWEgPSB3aW5kb3c7XG4gIFxuXHRjb25zdCBwcmV2ZW50RGVmYXVsdHMgPSAoZSkgPT4ge1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuICBcbiAgWydkcmFnZW50ZXInLCAnZHJhZ292ZXInLCAnZHJhZ2xlYXZlJywgJ2Ryb3AnXS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG5cdFx0ZHJvcEFyZWEuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHByZXZlbnREZWZhdWx0cywgZmFsc2UpO1xuXHR9KTtcblxuXHRjb25zdCBoYW5kbGVEcm9wID0gKGUpID0+IHtcblx0XHRjb25zdCBkdCA9IGUuZGF0YVRyYW5zZmVyO1xuXHRcdGNvbnN0IGZpbGVzID0gZHQuZmlsZXM7XG5cdFx0Y29uc3QgZmlsZSA9IGZpbGVzWzBdO1xuXG5cdFx0Y29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRyZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcblx0XHRyZWFkZXIub25sb2FkZW5kID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cblx0XHRcdGltZy5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0XHRcdGlmIChtQ0IpIHtcblx0XHRcdFx0XHRtQ0IoaW1nKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGltZy5zcmMgPSByZWFkZXIucmVzdWx0O1xuXHRcdH07XG5cdH07XG5cblx0ZHJvcEFyZWEuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIGhhbmRsZURyb3AsIGZhbHNlKTtcbn07XG5cbiIsIi8vIGRlYnVnUG9seWZpbGwuanNcblxud2luZG93Lmd1aSA9IHtcblx0YWRkOigpPT57XG5cblx0fVxufTsiLCJjbGFzcyBCaXRTd2l0Y2gge1xuICBjb25zdHJ1Y3RvciAoaW5pdFZhbHVlID0gMCkge1xuICAgIHRoaXMuX3ZhbHVlID0gaW5pdFZhbHVlO1xuICB9XG5cbiAgc2V0IChtTnVtRGlnaXQsIG1WYWx1ZSA9IDEpIHtcbiAgICBpZiAobVZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3ZhbHVlICYgKDAgPDwgbU51bURpZ2l0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3ZhbHVlIHwgKDEgPDwgbU51bURpZ2l0KVxuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZShtTnVtRGlnaXQpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3ZhbHVlIF4gKDEgPDwgKG1OdW1EaWdpdCkpXG4gIH1cblxuICBnZXQgKG1OdW1EaWdpdCkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuX3ZhbHVlICYgKDEgPDwgbU51bURpZ2l0KVxuICAgIHZhbHVlID0gdmFsdWUgPj4gbU51bURpZ2l0XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IDFcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLl92YWx1ZSA9IDBcbiAgfVxuXG4gIGdldCB2YWx1ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlXG4gIH1cblxuICBsb2cgKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLl92YWx1ZS50b1N0cmluZygyKVxuICAgIHJldHVybiBzXG4gIH1cbn1cblxuZXhwb3J0IHsgQml0U3dpdGNoIH1cbiIsImltcG9ydCBnc2FwIGZyb20gJ2dzYXAnO1xuXG5jbGFzcyBPcmJDb250cm9sVHdlZW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9yYml0YWxDb250cm9sID0gbnVsbDtcbiAgICB0aGlzLmluaXRpYWxpc2VkID0gZmFsc2U7XG4gIH1cblxuICBpbml0KG9yYml0YWxDb250cm9sKSB7XG4gICAgdGhpcy5pbml0aWFsaXNlZCA9IHRydWU7XG4gICAgdGhpcy5vcmJpdGFsQ29udHJvbCA9IG9yYml0YWxDb250cm9sO1xuICB9XG5cbiAgdHdlZW4ob3B0aW9ucykge1xuICAgIGNvbnN0IG9yYiA9IHRoaXMub3JiaXRhbENvbnRyb2w7XG5cbiAgICBjb25zdCBvID0ge1xuICAgICAgcmFkaXVzOiBvcmIucmFkaXVzLnZhbHVlLFxuICAgICAgcng6IG9yYi5yeC52YWx1ZSxcbiAgICAgIHJ5OiBvcmIucnkudmFsdWUsXG4gICAgICBjZW50ZXJYOiBvcmIuY2VudGVyWzBdLFxuICAgICAgY2VudGVyWTogb3JiLmNlbnRlclsxXSxcbiAgICAgIGNlbnRlclo6IG9yYi5jZW50ZXJbMl0sXG4gICAgICBvZmZzZXRYOiBvcmIucG9zaXRpb25PZmZzZXRbMF0sXG4gICAgICBvZmZzZXRZOiBvcmIucG9zaXRpb25PZmZzZXRbMV0sXG4gICAgICBvZmZzZXRaOiBvcmIucG9zaXRpb25PZmZzZXRbMl0sXG4gICAgfTtcblxuICAgIGdzYXAudG8obywgb3B0aW9ucy5kdXJhdGlvbiB8fCAxLCB7XG4gICAgICBkZWxheTogb3B0aW9ucy5kZWxheSB8fCAwLFxuICAgICAgcmFkaXVzOiBvcHRpb25zLnJhZGl1cyB8fCAwLFxuICAgICAgcng6IG9wdGlvbnMucnggfHwgMCxcbiAgICAgIHJ5OiBvcHRpb25zLnJ5IHx8IDAsXG4gICAgICBjZW50ZXJYOiBvcHRpb25zLmNlbnRlclggfHwgMCxcbiAgICAgIGNlbnRlclk6IG9wdGlvbnMuY2VudGVyWSB8fCAwLFxuICAgICAgY2VudGVyWjogb3B0aW9ucy5jZW50ZXJaIHx8IDAsXG4gICAgICBvZmZzZXRYOiBvcHRpb25zLm9mZnNldFggfHwgMCxcbiAgICAgIG9mZnNldFk6IG9wdGlvbnMub2Zmc2V0WSB8fCAwLFxuICAgICAgb2Zmc2V0Wjogb3B0aW9ucy5vZmZzZXRaIHx8IDAsXG4gICAgICBlYXNlOiBvcHRpb25zLmVhc2UgfHwgJ3NpbmUub3V0JyxcbiAgICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnJ4ICE9PSB1bmRlZmluZWQpIG9yYi5yeC5zZXRUbyhvLnJ4KTtcbiAgICAgICAgaWYgKG9wdGlvbnMucnkgIT09IHVuZGVmaW5lZCkgb3JiLnJ5LnNldFRvKG8ucnkpO1xuICAgICAgICBpZiAob3B0aW9ucy5yYWRpdXMgIT09IHVuZGVmaW5lZCkgb3JiLnJhZGl1cy5zZXRUbyhvLnJhZGl1cyk7XG4gICAgICAgIGlmIChvcHRpb25zLmNlbnRlclggIT09IHVuZGVmaW5lZCkgb3JiLmNlbnRlclswXSA9IG8uY2VudGVyWDtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2VudGVyWSAhPT0gdW5kZWZpbmVkKSBvcmIuY2VudGVyWzFdID0gby5jZW50ZXJZO1xuICAgICAgICBpZiAob3B0aW9ucy5jZW50ZXJaICE9PSB1bmRlZmluZWQpIG9yYi5jZW50ZXJbMl0gPSBvLmNlbnRlclo7XG4gICAgICAgIGlmIChvcHRpb25zLm9mZnNldFggIT09IHVuZGVmaW5lZCkgb3JiLnBvc2l0aW9uT2Zmc2V0WzBdID0gby5vZmZzZXRYO1xuICAgICAgICBpZiAob3B0aW9ucy5vZmZzZXRZICE9PSB1bmRlZmluZWQpIG9yYi5wb3NpdGlvbk9mZnNldFsxXSA9IG8ub2Zmc2V0WTtcbiAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0WiAhPT0gdW5kZWZpbmVkKSBvcmIucG9zaXRpb25PZmZzZXRbMl0gPSBvLm9mZnNldFo7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogb3B0aW9ucy5vbkNvbXBsZXRlIHx8IG51bGwsXG4gICAgfSk7XG4gIH1cblxuICBnZXQgaXNSZWFkeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGlzZWQ7XG4gIH1cbn1cblxuY29uc3Qgb3JiaXRhbENvbnRyb2xUd2VlbiA9IG5ldyBPcmJDb250cm9sVHdlZW4oKTtcblxuZXhwb3J0IHsgb3JiaXRhbENvbnRyb2xUd2VlbiB9O1xuIiwiZXhwb3J0IHsgb3JiaXRhbENvbnRyb2xUd2VlbiBhcyBPcmJpdGFsQ29udHJvbFR3ZWVuIH0gZnJvbSAnLi9PcmJpdGFsQ29udHJvbFR3ZWVuJztcbmV4cG9ydCB7IEJpdFN3aXRjaCB9IGZyb20gJy4vQml0U3dpdGNoJzsiLCIvLyBhbGZyaWQuanNcblxuaW1wb3J0ICogYXMgR0xNIGZyb20gJ2dsLW1hdHJpeCdcblxuaW1wb3J0IEJhdGNoIGZyb20gJy4vYWxmcmlkL0JhdGNoJ1xuaW1wb3J0IEJhdGNoQXhpcyBmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoQXhpcydcbmltcG9ydCBCYXRjaEJhbGwgZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaEJhbGwnXG4vLyBIRUxQRVJTXG5pbXBvcnQgQmF0Y2hDb3B5IGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hDb3B5J1xuaW1wb3J0IEJhdGNoRG90c1BsYW5lIGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hEb3RzUGxhbmUnXG5pbXBvcnQgQmF0Y2hMaW5lIGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hMaW5lJ1xuaW1wb3J0IEJhdGNoU2t5IGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hTa3knXG5pbXBvcnQgQmF0Y2hTa3lib3ggZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaFNreWJveCdcbi8vIExPQURFUlNcbmltcG9ydCBCaW5hcnlMb2FkZXIgZnJvbSAnLi9hbGZyaWQvbG9hZGVycy9CaW5hcnlMb2FkZXInXG4vLyBDQU1FUkFTXG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4vYWxmcmlkL2NhbWVyYXMvQ2FtZXJhJ1xuaW1wb3J0IENhbWVyYUN1YmUgZnJvbSAnLi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFDdWJlJ1xuaW1wb3J0IENhbWVyYU9ydGhvIGZyb20gJy4vYWxmcmlkL2NhbWVyYXMvQ2FtZXJhT3J0aG8nXG5pbXBvcnQgQ2FtZXJhUGVyc3BlY3RpdmUgZnJvbSAnLi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFQZXJzcGVjdGl2ZSdcbmltcG9ydCBDdWJlRnJhbWVCdWZmZXIgZnJvbSAnLi9hbGZyaWQvQ3ViZUZyYW1lQnVmZmVyJ1xuaW1wb3J0IERyYXcgZnJvbSAnLi9hbGZyaWQvaGVscGVycy9EcmF3J1xuaW1wb3J0IEVhc2VOdW1iZXIgZnJvbSAnLi9hbGZyaWQvdXRpbHMvRWFzZU51bWJlcidcbmltcG9ydCBFdmVudERpc3BhdGNoZXIgZnJvbSAnLi9hbGZyaWQvdXRpbHMvRXZlbnREaXNwYXRjaGVyJ1xuaW1wb3J0IEZib0FycmF5IGZyb20gJy4vYWxmcmlkL0Zib0FycmF5J1xuaW1wb3J0IEZib1BpbmdQb25nIGZyb20gJy4vYWxmcmlkL0Zib1BpbmdQb25nJ1xuaW1wb3J0IEZyYW1lQnVmZmVyIGZyb20gJy4vYWxmcmlkL0ZyYW1lQnVmZmVyJ1xuaW1wb3J0IEdMIGZyb20gJy4vYWxmcmlkL0dMVG9vbCdcbmltcG9ydCBHTEN1YmVUZXh0dXJlIGZyb20gJy4vYWxmcmlkL0dMQ3ViZVRleHR1cmUnXG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi9hbGZyaWQvR0xTaGFkZXInXG5pbXBvcnQgR0xURlBhcnNlciBmcm9tICcuL2FsZnJpZC9sb2FkZXJzL0dMVEZQYXJzZXInXG5pbXBvcnQgR0xUZXh0dXJlIGZyb20gJy4vYWxmcmlkL0dMVGV4dHVyZTInXG5pbXBvcnQgR2VvbSBmcm9tICcuL2FsZnJpZC9HZW9tJ1xuaW1wb3J0IEhEUkxvYWRlciBmcm9tICcuL2FsZnJpZC9sb2FkZXJzL0hEUkxvYWRlcidcbmltcG9ydCBNZXNoIGZyb20gJy4vYWxmcmlkL01lc2gnXG4vLyBXRUJHTCAyXG5pbXBvcnQgTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlciBmcm9tICcuL2FsZnJpZC9NdWx0aXNhbXBsZUZyYW1lQnVmZmVyJ1xuaW1wb3J0IE9iakxvYWRlciBmcm9tICcuL2FsZnJpZC9sb2FkZXJzL09iakxvYWRlcidcbi8vIE9CSkVDVFxuaW1wb3J0IE9iamVjdDNEIGZyb20gJy4vYWxmcmlkL29iamVjdHMvT2JqZWN0M0QnXG5pbXBvcnQgT3JiaXRhbENvbnRyb2wgZnJvbSAnLi9hbGZyaWQvdXRpbHMvT3JiaXRhbENvbnRyb2wnXG5pbXBvcnQgUXVhdFJvdGF0aW9uIGZyb20gJy4vYWxmcmlkL3V0aWxzL1F1YXRSb3RhdGlvbidcbi8vIE1BVEhcbmltcG9ydCBSYXkgZnJvbSAnLi9hbGZyaWQvbWF0aC9SYXknXG5pbXBvcnQgU2NlbmUgZnJvbSAnLi9hbGZyaWQvaGVscGVycy9TY2VuZSdcbi8vIFRPT0xTXG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJ3NjaGVkdWxpbmcnXG5pbXBvcnQgU2hhZGVyTGlicyBmcm9tICcuL2FsZnJpZC91dGlscy9TaGFkZXJMaWJzJ1xuaW1wb3J0IFNwcmluZ051bWJlciBmcm9tICcuL2FsZnJpZC91dGlscy9TcHJpbmdOdW1iZXInXG5pbXBvcnQgVG91Y2hEZXRlY3RvciBmcm9tICcuL2FsZnJpZC91dGlscy9Ub3VjaERldGVjdG9yJ1xuaW1wb3J0IFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0IGZyb20gJy4vYWxmcmlkL1RyYW5zZm9ybUZlZWRiYWNrT2JqZWN0J1xuaW1wb3J0IFR3ZWVuTnVtYmVyIGZyb20gJy4vYWxmcmlkL3V0aWxzL1R3ZWVuTnVtYmVyJ1xuaW1wb3J0IFZpZXcgZnJvbSAnLi9hbGZyaWQvaGVscGVycy9WaWV3J1xuaW1wb3J0IFZpZXczRCBmcm9tICcuL2FsZnJpZC9oZWxwZXJzL1ZpZXczRCdcbmltcG9ydCBXZWJnbE51bWJlciBmcm9tICcuL2FsZnJpZC91dGlscy9XZWJnbE51bWJlcidcblxuLy8gaW1wb3J0IFdlYmdsQ29uc3QgZnJvbSAnLi9hbGZyaWQvdXRpbHMvV2ViZ2xDb25zdCdcblxuXG5cblxuLy8gaW1wb3J0IENvbGxhZGFQYXJzZXIgIGZyb20gJy4vYWxmcmlkL2xvYWRlcnMvQ29sbGFkYVBhcnNlcic7XG5cblxuXG5jb25zdCBWRVJTSU9OID0gJzAuMy45J1xuXG5jbGFzcyBBbGZyaWQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5nbG0gPSBHTE1cbiAgICB0aGlzLkdMID0gR0xcbiAgICB0aGlzLkdMVG9vbCA9IEdMXG4gICAgdGhpcy5HTFNoYWRlciA9IEdMU2hhZGVyXG4gICAgdGhpcy5HTFRleHR1cmUgPSBHTFRleHR1cmVcbiAgICB0aGlzLkdMQ3ViZVRleHR1cmUgPSBHTEN1YmVUZXh0dXJlXG4gICAgdGhpcy5NZXNoID0gTWVzaFxuICAgIHRoaXMuR2VvbSA9IEdlb21cbiAgICB0aGlzLkJhdGNoID0gQmF0Y2hcbiAgICB0aGlzLkZyYW1lQnVmZmVyID0gRnJhbWVCdWZmZXJcbiAgICB0aGlzLkN1YmVGcmFtZUJ1ZmZlciA9IEN1YmVGcmFtZUJ1ZmZlclxuICAgIHRoaXMuU2NoZWR1bGVyID0gU2NoZWR1bGVyXG4gICAgdGhpcy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXJcbiAgICB0aGlzLkVhc2VOdW1iZXIgPSBFYXNlTnVtYmVyXG4gICAgdGhpcy5TcHJpbmdOdW1iZXIgPSBTcHJpbmdOdW1iZXJcbiAgICB0aGlzLlR3ZWVuTnVtYmVyID0gVHdlZW5OdW1iZXJcbiAgICB0aGlzLkNhbWVyYSA9IENhbWVyYVxuICAgIHRoaXMuQ2FtZXJhT3J0aG8gPSBDYW1lcmFPcnRob1xuICAgIHRoaXMuQ2FtZXJhUGVyc3BlY3RpdmUgPSBDYW1lcmFQZXJzcGVjdGl2ZVxuICAgIHRoaXMuUmF5ID0gUmF5XG4gICAgdGhpcy5DYW1lcmFDdWJlID0gQ2FtZXJhQ3ViZVxuICAgIHRoaXMuT3JiaXRhbENvbnRyb2wgPSBPcmJpdGFsQ29udHJvbFxuICAgIHRoaXMuUXVhdFJvdGF0aW9uID0gUXVhdFJvdGF0aW9uXG4gICAgdGhpcy5CaW5hcnlMb2FkZXIgPSBCaW5hcnlMb2FkZXJcbiAgICB0aGlzLk9iakxvYWRlciA9IE9iakxvYWRlclxuICAgIHRoaXMuR0xURlBhcnNlciA9IEdMVEZQYXJzZXJcbiAgICAvLyB0aGlzLkNvbGxhZGFQYXJzZXIgICAgID0gQ29sbGFkYVBhcnNlcjtcbiAgICB0aGlzLkhEUkxvYWRlciA9IEhEUkxvYWRlclxuICAgIHRoaXMuQmF0Y2hDb3B5ID0gQmF0Y2hDb3B5XG4gICAgdGhpcy5CYXRjaEF4aXMgPSBCYXRjaEF4aXNcbiAgICB0aGlzLkJhdGNoQmFsbCA9IEJhdGNoQmFsbFxuICAgIHRoaXMuQmF0Y2hCYWxsID0gQmF0Y2hCYWxsXG4gICAgdGhpcy5CYXRjaExpbmUgPSBCYXRjaExpbmVcbiAgICB0aGlzLkJhdGNoU2t5Ym94ID0gQmF0Y2hTa3lib3hcbiAgICB0aGlzLkJhdGNoU2t5ID0gQmF0Y2hTa3lcbiAgICB0aGlzLkJhdGNoRG90c1BsYW5lID0gQmF0Y2hEb3RzUGxhbmVcbiAgICB0aGlzLlNjZW5lID0gU2NlbmVcbiAgICB0aGlzLlZpZXcgPSBWaWV3XG4gICAgdGhpcy5WaWV3M0QgPSBWaWV3M0RcbiAgICB0aGlzLkRyYXcgPSBEcmF3XG4gICAgdGhpcy5PYmplY3QzRCA9IE9iamVjdDNEXG4gICAgdGhpcy5TaGFkZXJMaWJzID0gU2hhZGVyTGlic1xuICAgIHRoaXMuV2ViZ2xOdW1iZXIgPSBXZWJnbE51bWJlclxuXG4gICAgdGhpcy5GYm9BcnJheSA9IEZib0FycmF5XG4gICAgdGhpcy5GYm9QaW5nUG9uZyA9IEZib1BpbmdQb25nXG5cbiAgICB0aGlzLk11bHRpc2FtcGxlRnJhbWVCdWZmZXIgPSBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyXG4gICAgdGhpcy5UcmFuc2Zvcm1GZWVkYmFja09iamVjdCA9IFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0XG5cbiAgICBmb3IgKGNvbnN0IHMgaW4gR0xNKSB7XG4gICAgICBpZiAoR0xNW3NdKSB7XG4gICAgICAgIGlmICh3aW5kb3cpIHdpbmRvd1tzXSA9IEdMTVtzXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvZyAoKSB7XG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSkge1xuICAgICAgY29uc29sZS5sb2coYCVjbGliIGFsZnJpZCA6IFZFUlNJT04gJHtWRVJTSU9OfWAsICdiYWNrZ3JvdW5kOiAjMTkzNDQxOyBjb2xvcjogI0ZDRkZGNScpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdsaWIgYWxmcmlkIDogVkVSU0lPTiAnLCBWRVJTSU9OKVxuICAgIH1cbiAgICBjb25zb2xlLmxvZygnJWNDbGFzc2VzIDogJywgJ2NvbG9yOiAjMTkzNDQxJylcblxuICAgIGZvciAoY29uc3QgcyBpbiB0aGlzKSB7XG4gICAgICBpZiAodGhpc1tzXSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgJWMgLSAke3N9YCwgJ2NvbG9yOiAjM0U2MDZGJylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgYWwgPSBuZXcgQWxmcmlkKClcblxuZXhwb3J0IGRlZmF1bHQgYWxcbmV4cG9ydCB7XG4gIEdMLFxuICBHTFNoYWRlcixcbiAgR0xUZXh0dXJlLFxuICBHTEN1YmVUZXh0dXJlLFxuICBNZXNoLFxuICBHZW9tLFxuICBCYXRjaCxcbiAgRnJhbWVCdWZmZXIsXG4gIEN1YmVGcmFtZUJ1ZmZlcixcbiAgTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlcixcbiAgVHJhbnNmb3JtRmVlZGJhY2tPYmplY3QsXG4gIFNjaGVkdWxlcixcbiAgRXZlbnREaXNwYXRjaGVyLFxuICBFYXNlTnVtYmVyLFxuICBTcHJpbmdOdW1iZXIsXG4gIFR3ZWVuTnVtYmVyLFxuICBPcmJpdGFsQ29udHJvbCxcbiAgV2ViZ2xOdW1iZXIsXG4gIFF1YXRSb3RhdGlvbixcbiAgVG91Y2hEZXRlY3RvcixcbiAgQ2FtZXJhLFxuICBDYW1lcmFPcnRobyxcbiAgQ2FtZXJhUGVyc3BlY3RpdmUsXG4gIENhbWVyYUN1YmUsXG4gIFJheSxcbiAgT2JqZWN0M0QsXG4gIEJpbmFyeUxvYWRlcixcbiAgT2JqTG9hZGVyLFxuICBIRFJMb2FkZXIsXG4gIEdMVEZQYXJzZXIsXG4gIEJhdGNoQ29weSxcbiAgQmF0Y2hBeGlzLFxuICBCYXRjaEJhbGwsXG4gIEJhdGNoRG90c1BsYW5lLFxuICBCYXRjaExpbmUsXG4gIEJhdGNoU2t5Ym94LFxuICBCYXRjaFNreSxcbiAgU2NlbmUsXG4gIFZpZXcsXG4gIFZpZXczRCxcbiAgRHJhdyxcbiAgU2hhZGVyTGlicyxcbiAgRmJvQXJyYXksXG4gIEZib1BpbmdQb25nXG59XG4iLCIvLyBCYXRjaC5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuXG5jbGFzcyBCYXRjaCB7XG5cblx0Y29uc3RydWN0b3IobU1lc2gsIG1TaGFkZXIpIHtcblx0XHR0aGlzLl9tZXNoID0gbU1lc2g7XG5cdFx0dGhpcy5fc2hhZGVyID0gbVNoYWRlcjtcblx0fVxuXG5cblx0Ly9cdFBVQkxJQyBNRVRIT0RTXG5cblx0ZHJhdygpIHtcblx0XHR0aGlzLl9zaGFkZXIuYmluZCgpO1xuXHRcdEdMLmRyYXcodGhpcy5tZXNoKTtcblx0fVxuXG5cblx0Ly9cdEdFVFRFUiBBTkQgU0VUVEVSXG5cblx0Z2V0IG1lc2goKSB7XHRyZXR1cm4gdGhpcy5fbWVzaDtcdH1cblxuXHRnZXQgc2hhZGVyKCkge1x0cmV0dXJuIHRoaXMuX3NoYWRlcjtcdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2g7IiwiLy8gQ3ViZUZyYW1lQnVmZmVyLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcbmltcG9ydCBHTEN1YmVUZXh0dXJlIGZyb20gJy4vR0xDdWJlVGV4dHVyZSc7XG5cbmxldCBnbDtcblxuXG5jbGFzcyBDdWJlRnJhbWVCdWZmZXIge1xuXG5cdGNvbnN0cnVjdG9yKHNpemUsIG1QYXJhbWV0ZXJzID0ge30pIHtcblx0XHRnbCA9IEdMLmdsO1xuXHRcdHRoaXMuX3NpemUgPSBzaXplO1xuXHRcdHRoaXMubWFnRmlsdGVyID0gbVBhcmFtZXRlcnMubWFnRmlsdGVyIHx8IGdsLkxJTkVBUjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IG1QYXJhbWV0ZXJzLm1pbkZpbHRlciB8fCBnbC5MSU5FQVI7XG5cdFx0dGhpcy53cmFwUyAgICAgPSBtUGFyYW1ldGVycy53cmFwUyB8fCBnbC5DTEFNUF9UT19FREdFO1xuXHRcdHRoaXMud3JhcFQgICAgID0gbVBhcmFtZXRlcnMud3JhcFQgfHwgZ2wuQ0xBTVBfVE9fRURHRTtcblxuXHRcdHRoaXMuX2luaXQoKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy50ZXh0dXJlICAgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0dGhpcy5nbFRleHR1cmUgPSBuZXcgR0xDdWJlVGV4dHVyZSh0aGlzLnRleHR1cmUsIHt9LCB0cnVlKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5taW5GaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMud3JhcFQpO1xuXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IFtcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLCBcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLCBcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWiwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aIFxuXHRcdF07XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuXHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2ldLCAwLCBnbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdH1cblxuXG5cdFx0dGhpcy5fZnJhbWVCdWZmZXJzID0gW107XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuXHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0YXJnZXRzW2ldLCB0aGlzLnRleHR1cmUsIDApO1xuXG5cdFx0XHRjb25zdCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcblx0XHRcdGlmIChzdGF0dXMgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGAnZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cygpIHJldHVybmVkICcke3N0YXR1c31gKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZnJhbWVCdWZmZXJzLnB1c2goZnJhbWVCdWZmZXIpO1xuXHRcdH1cblxuXHRcdC8vIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfQ1VCRV9NQVApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuXHR9XG5cblxuXHRiaW5kKG1UYXJnZXRJbmRleCkge1xuXG5cdFx0Ly8gaWYoTWF0aC5yYW5kb20oKSA+IC45OSkgY29uc29sZS5sb2coJ2JpbmQgOicsIG1UYXJnZXRJbmRleCwgdGhpcy5fZnJhbWVCdWZmZXJzW21UYXJnZXRJbmRleF0pO1xuXHRcdEdMLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmZmVyc1ttVGFyZ2V0SW5kZXhdKTtcblx0fVxuXG5cdHVuYmluZCgpIHtcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdEdMLnZpZXdwb3J0KDAsIDAsIEdMLndpZHRoLCBHTC5oZWlnaHQpO1xuXHR9XG5cblx0Ly9cdFRFWFRVUkVTXG5cblx0Z2V0VGV4dHVyZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5nbFRleHR1cmU7XG5cdH1cblxuXHQvL1x0R0VUVEVSUyBBTkQgU0VUVEVSU1xuXG5cdGdldCB3aWR0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZTtcblx0fVxuXG5cdGdldCBoZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemU7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDdWJlRnJhbWVCdWZmZXI7IiwiLy8gRmJvQXJyYXkuanNcblxuaW1wb3J0IEZyYW1lQnVmZmVyIGZyb20gJy4vRnJhbWVCdWZmZXInO1xuXG5jbGFzcyBGYm9BcnJheSB7XG5cblx0Y29uc3RydWN0b3IobU51bSwgd2lkdGgsIGhlaWdodCwgcGFyYW1zPXt9LCBtTnVtVGFyZ2V0cz0xKSB7XG5cdFx0dGhpcy5fZmJvcyA9IFtdO1xuXG5cblx0XHRmb3IobGV0IGk9MDsgaTxtTnVtOyBpKyspIHtcblx0XHRcdGNvbnN0IGZibyA9IG5ldyBGcmFtZUJ1ZmZlcih3aWR0aCwgaGVpZ2h0LCBwYXJhbXMsIG1OdW1UYXJnZXRzKTtcblx0XHRcdHRoaXMuX2Zib3MucHVzaChmYm8pO1xuXHRcdH1cblxuXHR9XG5cblxuXHRzd2FwKCkge1xuXHRcdGNvbnN0IGEgPSB0aGlzLl9mYm9zLnNoaWZ0KCk7XG5cdFx0dGhpcy5fZmJvcy5wdXNoKGEpO1xuXHR9XG5cblxuXHRnZXQgcmVhZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmJvc1t0aGlzLl9mYm9zLmxlbmd0aCAtIDFdO1xuXHR9XG5cblxuXHRnZXQgd3JpdGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Zib3NbMF07XG5cdH1cblxuXG5cdGdldCBhbGwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Zib3M7XG5cdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEZib0FycmF5OyIsIi8vIEZib1BpbmdQb25nLmpzXG5cbmltcG9ydCBGYm9GYXJyYXkgZnJvbSAnLi9GYm9BcnJheSc7XG5cbmNsYXNzIEZib1BpbmdQb25nIGV4dGVuZHMgRmJvRmFycmF5IHtcblxuXHRjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBwYXJhbXM9e30sIG1OdW1UYXJnZXRzPTEpIHtcblx0XHRzdXBlcigyLCB3aWR0aCwgaGVpZ2h0LCBwYXJhbXMsIG1OdW1UYXJnZXRzKTtcblx0fVxuXHRcbn1cblxuZXhwb3J0IGRlZmF1bHQgRmJvUGluZ1Bvbmc7IiwiLy8gRnJhbWVCdWZmZXIuanNcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJ1xuaW1wb3J0IEdMVGV4dHVyZTIgZnJvbSAnLi9HTFRleHR1cmUyJ1xuaW1wb3J0IFdlYmdsTnVtYmVyIGZyb20gJy4vdXRpbHMvV2ViZ2xOdW1iZXInXG5cbmxldCBnbFxubGV0IHdlYmdsRGVwdGhUZXh0dXJlXG5sZXQgaGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCA9IGZhbHNlXG5sZXQgZXh0RHJhd0J1ZmZlclxuXG5jb25zdCBjaGVja011bHRpUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAoR0wud2ViZ2wyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIHtcbiAgICBleHREcmF3QnVmZmVyID0gR0wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKVxuICAgIHJldHVybiAhIWV4dERyYXdCdWZmZXJcbiAgfVxuXG4gIGhhc0NoZWNrZWRNdWx0aVJlbmRlclN1cHBvcnQgPSB0cnVlXG59XG5cbmNsYXNzIEZyYW1lQnVmZmVyIHtcbiAgY29uc3RydWN0b3IgKG1XaWR0aCwgbUhlaWdodCwgbVBhcmFtZXRlcnMgPSB7fSwgbU51bVRhcmdldHMgPSAxKSB7XG4gICAgZ2wgPSBHTC5nbFxuICAgIHdlYmdsRGVwdGhUZXh0dXJlID0gR0wuY2hlY2tFeHRlbnNpb24oJ1dFQkdMX2RlcHRoX3RleHR1cmUnKSB8fCBHTC53ZWJnbDJcblxuICAgIHRoaXMud2lkdGggPSBtV2lkdGhcbiAgICB0aGlzLmhlaWdodCA9IG1IZWlnaHRcbiAgICB0aGlzLl9udW1UYXJnZXRzID0gbU51bVRhcmdldHNcbiAgICB0aGlzLl9tdWx0aXBsZVRhcmdldHMgPSBtTnVtVGFyZ2V0cyA+IDFcbiAgICB0aGlzLl9wYXJhbWV0ZXJzID0gbVBhcmFtZXRlcnNcblxuICAgIGlmICghaGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCkge1xuICAgICAgY2hlY2tNdWx0aVJlbmRlcigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX211bHRpcGxlVGFyZ2V0cykge1xuICAgICAgdGhpcy5fY2hlY2tNYXhOdW1SZW5kZXJUYXJnZXQoKVxuICAgIH1cblxuICAgIHRoaXMuX2luaXQoKVxuICB9XG5cbiAgX2luaXQgKCkge1xuICAgIHRoaXMuX2luaXRUZXh0dXJlcygpXG5cbiAgICB0aGlzLmZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKVxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlcilcblxuICAgIGlmIChHTC53ZWJnbDIpIHtcbiAgICAgIC8vIHRoaXMucmVuZGVyQnVmZmVyRGVwdGggPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgIC8vIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlckRlcHRoKTtcbiAgICAgIC8vIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgLy8gZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9udW1UYXJnZXRzOyBpKyspIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRFJBV19GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlc1tpXS50ZXh0dXJlLCAwKVxuICAgICAgICBidWZmZXJzLnB1c2goZ2xbYENPTE9SX0FUVEFDSE1FTlQke2l9YF0pXG4gICAgICB9XG5cbiAgICAgIGdsLmRyYXdCdWZmZXJzKGJ1ZmZlcnMpXG5cbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkRSQVdfRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xEZXB0aFRleHR1cmUudGV4dHVyZSwgMClcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9udW1UYXJnZXRzOyBpKyspIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZXNbaV0udGV4dHVyZSwgMClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX211bHRpcGxlVGFyZ2V0cykge1xuICAgICAgICBjb25zdCBkcmF3QnVmZmVycyA9IFtdXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbnVtVGFyZ2V0czsgaSsrKSB7XG4gICAgICAgICAgZHJhd0J1ZmZlcnMucHVzaChleHREcmF3QnVmZmVyW2BDT0xPUl9BVFRBQ0hNRU5UJHtpfV9XRUJHTGBdKVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0RHJhd0J1ZmZlci5kcmF3QnVmZmVyc1dFQkdMKGRyYXdCdWZmZXJzKVxuICAgICAgfVxuXG4gICAgICBpZiAod2ViZ2xEZXB0aFRleHR1cmUpIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xEZXB0aFRleHR1cmUudGV4dHVyZSwgMClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1x0Q0hFQ0tJTkcgRkJPXG4gICAgY29uc3QgRkJPc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUilcbiAgICBpZiAoRkJPc3RhdHVzICE9IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGQk9zdGF0dXMnLCBGQk9zdGF0dXMpXG4gICAgICBjb25zb2xlLmVycm9yKCdHTF9GUkFNRUJVRkZFUl9DT01QTEVURSBmYWlsZWQsIENBTk5PVCB1c2UgRnJhbWVidWZmZXInKVxuICAgIH1cblxuICAgIC8vXHRVTkJJTkRcblxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpXG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKVxuXG4gICAgLy9cdENMRUFSIEZSQU1FQlVGRkVSXG5cbiAgICB0aGlzLmNsZWFyKClcbiAgfVxuXG4gIF9jaGVja01heE51bVJlbmRlclRhcmdldCAoKSB7XG4gICAgY29uc3QgbWF4TnVtRHJhd0J1ZmZlcnMgPSBHTC5nbC5nZXRQYXJhbWV0ZXIoZXh0RHJhd0J1ZmZlci5NQVhfRFJBV19CVUZGRVJTX1dFQkdMKVxuICAgIGlmICh0aGlzLl9udW1UYXJnZXRzID4gbWF4TnVtRHJhd0J1ZmZlcnMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ092ZXIgbWF4IG51bWJlciBvZiBkcmF3IGJ1ZmZlcnMgc3VwcG9ydGVkIDogJywgbWF4TnVtRHJhd0J1ZmZlcnMpXG4gICAgICB0aGlzLl9udW1UYXJnZXRzID0gbWF4TnVtRHJhd0J1ZmZlcnNcbiAgICB9XG4gIH1cblxuICBfaW5pdFRleHR1cmVzICgpIHtcbiAgICB0aGlzLl90ZXh0dXJlcyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9udW1UYXJnZXRzOyBpKyspIHtcbiAgICAgIGNvbnN0IGdsdCA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoKVxuICAgICAgdGhpcy5fdGV4dHVyZXMucHVzaChnbHQpXG4gICAgfVxuXG4gICAgaWYgKEdMLndlYmdsMikge1xuICAgICAgdGhpcy5nbERlcHRoVGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZ2wuREVQVEhfQ09NUE9ORU5UMTYsIGdsLlVOU0lHTkVEX1NIT1JULCBnbC5ERVBUSF9DT01QT05FTlQsIHsgbWluRmlsdGVyOiBHTC5ORUFSRVNULCBtYWdGaWx0ZXI6IEdMLk5FQVJFU1QsIG1pcG1hcDogZmFsc2UgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nbERlcHRoVGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZ2wuREVQVEhfQ09NUE9ORU5ULCBnbC5VTlNJR05FRF9TSE9SVCwgZ2wuREVQVEhfQ09NUE9ORU5ULCB7IG1pbkZpbHRlcjogR0wuTElORUFSIH0pXG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZVRleHR1cmUgKG1JbnRlcm5hbGZvcm1hdCwgbVRleGVsVHlwZSwgbUZvcm1hdCwgbVBhcmFtZXRlcnMgPSB7fSkge1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9wYXJhbWV0ZXJzKVxuICAgIGlmICghbUZvcm1hdCkgeyBtRm9ybWF0ID0gbUludGVybmFsZm9ybWF0IH1cblxuICAgIHBhcmFtZXRlcnMuaW50ZXJuYWxGb3JtYXQgPSBtSW50ZXJuYWxmb3JtYXQgfHwgZ2wuUkdCQVxuICAgIHBhcmFtZXRlcnMuZm9ybWF0ID0gbUZvcm1hdFxuXG4gICAgcGFyYW1ldGVycy50eXBlID0gcGFyYW1ldGVycy50eXBlIHx8IG1UZXhlbFR5cGUgfHwgR0wuVU5TSUdORURfQllURVxuICAgIGlmIChtVGV4ZWxUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVCkgeyAvLyBmaXggZm9yIGRlcHRoIHRleHR1cmVzXG4gICAgICBwYXJhbWV0ZXJzLnR5cGUgPSBtVGV4ZWxUeXBlXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBzIGluIG1QYXJhbWV0ZXJzKSB7XG4gICAgICBwYXJhbWV0ZXJzW3NdID0gbVBhcmFtZXRlcnNbc11cbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IEdMVGV4dHVyZTIobnVsbCwgcGFyYW1ldGVycywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgcmV0dXJuIHRleHR1cmVcbiAgfVxuXG4gIC8vXHRQVUJMSUMgTUVUSE9EU1xuXG4gIGJpbmQgKG1BdXRvU2V0Vmlld3BvcnQgPSB0cnVlKSB7XG4gICAgaWYgKG1BdXRvU2V0Vmlld3BvcnQpIHtcbiAgICAgIEdMLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgIH1cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpXG4gIH1cblxuICB1bmJpbmQgKG1BdXRvU2V0Vmlld3BvcnQgPSB0cnVlKSB7XG4gICAgaWYgKG1BdXRvU2V0Vmlld3BvcnQpIHtcbiAgICAgIEdMLnZpZXdwb3J0KDAsIDAsIEdMLndpZHRoLCBHTC5oZWlnaHQpXG4gICAgfVxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbClcblxuICAgIHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG4gICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwKClcbiAgICB9KVxuICB9XG5cbiAgY2xlYXIgKHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwKSB7XG4gICAgdGhpcy5iaW5kKClcbiAgICBHTC5jbGVhcihyLCBnLCBiLCBhKVxuICAgIHRoaXMudW5iaW5kKClcbiAgfVxuXG4gIC8vXHRURVhUVVJFU1xuXG4gIGdldFRleHR1cmUgKG1JbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZXNbbUluZGV4XVxuICB9XG5cbiAgZ2V0RGVwdGhUZXh0dXJlICgpIHtcbiAgICByZXR1cm4gdGhpcy5nbERlcHRoVGV4dHVyZVxuICB9XG5cbiAgZ2V0IHRleHR1cmUgKCkge1x0cmV0dXJuIHRoaXMuX3RleHR1cmVzWzBdXHR9XG5cbiAgZ2V0IGRlcHRoVGV4dHVyZSAoKSB7IHJldHVybiB0aGlzLmdsRGVwdGhUZXh0dXJlXHR9XG5cbiAgLy9cdFRPVUdIVFMgOiBTaG91bGQgSSByZW1vdmUgdGhlc2UgZnJvbSBmcmFtZSBidWZmZXIgP1xuICAvL1x0U2hvdWxkbid0IHRoZXNlIGJlIHNldCBpbmRpdmlkdWFsbHkgdG8gZWFjaCB0ZXh0dXJlID9cbiAgLy9cdGUuZy4gZmJvLmdldFRleHR1cmUoMCkubWluRmlsdGVyID0gR0wuTkVBUkVTVDtcbiAgLy9cdFx0IGZiby5nZXRUZXh0dXJlKDEpLm1pbkZpbHRlciA9IEdMLkxJTkVBUjsgLi4uIGV0YyA/XG5cbiAgLy9cdE1JUE1BUCBGSUxURVJcblxuICBnZXQgbWluRmlsdGVyICgpIHtcdHJldHVybiB0aGlzLl90ZXh0dXJlc1swXS5taW5GaWx0ZXJcdH1cblxuICBzZXQgbWluRmlsdGVyIChtVmFsdWUpIHtcbiAgICB0aGlzLl90ZXh0dXJlcy5mb3JFYWNoKHRleHR1cmUgPT4ge1xuICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBtVmFsdWVcbiAgICB9KVxuICB9XG5cbiAgZ2V0IG1hZ0ZpbHRlciAoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ubWFnRmlsdGVyXHR9XG5cbiAgc2V0IG1hZ0ZpbHRlciAobVZhbHVlKSB7XG4gICAgdGhpcy5fdGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gbVZhbHVlXG4gICAgfSlcbiAgfVxuXG4gIC8vXHRXUkFQUElOR1xuXG4gIGdldCB3cmFwUyAoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ud3JhcFNcdH1cblxuICBzZXQgd3JhcFMgKG1WYWx1ZSkge1xuICAgIHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG4gICAgICB0ZXh0dXJlLndyYXBTID0gbVZhbHVlXG4gICAgfSlcbiAgfVxuXG4gIGdldCB3cmFwVCAoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ud3JhcFRcdH1cblxuICBzZXQgd3JhcFQgKG1WYWx1ZSkge1xuICAgIHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG4gICAgICB0ZXh0dXJlLndyYXBUID0gbVZhbHVlXG4gICAgfSlcbiAgfVxuXG4gIC8vXHRVVElMU1xuXG4gIHNob3dQYXJhbWV0ZXJzICgpIHtcbiAgICB0aGlzLl90ZXh0dXJlc1swXS5zaG93UGFyYW1ldGVycygpXG4gIH1cblxuICBnZXQgbnVtVGFyZ2V0cyAoKSB7XHRyZXR1cm4gdGhpcy5fbnVtVGFyZ2V0c1x0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBGcmFtZUJ1ZmZlclxuIiwiLy8gR0xDdWJlVGV4dHVyZS5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5pbXBvcnQgcGFyc2UgZnJvbSAncGFyc2UtZGRzJztcbmxldCBnbDtcbmNvbnN0IEREU0RfTUlQTUFQQ09VTlQgPSAweDIwMDAwO1xuY29uc3QgT0ZGX01JUE1BUENPVU5UID0gNztcbmNvbnN0IGhlYWRlckxlbmd0aEludCA9IDMxO1xuXG5jbGFzcyBHTEN1YmVUZXh0dXJlIHtcblx0Y29uc3RydWN0b3IobVNvdXJjZSwgbVBhcmFtZXRlcnMgPSB7fSwgaXNDdWJlVGV4dHVyZSA9IGZhbHNlKSB7XG5cdFx0Z2wgPSBHTC5nbDtcblxuXHRcdGlmKGlzQ3ViZVRleHR1cmUpIHtcblx0XHRcdHRoaXMudGV4dHVyZSA9IG1Tb3VyY2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bGV0IGhhc01pcG1hcHMgPSBtU291cmNlLmxlbmd0aCA+IDY7XG5cdFx0aWYobVNvdXJjZVswXS5taXBtYXBDb3VudCkge1xuXHRcdFx0aGFzTWlwbWFwcyA9IG1Tb3VyY2VbMF0ubWlwbWFwQ291bnQgPiAxO1xuXHRcdH1cblxuXHRcdHRoaXMudGV4dHVyZSAgID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdHRoaXMubWFnRmlsdGVyID0gbVBhcmFtZXRlcnMubWFnRmlsdGVyIHx8IGdsLkxJTkVBUjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IG1QYXJhbWV0ZXJzLm1pbkZpbHRlciB8fCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcblx0XHR0aGlzLndyYXBTICAgICA9IG1QYXJhbWV0ZXJzLndyYXBTIHx8IGdsLkNMQU1QX1RPX0VER0U7XG5cdFx0dGhpcy53cmFwVCAgICAgPSBtUGFyYW1ldGVycy53cmFwVCB8fCBnbC5DTEFNUF9UT19FREdFO1xuXG5cdFx0aWYoIWhhc01pcG1hcHMgJiYgdGhpcy5taW5GaWx0ZXIgPT0gZ2wuTElORUFSX01JUE1BUF9MSU5FQVIpIHtcblx0XHRcdHRoaXMubWluRmlsdGVyID0gZ2wuTElORUFSO1xuXHRcdH1cblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSk7XG5cdFx0Y29uc3QgdGFyZ2V0cyA9IFtcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLCBcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLCBcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWiwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aIFxuXHRcdF07XG5cblx0XHRcblx0XHRsZXQgbnVtTGV2ZWxzID0gMTtcblx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdG51bUxldmVscyA9IG1Tb3VyY2UubGVuZ3RoIC8gNjtcblx0XHR0aGlzLm51bUxldmVscyA9IG51bUxldmVscztcblxuXHRcdGlmIChoYXNNaXBtYXBzKSB7XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IDY7IGorKykge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG51bUxldmVsczsgaSsrKSB7XG5cdFx0XHRcdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0XHRpbmRleCA9IGogKiBudW1MZXZlbHMgKyBpO1xuXHRcdFx0XHRcdGlmKG1Tb3VyY2VbaW5kZXhdLnNoYXBlKSB7XG5cdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKHRhcmdldHNbal0sIGksIGdsLlJHQkEsIG1Tb3VyY2VbaW5kZXhdLnNoYXBlWzBdLCBtU291cmNlW2luZGV4XS5zaGFwZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG1Tb3VyY2VbaW5kZXhdLmRhdGEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKHRhcmdldHNbal0sIGksIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG1Tb3VyY2VbaW5kZXhdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLndyYXBTKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLndyYXBUKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5tYWdGaWx0ZXIpO1xuXHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLm1pbkZpbHRlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgNjsgaisrKSB7XG5cdFx0XHRcdGluZGV4ID0gaiAqIG51bUxldmVscztcblx0XHRcdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuXHRcdFx0XHRpZihtU291cmNlW2luZGV4XS5zaGFwZSkge1xuXHRcdFx0XHRcdGdsLnRleEltYWdlMkQodGFyZ2V0c1tqXSwgMCwgZ2wuUkdCQSwgbVNvdXJjZVtpbmRleF0uc2hhcGVbMF0sIG1Tb3VyY2VbaW5kZXhdLnNoYXBlWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbVNvdXJjZVtpbmRleF0uZGF0YSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2pdLCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBtU291cmNlW2luZGV4XSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy53cmFwUyk7XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMud3JhcFQpO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5tYWdGaWx0ZXIpO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5taW5GaWx0ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFX0NVQkVfTUFQKTtcblx0XHR9XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcblx0fVxuXG5cdFxuXG5cdC8vXHRQVUJMSUMgTUVUSE9EXG5cblx0YmluZChpbmRleCA9IDApIHtcblx0XHRpZighR0wuc2hhZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGluZGV4KTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0aGlzLnRleHR1cmUpO1xuXHRcdGdsLnVuaWZvcm0xaShHTC5zaGFkZXIudW5pZm9ybVRleHR1cmVzW2luZGV4XSwgaW5kZXgpO1xuXHRcdHRoaXMuX2JpbmRJbmRleCA9IGluZGV4O1xuXHR9XG5cblx0dW5iaW5kKCkge1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1x0XG5cdH1cbn1cblxuXG5HTEN1YmVUZXh0dXJlLnBhcnNlRERTID0gZnVuY3Rpb24gcGFyc2VERFMobUFycmF5QnVmZmVyKSB7XG5cblx0ZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG5cdFx0aWYgKG1pbiA+IG1heCkge1xuXHRcdFx0cmV0dXJuIGNsYW1wKHZhbHVlLCBtYXgsIG1pbik7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbHVlIDwgbWluKSByZXR1cm4gbWluO1xuXHRcdGVsc2UgaWYgKHZhbHVlID4gbWF4KSByZXR1cm4gbWF4O1xuXHRcdGVsc2UgcmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0Ly9cdENIRUNLSU5HIE1JUCBNQVAgTEVWRUxTXG5cdGNvbnN0IGRkc0luZm9zID0gcGFyc2UobUFycmF5QnVmZmVyKTtcblx0Y29uc3QgeyBmbGFncyB9ID0gZGRzSW5mb3M7XG5cdGNvbnN0IGhlYWRlciA9IG5ldyBJbnQzMkFycmF5KG1BcnJheUJ1ZmZlciwgMCwgaGVhZGVyTGVuZ3RoSW50KTtcblx0bGV0IG1pcG1hcENvdW50ID0gMTtcblx0aWYgKGZsYWdzICYgRERTRF9NSVBNQVBDT1VOVCkge1xuXHRcdG1pcG1hcENvdW50ID0gTWF0aC5tYXgoMSwgaGVhZGVyW09GRl9NSVBNQVBDT1VOVF0pO1xuXHR9XG5cdGNvbnN0IHNvdXJjZXMgPSBkZHNJbmZvcy5pbWFnZXMubWFwKChpbWcpID0+IHtcblx0XHRjb25zdCBmYWNlRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobUFycmF5QnVmZmVyLnNsaWNlKGltZy5vZmZzZXQsIGltZy5vZmZzZXQgKyBpbWcubGVuZ3RoKSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGE6IGZhY2VEYXRhLFxuXHRcdFx0c2hhcGU6IGltZy5zaGFwZSxcblx0XHRcdG1pcG1hcENvdW50LFxuXHRcdH07XG5cdH0pO1xuXG5cdHJldHVybiBuZXcgR0xDdWJlVGV4dHVyZShzb3VyY2VzKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgR0xDdWJlVGV4dHVyZTsiLCIvLyBHTFNoYWRlci5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5pbXBvcnQgZGVmYXVsdEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVycy9iYXNpYy5mcmFnJztcbmltcG9ydCBkZWZhdWx0VmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVycy9iYXNpYy52ZXJ0JztcbmltcG9ydCBnbHNsaWZ5IGZyb20gJ2dsc2xpZnknO1xuXG5jb25zdCBpc1NhbWUgPSAoYXJyYXkxLCBhcnJheTIpID0+IHtcblx0aWYoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZvcihsZXQgaSA9IDA7IGkgPCBhcnJheTEubGVuZ3RoOyBpKyspIHtcblx0XHRpZihhcnJheTFbaV0gIT09IGFycmF5MltpXSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgYWRkTGluZU51bWJlcnMgPSAoc3RyaW5nKSA9PiB7XG5cdGNvbnN0IGxpbmVzID0gc3RyaW5nLnNwbGl0KCdcXG4nKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKyspIHtcblx0XHRsaW5lc1tpXSA9IGAkeyhpICsgMSl9OiAke2xpbmVzW2ldfWA7XG5cdH1cblx0cmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufTtcblxuXG5jb25zdCBjbG9uZUFycmF5ID0gKG1BcnJheSkgPT4ge1xuXHRpZihtQXJyYXkuc2xpY2UpIHtcblx0XHRyZXR1cm4gbUFycmF5LnNsaWNlKDApOyBcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShtQXJyYXkpO1xuXHR9XG59O1xuXG5sZXQgZ2w7XG5cbmNvbnN0IHVuaWZvcm1NYXBwaW5nID0ge1xuXHRmbG9hdDogJ3VuaWZvcm0xZicsXG5cdHZlYzI6ICd1bmlmb3JtMmZ2Jyxcblx0dmVjMzogJ3VuaWZvcm0zZnYnLFxuXHR2ZWM0OiAndW5pZm9ybTRmdicsXG5cdGludDogJ3VuaWZvcm0xaScsXG5cdG1hdDM6ICd1bmlmb3JtTWF0cml4M2Z2Jyxcblx0bWF0NDogJ3VuaWZvcm1NYXRyaXg0ZnYnXG59O1xuXG5jbGFzcyBHTFNoYWRlciB7XG5cdGNvbnN0cnVjdG9yKHN0clZlcnRleFNoYWRlciA9IGRlZmF1bHRWZXJ0ZXhTaGFkZXIsIHN0ckZyYWdtZW50U2hhZGVyID0gZGVmYXVsdEZyYWdtZW50U2hhZGVyLCBtVmFyeWluZ3MpIHtcblxuXHRcdGdsICAgICAgICAgICAgICAgICAgID0gR0wuZ2w7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzICAgICAgPSBbXTtcblx0XHR0aGlzLnVuaWZvcm1UZXh0dXJlcyA9IFtdO1xuXHRcdHRoaXMuX3ZhcnlpbmdzIFx0XHQgPSBtVmFyeWluZ3M7XG5cblx0XHRpZighc3RyVmVydGV4U2hhZGVyKSB7IHN0clZlcnRleFNoYWRlciA9IGRlZmF1bHRWZXJ0ZXhTaGFkZXI7IH1cblx0XHRpZighc3RyRnJhZ21lbnRTaGFkZXIpIHsgc3RyRnJhZ21lbnRTaGFkZXIgPSBkZWZhdWx0VmVydGV4U2hhZGVyOyB9XG5cblx0XHRjb25zdCB2c1NoYWRlciA9IHRoaXMuX2NyZWF0ZVNoYWRlclByb2dyYW0oc3RyVmVydGV4U2hhZGVyLCB0cnVlKTtcblx0XHRjb25zdCBmc1NoYWRlciA9IHRoaXMuX2NyZWF0ZVNoYWRlclByb2dyYW0oc3RyRnJhZ21lbnRTaGFkZXIsIGZhbHNlKTtcblx0XHR0aGlzLl9hdHRhY2hTaGFkZXJQcm9ncmFtKHZzU2hhZGVyLCBmc1NoYWRlcik7XG5cblx0fVxuXG5cblx0YmluZCgpIHtcblxuXHRcdGlmKEdMLnNoYWRlciA9PT0gdGhpcykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRnbC51c2VQcm9ncmFtKHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG5cdFx0R0wudXNlU2hhZGVyKHRoaXMpO1xuXHRcdHRoaXMudW5pZm9ybVRleHR1cmVzID0gW107XG5cblx0fVxuXG5cblx0dW5pZm9ybShtTmFtZSwgbVR5cGUsIG1WYWx1ZSkge1xuXHRcdGlmKHR5cGVvZiBtTmFtZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHRoaXMudW5pZm9ybU9iamVjdChtTmFtZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8qXG5cdFx0aWYoISFtVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBtVmFsdWUgPT09IG51bGwpIHtcblx0XHRcdGNvbnNvbGUud2FybignbVZhbHVlIEVycm9yOicsIG1OYW1lKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdCovXG5cdFx0Y29uc3QgdW5pZm9ybVR5cGUgPSB1bmlmb3JtTWFwcGluZ1ttVHlwZV0gfHwgbVR5cGU7XG5cdFx0XG5cdFx0bGV0IGhhc1VuaWZvcm0gPSBmYWxzZTtcblx0XHRsZXQgb1VuaWZvcm07XG5cdFx0bGV0IHBhcmFtZXRlckluZGV4ID0gLTE7XG5cblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG9Vbmlmb3JtID0gdGhpcy5wYXJhbWV0ZXJzW2ldO1xuXHRcdFx0aWYob1VuaWZvcm0ubmFtZSA9PT0gbU5hbWUpIHtcblx0XHRcdFx0aGFzVW5pZm9ybSA9IHRydWU7XG5cdFx0XHRcdHBhcmFtZXRlckluZGV4ID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IGlzTnVtYmVyID0gZmFsc2U7XG5cblx0XHRpZighaGFzVW5pZm9ybSkge1xuXHRcdFx0aXNOdW1iZXIgPSB1bmlmb3JtVHlwZSA9PT0gJ3VuaWZvcm0xaScgfHwgdW5pZm9ybVR5cGUgPT09ICd1bmlmb3JtMWYnO1xuXHRcdFx0dGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnNoYWRlclByb2dyYW0sIG1OYW1lKTtcblx0XHRcdGlmKGlzTnVtYmVyKSB7XG5cdFx0XHRcdHRoaXMucGFyYW1ldGVycy5wdXNoKHsgbmFtZSA6IG1OYW1lLCB0eXBlOiB1bmlmb3JtVHlwZSwgdmFsdWU6IG1WYWx1ZSwgdW5pZm9ybUxvYzogdGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSwgaXNOdW1iZXIgfSk7XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucGFyYW1ldGVycy5wdXNoKHsgbmFtZSA6IG1OYW1lLCB0eXBlOiB1bmlmb3JtVHlwZSwgdmFsdWU6IGNsb25lQXJyYXkobVZhbHVlKSwgdW5pZm9ybUxvYzogdGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSwgaXNOdW1iZXIgfSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHBhcmFtZXRlckluZGV4ID0gdGhpcy5wYXJhbWV0ZXJzLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0gPSBvVW5pZm9ybS51bmlmb3JtTG9jO1xuXHRcdFx0aXNOdW1iZXIgPSBvVW5pZm9ybS5pc051bWJlcjtcblx0XHR9XG5cblxuXHRcdGlmKCF0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnVuaWZvcm1Mb2MpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblxuXHRcdGlmKHVuaWZvcm1UeXBlLmluZGV4T2YoJ01hdHJpeCcpID09PSAtMSkge1xuXHRcdFx0aWYoIWlzTnVtYmVyKSB7XG5cdFx0XHRcdGlmKCFpc1NhbWUodGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XS52YWx1ZSwgbVZhbHVlKSB8fCAhaGFzVW5pZm9ybSkge1xuXHRcdFx0XHRcdGdsW3VuaWZvcm1UeXBlXSh0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdLCBtVmFsdWUpO1x0XG5cdFx0XHRcdFx0dGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XS52YWx1ZSA9IGNsb25lQXJyYXkobVZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbmVlZFVwZGF0ZSA9ICh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlICE9PSBtVmFsdWUgfHwgIWhhc1VuaWZvcm0pO1xuXHRcdFx0XHRpZihuZWVkVXBkYXRlKSB7XG5cdFx0XHRcdFx0Z2xbdW5pZm9ybVR5cGVdKHRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0sIG1WYWx1ZSk7XHRcblx0XHRcdFx0XHR0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlID0gbVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoIWlzU2FtZSh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlLCBtVmFsdWUpIHx8ICFoYXNVbmlmb3JtKSB7XG5cdFx0XHRcdGdsW3VuaWZvcm1UeXBlXSh0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdLCBmYWxzZSwgbVZhbHVlKTtcdFxuXHRcdFx0XHR0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlID0gY2xvbmVBcnJheShtVmFsdWUpO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHR1bmlmb3JtT2JqZWN0KG1Vbmlmb3JtT2JqKSB7XG5cdFx0Zm9yKGNvbnN0IHVuaWZvcm1OYW1lIGluIG1Vbmlmb3JtT2JqKSB7XG5cdFx0XHRsZXQgdW5pZm9ybVZhbHVlID0gbVVuaWZvcm1PYmpbdW5pZm9ybU5hbWVdO1xuXHRcdFx0Y29uc3QgdW5pZm9ybVR5cGUgPSBHTFNoYWRlci5nZXRVbmlmb3JtVHlwZSh1bmlmb3JtVmFsdWUpO1xuXG5cdFx0XHRpZih1bmlmb3JtVmFsdWUuY29uY2F0ICYmIHVuaWZvcm1WYWx1ZVswXS5jb25jYXQpIHtcblx0XHRcdFx0bGV0IHRtcCA9IFtdO1xuXHRcdFx0XHRmb3IobGV0IGk9MDsgaTx1bmlmb3JtVmFsdWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAuY29uY2F0KHVuaWZvcm1WYWx1ZVtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dW5pZm9ybVZhbHVlID0gdG1wO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLnVuaWZvcm0odW5pZm9ybU5hbWUsIHVuaWZvcm1UeXBlLCB1bmlmb3JtVmFsdWUpO1xuXHRcdH1cblxuXHR9XG5cblxuXHRfY3JlYXRlU2hhZGVyUHJvZ3JhbShtU2hhZGVyU3RyLCBpc1ZlcnRleFNoYWRlcikge1xuXHRcdFxuXHRcdGNvbnN0IHNoYWRlclR5cGUgPSBpc1ZlcnRleFNoYWRlciA/IEdMLlZFUlRFWF9TSEFERVIgOiBHTC5GUkFHTUVOVF9TSEFERVI7XG5cdFx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuXG5cdFx0Z2wuc2hhZGVyU291cmNlKHNoYWRlciwgbVNoYWRlclN0cik7XG5cdFx0Z2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG5cdFx0aWYoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdFcnJvciBpbiBTaGFkZXIgOiAnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuXHRcdFx0Y29uc29sZS5sb2coYWRkTGluZU51bWJlcnMobVNoYWRlclN0cikpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNoYWRlcjtcblx0fVxuXG5cdF9hdHRhY2hTaGFkZXJQcm9ncmFtKG1WZXJ0ZXhTaGFkZXIsIG1GcmFnbWVudFNoYWRlcikge1xuXG5cdFx0dGhpcy5zaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXHRcdGdsLmF0dGFjaFNoYWRlcih0aGlzLnNoYWRlclByb2dyYW0sIG1WZXJ0ZXhTaGFkZXIpO1xuXHRcdGdsLmF0dGFjaFNoYWRlcih0aGlzLnNoYWRlclByb2dyYW0sIG1GcmFnbWVudFNoYWRlcik7XG5cblx0XHRnbC5kZWxldGVTaGFkZXIobVZlcnRleFNoYWRlcik7XG5cdFx0Z2wuZGVsZXRlU2hhZGVyKG1GcmFnbWVudFNoYWRlcik7XG5cblx0XHRpZih0aGlzLl92YXJ5aW5ncykge1xuXHRcdFx0Y29uc29sZS5sb2coJ1RyYW5zZm9ybSBmZWVkYmFjayBzZXR1cCA6ICcsIHRoaXMuX3ZhcnlpbmdzKTtcblx0XHRcdGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3ModGhpcy5zaGFkZXJQcm9ncmFtLCB0aGlzLl92YXJ5aW5ncywgZ2wuU0VQQVJBVEVfQVRUUklCUyk7XG5cdFx0fVxuXG5cdFx0Z2wubGlua1Byb2dyYW0odGhpcy5zaGFkZXJQcm9ncmFtKTtcblxuXHR9XG5cbn1cblxuR0xTaGFkZXIuZ2V0VW5pZm9ybVR5cGUgPSBmdW5jdGlvbiAobVZhbHVlKSB7XG5cdGNvbnN0IGlzQXJyYXkgPSAhIW1WYWx1ZS5jb25jYXQ7XG5cblx0Y29uc3QgZ2V0QXJyYXlVbmlmb3JtVHlwZSA9IGZ1bmN0aW9uIChtVmFsdWUpIHtcblx0XHRpZihtVmFsdWUubGVuZ3RoID09PSA5KSB7XG5cdFx0XHRyZXR1cm4gJ3VuaWZvcm1NYXRyaXgzZnYnO1xuXHRcdH0gZWxzZSBpZihtVmFsdWUubGVuZ3RoID09PSAxNikge1xuXHRcdFx0cmV0dXJuICd1bmlmb3JtTWF0cml4NGZ2Jztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGB2ZWMke21WYWx1ZS5sZW5ndGh9YDtcdFxuXHRcdH1cblx0fTtcblxuXHRpZighaXNBcnJheSkge1xuXHRcdHJldHVybiAnZmxvYXQnO1xuXHR9IGVsc2Uge1xuXHRcdGlmICghbVZhbHVlWzBdLmNvbmNhdCkge1xuXHRcdFx0cmV0dXJuIGdldEFycmF5VW5pZm9ybVR5cGUobVZhbHVlKTtcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZ2V0QXJyYXlVbmlmb3JtVHlwZShtVmFsdWVbMF0pO1xuXHRcdH1cblx0fVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBHTFNoYWRlcjsiLCIvLyBHTFRleHR1cmUuanNcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcbmltcG9ydCBXZWJnbE51bWJlciBmcm9tICcuL3V0aWxzL1dlYmdsTnVtYmVyJztcblxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKHgpIHtcdFxuXHRyZXR1cm4gKHggIT09IDApICYmICghKHggJiAoeCAtIDEpKSk7XG59O1xuXG5mdW5jdGlvbiBpc1NvdXJjZVBvd2VyT2ZUd28ob2JqKSB7XHRcblx0Y29uc3QgdyA9IG9iai53aWR0aCB8fCBvYmoudmlkZW9XaWR0aDtcblx0Y29uc3QgaCA9IG9iai5oZWlnaHQgfHwgb2JqLnZpZGVvSGVpZ2h0O1xuXG5cdGlmKCF3IHx8ICFoKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBpc1Bvd2VyT2ZUd28odykgJiYgaXNQb3dlck9mVHdvKGgpO1xufTtcblxubGV0IGdsO1xuXG5jbGFzcyBHTFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKG1Tb3VyY2UsIGlzVGV4dHVyZSA9IGZhbHNlLCBtUGFyYW1ldGVycyA9IHt9KSB7XG5cdFx0Z2wgPSBHTC5nbDtcblxuXHRcdGlmKGlzVGV4dHVyZSkge1xuXHRcdFx0dGhpcy5fdGV4dHVyZSA9IG1Tb3VyY2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21Tb3VyY2UgID0gbVNvdXJjZTtcblx0XHRcdHRoaXMuX3RleHR1cmUgID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0dGhpcy5faXNWaWRlbyAgPSAobVNvdXJjZS50YWdOYW1lID09PSAnVklERU8nKTtcblx0XHRcdHRoaXMuX3ByZW11bHRpcGx5QWxwaGEgPSB0cnVlO1xuXHRcdFx0dGhpcy5fbWFnRmlsdGVyID0gbVBhcmFtZXRlcnMubWFnRmlsdGVyIHx8IGdsLkxJTkVBUjtcblx0XHRcdHRoaXMuX21pbkZpbHRlciA9IG1QYXJhbWV0ZXJzLm1pbkZpbHRlciB8fCBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG5cdFx0XHRcblx0XHRcdHRoaXMuX3dyYXBTICAgICA9IG1QYXJhbWV0ZXJzLndyYXBTIHx8IGdsLk1JUlJPUkVEX1JFUEVBVDtcblx0XHRcdHRoaXMuX3dyYXBUICAgICA9IG1QYXJhbWV0ZXJzLndyYXBUIHx8IGdsLk1JUlJPUkVEX1JFUEVBVDtcblx0XHRcdGNvbnN0IHdpZHRoICAgID0gbVNvdXJjZS53aWR0aCB8fCBtU291cmNlLnZpZGVvV2lkdGg7XG5cblx0XHRcdGlmKHdpZHRoKSB7XG5cdFx0XHRcdGlmKCFpc1NvdXJjZVBvd2VyT2ZUd28obVNvdXJjZSkpIHtcblx0XHRcdFx0XHR0aGlzLl93cmFwUyA9IHRoaXMuX3dyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHRcdFx0XHRpZih0aGlzLl9taW5GaWx0ZXIgPT09IGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUikge1xuXHRcdFx0XHRcdFx0dGhpcy5fbWluRmlsdGVyID0gZ2wuTElORUFSO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBcdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fd3JhcFMgPSB0aGlzLl93cmFwVCA9IGdsLkNMQU1QX1RPX0VER0U7XG5cdFx0XHRcdGlmKHRoaXMuX21pbkZpbHRlciA9PT0gZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWluRmlsdGVyID0gZ2wuTElORUFSO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG5cblx0XHRcdGlmKG1Tb3VyY2UuZXhwb3N1cmUpIHtcblx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBtU291cmNlLnNoYXBlWzBdLCBtU291cmNlLnNoYXBlWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbVNvdXJjZS5kYXRhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbVNvdXJjZSk7XHRcblx0XHRcdFx0Ly8gZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9tYWdGaWx0ZXIpO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuX21pbkZpbHRlcik7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl93cmFwUyk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl93cmFwVCk7XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKCdUZXh0dXJlIE1pbiA6JywgV2ViZ2xOdW1iZXJbdGhpcy5fbWluRmlsdGVyXSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnVGV4dHVyZSBNYWcgOicsIFdlYmdsTnVtYmVyW3RoaXMuX21hZ0ZpbHRlcl0pO1xuXG5cdFx0XHRjb25zdCBleHQgPSBHTC5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpO1xuXHRcdFx0aWYoZXh0KSB7XG5cdFx0XHRcdGNvbnN0IG1heCA9IGdsLmdldFBhcmFtZXRlcihleHQuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyZihnbC5URVhUVVJFXzJELCBleHQuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIG1heCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmKHRoaXMuX2NhbkdlbmVyYXRlTWlwbWFwKCkpIHtcblx0XHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG5cdFx0XHR9XG5cblx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHRcdH1cblx0fVxuXG5cdGdlbmVyYXRlTWlwbWFwKCkge1xuXHRcdGlmICghdGhpcy5fY2FuR2VuZXJhdGVNaXBtYXAoKSkgeyByZXR1cm47IH1cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cblx0Ly9cdE1JUE1BUCBGSUxURVJcblxuXHRzZXQgbWluRmlsdGVyKG1WYWx1ZSkge1xuXHRcdGlmKG1WYWx1ZSAhPT0gZ2wuTElORUFSXG5cdFx0XHQmJiBtVmFsdWUgIT09IGdsLk5FQVJFU1QgXG5cdFx0XHQmJiBtVmFsdWUgIT09IGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUlxuXHRcdFx0JiYgbVZhbHVlICE9PSBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVJcblx0XHRcdCYmIG1WYWx1ZSAhPT0gZ2wuTElORUFSX01JUE1BUF9MSU5FQVJcblx0XHRcdCYmIG1WYWx1ZSAhPT0gZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVFxuXHRcdCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX21pbkZpbHRlciA9IG1WYWx1ZTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5fbWluRmlsdGVyKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cdGdldCBtaW5GaWx0ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkZpbHRlcjtcblx0fVxuXG5cdHNldCBtYWdGaWx0ZXIobVZhbHVlKSB7XG5cdFx0aWYobVZhbHVlICE9PSBnbC5MSU5FQVIgJiYgbVZhbHVlICE9PSBnbC5ORUFSRVNUKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbWFnRmlsdGVyID0gbVZhbHVlO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9tYWdGaWx0ZXIpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblx0Z2V0IG1hZ0ZpbHRlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFnRmlsdGVyO1xuXHR9XG5cblxuXHQvL1x0V1JBUFxuXG5cdHNldCB3cmFwUyhtVmFsdWUpIHtcblx0XHRpZihtVmFsdWUgIT09IGdsLkNMQU1QX1RPX0VER0UgJiYgbVZhbHVlICE9PSBnbC5SRVBFQVQgJiYgbVZhbHVlICE9PSBnbC5NSVJST1JFRF9SRVBFQVQpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl93cmFwUyA9IG1WYWx1ZTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl93cmFwUyk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXHRnZXQgd3JhcFMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3dyYXBTO1xuXHR9XG5cblx0c2V0IHdyYXBUKG1WYWx1ZSkge1xuXHRcdGlmKG1WYWx1ZSAhPT0gZ2wuQ0xBTVBfVE9fRURHRSAmJiBtVmFsdWUgIT09IGdsLlJFUEVBVCAmJiBtVmFsdWUgIT09IGdsLk1JUlJPUkVEX1JFUEVBVCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX3dyYXBUID0gbVZhbHVlO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX3dyYXBUKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cdGdldCB3cmFwVCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fd3JhcFQ7XG5cdH1cblxuXG5cdC8vXHRQUkVNVUxUSVBMWSBBTFBIQVxuXG5cdHNldCBwcmVtdWx0aXBseUFscGhhKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3ByZW11bHRpcGx5QWxwaGEgPSBtVmFsdWU7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Y29uc29sZS5sb2coJ3ByZW11bHRpcGx5QWxwaGE6JywgbVZhbHVlKTtcblx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRoaXMuX3ByZW11bHRpcGx5QWxwaGEpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXG5cdH1cblxuXHRnZXQgcHJlbXVsdGlwbHlBbHBoYSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJlbXVsdGlwbHlBbHBoYTtcblx0fVxuXG5cdC8vXHRVUERBVEUgVEVYVFVSRVxuXG5cdHVwZGF0ZVRleHR1cmUobVNvdXJjZSkge1xuXHRcdGlmKG1Tb3VyY2UpIHsgdGhpcy5fbVNvdXJjZSA9IG1Tb3VyY2U7IH1cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcblx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuX21Tb3VyY2UpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9tYWdGaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9taW5GaWx0ZXIpO1xuXHRcdGlmKHRoaXMuX2NhbkdlbmVyYXRlTWlwbWFwKCkpIHtcblx0XHRcdGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuXHRcdH1cblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblxuXHRiaW5kKGluZGV4KSB7XG5cdFx0aWYoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IDA7IH1cblx0XHRpZighR0wuc2hhZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGluZGV4KTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHR0aGlzLl9iaW5kSW5kZXggPSBpbmRleDtcblx0fVxuXG5cdF9jYW5HZW5lcmF0ZU1pcG1hcCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluRmlsdGVyID09PSBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QgXG5cdFx0XHRcdHx8IHRoaXMuX21pbkZpbHRlciA9PT0gZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSIFxuXHRcdFx0XHR8fCB0aGlzLl9taW5GaWx0ZXIgPT09IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSIFxuXHRcdFx0XHR8fCB0aGlzLl9taW5GaWx0ZXIgPT09IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XG5cdH1cblxuXHQvL1x0R0VUVEVSXG5cblx0Z2V0IHRleHR1cmUoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZTtcdH1cbn1cblxuXG5sZXQgX3doaXRlVGV4dHVyZSwgX2dyZXlUZXh0dXJlLCBfYmxhY2tUZXh0dXJlO1xuXG5HTFRleHR1cmUud2hpdGVUZXh0dXJlID0gZnVuY3Rpb24gd2hpdGVUZXh0dXJlKCkge1xuXHRpZihfd2hpdGVUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gNDtcblx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjdHguZmlsbFN0eWxlID0gJyNmZmYnO1xuXHRcdGN0eC5maWxsUmVjdCgwLCAwLCA0LCA0KTtcblx0XHRfd2hpdGVUZXh0dXJlID0gbmV3IEdMVGV4dHVyZShjYW52YXMpO1xuXHR9XG5cdFxuXHRyZXR1cm4gX3doaXRlVGV4dHVyZTtcbn07XG5cbkdMVGV4dHVyZS5ncmV5VGV4dHVyZSA9IGZ1bmN0aW9uIGdyZXlUZXh0dXJlKCkge1xuXHRpZihfZ3JleVRleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSA0O1xuXHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSAncmdiKDEyNywgMTI3LCAxMjcpJztcblx0XHRjdHguZmlsbFJlY3QoMCwgMCwgNCwgNCk7XG5cdFx0X2dyZXlUZXh0dXJlID0gbmV3IEdMVGV4dHVyZShjYW52YXMpO1xuXHR9XG5cdHJldHVybiBfZ3JleVRleHR1cmU7XG59O1xuXG5HTFRleHR1cmUuYmxhY2tUZXh0dXJlID0gZnVuY3Rpb24gYmxhY2tUZXh0dXJlKCkge1xuXHRpZihfYmxhY2tUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gNDtcblx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjdHguZmlsbFN0eWxlID0gJ3JnYigxMjcsIDEyNywgMTI3KSc7XG5cdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDQsIDQpO1xuXHRcdF9ibGFja1RleHR1cmUgPSBuZXcgR0xUZXh0dXJlKGNhbnZhcyk7XG5cdH1cblx0cmV0dXJuIF9ibGFja1RleHR1cmU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHTFRleHR1cmU7IiwiLy8gR0xUZXh0dXJlMi5qc1xuXG5pbXBvcnQgZ2V0VGV4dHVyZVBhcmFtZXRlcnMgZnJvbSAnLi91dGlscy9nZXRUZXh0dXJlUGFyYW1ldGVycydcbmltcG9ydCBXZWJnbE51bWJlciBmcm9tICcuL3V0aWxzL1dlYmdsTnVtYmVyJ1xuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJ1xuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJ1xuXG5sZXQgZ2xcblxuY2xhc3MgR0xUZXh0dXJlIHtcbiAgY29uc3RydWN0b3IgKG1Tb3VyY2UsIG1QYXJhbSA9IHt9LCBtV2lkdGggPSAwLCBtSGVpZ2h0ID0gMCkge1xuICAgIGdsID0gR0wuZ2xcblxuICAgIHRoaXMuX3NvdXJjZSA9IG1Tb3VyY2VcbiAgICB0aGlzLl9nZXREaW1lbnNpb24obVNvdXJjZSwgbVdpZHRoLCBtSGVpZ2h0KVxuICAgIHRoaXMuX3NvdXJjZVR5cGUgPSBtUGFyYW0udHlwZSB8fCBnZXRTb3VyY2VUeXBlKG1Tb3VyY2UpXG4gICAgdGhpcy5fY2hlY2tTb3VyY2UoKVxuICAgIHRoaXMuX3RleGVsVHlwZSA9IHRoaXMuX2dldFRleGVsVHlwZSgpXG4gICAgdGhpcy5faXNUZXh0dXJlUmVhZHkgPSB0cnVlXG5cbiAgICB0aGlzLl9wYXJhbXMgPSBnZXRUZXh0dXJlUGFyYW1ldGVycyhtUGFyYW0sIG1Tb3VyY2UsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpXG4gICAgdGhpcy5fY2hlY2tNaXBtYXAoKVxuICAgIHRoaXMuX2NoZWNrV3JhcHBpbmcoKVxuXG4gICAgLy8gc2V0dXAgdGV4dHVyZVxuICAgIHRoaXMuX3RleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcblxuICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSAndmlkZW8nKSB7XG4gICAgICB0aGlzLl9pc1RleHR1cmVSZWFkeSA9IGZhbHNlXG4gICAgICBTY2hlZHVsZXIuYWRkRUYoKCkgPT4gdGhpcy5fbG9vcCgpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGxvYWRUZXh0dXJlKClcbiAgICB9XG4gIH1cblxuICBfbG9vcCAoKSB7XG4gICAgaWYgKHRoaXMuX3NvdXJjZS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICB0aGlzLl9pc1RleHR1cmVSZWFkeSA9IHRydWVcbiAgICAgIHRoaXMuX3VwbG9hZFRleHR1cmUoKVxuICAgIH1cbiAgfVxuXG4gIF91cGxvYWRUZXh0dXJlICgpIHtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKVxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpXG5cbiAgICBpZiAodGhpcy5faXNTb3VyY2VIdG1sRWxlbWVudCgpKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuX3BhcmFtcy5pbnRlcm5hbEZvcm1hdCwgdGhpcy5fcGFyYW1zLmZvcm1hdCwgdGhpcy5fdGV4ZWxUeXBlLCB0aGlzLl9zb3VyY2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5fcGFyYW1zLmludGVybmFsRm9ybWF0LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCAwLCB0aGlzLl9wYXJhbXMuZm9ybWF0LCB0aGlzLl90ZXhlbFR5cGUsIHRoaXMuX3NvdXJjZSlcbiAgICB9XG5cbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fcGFyYW1zLm1hZ0ZpbHRlcilcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5fcGFyYW1zLm1pbkZpbHRlcilcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl9wYXJhbXMud3JhcFMpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fcGFyYW1zLndyYXBUKVxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGhpcy5fcHJlbXVsdGlwbHlBbHBoYSlcblxuICAgIC8vIGNvbnN0IGV4dCA9IEdMLmdldEV4dGVuc2lvbignRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyk7XG4gICAgLy8gaWYoZXh0KSB7XG4gICAgLy8gXHRjb25zdCBtYXggPSBnbC5nZXRQYXJhbWV0ZXIoZXh0Lk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCk7XG4gICAgLy8gXHRsZXQgbGV2ZWw7XG4gICAgLy8gXHRpZighdGhpcy5fcGFyYW1zLmFuaXNvdHJvcHkpIHtcbiAgICAvLyBcdFx0bGV2ZWwgPSBtYXg7XG4gICAgLy8gXHR9XG4gICAgLy8gXHRnbC50ZXhQYXJhbWV0ZXJmKGdsLlRFWFRVUkVfMkQsIGV4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgbGV2ZWwpO1xuICAgIC8vIH1cblxuICAgIGlmICh0aGlzLl9nZW5lcmF0ZU1pcG1hcCkge1x0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRClcdH1cblxuICAgIC8vXHR1bmJpbmQgdGV4dHVyZVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpXG4gIH1cblxuICBiaW5kIChpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7IGluZGV4ID0gMCB9XG4gICAgaWYgKCFHTC5zaGFkZXIpIHsgcmV0dXJuIH1cblxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpbmRleClcbiAgICBpZiAodGhpcy5faXNUZXh0dXJlUmVhZHkpIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIEdMVGV4dHVyZS5ibGFja1RleHR1cmUoKS50ZXh0dXJlKVxuICAgIH1cblxuICAgIHRoaXMuX2JpbmRJbmRleCA9IGluZGV4XG4gIH1cblxuICB1cGRhdGVUZXh0dXJlIChtU291cmNlKSB7XG4gICAgdGhpcy5fc291cmNlID0gbVNvdXJjZVxuICAgIHRoaXMuX2NoZWNrU291cmNlKClcbiAgICB0aGlzLl91cGxvYWRUZXh0dXJlKClcbiAgfVxuXG4gIGdlbmVyYXRlTWlwbWFwICgpIHtcbiAgICBpZiAoIXRoaXMuX2dlbmVyYXRlTWlwbWFwKSB7IHJldHVybiB9XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSlcbiAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpXG4gIH1cblxuICBzaG93UGFyYW1ldGVycyAoKSB7XG4gICAgY29uc29sZS5sb2coJ1NvdXJjZSB0eXBlIDogJywgV2ViZ2xOdW1iZXJbdGhpcy5fc291cmNlVHlwZV0gfHwgdGhpcy5fc291cmNlVHlwZSlcbiAgICBjb25zb2xlLmxvZygnVGV4ZWwgdHlwZTonLCBXZWJnbE51bWJlclt0aGlzLnRleGVsVHlwZV0pXG4gICAgY29uc29sZS5sb2coJ0RpbWVuc2lvbiA6JywgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodClcbiAgICBmb3IgKGNvbnN0IHMgaW4gdGhpcy5fcGFyYW1zKSB7XG4gICAgICBjb25zb2xlLmxvZyhzLCBXZWJnbE51bWJlclt0aGlzLl9wYXJhbXNbc11dIHx8IHRoaXMuX3BhcmFtc1tzXSlcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnTWlwbWFwcGluZyA6JywgdGhpcy5fZ2VuZXJhdGVNaXBtYXApXG4gIH1cblxuICBfZ2V0RGltZW5zaW9uIChtU291cmNlLCBtV2lkdGgsIG1IZWlnaHQpIHtcbiAgICBpZiAobVNvdXJjZSkge1xuICAgICAgLy8gZm9yIGh0bWwgaW1hZ2UgLyB2aWRlbyBlbGVtZW50XG4gICAgICB0aGlzLl93aWR0aCA9IG1Tb3VyY2Uud2lkdGggfHwgbVNvdXJjZS52aWRlb1dpZHRoXG4gICAgICB0aGlzLl9oZWlnaHQgPSBtU291cmNlLmhlaWdodCB8fCBtU291cmNlLnZpZGVvV2lkdGhcblxuICAgICAgLy8gZm9yIG1hbnVhbCB3aWR0aCAvIGhlaWdodCBzZXR0aW5nc1xuICAgICAgdGhpcy5fd2lkdGggPSB0aGlzLl93aWR0aCB8fCBtV2lkdGhcbiAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2hlaWdodCB8fCBtSGVpZ2h0XG5cbiAgICAgIC8vIGF1dG8gZGV0ZWN0ICggZGF0YSBhcnJheSkgPyBub3Qgc3VyZSBpcyBnb29kIGlkZWEgP1xuICAgICAgLy8gdG9kbyA6IGNoZWNrIEhEUlxuICAgICAgaWYgKCF0aGlzLl93aWR0aCB8fCAhdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5faGVpZ2h0ID0gTWF0aC5zcXJ0KG1Tb3VyY2UubGVuZ3RoIC8gNClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0F1dG8gZGV0ZWN0LCBkYXRhIGRpbWVuc2lvbiA6ICcsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWR0aCA9IG1XaWR0aFxuICAgICAgdGhpcy5faGVpZ2h0ID0gbUhlaWdodFxuICAgIH1cbiAgfVxuXG4gIF9jaGVja1NvdXJjZSAoKSB7XG4gICAgaWYgKCF0aGlzLl9zb3VyY2UpIHsgcmV0dXJuIH1cblxuICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBHTC5VTlNJR05FRF9CWVRFKSB7XG4gICAgICBpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ29udmVydGluZyB0byBVaW50OEFycmF5Jyk7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IG5ldyBVaW50OEFycmF5KHRoaXMuX3NvdXJjZSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IEdMLkZMT0FUKSB7XG4gICAgICBpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDb252ZXJ0aW5nIHRvIEZsb2F0MzJBcnJheScpO1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX3NvdXJjZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZ2V0VGV4ZWxUeXBlICgpIHtcbiAgICBpZiAodGhpcy5faXNTb3VyY2VIdG1sRWxlbWVudCgpKSB7XG4gICAgICByZXR1cm4gR0wuVU5TSUdORURfQllURVxuICAgIH1cblxuICAgIHJldHVybiBHTFtXZWJnbE51bWJlclt0aGlzLl9zb3VyY2VUeXBlXV1cbiAgfVxuXG4gIF9jaGVja01pcG1hcCAoKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVNaXBtYXAgPSB0aGlzLl9wYXJhbXMubWlwbWFwXG5cbiAgICBpZiAoIShpc1Bvd2VyT2ZUd28odGhpcy5fd2lkdGgpICYmIGlzUG93ZXJPZlR3byh0aGlzLl9oZWlnaHQpKSkge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVNaXBtYXAgPSBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IG1pbkZpbHRlciA9IFdlYmdsTnVtYmVyW3RoaXMuX3BhcmFtcy5taW5GaWx0ZXJdXG4gICAgaWYgKG1pbkZpbHRlci5pbmRleE9mKCdNSVBNQVAnKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlTWlwbWFwID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBfY2hlY2tXcmFwcGluZyAoKSB7XG4gICAgaWYgKCF0aGlzLl9nZW5lcmF0ZU1pcG1hcCkge1xuICAgICAgdGhpcy5fcGFyYW1zLndyYXBTID0gR0wuQ0xBTVBfVE9fRURHRVxuICAgICAgdGhpcy5fcGFyYW1zLndyYXBUID0gR0wuQ0xBTVBfVE9fRURHRVxuICAgIH1cbiAgfVxuXG4gIF9pc1NvdXJjZUh0bWxFbGVtZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlVHlwZSA9PT0gJ2ltYWdlJyB8fCB0aGlzLl9zb3VyY2VUeXBlID09PSAndmlkZW8nIHx8IHRoaXMuX3NvdXJjZVR5cGUgPT09ICdjYW52YXMnXG4gIH1cblxuICBnZXQgbWluRmlsdGVyICgpIHsgcmV0dXJuIHRoaXMuX3BhcmFtcy5taW5GaWx0ZXIgfVxuXG4gIHNldCBtaW5GaWx0ZXIgKG1WYWx1ZSkge1xuICAgIHRoaXMuX3BhcmFtcy5taW5GaWx0ZXIgPSBtVmFsdWVcbiAgICB0aGlzLl9jaGVja01pcG1hcCgpXG5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9wYXJhbXMubWluRmlsdGVyKVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpXG5cbiAgICB0aGlzLmdlbmVyYXRlTWlwbWFwKClcbiAgfVxuXG4gIGdldCBtYWdGaWx0ZXIgKCkgeyByZXR1cm4gdGhpcy5fcGFyYW1zLm1pbkZpbHRlciB9XG5cbiAgc2V0IG1hZ0ZpbHRlciAobVZhbHVlKSB7XG4gICAgdGhpcy5fcGFyYW1zLm1hZ0ZpbHRlciA9IG1WYWx1ZVxuXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSlcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fcGFyYW1zLm1hZ0ZpbHRlcilcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKVxuICB9XG5cbiAgZ2V0IHdyYXBTICgpIHsgcmV0dXJuIHRoaXMuX3BhcmFtcy53cmFwUyB9XG5cbiAgc2V0IHdyYXBTIChtVmFsdWUpIHtcbiAgICB0aGlzLl9wYXJhbXMud3JhcFMgPSBtVmFsdWVcbiAgICB0aGlzLl9jaGVja1dyYXBwaW5nKClcblxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fcGFyYW1zLndyYXBTKVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpXG4gIH1cblxuICBnZXQgd3JhcFQgKCkgeyByZXR1cm4gdGhpcy5fcGFyYW1zLndyYXBUIH1cblxuICBzZXQgd3JhcFQgKG1WYWx1ZSkge1xuICAgIHRoaXMuX3BhcmFtcy53cmFwVCA9IG1WYWx1ZVxuICAgIHRoaXMuX2NoZWNrV3JhcHBpbmcoKVxuXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSlcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl9wYXJhbXMud3JhcFQpXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbClcbiAgfVxuXG4gIGdldCB0ZXhlbFR5cGUgKCkgeyByZXR1cm4gdGhpcy5fdGV4ZWxUeXBlIH1cblxuICBnZXQgd2lkdGggKCkgeyByZXR1cm4gdGhpcy5fd2lkdGggfVxuXG4gIGdldCBoZWlnaHQgKCkgeyByZXR1cm4gdGhpcy5faGVpZ2h0IH1cblxuICBnZXQgdGV4dHVyZSAoKSB7IHJldHVybiB0aGlzLl90ZXh0dXJlIH1cblxuICBnZXQgaXNUZXh0dXJlUmVhZHkgKCkge1x0cmV0dXJuIHRoaXMuX2lzVGV4dHVyZVJlYWR5XHR9XG59XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byAoeCkge1xuICByZXR1cm4gKHggIT09IDApICYmICghKHggJiAoeCAtIDEpKSlcbn07XG5cbmZ1bmN0aW9uIGdldFNvdXJjZVR5cGUgKG1Tb3VyY2UpIHtcbiAgLy9cdHBvc3NpYmxlIHNvdXJjZSB0eXBlIDogSW1hZ2UgLyBWaWRlbyAvIFVuaXQ4QXJyYXkgLyBGbG9hdDMyQXJyYXlcbiAgLy9cdHRoaXMgbGlzdCBtdXN0IGJlIGZsZXhpYmxlXG5cbiAgbGV0IHR5cGUgPSBHTC5VTlNJR05FRF9CWVRFXG5cbiAgaWYgKG1Tb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHR5cGUgPSBHTC5VTlNJR05FRF9CWVRFXG4gIH0gZWxzZSBpZiAobVNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICB0eXBlID0gR0wuVU5TSUdORURfQllURVxuICB9IGVsc2UgaWYgKG1Tb3VyY2UgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICB0eXBlID0gR0wuRkxPQVRcbiAgfSBlbHNlIGlmIChtU291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgIHR5cGUgPSAnaW1hZ2UnXG4gIH0gZWxzZSBpZiAobVNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgdHlwZSA9ICdjYW52YXMnXG4gIH0gZWxzZSBpZiAobVNvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICB0eXBlID0gJ3ZpZGVvJ1xuICB9XG4gIHJldHVybiB0eXBlXG59XG5cbmxldCBfd2hpdGVUZXh0dXJlLCBfZ3JleVRleHR1cmUsIF9ibGFja1RleHR1cmVcblxuR0xUZXh0dXJlLndoaXRlVGV4dHVyZSA9IGZ1bmN0aW9uIHdoaXRlVGV4dHVyZSAoKSB7XG4gIGlmIChfd2hpdGVUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjdHguZmlsbFN0eWxlID0gJyNmZmYnXG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIDIsIDIpXG4gICAgX3doaXRlVGV4dHVyZSA9IG5ldyBHTFRleHR1cmUoY2FudmFzKVxuICB9XG5cbiAgcmV0dXJuIF93aGl0ZVRleHR1cmVcbn1cblxuR0xUZXh0dXJlLmdyZXlUZXh0dXJlID0gZnVuY3Rpb24gZ3JleVRleHR1cmUgKCkge1xuICBpZiAoX2dyZXlUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYigxMjcsIDEyNywgMTI3KSdcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgMiwgMilcbiAgICBfZ3JleVRleHR1cmUgPSBuZXcgR0xUZXh0dXJlKGNhbnZhcylcbiAgfVxuICByZXR1cm4gX2dyZXlUZXh0dXJlXG59XG5cbkdMVGV4dHVyZS5ibGFja1RleHR1cmUgPSBmdW5jdGlvbiBibGFja1RleHR1cmUgKCkge1xuICBpZiAoX2JsYWNrVGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMlxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2IoMCwgMCwgMCknXG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIDIsIDIpXG4gICAgX2JsYWNrVGV4dHVyZSA9IG5ldyBHTFRleHR1cmUoY2FudmFzKVxuICB9XG4gIHJldHVybiBfYmxhY2tUZXh0dXJlXG59XG5cbmV4cG9ydCBkZWZhdWx0IEdMVGV4dHVyZVxuIiwiLy8gR0xUb29sLmpzXG5cbmltcG9ydCB7IG1hdDQsIG1hdDMgfSBmcm9tICdnbC1tYXRyaXgnXG5cbmltcG9ydCBnZXRBbmRBcHBseUV4dGVuc2lvbiBmcm9tICcuL3V0aWxzL2dldEFuZEFwcGx5RXh0ZW5zaW9uJ1xuaW1wb3J0IGV4cG9zZUF0dHJpYnV0ZXMgZnJvbSAnLi91dGlscy9leHBvc2VBdHRyaWJ1dGVzJ1xuaW1wb3J0IGdldEZsb2F0IGZyb20gJy4vdXRpbHMvZ2V0RmxvYXQnXG5pbXBvcnQgZ2V0SGFsZkZsb2F0IGZyb20gJy4vdXRpbHMvZ2V0SGFsZkZsb2F0J1xuaW1wb3J0IGdldEF0dHJpYkxvYyBmcm9tICcuL3V0aWxzL2dldEF0dHJpYkxvYydcbmltcG9ydCBFeHRlbnNpb25zTGlzdCBmcm9tICcuL3V0aWxzL0V4dGVuc2lvbnNMaXN0J1xuXG5sZXQgZ2xcblxuY2xhc3MgR0xUb29sIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX3ZpZXdwb3J0ID0gWzAsIDAsIDAsIDBdXG4gICAgdGhpcy5fZW5hYmxlZFZlcnRleEF0dHJpYnV0ZSA9IFtdXG4gICAgdGhpcy5pZGVudGl0eU1hdHJpeCA9IG1hdDQuY3JlYXRlKClcbiAgICB0aGlzLl9ub3JtYWxNYXRyaXggPSBtYXQzLmNyZWF0ZSgpXG4gICAgdGhpcy5faW52ZXJzZU1vZGVsVmlld01hdHJpeCA9IG1hdDMuY3JlYXRlKClcbiAgICB0aGlzLl9tb2RlbE1hdHJpeCA9IG1hdDQuY3JlYXRlKClcbiAgICB0aGlzLl9tYXRyaXggPSBtYXQ0LmNyZWF0ZSgpXG4gICAgdGhpcy5fbWF0cml4U3RhY2tzID0gW11cbiAgICB0aGlzLl9sYXN0TWVzaCA9IG51bGxcbiAgICB0aGlzLl91c2VXZWJHTDIgPSBmYWxzZVxuICAgIHRoaXMuX2hhc0FycmF5SW5zdGFuY2UgPSBmYWxzZVxuICAgIHRoaXMuX2V4dEFycmF5SW5zdGFuY2UgPSBmYWxzZVxuICAgIHRoaXMuX2hhc0NoZWNrZWRFeHQgPSBmYWxzZVxuICAgIG1hdDQuaWRlbnRpdHkodGhpcy5pZGVudGl0eU1hdHJpeCwgdGhpcy5pZGVudGl0eU1hdHJpeClcblxuICAgIHRoaXMuaXNNb2JpbGUgPSBmYWxzZVxuICAgIGlmICgvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIHRoaXMuaXNNb2JpbGUgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gSU5JVElBTElaRVxuXG4gIGluaXQgKG1DYW52YXMsIG1QYXJhbWV0ZXJzID0ge30pIHtcbiAgICBpZiAobUNhbnZhcyA9PT0gbnVsbCB8fCBtQ2FudmFzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbnZhcyBub3QgZXhpc3QnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FudmFzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jYW52YXMgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgdGhpcy5jYW52YXMgPSBtQ2FudmFzXG4gICAgdGhpcy5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpXG5cbiAgICBtUGFyYW1ldGVycy51c2VXZWJnbDIgPSBtUGFyYW1ldGVycy51c2VXZWJnbDIgfHwgZmFsc2VcblxuICAgIGxldCBjdHhcbiAgICBpZiAobVBhcmFtZXRlcnMudXNlV2ViZ2wyKSB7XG4gICAgICBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wyJywgbVBhcmFtZXRlcnMpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIG1QYXJhbWV0ZXJzKVxuXG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG1QYXJhbWV0ZXJzKSB8fCB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBtUGFyYW1ldGVycylcbiAgICAgICAgdGhpcy5fdXNlV2ViR0wyID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VzZVdlYkdMMiA9IHRydWVcbiAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIFdlYkdMIDIgOiAnLCBjdHgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgbVBhcmFtZXRlcnMpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG1QYXJhbWV0ZXJzKVxuICAgICAgdGhpcy5fdXNlV2ViR0wyID0gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBleHRlbnNpb25zXG4gICAgdGhpcy5pbml0V2l0aEdMKGN0eClcbiAgfVxuXG4gIGluaXRXaXRoR0wgKGN0eCkge1xuICAgIGlmICghdGhpcy5jYW52YXMpIHsgdGhpcy5jYW52YXMgPSBjdHguY2FudmFzIH1cbiAgICBnbCA9IHRoaXMuZ2wgPSBjdHhcblxuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBFeHRlbnNpb25zTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5leHRlbnNpb25zW0V4dGVuc2lvbnNMaXN0W2ldXSA9IGdsLmdldEV4dGVuc2lvbihFeHRlbnNpb25zTGlzdFtpXSlcbiAgICB9XG5cbiAgICAvLyBDb3B5IGdsIEF0dHJpYnV0ZXNcbiAgICBleHBvc2VBdHRyaWJ1dGVzKClcbiAgICBnZXRBbmRBcHBseUV4dGVuc2lvbihnbCwgJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JylcbiAgICBnZXRBbmRBcHBseUV4dGVuc2lvbihnbCwgJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKVxuICAgIGdldEFuZEFwcGx5RXh0ZW5zaW9uKGdsLCAnV0VCR0xfZHJhd19idWZmZXJzJylcblxuICAgIHRoaXMuZW5hYmxlKHRoaXMuREVQVEhfVEVTVClcbiAgICB0aGlzLmVuYWJsZSh0aGlzLkNVTExfRkFDRSlcbiAgICB0aGlzLmVuYWJsZSh0aGlzLkJMRU5EKVxuICAgIHRoaXMuZW5hYmxlQWxwaGFCbGVuZGluZygpXG4gIH1cblxuICAvLyBQVUJMSUMgTUVUSE9EU1xuXG4gIHNldFZpZXdwb3J0ICh4LCB5LCB3LCBoKSB7XG4gICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZVxuICAgIGlmICh4ICE9PSB0aGlzLl92aWV3cG9ydFswXSkgeyBoYXNDaGFuZ2VkID0gdHJ1ZSB9XG4gICAgaWYgKHkgIT09IHRoaXMuX3ZpZXdwb3J0WzFdKSB7IGhhc0NoYW5nZWQgPSB0cnVlIH1cbiAgICBpZiAodyAhPT0gdGhpcy5fdmlld3BvcnRbMl0pIHsgaGFzQ2hhbmdlZCA9IHRydWUgfVxuICAgIGlmIChoICE9PSB0aGlzLl92aWV3cG9ydFszXSkgeyBoYXNDaGFuZ2VkID0gdHJ1ZSB9XG5cbiAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgZ2wudmlld3BvcnQoeCwgeSwgdywgaClcbiAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gW3gsIHksIHcsIGhdXG4gICAgfVxuICB9XG5cbiAgc2Npc3NvciAoeCwgeSwgdywgaCkge1xuICAgIGdsLnNjaXNzb3IoeCwgeSwgdywgaClcbiAgfVxuXG4gIGNsZWFyIChyLCBnLCBiLCBhKSB7XG4gICAgZ2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKVxuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKVxuICB9XG5cbiAgY3VsbEZhY2UgKG1WYWx1ZSkge1xuICAgIGdsLmN1bGxGYWNlKG1WYWx1ZSlcbiAgfVxuXG4gIHNldE1hdHJpY2VzIChtQ2FtZXJhKSB7XG4gICAgdGhpcy5jYW1lcmEgPSBtQ2FtZXJhXG4gICAgdGhpcy5yb3RhdGUodGhpcy5pZGVudGl0eU1hdHJpeClcbiAgfVxuXG4gIHVzZVNoYWRlciAobVNoYWRlcikge1xuICAgIHRoaXMuc2hhZGVyID0gbVNoYWRlclxuICAgIHRoaXMuc2hhZGVyUHJvZ3JhbSA9IHRoaXMuc2hhZGVyLnNoYWRlclByb2dyYW1cbiAgfVxuXG4gIHJvdGF0ZSAobVJvdGF0aW9uKSB7XG4gICAgbWF0NC5jb3B5KHRoaXMuX21vZGVsTWF0cml4LCBtUm90YXRpb24pXG4gICAgbWF0NC5tdWx0aXBseSh0aGlzLl9tYXRyaXgsIHRoaXMuY2FtZXJhLm1hdHJpeCwgdGhpcy5fbW9kZWxNYXRyaXgpXG4gICAgbWF0My5mcm9tTWF0NCh0aGlzLl9ub3JtYWxNYXRyaXgsIHRoaXMuX21hdHJpeClcbiAgICBtYXQzLmludmVydCh0aGlzLl9ub3JtYWxNYXRyaXgsIHRoaXMuX25vcm1hbE1hdHJpeClcbiAgICBtYXQzLnRyYW5zcG9zZSh0aGlzLl9ub3JtYWxNYXRyaXgsIHRoaXMuX25vcm1hbE1hdHJpeClcblxuICAgIG1hdDMuZnJvbU1hdDQodGhpcy5faW52ZXJzZU1vZGVsVmlld01hdHJpeCwgdGhpcy5fbWF0cml4KVxuICAgIG1hdDMuaW52ZXJ0KHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgsIHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgpXG4gIH1cblxuICBkcmF3IChtTWVzaCwgbURyYXdpbmdUeXBlKSB7XG4gICAgaWYgKG1NZXNoLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtTWVzaC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmRyYXcobU1lc2hbaV0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBtTWVzaC5iaW5kKHRoaXMuc2hhZGVyUHJvZ3JhbSlcblxuICAgIC8vXHRERUZBVUxUIFVOSUZPUk1TXG4gICAgaWYgKHRoaXMuY2FtZXJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VQcm9qZWN0aW9uTWF0cml4JywgJ21hdDQnLCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uKVxuICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybSgndVZpZXdNYXRyaXgnLCAnbWF0NCcsIHRoaXMuY2FtZXJhLm1hdHJpeClcbiAgICB9XG5cbiAgICB0aGlzLnNoYWRlci51bmlmb3JtKCd1TW9kZWxNYXRyaXgnLCAnbWF0NCcsIHRoaXMuX21vZGVsTWF0cml4KVxuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VOb3JtYWxNYXRyaXgnLCAnbWF0MycsIHRoaXMuX25vcm1hbE1hdHJpeClcbiAgICB0aGlzLnNoYWRlci51bmlmb3JtKCd1TW9kZWxWaWV3TWF0cml4SW52ZXJzZScsICdtYXQzJywgdGhpcy5faW52ZXJzZU1vZGVsVmlld01hdHJpeClcblxuICAgIGxldCBkcmF3VHlwZSA9IG1NZXNoLmRyYXdUeXBlXG4gICAgaWYgKG1EcmF3aW5nVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkcmF3VHlwZSA9IG1EcmF3aW5nVHlwZVxuICAgIH1cblxuICAgIGlmIChtTWVzaC5pc0luc3RhbmNlZCkge1xuICAgICAgLy9cdERSQVdJTkdcbiAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZChtTWVzaC5kcmF3VHlwZSwgbU1lc2guaUJ1ZmZlci5udW1JdGVtcywgZ2wuVU5TSUdORURfU0hPUlQsIDAsIG1NZXNoLm51bUluc3RhbmNlKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHJhd1R5cGUgPT09IGdsLlBPSU5UUykge1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGRyYXdUeXBlLCAwLCBtTWVzaC52ZXJ0ZXhTaXplKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGRyYXdUeXBlLCBtTWVzaC5pQnVmZmVyLm51bUl0ZW1zLCBnbC5VTlNJR05FRF9TSE9SVCwgMClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtTWVzaC51bmJpbmQoKVxuICB9XG5cbiAgZHJhd1RyYW5zZm9ybUZlZWRiYWNrIChtVHJhbnNmb3JtT2JqZWN0KSB7XG4gICAgY29uc3QgeyBtZXNoU291cmNlLCBtZXNoRGVzdGluYXRpb24sIG51bVBvaW50cywgdHJhbnNmb3JtRmVlZGJhY2sgfSA9IG1UcmFuc2Zvcm1PYmplY3RcblxuICAgIC8vXHRCSU5EIFNPVVJDRSBCVUZGRVJTIC0+IHNldHVwVmVydGV4QXR0cihzb3VyY2VWQU8pXG4gICAgbWVzaFNvdXJjZS5iaW5kKHRoaXMuc2hhZGVyUHJvZ3JhbSlcbiAgICBtZXNoRGVzdGluYXRpb24uZ2VuZXJhdGVCdWZmZXJzKHRoaXMuc2hhZGVyUHJvZ3JhbSlcblxuICAgIC8vXHRCSU5EIERFU1RJTkFUSU9OIEJVRkZFUlNcbiAgICBnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCB0cmFuc2Zvcm1GZWVkYmFjaylcblxuICAgIG1lc2hEZXN0aW5hdGlvbi5hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIsIGkpID0+IHtcbiAgICAgIGdsLmJpbmRCdWZmZXJCYXNlKGdsLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIsIGksIGF0dHIuYnVmZmVyKVxuICAgIH0pXG5cbiAgICBnbC5lbmFibGUoZ2wuUkFTVEVSSVpFUl9ESVNDQVJEKVxuXG4gICAgZ2wuYmVnaW5UcmFuc2Zvcm1GZWVkYmFjayhnbC5QT0lOVFMpXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIG51bVBvaW50cylcbiAgICBnbC5lbmRUcmFuc2Zvcm1GZWVkYmFjaygpXG5cbiAgICAvL1x0cmVzZXQgc3RhdGVcbiAgICBnbC5kaXNhYmxlKGdsLlJBU1RFUklaRVJfRElTQ0FSRClcbiAgICBnbC51c2VQcm9ncmFtKG51bGwpXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpXG4gICAgbWVzaERlc3RpbmF0aW9uLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ciwgaSkgPT4ge1xuICAgICAgZ2wuYmluZEJ1ZmZlckJhc2UoZ2wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgaSwgbnVsbClcbiAgICB9KVxuICAgIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIG51bGwpXG5cbiAgICBtZXNoU291cmNlLnVuYmluZCgpXG4gIH1cblxuICBzZXRTaXplIChtV2lkdGgsIG1IZWlnaHQpIHtcbiAgICB0aGlzLl93aWR0aCA9IG1XaWR0aFxuICAgIHRoaXMuX2hlaWdodCA9IG1IZWlnaHRcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuX3dpZHRoXG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLl93aWR0aCAvIHRoaXMuX2hlaWdodFxuXG4gICAgaWYgKGdsKSB7XG4gICAgICB0aGlzLnZpZXdwb3J0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpXG4gICAgfVxuICB9XG5cbiAgc2hvd0V4dGVuc2lvbnMgKCkge1xuICAgIGNvbnNvbGUubG9nKCdFeHRlbnNpb25zIDogJywgdGhpcy5leHRlbnNpb25zKVxuICAgIGZvciAoY29uc3QgZXh0IGluIHRoaXMuZXh0ZW5zaW9ucykge1xuICAgICAgaWYgKHRoaXMuZXh0ZW5zaW9uc1tleHRdKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV4dCwgJzonLCB0aGlzLmV4dGVuc2lvbnNbZXh0XSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjaGVja0V4dGVuc2lvbiAobUV4dGVuc2lvbikge1xuICAgIHJldHVybiAhIXRoaXMuZXh0ZW5zaW9uc1ttRXh0ZW5zaW9uXVxuICB9XG5cbiAgZ2V0RXh0ZW5zaW9uIChtRXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uc1ttRXh0ZW5zaW9uXVxuICB9XG5cbiAgLy9cdEJMRU5EIE1PREVTXG5cbiAgZW5hYmxlQWxwaGFCbGVuZGluZyAoKSB7XG4gICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSlcbiAgfVxuXG4gIGVuYWJsZUFkZGl0aXZlQmxlbmRpbmcgKCkge1xuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORSlcbiAgfVxuXG4gIC8vXHRtYXRyaWNlc1xuXG4gIHB1c2hNYXRyaXggKCkge1xuICAgIGNvbnN0IG10eCA9IG1hdDQuY2xvbmUodGhpcy5fbW9kZWxNYXRyaXgpXG4gICAgdGhpcy5fbWF0cml4U3RhY2tzLnB1c2gobXR4KVxuICB9XG5cbiAgcG9wTWF0cml4ICgpIHtcbiAgICBpZiAodGhpcy5fbWF0cml4U3RhY2tzLmxlbmd0aCA9PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBjb25zdCBtdHggPSB0aGlzLl9tYXRyaXhTdGFja3MucG9wKClcbiAgICB0aGlzLnJvdGF0ZShtdHgpXG4gIH1cblxuICAvL1x0R0wgTkFUSVZFIEZVTkNUSU9OU1xuXG4gIGVuYWJsZSAobVBhcmFtZXRlcikge1x0Z2wuZW5hYmxlKG1QYXJhbWV0ZXIpXHRcdH1cblxuICBkaXNhYmxlIChtUGFyYW1ldGVyKSB7XHRnbC5kaXNhYmxlKG1QYXJhbWV0ZXIpXHR9XG5cbiAgdmlld3BvcnQgKHgsIHksIHcsIGgpIHtcdHRoaXMuc2V0Vmlld3BvcnQoeCwgeSwgdywgaClcdH1cblxuICAvL1x0R0VUVEVSIEFORCBTRVRURVJTXG5cbiAgZ2V0IEZMT0FUICgpIHsgcmV0dXJuIGdldEZsb2F0KCkgfVxuXG4gIGdldCBIQUxGX0ZMT0FUICgpIHsgcmV0dXJuIGdldEhhbGZGbG9hdCgpIH1cblxuICBnZXQgd2lkdGggKCkge1x0cmV0dXJuIHRoaXMuX3dpZHRoXHRcdH1cblxuICBnZXQgaGVpZ2h0ICgpIHtcdHJldHVybiB0aGlzLl9oZWlnaHRcdH1cblxuICBnZXQgYXNwZWN0UmF0aW8gKCkge1x0cmV0dXJuIHRoaXMuX2FzcGVjdFJhdGlvXHR9XG5cbiAgZ2V0IHdlYmdsMiAoKSB7XHRyZXR1cm4gdGhpcy5fdXNlV2ViR0wyXHR9XG5cbiAgLy9cdERFU1RST1lcblxuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIDogJywgZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNhbnZhcyA9IG51bGxcbiAgfVxufVxuXG5jb25zdCBHTCA9IG5ldyBHTFRvb2woKVxuXG5leHBvcnQgZGVmYXVsdCBHTFxuIiwiLy8gR2VvbS5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBNZXNoIGZyb20gJy4vTWVzaCc7XG5cbmNvbnN0IEdlb20gPSB7fTtcbmxldCBtZXNoVHJpO1xuXG5HZW9tLnBsYW5lID0gZnVuY3Rpb24gcGxhbmUod2lkdGgsIGhlaWdodCwgbnVtU2VnbWVudHMsIGF4aXMgPSAneHknLCBkcmF3VHlwZSA9IDQpIHtcblx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdGNvbnN0IGNvb3JkcyAgICA9IFtdO1xuXHRjb25zdCBpbmRpY2VzICAgPSBbXTtcblx0Y29uc3Qgbm9ybWFscyAgID0gW107XG5cblx0Y29uc3QgZ2FwWCAgPSB3aWR0aCAvIG51bVNlZ21lbnRzO1xuXHRjb25zdCBnYXBZICA9IGhlaWdodCAvIG51bVNlZ21lbnRzO1xuXHRjb25zdCBnYXBVViA9IDEgLyBudW1TZWdtZW50cztcblx0Y29uc3Qgc3ggICAgPSAtd2lkdGggKiAwLjU7XG5cdGNvbnN0IHN5ICAgID0gLWhlaWdodCAqIDAuNTtcblx0bGV0IGluZGV4ID0gMDtcblxuXHRmb3IobGV0IGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXHRcdGZvciAobGV0IGogPSAwOyBqIDwgbnVtU2VnbWVudHM7IGorKykge1xuXHRcdFx0Y29uc3QgdHggPSBnYXBYICogaSArIHN4O1xuXHRcdFx0Y29uc3QgdHkgPSBnYXBZICogaiArIHN5O1xuXG5cdFx0XHRjb25zdCB1ID0gaSAvIG51bVNlZ21lbnRzO1xuXHRcdFx0Y29uc3QgdiA9IGogLyBudW1TZWdtZW50cztcblxuXHRcdFx0aWYoYXhpcyA9PT0gJ3h6Jykge1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHgsIFx0XHQwLCBcdCB0eSArIGdhcFldKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4ICsgZ2FwWCwgXHQwLCBcdCB0eSArIGdhcFldKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4ICsgZ2FwWCwgXHQwLCBcdCB0eV0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHgsIFx0XHQwLCBcdCB0eV0pO1x0XG5cblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIDEuMCAtICh2ICsgZ2FwVVYpXSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1ICsgZ2FwVVYsIDEuMCAtICh2ICsgZ2FwVVYpXSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1ICsgZ2FwVVYsIDEuMCAtIHZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIDEuMCAtIHZdKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0XHRcdH0gZWxzZSBpZihheGlzID09PSAneXonKSB7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFswLCB0eSwgdHhdKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goWzAsIHR5LCB0eCArIGdhcFhdKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goWzAsIHR5ICsgZ2FwWSwgdHggKyBnYXBYXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFswLCB0eSArIGdhcFksIHR4XSk7XHRcblxuXHRcdFx0XHRjb29yZHMucHVzaChbdSwgdl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCB2XSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1ICsgZ2FwVVYsIHYgKyBnYXBVVl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSwgdiArIGdhcFVWXSk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHgsIFx0XHR0eSwgXHQwXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCArIGdhcFgsIFx0dHksIFx0MF0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHggKyBnYXBYLCBcdHR5ICsgZ2FwWSwgXHQwXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCwgXHRcdHR5ICsgZ2FwWSwgXHQwXSk7XHRcblxuXHRcdFx0XHRjb29yZHMucHVzaChbdSwgdl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCB2XSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1ICsgZ2FwVVYsIHYgKyBnYXBVVl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSwgdiArIGdhcFVWXSk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdFx0XHR9IFxuXG5cblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAwKTtcblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAxKTtcblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAyKTtcblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAwKTtcblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAyKTtcblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAzKTtcblxuXHRcdFx0aW5kZXgrKztcblx0XHR9XG5cdH1cblxuXHRjb25zdCBtZXNoID0gbmV3IE1lc2goZHJhd1R5cGUpO1xuXHRtZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRtZXNoLmJ1ZmZlclRleENvb3JkKGNvb3Jkcyk7XG5cdG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdG1lc2guYnVmZmVyTm9ybWFsKG5vcm1hbHMpO1xuXG5cdHJldHVybiBtZXNoO1xufTtcblxuR2VvbS5zcGhlcmUgPSBmdW5jdGlvbiBzcGhlcmUoc2l6ZSwgbnVtU2VnbWVudHMsIGlzSW52ZXJ0ID0gZmFsc2UsIGRyYXdUeXBlID0gNCkge1xuXHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0Y29uc3QgY29vcmRzICAgID0gW107XG5cdGNvbnN0IGluZGljZXMgICA9IFtdO1xuXHRjb25zdCBub3JtYWxzICAgPSBbXTtcblx0Y29uc3QgZ2FwVVYgICAgID0gMSAvIG51bVNlZ21lbnRzO1xuXHRsZXQgaW5kZXggICAgIFx0PSAwO1xuXHRcblxuXHRmdW5jdGlvbiBnZXRQb3NpdGlvbihpLCBqLCBpc05vcm1hbCA9IGZhbHNlKSB7XHQvL1x0cnggOiAtOTAgfiA5MCAsIHJ5IDogMCB+IDM2MFxuXHRcdGNvbnN0IHJ4ICAgICAgICA9IGkgLyBudW1TZWdtZW50cyAqIE1hdGguUEkgLSBNYXRoLlBJICogMC41O1xuXHRcdGNvbnN0IHJ5ICAgICAgICA9IGogLyBudW1TZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXHRcdGNvbnN0IHIgICAgICAgICA9IGlzTm9ybWFsID8gMSA6IHNpemU7XG5cdFx0Y29uc3QgcG9zICAgICAgID0gW107XG5cdFx0cG9zWzFdICAgICAgICBcdD0gTWF0aC5zaW4ocngpICogcjtcblx0XHRjb25zdCB0ICAgICAgICAgPSBNYXRoLmNvcyhyeCkgKiByO1xuXHRcdHBvc1swXSAgICAgICAgXHQ9IE1hdGguY29zKHJ5KSAqIHQ7XG5cdFx0cG9zWzJdICAgICAgICBcdD0gTWF0aC5zaW4ocnkpICogdDtcblx0XHRcblx0XHRjb25zdCBwcmVjaXNpb24gPSAxMDAwMDtcblx0XHRwb3NbMF0gICAgICAgID0gTWF0aC5mbG9vcihwb3NbMF0gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuXHRcdHBvc1sxXSAgICAgICAgPSBNYXRoLmZsb29yKHBvc1sxXSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG5cdFx0cG9zWzJdICAgICAgICA9IE1hdGguZmxvb3IocG9zWzJdICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblxuXHRcdHJldHVybiBwb3M7XG5cdH07XG5cblx0XG5cdGZvcihsZXQgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cdFx0Zm9yKGxldCBqID0gMDsgaiA8IG51bVNlZ21lbnRzOyBqKyspIHtcblx0XHRcdHBvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGksIGopKTtcblx0XHRcdHBvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGkgKyAxLCBqKSk7XG5cdFx0XHRwb3NpdGlvbnMucHVzaChnZXRQb3NpdGlvbihpICsgMSwgaiArIDEpKTtcblx0XHRcdHBvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGksIGogKyAxKSk7XG5cblx0XHRcdG5vcm1hbHMucHVzaChnZXRQb3NpdGlvbihpLCBqLCB0cnVlKSk7XG5cdFx0XHRub3JtYWxzLnB1c2goZ2V0UG9zaXRpb24oaSArIDEsIGosIHRydWUpKTtcblx0XHRcdG5vcm1hbHMucHVzaChnZXRQb3NpdGlvbihpICsgMSwgaiArIDEsIHRydWUpKTtcblx0XHRcdG5vcm1hbHMucHVzaChnZXRQb3NpdGlvbihpLCBqICsgMSwgdHJ1ZSkpO1xuXHRcdFx0XG5cblx0XHRcdGNvbnN0IHUgPSBqIC8gbnVtU2VnbWVudHM7XG5cdFx0XHRjb25zdCB2ID0gaSAvIG51bVNlZ21lbnRzO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdGNvb3Jkcy5wdXNoKFsxLjAgLSB1LCB2XSk7XG5cdFx0XHRjb29yZHMucHVzaChbMS4wIC0gdSwgdiArIGdhcFVWXSk7XG5cdFx0XHRjb29yZHMucHVzaChbMS4wIC0gdSAtIGdhcFVWLCB2ICsgZ2FwVVZdKTtcblx0XHRcdGNvb3Jkcy5wdXNoKFsxLjAgLSB1IC0gZ2FwVVYsIHZdKTtcblxuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDApO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDEpO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDIpO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDApO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDIpO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDMpO1xuXG5cdFx0XHRpbmRleCsrO1xuXHRcdH1cblx0fVxuXG5cblx0aWYoaXNJbnZlcnQpIHtcblx0XHRpbmRpY2VzLnJldmVyc2UoKTtcblx0fVxuXG5cdGNvbnN0IG1lc2ggPSBuZXcgTWVzaChkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLmN1YmUgPSBmdW5jdGlvbiBjdWJlKHcsIGgsIGQsIGRyYXdUeXBlID0gNCkge1xuXHRoID0gaCB8fCB3O1xuXHRkID0gZCB8fCB3O1xuXG5cdGNvbnN0IHggPSB3IC8gMjtcblx0Y29uc3QgeSA9IGggLyAyO1xuXHRjb25zdCB6ID0gZCAvIDI7XG5cblx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdGNvbnN0IGNvb3JkcyAgICA9IFtdO1xuXHRjb25zdCBpbmRpY2VzICAgPSBbXTsgXG5cdGNvbnN0IG5vcm1hbHMgICA9IFtdOyBcblx0bGV0IGNvdW50ICAgICA9IDA7XG5cblxuXHQvLyBCQUNLXG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAgeSwgLXpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsIC15LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsIC15LCAtel0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gUklHSFRcblx0cG9zaXRpb25zLnB1c2goW3gsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgIHpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsIC15LCAtel0pO1xuXG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBGUk9OVFxuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgIHpdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblxuXHQvLyBMRUZUXG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBUT1Bcblx0cG9zaXRpb25zLnB1c2goW3gsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsICB5LCAgel0pO1xuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIEJPVFRPTVxuXHRwb3NpdGlvbnMucHVzaChbeCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgLXpdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cblx0Y29uc3QgbWVzaCA9IG5ldyBNZXNoKGRyYXdUeXBlKTtcblx0bWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKTtcblx0bWVzaC5idWZmZXJUZXhDb29yZChjb29yZHMpO1xuXHRtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpO1xuXHRtZXNoLmJ1ZmZlck5vcm1hbChub3JtYWxzKTtcblxuXHRyZXR1cm4gbWVzaDtcbn07XG5cbkdlb20uc2t5Ym94ID0gZnVuY3Rpb24gc2t5Ym94KHNpemUsIGRyYXdUeXBlID0gNCkge1xuXHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0Y29uc3QgY29vcmRzICAgID0gW107XG5cdGNvbnN0IGluZGljZXMgICA9IFtdOyBcblx0Y29uc3Qgbm9ybWFscyAgID0gW107IFxuXHRsZXQgY291bnQgICAgID0gMDtcblxuXHQvLyBCQUNLXG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAgc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsIC1zaXplLCAtc2l6ZV0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gUklHSFRcblx0cG9zaXRpb25zLnB1c2goW3NpemUsIC1zaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgLXNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAgc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsICBzaXplLCAtc2l6ZV0pO1xuXG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBGUk9OVFxuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsICBzaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgIHNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAtc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgIHNpemVdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gTEVGVFxuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsIC1zaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsIC1zaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsICBzaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsICBzaXplLCAgc2l6ZV0pO1xuXG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gVE9QXG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAgc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsICBzaXplLCAtc2l6ZV0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBCT1RUT01cblx0cG9zaXRpb25zLnB1c2goW3NpemUsIC1zaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsIC1zaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsIC1zaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgLXNpemUsICBzaXplXSk7XG5cblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb25zdCBtZXNoID0gbmV3IE1lc2goZHJhd1R5cGUpO1xuXHRtZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRtZXNoLmJ1ZmZlclRleENvb3JkKGNvb3Jkcyk7XG5cdG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdG1lc2guYnVmZmVyTm9ybWFsKG5vcm1hbHMpO1xuXG5cdHJldHVybiBtZXNoO1xufTtcblxuR2VvbS5iaWdUcmlhbmdsZSA9IGZ1bmN0aW9uIGJpZ1RyaWFuZ2xlKCkge1xuXG5cdGlmKCFtZXNoVHJpKSB7XG5cdFx0Y29uc3QgaW5kaWNlcyA9IFsyLCAxLCAwXTtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXG5cdFx0XHRbLTEsIC0xXSwgXG5cdFx0XHRbLTEsIDRdLCBcblx0XHRcdFs0LCAtMV1cblx0XHRdO1xuXHRcdFxuXHRcdG1lc2hUcmkgPSBuZXcgTWVzaCgpO1xuXHRcdG1lc2hUcmkuYnVmZmVyRGF0YShwb3NpdGlvbnMsICdhUG9zaXRpb24nLCAyKTtcblx0XHRtZXNoVHJpLmJ1ZmZlckluZGV4KGluZGljZXMpO1x0XG5cdH1cblx0XG5cblx0cmV0dXJuIG1lc2hUcmk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHZW9tOyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcbmltcG9ydCB7IHZlYzMgfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IGdldEF0dHJpYkxvYyBmcm9tICcuL3V0aWxzL2dldEF0dHJpYkxvYyc7XG5cbmxldCBnbDtcbmNvbnN0IFNUQVRJQ19EUkFXID0gMzUwNDQ7XG5cbmNvbnN0IGdldEJ1ZmZlciA9IGZ1bmN0aW9uIChhdHRyKSB7XG5cdGxldCBidWZmZXI7XG5cdFxuXHRpZihhdHRyLmJ1ZmZlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0YnVmZmVyID0gYXR0ci5idWZmZXI7XHRcblx0fSBlbHNlIHtcblx0XHRidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRhdHRyLmJ1ZmZlciA9IGJ1ZmZlcjtcblx0fVxuXG5cdHJldHVybiBidWZmZXI7XG59O1xuXG5cbmNvbnN0IGZvcm1CdWZmZXIgPSBmdW5jdGlvbiAobURhdGEsIG1OdW0pIHtcblx0Y29uc3QgYXJ5ID0gW107XG5cblx0Zm9yKGxldCBpPTA7IGk8bURhdGEubGVuZ3RoOyBpKz0gbU51bSkge1xuXHRcdGNvbnN0IG8gPSBbXTtcblx0XHRmb3IobGV0IGo9MDsgajxtTnVtOyBqKyspIHtcblx0XHRcdG8ucHVzaChtRGF0YVtpK2pdKTtcblx0XHR9XG5cblx0XHRhcnkucHVzaChvKTtcblx0fVxuXG5cdHJldHVybiBhcnk7XG59O1xuXG5jbGFzcyBNZXNoIHtcblx0Y29uc3RydWN0b3IobURyYXdpbmdUeXBlID0gNCwgbVVzZVZhbyA9IHRydWUpIHtcblx0XHRnbCAgICAgICAgICAgICAgICAgICAgICAgICAgID0gR0wuZ2w7XG5cdFx0dGhpcy5kcmF3VHlwZSAgICAgICAgICAgICAgICA9IG1EcmF3aW5nVHlwZTtcblx0XHR0aGlzLl9hdHRyaWJ1dGVzICAgICAgICAgICAgID0gW107XG5cdFx0dGhpcy5fbnVtSW5zdGFuY2UgXHRcdFx0ID0gLTE7XG5cdFx0dGhpcy5fZW5hYmxlZFZlcnRleEF0dHJpYnV0ZSA9IFtdO1xuXHRcdFxuXHRcdHRoaXMuX2luZGljZXMgICAgICAgICAgICAgICAgPSBbXTtcblx0XHR0aGlzLl9mYWNlcyAgICAgICAgICAgICAgICAgID0gW107XG5cdFx0dGhpcy5fYnVmZmVyQ2hhbmdlZCAgICAgICAgICA9IFtdO1xuXHRcdHRoaXMuX2hhc0luZGV4QnVmZmVyQ2hhbmdlZCAgPSBmYWxzZTtcblx0XHR0aGlzLl9oYXNWQU8gICAgICAgICAgICAgICAgID0gZmFsc2U7XG5cdFx0dGhpcy5faXNJbnN0YW5jZWQgXHRcdFx0ID0gZmFsc2U7XG5cdFx0XG5cdFx0dGhpcy5fZXh0VkFPICAgICAgICAgICAgICAgICA9ICEhR0wuZ2wuY3JlYXRlVmVydGV4QXJyYXk7XG5cdFx0dGhpcy5fdXNlVkFPICAgICAgICAgICAgIFx0ID0gISF0aGlzLl9leHRWQU8gJiYgbVVzZVZhbztcblx0XHQvLyB0aGlzLl91c2VWQU8gPSBmYWxzZTtcblx0fVxuXG5cblx0YnVmZmVyVmVydGV4KG1BcnJheVZlcnRpY2VzLCBtRHJhd1R5cGUgPSBTVEFUSUNfRFJBVykge1xuXG5cdFx0dGhpcy5idWZmZXJEYXRhKG1BcnJheVZlcnRpY2VzLCAnYVZlcnRleFBvc2l0aW9uJywgMywgbURyYXdUeXBlKTtcblxuXHRcdGlmICh0aGlzLm5vcm1hbHMubGVuZ3RoIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuYnVmZmVyTm9ybWFsKG1BcnJheVZlcnRpY2VzLCBtRHJhd1R5cGUpO1x0XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG5cdGJ1ZmZlclRleENvb3JkKG1BcnJheVRleENvb3JkcywgbURyYXdUeXBlID0gU1RBVElDX0RSQVcpIHtcblxuXHRcdHRoaXMuYnVmZmVyRGF0YShtQXJyYXlUZXhDb29yZHMsICdhVGV4dHVyZUNvb3JkJywgMiwgbURyYXdUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblxuXHRidWZmZXJOb3JtYWwobU5vcm1hbHMsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXKSB7XG5cblx0XHR0aGlzLmJ1ZmZlckRhdGEobU5vcm1hbHMsICdhTm9ybWFsJywgMywgbURyYXdUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblxuXHRidWZmZXJJbmRleChtQXJyYXlJbmRpY2VzLCBpc0R5bmFtaWMgPSBmYWxzZSkge1xuXG5cdFx0dGhpcy5fZHJhd1R5cGUgICAgICAgID0gaXNEeW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVc7XG5cdFx0dGhpcy5faW5kaWNlcyAgICAgICAgID0gbmV3IFVpbnQxNkFycmF5KG1BcnJheUluZGljZXMpO1xuXHRcdHRoaXMuX251bUl0ZW1zIFx0XHQgID0gdGhpcy5faW5kaWNlcy5sZW5ndGg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGJ1ZmZlckZsYXR0ZW5EYXRhKG1EYXRhLCBtTmFtZSwgbUl0ZW1TaXplLCBtRHJhd1R5cGUgPSBTVEFUSUNfRFJBVywgaXNJbnN0YW5jZWQgPSBmYWxzZSkge1xuXHRcdFxuXHRcdGNvbnN0IGRhdGEgPSBmb3JtQnVmZmVyKG1EYXRhLCBtSXRlbVNpemUpO1xuXHRcdHRoaXMuYnVmZmVyRGF0YShkYXRhLCBtTmFtZSwgbUl0ZW1TaXplLCBtRHJhd1R5cGUgPSBTVEFUSUNfRFJBVywgaXNJbnN0YW5jZWQgPSBmYWxzZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGJ1ZmZlckRhdGEobURhdGEsIG1OYW1lLCBtSXRlbVNpemUsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXLCBpc0luc3RhbmNlZCA9IGZhbHNlKSB7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGNvbnN0IGRyYXdUeXBlICAgPSBtRHJhd1R5cGU7XG5cdFx0aWYoIWRyYXdUeXBlKSBkZWJ1Z2dlcjtcblxuXHRcdGNvbnN0IGJ1ZmZlckRhdGEgPSBbXTtcblx0XHRpZiAoIW1JdGVtU2l6ZSkge1x0bUl0ZW1TaXplID0gbURhdGFbMF0ubGVuZ3RoOyB9XG5cdFx0dGhpcy5faXNJbnN0YW5jZWQgPSBpc0luc3RhbmNlZCB8fCB0aGlzLl9pc0luc3RhbmNlZDtcblxuXHRcdC8vXHRmbGF0dGVuIGJ1ZmZlciBkYXRhXHRcdFxuXHRcdGZvcihpID0gMDsgaSA8IG1EYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRmb3IobGV0IGogPSAwOyBqIDwgbURhdGFbaV0ubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0YnVmZmVyRGF0YS5wdXNoKG1EYXRhW2ldW2pdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgZGF0YUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJEYXRhKTtcblx0XHRjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZShtTmFtZSk7XG5cblx0XHRcblx0XHRpZihhdHRyaWJ1dGUpIHtcdFxuXHRcdFx0Ly9cdGF0dHJpYnV0ZSBleGlzdGVkLCByZXBsYWNlIHdpdGggbmV3IGRhdGFcblx0XHRcdGF0dHJpYnV0ZS5pdGVtU2l6ZSA9IG1JdGVtU2l6ZTtcblx0XHRcdGF0dHJpYnV0ZS5kYXRhQXJyYXkgPSBkYXRhQXJyYXk7XG5cdFx0XHRhdHRyaWJ1dGUuc291cmNlID0gbURhdGE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vXHRhdHRyaWJ1dGUgbm90IGV4aXN0IHlldCwgY3JlYXRlIG5ldyBhdHRyaWJ1dGUgb2JqZWN0XG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGVzLnB1c2goeyBuYW1lOm1OYW1lLCBzb3VyY2U6bURhdGEsIGl0ZW1TaXplOiBtSXRlbVNpemUsIGRyYXdUeXBlLCBkYXRhQXJyYXksIGlzSW5zdGFuY2VkIH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2J1ZmZlckNoYW5nZWQucHVzaChtTmFtZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRidWZmZXJJbnN0YW5jZShtRGF0YSwgbU5hbWUpIHtcblx0XHRpZiAoIUdMLmdsLnZlcnRleEF0dHJpYkRpdmlzb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0V4dGVuc2lvbiA6IEFOR0xFX2luc3RhbmNlZF9hcnJheXMgaXMgbm90IHN1cHBvcnRlZCB3aXRoIHRoaXMgZGV2aWNlICEnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBpdGVtU2l6ZSA9IG1EYXRhWzBdLmxlbmd0aDtcblx0XHR0aGlzLl9udW1JbnN0YW5jZSA9IG1EYXRhLmxlbmd0aDtcblx0XHR0aGlzLmJ1ZmZlckRhdGEobURhdGEsIG1OYW1lLCBpdGVtU2l6ZSwgU1RBVElDX0RSQVcsIHRydWUpO1xuXHR9XG5cblxuXHRiaW5kKG1TaGFkZXJQcm9ncmFtKSB7XG5cdFx0dGhpcy5nZW5lcmF0ZUJ1ZmZlcnMobVNoYWRlclByb2dyYW0pO1xuXG5cdFx0aWYodGhpcy5oYXNWQU8pIHtcblx0XHRcdGdsLmJpbmRWZXJ0ZXhBcnJheSh0aGlzLnZhbyk7IFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cmlidXRlKT0+IHtcblx0XHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZS5idWZmZXIpO1xuXHRcdFx0XHRjb25zdCBhdHRyUG9zaXRpb24gPSBhdHRyaWJ1dGUuYXR0clBvc2l0aW9uO1xuXHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJQb3NpdGlvbiwgYXR0cmlidXRlLml0ZW1TaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG5cdFx0XHRcdGlmKGF0dHJpYnV0ZS5pc0luc3RhbmNlZCkge1xuXHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0clBvc2l0aW9uLCAxKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly9cdEJJTkQgSU5ERVggQlVGRkVSXG5cdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmlCdWZmZXIpO1x0XG5cdFx0fVxuXHR9XG5cblx0Z2VuZXJhdGVCdWZmZXJzKG1TaGFkZXJQcm9ncmFtKSB7XG5cdFx0aWYodGhpcy5fYnVmZmVyQ2hhbmdlZC5sZW5ndGggPT0gMCkgeyByZXR1cm47IH1cblxuXHRcdGlmKHRoaXMuX3VzZVZBTykgeyAvL1x0SUYgU1VQUE9SVEVELCBDUkVBVEUgVkFPXG5cblx0XHRcdC8vXHRDUkVBVEUgJiBCSU5EIFZBT1xuXHRcdFx0aWYoIXRoaXMuX3Zhbykge1xuXHRcdFx0XHR0aGlzLl92YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1x0XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGdsLmJpbmRWZXJ0ZXhBcnJheSh0aGlzLl92YW8pO1xuXG5cdFx0XHQvL1x0VVBEQVRFIEJVRkZFUlNcblx0XHRcdHRoaXMuX2F0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ck9iaikgPT4ge1xuXG5cdFx0XHRcdGlmKHRoaXMuX2J1ZmZlckNoYW5nZWQuaW5kZXhPZihhdHRyT2JqLm5hbWUpICE9PSAtMSkge1xuXHRcdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IGdldEJ1ZmZlcihhdHRyT2JqKTtcblx0XHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRcdFx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXR0ck9iai5kYXRhQXJyYXksIGF0dHJPYmouZHJhd1R5cGUpO1xuXG5cdFx0XHRcdFx0Y29uc3QgYXR0clBvc2l0aW9uID0gZ2V0QXR0cmliTG9jKGdsLCBtU2hhZGVyUHJvZ3JhbSwgYXR0ck9iai5uYW1lKTtcblx0XHRcdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyUG9zaXRpb24pOyBcblx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJQb3NpdGlvbiwgYXR0ck9iai5pdGVtU2l6ZSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblx0XHRcdFx0XHRhdHRyT2JqLmF0dHJQb3NpdGlvbiA9IGF0dHJQb3NpdGlvbjtcblxuXHRcdFx0XHRcdGlmKGF0dHJPYmouaXNJbnN0YW5jZWQpIHtcblx0XHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0clBvc2l0aW9uLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHQvL1x0Y2hlY2sgaW5kZXggYnVmZmVyXG5cdFx0XHR0aGlzLl91cGRhdGVJbmRleEJ1ZmZlcigpO1xuXG5cdFx0XHQvL1x0VU5CSU5EIFZBT1xuXHRcdFx0Z2wuYmluZFZlcnRleEFycmF5KG51bGwpO1x0XG5cdFx0XHRcblx0XHRcdHRoaXMuX2hhc1ZBTyA9IHRydWU7XG5cblx0XHR9IGVsc2UgeyAvL1x0RUxTRSwgVVNFIFRSQURJVElPTkFMIE1FVEhPRFxuXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJPYmopID0+IHtcblx0XHRcdFx0Ly9cdFNLSVAgSUYgQlVGRkVSIEhBU04nVCBDSEFOR0VEXG5cdFx0XHRcdGlmKHRoaXMuX2J1ZmZlckNoYW5nZWQuaW5kZXhPZihhdHRyT2JqLm5hbWUpICE9PSAtMSkge1xuXHRcdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IGdldEJ1ZmZlcihhdHRyT2JqKTtcblx0XHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRcdFx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXR0ck9iai5kYXRhQXJyYXksIGF0dHJPYmouZHJhd1R5cGUpO1xuXG5cdFx0XHRcdFx0Y29uc3QgYXR0clBvc2l0aW9uID0gZ2V0QXR0cmliTG9jKGdsLCBtU2hhZGVyUHJvZ3JhbSwgYXR0ck9iai5uYW1lKTtcblx0XHRcdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyUG9zaXRpb24pO1xuXHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0clBvc2l0aW9uLCBhdHRyT2JqLml0ZW1TaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXHRcdFx0XHRcdGF0dHJPYmouYXR0clBvc2l0aW9uID0gYXR0clBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0aWYoYXR0ck9iai5pc0luc3RhbmNlZCkge1xuXHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyUG9zaXRpb24sIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUluZGV4QnVmZmVyKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5faGFzSW5kZXhCdWZmZXJDaGFuZ2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fYnVmZmVyQ2hhbmdlZCA9IFtdO1xuXHR9XG5cblxuXHR1bmJpbmQoKSB7XG5cdFx0aWYodGhpcy5fdXNlVkFPKSB7XG5cdFx0XHRnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XHRcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5fYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyaWJ1dGUpPT4ge1xuXHRcdFx0aWYoYXR0cmlidXRlLmlzSW5zdGFuY2VkKSB7XG5cdFx0XHRcdGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0cmlidXRlLmF0dHJQb3NpdGlvbiwgMCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXG5cdF91cGRhdGVJbmRleEJ1ZmZlcigpIHtcblx0XHRpZighdGhpcy5faGFzSW5kZXhCdWZmZXJDaGFuZ2VkKSB7XG5cdFx0XHRpZiAoIXRoaXMuaUJ1ZmZlcikgeyB0aGlzLmlCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcdCB9XG5cdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmlCdWZmZXIpO1xuXHRcdFx0Z2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5faW5kaWNlcywgdGhpcy5fZHJhd1R5cGUpO1xuXHRcdFx0dGhpcy5pQnVmZmVyLml0ZW1TaXplID0gMTtcblx0XHRcdHRoaXMuaUJ1ZmZlci5udW1JdGVtcyA9IHRoaXMuX251bUl0ZW1zO1xuXHRcdH1cblx0fVxuXG5cblx0Y29tcHV0ZU5vcm1hbHModXNpbmdGYWNlTm9ybWFscyA9IGZhbHNlKSB7XG5cblx0XHR0aGlzLmdlbmVyYXRlRmFjZXMoKTtcblxuXHRcdGlmKHVzaW5nRmFjZU5vcm1hbHMpIHtcblx0XHRcdHRoaXMuX2NvbXB1dGVGYWNlTm9ybWFscygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXHRcdH1cblx0fVxuXG5cdC8vXHRQUklWQVRFIE1FVEhPRFNcblxuXHRfY29tcHV0ZUZhY2VOb3JtYWxzKCkge1xuXG5cdFx0bGV0IGZhY2VJbmRleDtcblx0XHRsZXQgZmFjZTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5kaWNlcy5sZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0ZmFjZUluZGV4ID0gaSAvIDM7XG5cdFx0XHRmYWNlID0gdGhpcy5fZmFjZXNbZmFjZUluZGV4XTtcblx0XHRcdGNvbnN0IE4gPSBmYWNlLm5vcm1hbDtcblxuXHRcdFx0bm9ybWFsc1tmYWNlLmluZGljZXNbMF1dID0gTjtcblx0XHRcdG5vcm1hbHNbZmFjZS5pbmRpY2VzWzFdXSA9IE47XG5cdFx0XHRub3JtYWxzW2ZhY2UuaW5kaWNlc1syXV0gPSBOO1xuXHRcdH1cblxuXHRcdHRoaXMuYnVmZmVyTm9ybWFsKG5vcm1hbHMpO1xuXHR9XG5cblxuXHRfY29tcHV0ZVZlcnRleE5vcm1hbHMoKSB7XG5cdFx0Ly9cdGxvb3AgdGhyb3VnaCBhbGwgdmVydGljZXNcblx0XHRsZXQgZmFjZTtcblx0XHRjb25zdCBzdW1Ob3JtYWwgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB7IHZlcnRpY2VzIH0gPSB0aGlzO1xuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdHZlYzMuc2V0KHN1bU5vcm1hbCwgMCwgMCwgMCk7XG5cblx0XHRcdGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLl9mYWNlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRmYWNlID0gdGhpcy5fZmFjZXNbal07XG5cblx0XHRcdFx0Ly9cdGlmIHZlcnRleCBleGlzdCBpbiB0aGUgZmFjZSwgYWRkIHRoZSBub3JtYWwgdG8gc3VtIG5vcm1hbFxuXHRcdFx0XHRpZihmYWNlLmluZGljZXMuaW5kZXhPZihpKSA+PSAwKSB7XG5cblx0XHRcdFx0XHRzdW1Ob3JtYWxbMF0gKz0gZmFjZS5ub3JtYWxbMF07XG5cdFx0XHRcdFx0c3VtTm9ybWFsWzFdICs9IGZhY2Uubm9ybWFsWzFdO1xuXHRcdFx0XHRcdHN1bU5vcm1hbFsyXSArPSBmYWNlLm5vcm1hbFsyXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmVjMy5ub3JtYWxpemUoc3VtTm9ybWFsLCBzdW1Ob3JtYWwpO1xuXHRcdFx0bm9ybWFscy5wdXNoKFtzdW1Ob3JtYWxbMF0sIHN1bU5vcm1hbFsxXSwgc3VtTm9ybWFsWzJdXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0fVxuXG5cblx0Z2VuZXJhdGVGYWNlcygpIHtcblx0XHRsZXQgaWEsIGliLCBpYztcblx0XHRsZXQgYSwgYiwgYztcblx0XHRjb25zdCB2YmEgPSB2ZWMzLmNyZWF0ZSgpLCB2Y2EgPSB2ZWMzLmNyZWF0ZSgpLCB2Tm9ybWFsID0gdmVjMy5jcmVhdGUoKTtcblx0XHRjb25zdCB7IHZlcnRpY2VzIH0gPSB0aGlzO1xuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX2luZGljZXMubGVuZ3RoOyBpICs9IDMpIHtcblxuXHRcdFx0aWEgPSB0aGlzLl9pbmRpY2VzW2ldO1xuXHRcdFx0aWIgPSB0aGlzLl9pbmRpY2VzW2kgKyAxXTtcblx0XHRcdGljID0gdGhpcy5faW5kaWNlc1tpICsgMl07XG5cblx0XHRcdGEgPSB2ZXJ0aWNlc1tpYV07XG5cdFx0XHRiID0gdmVydGljZXNbaWJdO1xuXHRcdFx0YyA9IHZlcnRpY2VzW2ljXTtcblxuXHRcdFx0Y29uc3QgZmFjZSA9IHtcblx0XHRcdFx0aW5kaWNlczpbaWEsIGliLCBpY10sXG5cdFx0XHRcdHZlcnRpY2VzOlthLCBiLCBjXSxcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuX2ZhY2VzLnB1c2goZmFjZSk7XG5cdFx0fVxuXG5cdH1cblxuXG5cdGdldEF0dHJpYnV0ZShtTmFtZSkge1x0cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXMuZmluZCgoYSkgPT4gYS5uYW1lID09PSBtTmFtZSk7XHR9XG5cdGdldFNvdXJjZShtTmFtZSkge1xuXHRcdGNvbnN0IGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZShtTmFtZSk7XG5cdFx0cmV0dXJuIGF0dHIgPyBhdHRyLnNvdXJjZSA6IFtdO1xuXHR9XG5cblxuXHQvL1x0R0VUVEVSIEFORCBTRVRURVJTXG5cblx0Z2V0IHZlcnRpY2VzKCkge1x0cmV0dXJuIHRoaXMuZ2V0U291cmNlKCdhVmVydGV4UG9zaXRpb24nKTtcdH1cblxuXHRnZXQgbm9ybWFscygpIHtcdFx0cmV0dXJuIHRoaXMuZ2V0U291cmNlKCdhTm9ybWFsJyk7XHR9XG5cblx0Z2V0IGNvb3JkcygpIHtcdFx0cmV0dXJuIHRoaXMuZ2V0U291cmNlKCdhVGV4dHVyZUNvb3JkJyk7XHR9XG5cblx0Z2V0IGluZGljZXMoKSB7XHRcdHJldHVybiB0aGlzLl9pbmRpY2VzO1x0fVxuXG5cdGdldCB2ZXJ0ZXhTaXplKCkge1x0cmV0dXJuIHRoaXMudmVydGljZXMubGVuZ3RoO1x0fVxuXG5cdGdldCBmYWNlcygpIHtcdHJldHVybiB0aGlzLl9mYWNlcztcdH1cblxuXHRnZXQgYXR0cmlidXRlcygpIHtcdHJldHVybiB0aGlzLl9hdHRyaWJ1dGVzO1x0fVxuXG5cdGdldCBoYXNWQU8oKSB7XHRyZXR1cm4gdGhpcy5faGFzVkFPO1x0fVxuXG5cdGdldCB2YW8oKSB7XHRyZXR1cm4gdGhpcy5fdmFvO1x0fVxuXG5cdGdldCBudW1JbnN0YW5jZSgpIHtcdHJldHVybiB0aGlzLl9udW1JbnN0YW5jZTtcdH1cblxuXHRnZXQgaXNJbnN0YW5jZWQoKSB7IHJldHVybiB0aGlzLl9pc0luc3RhbmNlZDtcdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE1lc2g7IiwiLy8gTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlci5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMVGV4dHVyZSBmcm9tICcuL0dMVGV4dHVyZSc7XG5cbmxldCBnbDtcblxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKHgpIHtcdFxuXHRyZXR1cm4gKHggIT09IDApICYmICghKHggJiAoeCAtIDEpKSk7XG59O1xuXG5jbGFzcyBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyIHtcblx0Y29uc3RydWN0b3IobVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1ldGVycyA9IHt9KSB7XG5cdFx0Z2wgPSBHTC5nbDtcblxuXHRcdHRoaXMud2lkdGggICAgICAgICAgICA9IG1XaWR0aDtcblx0XHR0aGlzLmhlaWdodCAgICAgICAgICAgPSBtSGVpZ2h0O1xuXG5cdFx0dGhpcy5tYWdGaWx0ZXIgID0gbVBhcmFtZXRlcnMubWFnRmlsdGVyIFx0fHwgZ2wuTElORUFSO1xuXHRcdHRoaXMubWluRmlsdGVyICA9IG1QYXJhbWV0ZXJzLm1pbkZpbHRlciBcdHx8IGdsLkxJTkVBUjtcblx0XHR0aGlzLndyYXBTICAgICAgPSBtUGFyYW1ldGVycy53cmFwUyBcdFx0fHwgZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHR0aGlzLndyYXBUICAgICAgPSBtUGFyYW1ldGVycy53cmFwVCBcdFx0fHwgZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHR0aGlzLnVzZURlcHRoICAgPSBtUGFyYW1ldGVycy51c2VEZXB0aCBcdFx0fHwgdHJ1ZTtcblx0XHR0aGlzLnVzZVN0ZW5jaWwgPSBtUGFyYW1ldGVycy51c2VTdGVuY2lsIFx0fHwgZmFsc2U7XG5cdFx0dGhpcy50ZXhlbFR5cGUgXHQ9IG1QYXJhbWV0ZXJzLnR5cGU7XG5cdFx0dGhpcy5fbnVtU2FtcGxlID0gbVBhcmFtZXRlcnMubnVtU2FtcGxlIFx0fHwgODtcblxuXHRcdGlmKCFpc1Bvd2VyT2ZUd28odGhpcy53aWR0aCkgfHwgIWlzUG93ZXJPZlR3byh0aGlzLmhlaWdodCkpIHtcblx0XHRcdHRoaXMud3JhcFMgPSB0aGlzLndyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRTtcblxuXHRcdFx0aWYodGhpcy5taW5GaWx0ZXIgPT09IGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCkge1xuXHRcdFx0XHR0aGlzLm1pbkZpbHRlciA9IGdsLkxJTkVBUjtcblx0XHRcdH1cblx0XHR9IFxuXG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9XG5cblx0X2luaXQoKSB7XG5cdFx0bGV0IHRleGVsVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKHRoaXMudGV4ZWxUeXBlKSB7XG5cdFx0XHR0ZXhlbFR5cGUgPSB0aGlzLnRleGVsVHlwZTtcblx0XHR9XG5cblx0XHR0aGlzLnRleGVsVHlwZSA9IHRleGVsVHlwZTtcblxuXHRcdHRoaXMuZnJhbWVCdWZmZXIgICAgICAgID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcdFxuXHRcdHRoaXMuZnJhbWVCdWZmZXJDb2xvciAgID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcdFxuXHRcdHRoaXMucmVuZGVyQnVmZmVyQ29sb3IgID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0dGhpcy5yZW5kZXJCdWZmZXJEZXB0aCAgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHR0aGlzLmdsVGV4dHVyZSBcdFx0XHQ9IHRoaXMuX2NyZWF0ZVRleHR1cmUoKTtcblx0XHR0aGlzLmdsRGVwdGhUZXh0dXJlIFx0PSB0aGlzLl9jcmVhdGVUZXh0dXJlKGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBnbC5VTlNJR05FRF9TSE9SVCwgZ2wuREVQVEhfQ09NUE9ORU5ULCB0cnVlKTtcblxuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlckNvbG9yKTtcblx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9udW1TYW1wbGUsIGdsLlJHQkE4LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cdFx0Z2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fbnVtU2FtcGxlLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcblx0XHRnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJDb2xvcik7XG5cdFx0Z2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlckNvbG9yKTtcblx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xUZXh0dXJlLnRleHR1cmUsIDApO1xuXHRcdC8vIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5URVhUVVJFXzJELCB0aGlzLmdsRGVwdGhUZXh0dXJlLnRleHR1cmUsIDApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cblx0XHQvLyBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXJEZXB0aCk7XG5cdFx0Ly8gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xEZXB0aFRleHR1cmUudGV4dHVyZSwgMCk7XG5cdFx0Ly8gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblx0fVxuXG5cdF9jcmVhdGVUZXh0dXJlKG1JbnRlcm5hbGZvcm1hdCwgbVRleGVsVHlwZSwgbUZvcm1hdCwgZm9yY2VOZWFyZXN0ID0gZmFsc2UpIHtcblx0XHRpZihtSW50ZXJuYWxmb3JtYXQgPT09IHVuZGVmaW5lZCkge1x0bUludGVybmFsZm9ybWF0ID0gZ2wuUkdCQTtcdH1cblx0XHRpZihtVGV4ZWxUeXBlID09PSB1bmRlZmluZWQpIHtcdG1UZXhlbFR5cGUgPSB0aGlzLnRleGVsVHlwZTtcdH1cblx0XHRpZighbUZvcm1hdCkge1x0bUZvcm1hdCA9IG1JbnRlcm5hbGZvcm1hdDsgfVxuXG5cdFx0Y29uc3QgdCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHRjb25zdCBnbHQgPSBuZXcgR0xUZXh0dXJlKHQsIHRydWUpO1xuXHRcdGNvbnN0IG1hZ0ZpbHRlciA9IGZvcmNlTmVhcmVzdCA/IEdMLk5FQVJFU1QgOiB0aGlzLm1hZ0ZpbHRlcjtcblx0XHRjb25zdCBtaW5GaWx0ZXIgPSBmb3JjZU5lYXJlc3QgPyBHTC5ORUFSRVNUIDogdGhpcy5taW5GaWx0ZXI7XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0KTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgbWFnRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbWluRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLndyYXBTKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLndyYXBUKTtcblx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIG1JbnRlcm5hbGZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIG1Gb3JtYXQsIG1UZXhlbFR5cGUsIG51bGwpO1x0XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cblx0XHRyZXR1cm4gZ2x0O1xuXHR9XG5cblxuXHRiaW5kKG1BdXRvU2V0Vmlld3BvcnQ9dHJ1ZSkge1xuXHRcdGlmKG1BdXRvU2V0Vmlld3BvcnQpIHtcblx0XHRcdEdMLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcdFxuXHRcdH1cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXHR9XG5cblxuXHR1bmJpbmQobUF1dG9TZXRWaWV3cG9ydD10cnVlKSB7XG5cdFx0aWYobUF1dG9TZXRWaWV3cG9ydCkge1xuXHRcdFx0R0wudmlld3BvcnQoMCwgMCwgR0wud2lkdGgsIEdMLmhlaWdodCk7XHRcblx0XHR9XG5cblx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG5cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5EUkFXX0ZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyQ29sb3IpO1xuXHRcdGdsLmNsZWFyQnVmZmVyZnYoZ2wuQ09MT1IsIDAsIFswLjAsIDAuMCwgMC4wLCAwLjBdKTtcblx0XHRnbC5ibGl0RnJhbWVidWZmZXIoXG5cdFx0XHQwLCAwLCB3aWR0aCwgaGVpZ2h0LFxuXHRcdFx0MCwgMCwgd2lkdGgsIGhlaWdodCxcblx0XHRcdGdsLkNPTE9SX0JVRkZFUl9CSVQsIEdMLk5FQVJFU1Rcblx0XHQpO1xuXHRcdC8vIGdsLmJsaXRGcmFtZWJ1ZmZlcihcblx0XHQvLyBcdDAsIDAsIHdpZHRoLCBoZWlnaHQsXG5cdFx0Ly8gXHQwLCAwLCB3aWR0aCwgaGVpZ2h0LFxuXHRcdC8vIFx0Z2wuQ09MT1JfQlVGRkVSX0JJVHxnbC5ERVBUSF9TVEVOQ0lMLCBHTC5ORUFSRVNUXG5cdFx0Ly8gKTtcblxuXHRcdC8vIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5SRUFEX0ZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcblx0XHQvLyBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRFJBV19GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlckRlcHRoKTtcblx0XHQvLyBnbC5jbGVhckJ1ZmZlcmZpKGdsLkRFUFRIX1NURU5DSUwsIDAsIDEuMCwgMCk7XG5cdFx0Ly8gZ2wuYmxpdEZyYW1lYnVmZmVyKFxuXHRcdC8vIFx0MCwgMCwgd2lkdGgsIGhlaWdodCxcblx0XHQvLyBcdDAsIDAsIHdpZHRoLCBoZWlnaHQsXG5cdFx0Ly8gXHRnbC5ERVBUSF9CVUZGRVJfQklULCBnbC5ORUFSRVNUXG5cdFx0Ly8gKTtcblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdH1cblxuXG5cdGdldFRleHR1cmUobUluZGV4ID0gMCkge1xuXHRcdHJldHVybiB0aGlzLmdsVGV4dHVyZTtcblx0fVxuXG5cblx0Z2V0RGVwdGhUZXh0dXJlKCkge1xuXHRcdHJldHVybiB0aGlzLmdsRGVwdGhUZXh0dXJlO1xuXHR9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyOyIsIi8vIFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0LmpzXG5cbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi9HTFNoYWRlcic7XG5pbXBvcnQgTWVzaCBmcm9tICcuL01lc2gnO1xuXG5sZXQgZ2w7XG5cbmNsYXNzIFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0IHtcblxuXG5cdGNvbnN0cnVjdG9yKHN0clZlcnRleFNoYWRlciwgc3RyRnJhZ21lbnRTaGFkZXIpIHtcblx0XHRnbCA9IEdMLmdsO1xuXHRcdHRoaXMuX3ZzID0gc3RyVmVydGV4U2hhZGVyO1xuXHRcdHRoaXMuX2ZzID0gc3RyRnJhZ21lbnRTaGFkZXI7XG5cdFx0XG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9XG5cblxuXHRfaW5pdCgpIHtcblx0XHR0aGlzLl9tZXNoQ3VycmVudCA9IG5ldyBNZXNoKCk7XG5cdFx0dGhpcy5fbWVzaFRhcmdldCA9IG5ldyBNZXNoKCk7XG5cdFx0dGhpcy5fbnVtUG9pbnRzID0gLTE7XG5cblx0XHR0aGlzLl92YXJ5aW5ncyA9IFtdO1xuXHRcdHRoaXMudHJhbnNmb3JtRmVlZGJhY2sgPSBnbC5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaygpO1xuXHR9XG5cblxuXHRidWZmZXJEYXRhKG1EYXRhLCBtTmFtZSwgbVZhcnlpbmdOYW1lKSB7XG5cdFx0Y29uc3QgaXNUcmFuc2Zvcm1GZWVkYmFjayA9ICEhbVZhcnlpbmdOYW1lO1xuXHRcdGNvbnNvbGUubG9nKCdpcyBUcmFuc2Zvcm0gZmVlZGJhY2sgPycsIG1OYW1lLCBpc1RyYW5zZm9ybUZlZWRiYWNrKTtcblx0XHR0aGlzLl9tZXNoQ3VycmVudC5idWZmZXJEYXRhKG1EYXRhLCBtTmFtZSwgbnVsbCwgZ2wuU1RSRUFNX0NPUFksIGZhbHNlKTtcblx0XHR0aGlzLl9tZXNoVGFyZ2V0LmJ1ZmZlckRhdGEobURhdGEsIG1OYW1lLCBudWxsLCBnbC5TVFJFQU1fQ09QWSwgZmFsc2UpO1xuXG5cdFx0aWYoaXNUcmFuc2Zvcm1GZWVkYmFjaykge1xuXHRcdFx0dGhpcy5fdmFyeWluZ3MucHVzaChtVmFyeWluZ05hbWUpO1xuXG5cdFx0XHRpZih0aGlzLl9udW1Qb2ludHMgPCAwKSB7XG5cdFx0XHRcdHRoaXMuX251bVBvaW50cyA9IG1EYXRhLmxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRidWZmZXJJbmRleChtQXJyYXlJbmRpY2VzKSB7XG5cdFx0dGhpcy5fbWVzaEN1cnJlbnQuYnVmZmVySW5kZXgobUFycmF5SW5kaWNlcyk7XG5cdFx0dGhpcy5fbWVzaFRhcmdldC5idWZmZXJJbmRleChtQXJyYXlJbmRpY2VzKTtcblx0fVxuXG5cblx0dW5pZm9ybShtTmFtZSwgbVR5cGUsIG1WYWx1ZSkge1xuXHRcdGlmKHRoaXMuc2hhZGVyKSB7XG5cdFx0XHR0aGlzLnNoYWRlci51bmlmb3JtKG1OYW1lLCBtVHlwZSwgbVZhbHVlKTtcdFxuXHRcdH1cblx0XHRcblx0fVxuXG5cdGdlbmVyYXRlKCkge1xuXHRcdHRoaXMuc2hhZGVyID0gbmV3IEdMU2hhZGVyKHRoaXMuX3ZzLCB0aGlzLl9mcywgdGhpcy5fdmFyeWluZ3MpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGlmKCF0aGlzLnNoYWRlcikge1x0dGhpcy5nZW5lcmF0ZSgpO1x0fVxuXG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdEdMLmRyYXdUcmFuc2Zvcm1GZWVkYmFjayh0aGlzKTtcblxuXHRcdHRoaXMuX3N3YXAoKTtcblx0fVxuXG5cdF9zd2FwKCkge1xuXHRcdGNvbnN0IHRtcCAgICAgICAgICA9IHRoaXMuX21lc2hDdXJyZW50O1xuXHRcdHRoaXMuX21lc2hDdXJyZW50ID0gdGhpcy5fbWVzaFRhcmdldDtcblx0XHR0aGlzLl9tZXNoVGFyZ2V0ICA9IHRtcDtcblx0fVxuXG5cdGdldCBudW1Qb2ludHMoKSB7XHRyZXR1cm4gdGhpcy5fbnVtUG9pbnRzO1x0fVxuXHRnZXQgbWVzaEN1cnJlbnQoKSB7XHRyZXR1cm4gdGhpcy5fbWVzaEN1cnJlbnQ7XHR9XG5cdGdldCBtZXNoVGFyZ2V0KCkge1x0cmV0dXJuIHRoaXMuX21lc2hUYXJnZXQ7XHR9XG5cdGdldCBtZXNoU291cmNlKCkge1x0cmV0dXJuIHRoaXMuX21lc2hDdXJyZW50O1x0fVxuXHRnZXQgbWVzaERlc3RpbmF0aW9uKCkge1x0cmV0dXJuIHRoaXMuX21lc2hUYXJnZXQ7XHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNmb3JtRmVlZGJhY2tPYmplY3Q7IiwiLy8gQ2FtZXJhLmpzXG5cbmltcG9ydCB7IG1hdDQsIG1hdDMsIHF1YXQgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5jbGFzcyBDYW1lcmEge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHQvL1x0VklFVyBNQVRSSVhcblx0XHR0aGlzLl9tYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG5cdFx0Ly9cdEZPUiBUUkFOU0ZPUk0gRlJPTSBPUklFTlRBVElPTlxuXHRcdHRoaXMuX3F1YXQgPSBxdWF0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX29yaWVudGF0aW9uID0gbWF0NC5jcmVhdGUoKTtcblxuXHRcdC8vXHRQUk9KRUNUSU9OIE1BVFJJWFxuXHRcdHRoaXMuX3Byb2plY3Rpb24gPSBtYXQ0LmNyZWF0ZSgpO1xuXG5cdFx0Ly9cdFBPU0lUSU9OIE9GIENBTUVSQVxuXHRcdHRoaXMucG9zaXRpb24gPSB2ZWMzLmNyZWF0ZSgpO1xuXHR9XG5cblxuXHRsb29rQXQoYUV5ZSwgYUNlbnRlciwgYVVwID0gWzAsIDEsIDBdKSB7XG5cdFx0dGhpcy5fZXllID0gdmVjMy5jbG9uZShhRXllKTtcblx0XHR0aGlzLl9jZW50ZXIgPSB2ZWMzLmNsb25lKGFDZW50ZXIpO1xuXG5cdFx0dmVjMy5jb3B5KHRoaXMucG9zaXRpb24sIGFFeWUpO1xuXHRcdG1hdDQuaWRlbnRpdHkodGhpcy5fbWF0cml4KTtcblx0XHRtYXQ0Lmxvb2tBdCh0aGlzLl9tYXRyaXgsIGFFeWUsIGFDZW50ZXIsIGFVcCk7XG5cdH1cblxuXG5cdHNldEZyb21PcmllbnRhdGlvbih4LCB5LCB6LCB3KSB7XG5cdFx0cXVhdC5zZXQodGhpcy5fcXVhdCwgeCwgeSwgeiwgdyk7XG5cdFx0bWF0NC5mcm9tUXVhdCh0aGlzLl9vcmllbnRhdGlvbiwgdGhpcy5fcXVhdCk7XG5cdFx0bWF0NC50cmFuc2xhdGUodGhpcy5fbWF0cml4LCB0aGlzLl9vcmllbnRhdGlvbiwgdGhpcy5wb3NpdGlvbk9mZnNldCk7XG5cdH1cblxuXG5cdHNldFByb2plY3Rpb24obVByb2opIHtcblx0XHR0aGlzLl9wcm9qZWN0aW9uID0gbWF0NC5jbG9uZShtUHJvaik7XG5cdH1cblxuXG5cdHNldFZpZXcobVZpZXcpIHtcblx0XHR0aGlzLl9tYXRyaXggPSBtYXQ0LmNsb25lKG1WaWV3KTtcblx0fVxuXHRcblxuXHRzZXRGcm9tVmlld1Byb2oobVZpZXcsIG1Qcm9qKSB7XG5cdFx0dGhpcy5zZXRWaWV3KG1WaWV3KTtcblx0XHR0aGlzLnNldFByb2plY3Rpb24obVByb2opO1xuXHR9XG5cblxuXHQvL1x0R0VUVEVSUyBcblxuXHRnZXQgbWF0cml4KCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXg7XG5cdH1cblxuXHRnZXQgdmlld01hdHJpeCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9XG5cblxuXHRnZXQgcHJvamVjdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdGlvbjtcblx0fSBcblxuXHRnZXQgcHJvamVjdGlvbk1hdHJpeCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdGlvbjtcblx0fSBcblxuXG5cdGdldCBleWUoKSB7XHRyZXR1cm4gdGhpcy5fZXllO1x0fVxuXG5cdGdldCBjZW50ZXIoKSB7XHRyZXR1cm4gdGhpcy5fY2VudGVyO1x0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENhbWVyYTsiLCIvLyBDYW1lcmFDdWJlLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IENhbWVyYVBlcnNwZWN0aXZlIGZyb20gJy4vQ2FtZXJhUGVyc3BlY3RpdmUnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNvbnN0IENBTUVSQV9TRVRUSU5HUyA9IFtcblx0W3ZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDEsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgLTEsIDApXSxcdFx0XG5cdFt2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygtMSwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAtMSwgMCldLFxuXHRbdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgIDEsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgIDEpXSxcblx0W3ZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsIC0xLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsIDAsIC0xKV0sXG5cdFt2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAwLCAgMSksIHZlYzMuZnJvbVZhbHVlcygwLCAtMSwgMCldLFxuXHRbdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgLTEpLCB2ZWMzLmZyb21WYWx1ZXMoMCwgLTEsIDApXVxuXTtcblxuY2xhc3MgQ2FtZXJhQ3ViZSBleHRlbmRzIENhbWVyYVBlcnNwZWN0aXZlIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5zZXRQZXJzcGVjdGl2ZShNYXRoLlBJIC8gMiwgMSwgMC4xLCAxMDAwKTtcblx0fVxuXG5cblx0ZmFjZShtSW5kZXgpIHtcblx0XHRjb25zdCBvID0gQ0FNRVJBX1NFVFRJTkdTW21JbmRleF07XG5cdFx0dGhpcy5sb29rQXQob1swXSwgb1sxXSwgb1syXSk7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW1lcmFDdWJlOyIsIi8vIENhbWVyYU9ydGhvLmpzXG5cbmltcG9ydCBDYW1lcmEgZnJvbSAnLi9DYW1lcmEnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNsYXNzIENhbWVyYU9ydGhvIGV4dGVuZHMgQ2FtZXJhIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGNvbnN0IGV5ZSAgICA9IHZlYzMuY2xvbmUoWzAsIDAsIDVdKTtcblx0XHRjb25zdCBjZW50ZXIgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdGNvbnN0IHVwICAgICA9IHZlYzMuY2xvbmUoWzAsIDEsIDBdKTtcblx0XHR0aGlzLmxvb2tBdChleWUsIGNlbnRlciwgdXApO1xuXHRcdHRoaXMub3J0aG8oLTEsIDEsIDEsIC0xKTtcblx0fVxuXG5cblx0c2V0Qm91bmRhcnkobGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyPTAuMSwgZmFyPTEwMCkge1xuXHRcdHRoaXMub3J0aG8obGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIpO1xuXHR9XG5cblxuXHRvcnRobyhsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXI9MC4xLCBmYXI9MTAwKSB7XG5cdFx0dGhpcy5sZWZ0ICAgPSBsZWZ0O1xuXHRcdHRoaXMucmlnaHQgID0gcmlnaHQ7XG5cdFx0dGhpcy50b3AgICAgPSB0b3A7XG5cdFx0dGhpcy5ib3R0b20gPSBib3R0b207XG5cdFx0bWF0NC5vcnRobyh0aGlzLl9wcm9qZWN0aW9uLCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcik7XG5cdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENhbWVyYU9ydGhvOyIsIi8vIENhbWVyYVBlcnNwZWN0aXZlLmpzXG5cbmltcG9ydCBDYW1lcmEgZnJvbSAnLi9DYW1lcmEnO1xuaW1wb3J0IFJheSBmcm9tICcuLi9tYXRoL1JheSc7XG5pbXBvcnQgeyBtYXQ0LCB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY29uc3QgbUludmVyc2VWaWV3UHJvaiA9IG1hdDQuY3JlYXRlKCk7XG5jb25zdCBjYW1lcmFEaXIgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5cbmNsYXNzIENhbWVyYVBlcnNwZWN0aXZlIGV4dGVuZHMgQ2FtZXJhIHtcblxuXHRjb25zdHJ1Y3RvcihtRm92LCBtQXNwZWN0UmF0aW8sIG1OZWFyLCBtRmFyKSB7XG5cdFx0c3VwZXIoKTtcblx0XHRcblx0XHRpZihtRm92KSB7XG5cdFx0XHR0aGlzLnNldFBlcnNwZWN0aXZlKG1Gb3YsIG1Bc3BlY3RSYXRpbywgbU5lYXIsIG1GYXIpO1xuXHRcdH1cblx0fVxuXG5cdHNldFBlcnNwZWN0aXZlKG1Gb3YsIG1Bc3BlY3RSYXRpbywgbU5lYXIsIG1GYXIpIHtcblx0XHRcblx0XHR0aGlzLl9mb3YgICAgICAgICA9IG1Gb3Y7XG5cdFx0dGhpcy5fbmVhciAgICAgICAgPSBtTmVhcjtcblx0XHR0aGlzLl9mYXIgICAgICAgICA9IG1GYXI7XG5cdFx0dGhpcy5fYXNwZWN0UmF0aW8gPSBtQXNwZWN0UmF0aW87XG5cdFx0bWF0NC5wZXJzcGVjdGl2ZSh0aGlzLl9wcm9qZWN0aW9uLCBtRm92LCBtQXNwZWN0UmF0aW8sIG1OZWFyLCBtRmFyKTtcblxuXHRcdC8vIHRoaXMuX2ZydXN0dW1Ub3AgPSB0aGlzLl9uZWFyICogTWF0aC50YW4odGhpcy5fZm92ICogMC41KTtcblx0XHQvLyB0aGlzLl9mcnVzdHVtQnV0dG9tID0gLXRoaXMuX2ZydXN0dW1Ub3A7XG5cdFx0Ly8gdGhpcy5fZnJ1c3R1bVJpZ2h0ID0gdGhpcy5fZnJ1c3R1bVRvcCAqIHRoaXMuX2FzcGVjdFJhdGlvO1xuXHRcdC8vIHRoaXMuX2ZydXN0dW1MZWZ0ID0gLXRoaXMuX2ZydXN0dW1SaWdodDtcblx0fVxuXG5cblx0c2V0QXNwZWN0UmF0aW8obUFzcGVjdFJhdGlvKSB7XG5cdFx0dGhpcy5fYXNwZWN0UmF0aW8gPSBtQXNwZWN0UmF0aW87XG5cdFx0bWF0NC5wZXJzcGVjdGl2ZSh0aGlzLnByb2plY3Rpb24sIHRoaXMuX2ZvdiwgbUFzcGVjdFJhdGlvLCB0aGlzLl9uZWFyLCB0aGlzLl9mYXIpO1xuXHR9XG5cblxuXHRnZW5lcmF0ZVJheShtU2NyZWVuUG9zaXRpb24sIG1SYXkpIHtcblx0XHRjb25zdCBwcm9qID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4O1xuXHRcdGNvbnN0IHZpZXcgPSB0aGlzLnZpZXdNYXRyaXg7XG5cblx0XHRtYXQ0Lm11bHRpcGx5KG1JbnZlcnNlVmlld1Byb2osIHByb2osIHZpZXcpO1xuXHRcdG1hdDQuaW52ZXJ0KG1JbnZlcnNlVmlld1Byb2osIG1JbnZlcnNlVmlld1Byb2opO1xuXG5cdFx0dmVjMy50cmFuc2Zvcm1NYXQ0KGNhbWVyYURpciwgbVNjcmVlblBvc2l0aW9uLCBtSW52ZXJzZVZpZXdQcm9qKTtcblx0XHR2ZWMzLnN1YihjYW1lcmFEaXIsIGNhbWVyYURpciwgdGhpcy5wb3NpdGlvbik7XG5cdFx0dmVjMy5ub3JtYWxpemUoY2FtZXJhRGlyLCBjYW1lcmFEaXIpO1xuXG5cdFx0aWYgKCFtUmF5KSB7XG5cdFx0XHRtUmF5ID0gbmV3IFJheSh0aGlzLnBvc2l0aW9uLCBjYW1lcmFEaXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtUmF5Lm9yaWdpbiA9IHRoaXMucG9zaXRpb247XG5cdFx0XHRtUmF5LmRpcmVjdGlvbiA9IGNhbWVyYURpcjtcblx0XHR9XG5cblxuXHRcdHJldHVybiBtUmF5O1xuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FtZXJhUGVyc3BlY3RpdmU7IiwiLy8gQmF0Y2hBeGlzLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IE1lc2ggZnJvbSAnLi4vTWVzaCc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuaW1wb3J0IHZzIGZyb20gJy4uL3NoYWRlcnMvYXhpcy52ZXJ0JztcbmltcG9ydCBmcyBmcm9tICcuLi9zaGFkZXJzL2F4aXMuZnJhZyc7XG5cblxuY2xhc3MgQmF0Y2hBeGlzIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdGNvbnN0IGNvbG9ycyA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgPSBbMCwgMSwgMiwgMywgNCwgNV07XG5cdFx0Y29uc3QgciA9IDk5OTk7XG5cblx0XHRwb3NpdGlvbnMucHVzaChbLXIsICAwLCAgMF0pO1xuXHRcdHBvc2l0aW9ucy5wdXNoKFtyLCAgMCwgIDBdKTtcblx0XHRwb3NpdGlvbnMucHVzaChbMCwgLXIsICAwXSk7XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsICByLCAgMF0pO1xuXHRcdHBvc2l0aW9ucy5wdXNoKFswLCAgMCwgLXJdKTtcblx0XHRwb3NpdGlvbnMucHVzaChbMCwgIDAsICByXSk7XG5cblxuXHRcdGNvbG9ycy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0Y29sb3JzLnB1c2goWzEsIDAsIDBdKTtcblx0XHRjb2xvcnMucHVzaChbMCwgMSwgMF0pO1xuXHRcdGNvbG9ycy5wdXNoKFswLCAxLCAwXSk7XG5cdFx0Y29sb3JzLnB1c2goWzAsIDAsIDFdKTtcblx0XHRjb2xvcnMucHVzaChbMCwgMCwgMV0pO1xuXG5cdFx0Y29uc3QgbWVzaCA9IG5ldyBNZXNoKEdMLkxJTkVTKTtcblx0XHRtZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRcdG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdFx0bWVzaC5idWZmZXJEYXRhKGNvbG9ycywgJ2FDb2xvcicsIDMpO1xuXG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cblx0XHRzdXBlcihtZXNoLCBzaGFkZXIpO1xuXG5cdH1cblxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hBeGlzOyIsIi8vIEJhdGNoQmFsbC5qc1xuXG5pbXBvcnQgR2VvbSBmcm9tICcuLi9HZW9tJztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgQmF0Y2ggZnJvbSAnLi4vQmF0Y2gnO1xuXG5pbXBvcnQgdnMgZnJvbSAnLi4vc2hhZGVycy9nZW5lcmFsLnZlcnQnO1xuaW1wb3J0IGZzIGZyb20gJy4uL3NoYWRlcnMvc2ltcGxlQ29sb3IuZnJhZyc7XG5cbmNsYXNzIEJhdGNoQmFsbCBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBtZXNoID0gR2VvbS5zcGhlcmUoMSwgMjQpO1xuXHRcdGNvbnN0IHNoYWRlciA9IG5ldyBHTFNoYWRlcih2cywgZnMpO1xuXHRcdHN1cGVyKG1lc2gsIHNoYWRlcik7XG5cdH1cblxuXG5cdGRyYXcocG9zaXRpb24gPSBbMCwgMCwgMF0sIHNjYWxlID0gWzEsIDEsIDFdLCBjb2xvciA9IFsxLCAxLCAxXSwgb3BhY2l0eSA9IDEpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgncG9zaXRpb24nLCAndW5pZm9ybTNmdicsIHBvc2l0aW9uKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCdzY2FsZScsICd1bmlmb3JtM2Z2Jywgc2NhbGUpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ2NvbG9yJywgJ3VuaWZvcm0zZnYnLCBjb2xvcik7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgnb3BhY2l0eScsICd1bmlmb3JtMWYnLCBvcGFjaXR5KTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXRjaEJhbGw7IiwiLy8gQmF0Y2hDb3B5LmpzXG5cbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmltcG9ydCB2cyBmcm9tICcuLi9zaGFkZXJzL2JpZ1RyaWFuZ2xlLnZlcnQnO1xuaW1wb3J0IGZzIGZyb20gJy4uL3NoYWRlcnMvY29weS5mcmFnJztcblxuY2xhc3MgQmF0Y2hDb3B5IGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IG1lc2ggPSBHZW9tLmJpZ1RyaWFuZ2xlKCk7XG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cdFx0c3VwZXIobWVzaCwgc2hhZGVyKTtcblxuXHRcdHNoYWRlci5iaW5kKCk7XG5cdFx0c2hhZGVyLnVuaWZvcm0oJ3RleHR1cmUnLCAndW5pZm9ybTFpJywgMCk7XG5cdH1cblxuXG5cdGRyYXcodGV4dHVyZSkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0ZXh0dXJlLmJpbmQoMCk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hDb3B5OyIsIi8vIEJhdGNoRG90c1BsYW5lLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IE1lc2ggZnJvbSAnLi4vTWVzaCc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuaW1wb3J0IHZzIGZyb20gJy4uL3NoYWRlcnMvZG90c1BsYW5lLnZlcnQnO1xuaW1wb3J0IGZzIGZyb20gJy4uL3NoYWRlcnMvZG90c1BsYW5lLmZyYWcnO1xuXG5jbGFzcyBCYXRjaERvdHNQbGFuZSBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzICAgPSBbXTtcblx0XHRsZXQgaW5kZXggICAgICAgPSAwO1xuXHRcdGNvbnN0IHNpemUgICAgICA9IDEwMDtcblx0XHRsZXQgaSwgajtcblxuXHRcdGZvcihpID0gLXNpemU7IGkgPCBzaXplOyBpICs9IDEpIHtcblx0XHRcdGZvcihqID0gLXNpemU7IGogPCBzaXplOyBqICs9IDEpIHtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW2ksIGosIDBdKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4KTtcblx0XHRcdFx0aW5kZXgrKztcblxuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbaSwgMCwgal0pO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goaW5kZXgpO1xuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRjb25zdCBtZXNoICAgICA9IG5ldyBNZXNoKEdMLlBPSU5UUyk7XG5cdFx0bWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKTtcblx0XHRtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpO1xuXHRcdFxuXHRcdGNvbnN0IHNoYWRlciAgID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cdFx0XG5cdFx0c3VwZXIobWVzaCwgc2hhZGVyKTtcblx0XHRcblx0XHR0aGlzLmNvbG9yICAgPSBbMSwgMSwgMV07XG5cdFx0dGhpcy5vcGFjaXR5ID0gMC42NTtcblx0fVxuXG5cblx0ZHJhdygpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgnY29sb3InLCAndW5pZm9ybTNmdicsIHRoaXMuY29sb3IpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ29wYWNpdHknLCAndW5pZm9ybTFmJywgdGhpcy5vcGFjaXR5KTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd2aWV3cG9ydCcsICd2ZWMyJywgW0dMLndpZHRoLCBHTC5oZWlnaHRdKTtcblx0XHQvLyBHTC5kcmF3KHRoaXMubWVzaCk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoRG90c1BsYW5lOyIsIi8vIEJhdGNoTGluZS5qc1xuXG5pbXBvcnQgQmF0Y2ggZnJvbSAnLi4vQmF0Y2gnO1xuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IE1lc2ggZnJvbSAnLi4vTWVzaCc7XG5pbXBvcnQgZnMgZnJvbSAnLi4vc2hhZGVycy9zaW1wbGVDb2xvci5mcmFnJztcbmltcG9ydCB2cyBmcm9tICcuLi9zaGFkZXJzL2Jhc2ljLnZlcnQnO1xuXG5jbGFzcyBCYXRjaEF4aXMgZXh0ZW5kcyBCYXRjaCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdFx0Y29uc3QgaW5kaWNlcyA9IFswLCAxXTtcblx0XHRjb25zdCBjb29yZHMgPSBbWzAsIDBdLCBbMSwgMV1dO1xuXHRcdHBvc2l0aW9ucy5wdXNoKFswLCAgMCwgIDBdKTtcblx0XHRwb3NpdGlvbnMucHVzaChbMCwgIDAsICAwXSk7XG5cblx0XHRjb25zdCBtZXNoID0gbmV3IE1lc2goR0wuTElORVMpO1xuXHRcdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdFx0bWVzaC5idWZmZXJUZXhDb29yZChjb29yZHMpO1xuXHRcdG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblxuXHRcdHN1cGVyKG1lc2gsIHNoYWRlcik7XG5cdH1cblxuXG5cdGRyYXcobVBvc2l0aW9uQSwgbVBvc2l0aW9uQiwgY29sb3IgPSBbMSwgMSwgMV0sIG9wYWNpdHkgPSAxLjApIHtcblx0XHR0aGlzLl9tZXNoLmJ1ZmZlclZlcnRleChbbVBvc2l0aW9uQSwgbVBvc2l0aW9uQl0pO1xuXG5cdFx0dGhpcy5fc2hhZGVyLmJpbmQoKTtcblx0XHR0aGlzLl9zaGFkZXIudW5pZm9ybSgnY29sb3InLCAndmVjMycsIGNvbG9yKTtcblx0XHR0aGlzLl9zaGFkZXIudW5pZm9ybSgnb3BhY2l0eScsICdmbG9hdCcsIG9wYWNpdHkpO1xuXHRcdHN1cGVyLmRyYXcoKTtcblx0fVxuXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBCYXRjaEF4aXM7IiwiLy8gQmF0Y2hTa3kuanNcblxuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgR2VvbSBmcm9tICcuLi9HZW9tJztcbmltcG9ydCBmcyBmcm9tICcuLi9zaGFkZXJzL2NvcHkuZnJhZyc7XG5pbXBvcnQgdnMgZnJvbSAnLi4vc2hhZGVycy9za3kudmVydCc7XG5cbmNsYXNzIEJhdGNoU2t5IGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKHNpemUgPSA1MCwgc2VnID0gMjQpIHtcblx0XHRjb25zdCBtZXNoID0gR2VvbS5zcGhlcmUoc2l6ZSwgc2VnLCB0cnVlKTtcblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblxuXHRcdHN1cGVyKG1lc2gsIHNoYWRlcik7XG5cdH1cblxuXHRkcmF3KHRleHR1cmUpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGV4dHVyZS5iaW5kKDApO1xuXHRcdHN1cGVyLmRyYXcoKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXRjaFNreTsiLCIvLyBCYXRjaFNreWJveC5qc1xuXG5pbXBvcnQgQmF0Y2ggZnJvbSAnLi4vQmF0Y2gnO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IGZzIGZyb20gJy4uL3NoYWRlcnMvc2t5Ym94LmZyYWcnO1xuaW1wb3J0IHZzIGZyb20gJy4uL3NoYWRlcnMvc2t5Ym94LnZlcnQnO1xuXG5jbGFzcyBCYXRjaFNreWJveCBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcihzaXplID0gMjApIHtcblx0XHRjb25zdCBtZXNoID0gR2VvbS5za3lib3goc2l6ZSk7XG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cblx0XHRzdXBlcihtZXNoLCBzaGFkZXIpO1xuXHR9XG5cblx0ZHJhdyh0ZXh0dXJlKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRleHR1cmUuYmluZCgwKTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cblxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hTa3lib3g7IiwiLy8gRHJhdy5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBNZXNoIGZyb20gJy4uL01lc2gnO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcblxuY2xhc3MgRHJhdyB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7fTtcblx0XHR0aGlzLl91bmlmb3JtVGV4dHVyZXMgPSBbXTtcblx0XHR0aGlzLl9mYm87XG5cblx0XHR0aGlzLl9jbGVhckNvbG9yID0geyByOjAsIGc6MCwgYjowLCBhOjAgfTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblxuXHRzZXRDbGVhckNvbG9yKHI9MCwgZz0wLCBiPTAsIGE9MCkge1xuXHRcdHRoaXMuX2NsZWFyQ29sb3IuciA9IHI7XG5cdFx0dGhpcy5fY2xlYXJDb2xvci5nID0gZztcblx0XHR0aGlzLl9jbGVhckNvbG9yLmIgPSBiO1xuXHRcdHRoaXMuX2NsZWFyQ29sb3IuYSA9IGE7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG5cdHVzZVByb2dyYW0odnMsIGZzKSB7XG5cdFx0aWYodnMgaW5zdGFuY2VvZiBHTFNoYWRlcikge1xuXHRcdFx0dGhpcy5fc2hhZGVyID0gdnM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NoYWRlciA9IG5ldyBHTFNoYWRlcih2cywgZnMpO1x0XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblxuXHRzZXRNZXNoKG1NZXNoKSB7XG5cdFx0dGhpcy5fbWVzaCA9IG1NZXNoO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblxuXHRjcmVhdGVNZXNoKG1UeXBlKSB7XG5cdFx0dGhpcy5fbWVzaCA9IG5ldyBNZXNoKG1UeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cblx0YnVmZmVyVmVydGV4KG1BcnJheVZlcnRpY2VzKSB7XG5cdFx0aWYoIXRoaXMuX21lc2gpIHtcblx0XHRcdHRoaXMuX21lc2ggPSBuZXcgTWVzaCgpO1xuXHRcdH1cblx0XHR0aGlzLl9tZXNoLmJ1ZmZlclZlcnRleChtQXJyYXlWZXJ0aWNlcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG5cdGJ1ZmZlclRleENvb3JkKG1BcnJheVRleENvb3Jkcykge1xuXHRcdGlmKCF0aGlzLl9tZXNoKSB7XG5cdFx0XHR0aGlzLl9tZXNoID0gbmV3IE1lc2goKTtcblx0XHR9XG5cdFx0dGhpcy5fbWVzaC5idWZmZXJUZXhDb29yZChtQXJyYXlUZXhDb29yZHMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblxuXHRidWZmZXJOb3JtYWwobUFycmF5Tm9ybWFscykge1xuXHRcdGlmKCF0aGlzLl9tZXNoKSB7XG5cdFx0XHR0aGlzLl9tZXNoID0gbmV3IE1lc2goKTtcblx0XHR9XG5cdFx0dGhpcy5fbWVzaC5idWZmZXJOb3JtYWwobUFycmF5Tm9ybWFscyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG5cdGJ1ZmZlckluZGV4KG1JbmRpY2VzKSB7XG5cdFx0aWYoIXRoaXMuX21lc2gpIHtcblx0XHRcdHRoaXMuX21lc2ggPSBuZXcgTWVzaCgpO1xuXHRcdH1cblx0XHR0aGlzLl9tZXNoLmJ1ZmZlckluZGV4KG1JbmRpY2VzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGJ1ZmZlckluc3RhbmNlKG1EYXRhLCBtTmFtZSkge1xuXHRcdGlmKCF0aGlzLl9tZXNoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ05lZWQgdG8gY3JlYXRlIG1lc2ggZmlyc3QnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRoaXMuX21lc2guYnVmZmVySW5zdGFuY2UobURhdGEsIG1OYW1lKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblxuXHRidWZmZXJEYXRhKG1BcnJheURhdGEsIG1OYW1lKSB7XG5cdFx0aWYoIXRoaXMuX21lc2gpIHtcblx0XHRcdHRoaXMuX21lc2ggPSBuZXcgTWVzaCgpO1xuXHRcdH1cblx0XHR0aGlzLl9tZXNoLmJ1ZmZlckRhdGEobUFycmF5RGF0YSwgbU5hbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdFxuXG5cdHVuaWZvcm0obmFtZSwgdHlwZSwgdmFsdWUpIHtcblx0XHR0aGlzLl91bmlmb3Jtc1tuYW1lXSA9IHtcblx0XHRcdHR5cGUsXG5cdFx0XHR2YWx1ZVxuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG5cdHVuaWZvcm1UZXh0dXJlKG5hbWUsIHRleHR1cmUsIGluZGV4KSB7XG5cdFx0aWYoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fdW5pZm9ybVRleHR1cmVzW2luZGV4XSA9IHtcblx0XHRcdFx0bmFtZSxcblx0XHRcdFx0dGV4dHVyZVxuXHRcdFx0fTtcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl91bmlmb3JtVGV4dHVyZXMucHVzaCh7XG5cdFx0XHRcdG5hbWUsXG5cdFx0XHRcdHRleHR1cmVcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblxuXHRiaW5kRnJhbWVCdWZmZXIoZmJvKSB7XG5cdFx0dGhpcy5fZmJvID0gZmJvO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblxuXHRkcmF3KCkge1xuXHRcdGlmKCF0aGlzLl9zaGFkZXIpIHtcdHJldHVybjtcdH1cblx0XHRpZighdGhpcy5fbWVzaCkge1x0cmV0dXJuO1x0fVxuXG5cblx0XHRpZih0aGlzLl9mYm8pIHtcblx0XHRcdGNvbnN0IHsgciwgZywgYiwgYSB9ID0gdGhpcy5fY2xlYXJDb2xvcjtcblx0XHRcdHRoaXMuX2Ziby5iaW5kKCk7XG5cdFx0XHRHTC5jbGVhcihyLCBnLCBiLCBhKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zaGFkZXIuYmluZCgpO1xuXHRcdGZvcihjb25zdCBzIGluIHRoaXMuX3VuaWZvcm1zKSB7XG5cdFx0XHRjb25zdCBvID0gdGhpcy5fdW5pZm9ybXNbc107XG5cdFx0XHR0aGlzLl9zaGFkZXIudW5pZm9ybShzLCBvLnR5cGUsIG8udmFsdWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VuaWZvcm1UZXh0dXJlcy5mb3JFYWNoKChvLCBpKSA9PiB7XG5cdFx0XHRpZihvICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5fc2hhZGVyLnVuaWZvcm0oby5uYW1lLCAndW5pZm9ybTFpJywgaSk7XG5cdFx0XHRcdG8udGV4dHVyZS5iaW5kKGkpO1x0XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRHTC5kcmF3KHRoaXMuX21lc2gpO1xuXG5cdFx0aWYodGhpcy5fZmJvKSB7XG5cdFx0XHR0aGlzLl9mYm8udW5iaW5kKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG5cdGdldCBzaGFkZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NoYWRlcjtcblx0fVxuXG5cdGdldCBmcmFtZWJ1ZmZlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmJvO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyYXc7IiwiLy8gU2NlbmUuanNcblxuaW1wb3J0IENhbWVyYU9ydGhvIGZyb20gJy4uL2NhbWVyYXMvQ2FtZXJhT3J0aG8nO1xuaW1wb3J0IENhbWVyYVBlcnNwZWN0aXZlIGZyb20gJy4uL2NhbWVyYXMvQ2FtZXJhUGVyc3BlY3RpdmUnO1xuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgT3JiaXRhbENvbnRyb2wgZnJvbSAnLi4vdXRpbHMvT3JiaXRhbENvbnRyb2wnO1xuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJztcblxuY2xhc3MgU2NlbmUge1xuXG5cblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9tYXRyaXhJZGVudGl0eSA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0R0wuZW5hYmxlQWxwaGFCbGVuZGluZygpO1xuXG5cdFx0dGhpcy5faW5pdChvcHRpb25zKTtcblx0XHR0aGlzLl9pbml0VGV4dHVyZXMob3B0aW9ucyk7XG5cdFx0dGhpcy5faW5pdFZpZXdzKG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5fZWZJbmRleCA9IFNjaGVkdWxlci5hZGRFRigoKT0+dGhpcy5fbG9vcCgpKTtcblxuXHRcdHRoaXMuX3RhcmdldExpc3RlbmVyID0gb3B0aW9ucy5jb250YWluZXIgfHwgd2luZG93O1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKT0+dGhpcy5yZXNpemUoKSk7XG5cdH1cblx0XG5cblx0XG5cdC8vXHRQVUJMSUMgTUVUSE9EU1xuXG5cdHVwZGF0ZSgpIHtcblxuXHR9XG5cblx0cmVuZGVyKCkge1xuXG5cdH1cblxuXG5cdHN0b3AoKSB7XG5cdFx0aWYodGhpcy5fZWZJbmRleCA9PT0gLTEpIHtcdHJldHVybjsgfVxuXHRcdHRoaXMuX2VmSW5kZXggPSBTY2hlZHVsZXIucmVtb3ZlRUYodGhpcy5fZWZJbmRleCk7XG5cdH1cblxuXG5cdHN0YXJ0KCkge1xuXHRcdGlmKHRoaXMuX2VmSW5kZXggIT09IC0xKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSBcblxuXHRcdHRoaXMuX2VmSW5kZXggPSBTY2hlZHVsZXIuYWRkRUYoKCk9PnRoaXMuX2xvb3AoKSk7XG5cdH1cblxuXG5cdHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0R0wuc2V0U2l6ZSh3aWR0aCB8fCB3aW5kb3cuaW5uZXJXaWR0aCwgaGVpZ2h0IHx8IHdpbmRvdy5pbm5lckhlaWdodCk7XG5cdFx0dGhpcy5jYW1lcmEuc2V0QXNwZWN0UmF0aW8oR0wuYXNwZWN0UmF0aW8pO1xuXHR9XG5cblxuXHRhZGRDaGlsZChtQ2hpbGQpIHtcblx0XHR0aGlzLl9jaGlsZHJlbi5wdXNoKG1DaGlsZCk7XG5cdH1cblxuXHRyZW1vdmVDaGlsZChtQ2hpbGQpIHtcblx0XHRjb25zdCBpbmRleCA9IHRoaXMuX2NoaWxkcmVuLmluZGV4T2YobUNoaWxkKTtcblx0XHRpZihpbmRleCA9PSAtMSkge1x0Y29uc29sZS53YXJuKCdDaGlsZCBubyBleGlzdCcpOyByZXR1cm47XHR9XG5cblx0XHR0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG5cblxuXHQvL1x0UFJPVEVDVEVEIE1FVEhPRFMgVE8gQkUgT1ZFUlJJREVOIEJZIENISUxEUkVOXG5cblx0X2luaXRUZXh0dXJlcygpIHtcblxuXHR9XG5cblxuXHRfaW5pdFZpZXdzKCkge1xuXG5cdH1cblxuXG5cdF9yZW5kZXJDaGlsZHJlbigpIHtcblx0XHRsZXQgY2hpbGQ7XG5cdFx0Zm9yKGxldCBpPTA7IGk8dGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG5cdFx0XHRjaGlsZC50b1JlbmRlcigpO1xuXHRcdH1cblxuXHRcdEdMLnJvdGF0ZSh0aGlzLl9tYXRyaXhJZGVudGl0eSk7XG5cdH1cblxuXHQvL1x0UFJJVkFURSBNRVRIT0RTXG5cblx0X2luaXQob3B0aW9ucykge1xuXHRcdHRoaXMuY2FtZXJhICAgICAgICAgICAgICAgICA9IG5ldyBDYW1lcmFQZXJzcGVjdGl2ZSgpO1xuXHRcdHRoaXMuY2FtZXJhLnNldFBlcnNwZWN0aXZlKDQ1ICogTWF0aC5QSSAvIDE4MCwgR0wuYXNwZWN0UmF0aW8sIDAuMSwgMTAwKTtcblx0XHR0aGlzLm9yYml0YWxDb250cm9sICAgICAgICAgID0gbmV3IE9yYml0YWxDb250cm9sKHRoaXMuY2FtZXJhLCB0aGlzLl90YXJnZXRMaXN0ZW5lciwgMTUpO1xuXG5cdFx0Y29uc29sZS5sb2coJ29wdGlvbnMnLCBvcHRpb25zKTtcblx0XHRpZiAoIW9wdGlvbnMubm9Db250cm9sKSB7XG5cdFx0XHR0aGlzLm9yYml0YWxDb250cm9sLmNvbm5lY3QoKTtcblx0XHR9XG5cdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5yYWRpdXMudmFsdWUgPSAxMDtcblx0XHRcblx0XHR0aGlzLmNhbWVyYU9ydGhvICAgICAgICAgICAgPSBuZXcgQ2FtZXJhT3J0aG8oKTtcblx0fVxuXG5cdF9sb29wKCkge1xuXG5cdFx0Ly9cdFJFU0VUIFZJRVdQT1JUXG5cdFx0R0wudmlld3BvcnQoMCwgMCwgR0wud2lkdGgsIEdMLmhlaWdodCk7XG5cblx0XHQvL1x0UkVTRVQgQ0FNRVJBXG5cdFx0R0wuc2V0TWF0cmljZXModGhpcy5jYW1lcmEpO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblx0XHR0aGlzLl9yZW5kZXJDaGlsZHJlbigpO1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cdH1cblxuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMub3JiaXRhbENvbnRyb2wuZGlzY29ubmVjdCgpO1xuXHRcdGFsZnJpZC5TY2hlZHVsZXIucmVtb3ZlRUYodGhpcy5fZWZJbmRleCk7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpPT50aGlzLnJlc2l6ZSgpKTtcblx0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgU2NlbmU7IiwiLy8gVmlldy5qc1xuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuXG5jbGFzcyBWaWV3IHtcblx0Y29uc3RydWN0b3IobVN0clZlcnRleCwgbVN0ckZyYWcpIHtcblx0XHR0aGlzLnNoYWRlciA9IG5ldyBHTFNoYWRlcihtU3RyVmVydGV4LCBtU3RyRnJhZyk7XG5cblx0XHR0aGlzLl9pbml0KCk7XG5cdH1cblxuXG5cdC8vXHRQUk9URUNURUQgTUVUSE9EU1xuXG5cdF9pbml0KCkge1xuXG5cdH1cblxuXHQvLyBcdFBVQkxJQyBNRVRIT0RTXG5cblx0cmVuZGVyKCkge1xuXG5cdH1cblxuXHRkZXN0cm95KCkge1xuXHRcdGNvbnN0IGdsID0gR0wuZ2w7XG5cblx0XHRnbC51c2VQcm9ncmFtKG51bGwpO1xuXHRcdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5zaGFkZXIuc2hhZGVyUHJvZ3JhbSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlldzsiLCIvLyBWaWV3M0QuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IE9iamVjdDNEIGZyb20gJy4uL29iamVjdHMvT2JqZWN0M0QnO1xuXG5jbGFzcyBWaWV3M0QgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdGNvbnN0cnVjdG9yKG1TdHJWZXJ0ZXgsIG1TdHJGcmFnKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5zaGFkZXIgPSBuZXcgR0xTaGFkZXIobVN0clZlcnRleCwgbVN0ckZyYWcpO1xuXHRcdHRoaXMuX2luaXQoKTtcblx0fVxuXG5cblx0Ly9cdFBST1RFQ1RFRCBNRVRIT0RTXG5cblx0X2luaXQoKSB7XG5cblx0fVxuXG5cdC8vIFx0UFVCTElDIE1FVEhPRFNcblxuXHRyZW5kZXIoKSB7XG5cdH1cblxuXHRkZXN0cm95KCkge1xuXHRcdGNvbnN0IGdsID0gR0wuZ2w7XG5cblx0XHRnbC51c2VQcm9ncmFtKG51bGwpO1xuXHRcdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5zaGFkZXIuc2hhZGVyUHJvZ3JhbSk7XG5cdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFZpZXczRDsiLCIvLyBCaW5hcnlMb2FkZXIuanNcblxuY2xhc3MgQmluYXJ5TG9hZGVyIHtcblxuXHRjb25zdHJ1Y3Rvcihpc0FycmF5QnVmZmVyID0gZmFsc2UpIHtcblx0XHR0aGlzLl9yZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR0aGlzLl9yZXEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChlKT0+dGhpcy5fb25Mb2FkZWQoZSkpO1xuXHRcdHRoaXMuX3JlcS5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIChlKT0+dGhpcy5fb25Qcm9ncmVzcyhlKSk7XG5cdFx0aWYoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5fcmVxLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdFx0fVxuXHR9XHRcblxuXG5cdGxvYWQodXJsLCBjYWxsYmFjaykge1xuXHRcdGNvbnNvbGUubG9nKCdMb2FkaW5nIDogJywgdXJsKTtcblx0XHR0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0dGhpcy5fcmVxLm9wZW4oJ0dFVCcsIHVybCk7XG5cdFx0dGhpcy5fcmVxLnNlbmQoKTtcblx0fVxuXG5cblx0X29uTG9hZGVkKCkge1xuXHRcdHRoaXMuX2NhbGxiYWNrKHRoaXMuX3JlcS5yZXNwb25zZSk7XG5cdH1cblxuXHRfb25Qcm9ncmVzcygvKiBlKi8pIHtcblx0XHQvLyBjb25zb2xlLmxvZygnb24gUHJvZ3Jlc3M6JywgKGUubG9hZGVkL2UudG90YWwqMTAwKS50b0ZpeGVkKDIpKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCaW5hcnlMb2FkZXI7IiwiLy8gR0xURlBhcnNlci5qc1xuXG5pbXBvcnQgTWVzaCBmcm9tICcuLi9NZXNoJztcblxuY29uc3QgQVJSQVlfQ1RPUl9NQVAgPSB7XG5cdDUxMjA6IEludDhBcnJheSxcblx0NTEyMTogVWludDhBcnJheSxcblx0NTEyMjogSW50MTZBcnJheSxcblx0NTEyMzogVWludDE2QXJyYXksXG5cdDUxMjU6IFVpbnQzMkFycmF5LFxuXHQ1MTI2OiBGbG9hdDMyQXJyYXlcbn07XG5cbmNvbnN0IFNJWkVfTUFQID0ge1xuXHRTQ0FMQVI6IDEsXG5cdFZFQzI6IDIsXG5cdFZFQzM6IDMsXG5cdFZFQzQ6IDQsXG5cdE1BVDI6IDQsXG5cdE1BVDM6IDksXG5cdE1BVDQ6IDE2XG59O1xuXG5jb25zdCBzZW1hbnRpY0F0dHJpYnV0ZU1hcCA9IHtcblx0Tk9STUFMOiAnYU5vcm1hbCcsXG5cdFBPU0lUSU9OOiAnYVZlcnRleFBvc2l0aW9uJyxcblx0Ly8gJ1RBTkdFTlQnOiAnYVRhbmdlbnQnLFxuXHRURVhDT09SRF8wOiAnYVRleHR1cmVDb29yZCcsXG5cdC8vIFRFWENPT1JEXzE6ICdhVGV4dHVyZUNvb3JkMScsXG5cdFdFSUdIVFNfMDogJ2FXZWlnaHQnLFxuXHRKT0lOVFNfMDogJ2FKb2ludCcsXG5cdENPTE9SOiAnYUNvbG9yJ1xufTtcblxuXG5jb25zdCBwYXJzZSA9IChnbHRmLCBiaW4pID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuXHRnbHRmLm91dHB1dCA9IHtcblx0XHRtZXNoZXM6W10sXG5cdFx0c2NlbmVzOltdLFxuXHRcdHRleHR1cmVzOltdXG5cdH07XG5cblx0X2dldEJ1ZmZlclZpZXdEYXRhKGdsdGYsIGJpbilcblx0XHQudGhlbihfcGFyc2VNZXNoKVxuXHRcdC50aGVuKChnbHRmSW5mbyk9Pntcblx0XHRcdHJlc29sdmUoZ2x0ZkluZm8pO1xuXHRcdH0pXG5cdFx0LmNhdGNoKGUgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coJ0Vycm9yOicsIGUpO1xuXHRcdH0pO1xuXHQvLyByZXNvbHZlKG8pO1xufSk7XG5cblxuXG5cbmNvbnN0IF9nZXRCdWZmZXJWaWV3RGF0YSA9IChnbHRmSW5mbywgYmluKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHsgYnVmZmVyVmlld3MsIGJ1ZmZlcnMgfSA9IGdsdGZJbmZvO1xuXG5cblx0YnVmZmVyVmlld3MuZm9yRWFjaCgoYnVmZmVyVmlld0luZm8sIGkpID0+IHtcblx0XHRjb25zdCBidWZmZXIgPSBiaW47XG5cdFx0YnVmZmVyVmlld0luZm8uZGF0YSA9IGJ1ZmZlci5zbGljZShidWZmZXJWaWV3SW5mby5ieXRlT2Zmc2V0IHx8IDAsIChidWZmZXJWaWV3SW5mby5ieXRlT2Zmc2V0IHx8IDApICsgKGJ1ZmZlclZpZXdJbmZvLmJ5dGVMZW5ndGggfHwgMCkpO1xuXHR9KTtcblx0cmVzb2x2ZShnbHRmSW5mbyk7XG59KTtcblxuY29uc3QgX3BhcnNlTWVzaCA9IChnbHRmKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHsgbWVzaGVzIH0gPSBnbHRmO1xuXHRnbHRmLmdlb21ldHJpZXMgPSBbXTtcblx0XG5cblx0bWVzaGVzLmZvckVhY2goKG1lc2gsIGkpID0+IHtcblx0XHRjb25zdCB7IHByaW1pdGl2ZXMgfSA9IG1lc2g7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHt9O1xuXG5cdFx0cHJpbWl0aXZlcy5mb3JFYWNoKChwcmltaXRpdmVJbmZvLCBpKSA9PiB7XG5cdFx0XHRjb25zdCBzZW1hbnRpY3MgPSBPYmplY3Qua2V5cyhwcmltaXRpdmVJbmZvLmF0dHJpYnV0ZXMpO1xuXHRcdFx0bGV0IGRlZmluZXMgPSB7fTtcblxuXHRcdFx0c2VtYW50aWNzLmZvckVhY2goKHNlbWFudGljLCBpKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGFjY2Vzc29ySWR4ID0gcHJpbWl0aXZlSW5mby5hdHRyaWJ1dGVzW3NlbWFudGljXTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlSW5mbyA9IGdsdGYuYWNjZXNzb3JzW2FjY2Vzc29ySWR4XTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlTmFtZSA9IHNlbWFudGljQXR0cmlidXRlTWFwW3NlbWFudGljXTtcblx0XHRcdFx0aWYoIWF0dHJpYnV0ZU5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoc2VtYW50aWMgPT09ICdOT1JNQUwnKSB7XG5cdFx0XHRcdFx0ZGVmaW5lcy5IQVNfTk9STUFMUyA9IDE7XG5cdFx0XHRcdH0gXG5cdFx0XHRcdGlmKHNlbWFudGljLmluZGV4T2YoJ1RFWENPT1JEJykgPiAtMSkge1xuXHRcdFx0XHRcdGRlZmluZXMuSEFTX1VWID0gMTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Y29uc3Qgc2l6ZSA9IFNJWkVfTUFQW2F0dHJpYnV0ZUluZm8udHlwZV07XG5cdFx0XHRcdGxldCBhdHRyaWJ1dGVBcnJheSA9IF9nZXRBY2Nlc3NvckRhdGEoZ2x0ZiwgYWNjZXNzb3JJZHgpO1xuXHRcdFx0XHRpZiAoYXR0cmlidXRlQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShhdHRyaWJ1dGVBcnJheSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihzZW1hbnRpYyA9PT0gJ1RFWENPT1JEXzEnKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coc2l6ZSwgYXR0cmlidXRlQXJyYXkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnlbYXR0cmlidXRlTmFtZV0gPSB7XG5cdFx0XHRcdFx0dmFsdWU6YXR0cmlidXRlQXJyYXksXG5cdFx0XHRcdFx0c2l6ZSxcblx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2F0dHJpYnV0ZScsIGF0dHJpYnV0ZU5hbWUsIGdlb21ldHJ5W2F0dHJpYnV0ZU5hbWVdKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvL1x0cGFyc2UgaW5kZXhcblx0XHRcdGlmIChwcmltaXRpdmVJbmZvLmluZGljZXMgIT0gbnVsbCkge1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVBcnJheSA9IF9nZXRBY2Nlc3NvckRhdGEoZ2x0ZiwgcHJpbWl0aXZlSW5mby5pbmRpY2VzLCB0cnVlKTtcblx0XHRcdFx0Z2VvbWV0cnkuaW5kaWNlcyA9IHtcblx0XHRcdFx0XHR2YWx1ZTphdHRyaWJ1dGVBcnJheSxcblx0XHRcdFx0XHRzaXplOjFcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbSA9IG5ldyBNZXNoKCk7XG5cblx0XHRcdGZvcihjb25zdCBzIGluIGdlb21ldHJ5KSB7XG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBnZW9tZXRyeVtzXTtcblx0XHRcdFx0aWYocyAhPT0gJ2luZGljZXMnKSB7XG5cdFx0XHRcdFx0bS5idWZmZXJGbGF0dGVuRGF0YShkYXRhLnZhbHVlLCBzLCBkYXRhLnNpemUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG0uYnVmZmVySW5kZXgoZGF0YS52YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Z2x0Zi5vdXRwdXQubWVzaGVzLnB1c2gobSk7XG5cdFx0XHRpZiAocHJpbWl0aXZlSW5mby5tYXRlcmlhbCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnZ2x0Zi5vdXRwdXQnLCBnbHRmLm91dHB1dCwgcHJpbWl0aXZlSW5mby5tYXRlcmlhbCk7XG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gZ2x0Zi5vdXRwdXQubWF0ZXJpYWxzW3ByaW1pdGl2ZUluZm8ubWF0ZXJpYWxdO1xuXHRcdFx0XHRtLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdFx0XHRcdGRlZmluZXMgPSBvYmplY3RBc3NpZ24oZGVmaW5lcywgbS5tYXRlcmlhbC5kZWZpbmVzKTtcblxuXHRcdFx0XHRtLmRlZmluZXMgPSBkZWZpbmVzO1xuXG5cdFx0XHRcdGNvbnN0IHNoYWRlciA9IFNoYWRlcnMuZ2V0KFNoYWRlckxpYnMuZ2x0ZlZlcnQsIFNoYWRlckxpYnMuZ2x0ZkZyYWcsIGRlZmluZXMpO1xuXG5cdFx0XHRcdGNvbnN0IHtcblx0XHRcdFx0XHRlbWlzc2l2ZUZhY290cixcblx0XHRcdFx0XHRub3JtYWxUZXh0dXJlLFxuXHRcdFx0XHRcdG9jY2x1c2lvblRleHR1cmUsXG5cdFx0XHRcdFx0cGJyTWV0YWxsaWNSb3VnaG5lc3MsXG5cdFx0XHRcdH0gPSBtYXRlcmlhbDtcblxuXHRcdFx0XHRjb25zdCB7XG5cdFx0XHRcdFx0YmFzZUNvbG9yVGV4dHVyZSxcblx0XHRcdFx0XHRtZXRhbGxpY1JvdWdobmVzc1RleHR1cmVcblx0XHRcdFx0fSA9IHBick1ldGFsbGljUm91Z2huZXNzO1xuXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdHVFbWlzc2l2ZUZhY3RvcjplbWlzc2l2ZUZhY290ciB8fCBbMCwgMCwgMF0sXG5cdFx0XHRcdFx0dUJhc2VDb2xvcjpwYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IgfHwgWzEsIDEsIDEsIDFdLFxuXHRcdFx0XHRcdHVSb3VnaG5lc3M6cGJyTWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yIHx8IDEsXG5cdFx0XHRcdFx0dU1ldGFsbGljOnBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yIHx8IDEsXG5cdFx0XHRcdFx0dVNjYWxlRGlmZkJhc2VNUjpbMCwgMCwgMCwgMF0sXG5cdFx0XHRcdFx0dVNjYWxlRkdEU3BlYzpbMCwgMCwgMCwgMF0sXG5cdFx0XHRcdFx0dVNjYWxlSUJMQW1iaWVudDpbMSwgMSwgMSwgMV0sXG5cdFx0XHRcdFx0dUxpZ2h0RGlyZWN0aW9uOlsxLCAxLCAxXSxcblx0XHRcdFx0XHR1TGlnaHRDb2xvcjpbMSwgMSwgMV0sXG5cdFx0XHRcdFx0dUdhbW1hOjFcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAoYmFzZUNvbG9yVGV4dHVyZSkge1xuXHRcdFx0XHRcdHVuaWZvcm1zLnVDb2xvck1hcCA9IGJhc2VDb2xvclRleHR1cmUuZ2xUZXh0dXJlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkge1xuXHRcdFx0XHRcdHVuaWZvcm1zLnVNZXRhbGxpY1JvdWdobmVzc01hcCA9IG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZS5nbFRleHR1cmU7XHRcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChub3JtYWxUZXh0dXJlKSB7XG5cdFx0XHRcdFx0dW5pZm9ybXMudU5vcm1hbFNjYWxlID0gbm9ybWFsVGV4dHVyZS5zY2FsZSB8fCAxO1xuXHRcdFx0XHRcdHVuaWZvcm1zLnVOb3JtYWxNYXAgPSBub3JtYWxUZXh0dXJlLmdsVGV4dHVyZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvY2NsdXNpb25UZXh0dXJlKSB7XG5cdFx0XHRcdFx0dW5pZm9ybXMudUFvTWFwID0gb2NjbHVzaW9uVGV4dHVyZS5nbFRleHR1cmU7XG5cdFx0XHRcdFx0dW5pZm9ybXMudU9jY2x1c2lvblN0cmVuZ3RoID0gb2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aCB8fCAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2hhZGVyLmJpbmQoKTtcblx0XHRcdFx0c2hhZGVyLnVuaWZvcm0odW5pZm9ybXMpO1xuXG5cblx0XHRcdFx0bS5tYXRlcmlhbC5zaGFkZXIgPSBzaGFkZXI7XG5cdFx0XHRcdG0ubWF0ZXJpYWwudW5pZm9ybXMgPSB1bmlmb3Jtcztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Z2x0Zi5nZW9tZXRyaWVzLnB1c2goZ2VvbWV0cnkpO1xuXHRcdH0pO1xuXHR9KTtcblxuXHRyZXNvbHZlKGdsdGYpO1xufSk7XG5cbmNvbnN0IF9nZXRBY2Nlc3NvckRhdGEgPSAoZ2x0ZiwgYWNjZXNzb3JJZHgsIGlzSW5kaWNlcyA9IGZhbHNlKSA9PiB7XG5cdGNvbnN0IGFjY2Vzc29ySW5mbyA9IGdsdGYuYWNjZXNzb3JzW2FjY2Vzc29ySWR4XTtcblx0Y29uc3QgYnVmZmVyID0gZ2x0Zi5idWZmZXJWaWV3c1thY2Nlc3NvckluZm8uYnVmZmVyVmlld10uZGF0YTtcblx0Y29uc3QgYnl0ZU9mZnNldCA9IGFjY2Vzc29ySW5mby5ieXRlT2Zmc2V0IHx8IDA7XG5cdGNvbnN0IEFycmF5Q3RvciA9IEFSUkFZX0NUT1JfTUFQW2FjY2Vzc29ySW5mby5jb21wb25lbnRUeXBlXSB8fCBGbG9hdDMyQXJyYXk7XG5cdGxldCBzaXplID0gU0laRV9NQVBbYWNjZXNzb3JJbmZvLnR5cGVdO1xuXHRpZiAoc2l6ZSA9PSBudWxsICYmIGlzSW5kaWNlcykge1xuXHRcdHNpemUgPSAxO1xuXHR9XG5cdGxldCBhcnIgPSBuZXcgQXJyYXlDdG9yKGJ1ZmZlciwgYnl0ZU9mZnNldCwgc2l6ZSAqIGFjY2Vzc29ySW5mby5jb3VudCk7XG5cdGNvbnN0IHF1YW50aXplRXh0ZW5zaW9uID0gYWNjZXNzb3JJbmZvLmV4dGVuc2lvbnMgJiYgYWNjZXNzb3JJbmZvLmV4dGVuc2lvbnNbJ1dFQjNEX3F1YW50aXplZF9hdHRyaWJ1dGVzJ107XG5cdGlmIChxdWFudGl6ZUV4dGVuc2lvbikge1xuXHRcdGNvbnN0IGRlY29kZWRBcnIgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiBhY2Nlc3NvckluZm8uY291bnQpO1xuXHRcdGNvbnN0IGRlY29kZU1hdHJpeCA9IHF1YW50aXplRXh0ZW5zaW9uLmRlY29kZU1hdHJpeDtcblx0XHRjb25zdCBkZWNvZGVPZmZzZXQgPSBuZXcgQXJyYXkoc2l6ZSk7XG5cdFx0Y29uc3QgZGVjb2RlU2NhbGUgPSBuZXcgQXJyYXkoc2l6ZSk7XG5cdFx0Zm9yIChsZXQgayA9IDA7IGsgPCBzaXplOyBrKyspIHtcblx0XHRcdGRlY29kZU9mZnNldFtrXSA9IGRlY29kZU1hdHJpeFtzaXplICogKHNpemUgKyAxKSArIGtdO1xuXHRcdFx0ZGVjb2RlU2NhbGVba10gPSBkZWNvZGVNYXRyaXhbayAqIChzaXplICsgMSkgKyBrXTtcblx0XHR9XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhY2Nlc3NvckluZm8uY291bnQ7IGkrKykge1xuXHRcdFx0Zm9yIChsZXQgayA9IDA7IGsgPCBzaXplOyBrKyspIHtcblx0XHRcdFx0ZGVjb2RlZEFycltpICogc2l6ZSArIGtdID0gYXJyW2kgKiBzaXplICsga10gKiBkZWNvZGVTY2FsZVtrXSArIGRlY29kZU9mZnNldFtrXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhcnIgPSBkZWNvZGVkQXJyO1xuXHR9XG5cblx0Ly8gY29uc29sZS5sb2coe2J1ZmZlciwgYnl0ZU9mZnNldCwgQXJyYXlDdG9yLCBzaXplLCBhcnJ9KTtcblxuXHRyZXR1cm4gYXJyO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRwYXJzZVxufTsiLCIvLyBIRFJMb2FkZXIuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQmluYXJ5TG9hZGVyIGZyb20gJy4vQmluYXJ5TG9hZGVyJztcbmltcG9ydCBoZHJQYXJzZXIgZnJvbSAnLi4vdXRpbHMvSERSUGFyc2VyJztcblxuY2xhc3MgSERSTG9hZGVyIGV4dGVuZHMgQmluYXJ5TG9hZGVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIodHJ1ZSk7XG5cdH1cblxuXHRwYXJzZShtQXJyYXlCdWZmZXIpIHtcblx0XHRyZXR1cm4gaGRyUGFyc2VyKG1BcnJheUJ1ZmZlcik7XG5cdH1cblxuXHRfb25Mb2FkZWQoKSB7XG5cdFx0Y29uc3QgbyA9IHRoaXMucGFyc2UodGhpcy5fcmVxLnJlc3BvbnNlKTtcblx0XHRpZih0aGlzLl9jYWxsYmFjaykge1xuXHRcdFx0dGhpcy5fY2FsbGJhY2sobyk7XG5cdFx0fVxuXHR9XG5cbn1cblxuXG5IRFJMb2FkZXIucGFyc2UgPSBmdW5jdGlvbiAobUFycmF5QnVmZmVyKSB7XG5cdHJldHVybiBoZHJQYXJzZXIobUFycmF5QnVmZmVyKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhEUkxvYWRlcjsiLCIvLyBPYmpMb2FkZXIuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQmluYXJ5TG9hZGVyIGZyb20gJy4vQmluYXJ5TG9hZGVyJztcbmltcG9ydCBNZXNoIGZyb20gJy4uL01lc2gnO1xuXG5jbGFzcyBPYmpMb2FkZXIgZXh0ZW5kcyBCaW5hcnlMb2FkZXIge1xuXG5cdGxvYWQodXJsLCBjYWxsYmFjaywgZHJhd1R5cGUgPSA0KSB7XG5cdFx0dGhpcy5fZHJhd1R5cGUgPSBkcmF3VHlwZTtcblx0XHRzdXBlci5sb2FkKHVybCwgY2FsbGJhY2spO1xuXHR9XG5cblx0X29uTG9hZGVkKCkge1xuXHRcdHRoaXMucGFyc2VPYmoodGhpcy5fcmVxLnJlc3BvbnNlKTtcblx0fVxuXG5cdHBhcnNlT2JqKG9ialN0cikge1xuXHRcdGNvbnN0IGxpbmVzID0gb2JqU3RyLnNwbGl0KCdcXG4nKTtcblxuXHRcdGNvbnN0IHBvc2l0aW9ucyAgICA9IFtdO1xuXHRcdGNvbnN0IGNvb3JkcyAgICAgICA9IFtdO1xuXHRcdGNvbnN0IGZpbmFsTm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzICAgICA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgICAgICA9IFtdO1xuXHRcdGNvbnN0IHV2cyAgICAgICAgICA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgICAgICA9IFtdO1xuXHRcdGxldCBjb3VudCAgICAgICAgPSAwO1xuXHRcdGxldCByZXN1bHQ7XG5cblx0XHQvLyB2IGZsb2F0IGZsb2F0IGZsb2F0XG5cdFx0Y29uc3QgdmVydGV4UGF0dGVybiA9IC92KCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKSggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspLztcblxuXHRcdC8vIHZuIGZsb2F0IGZsb2F0IGZsb2F0XG5cdFx0Y29uc3Qgbm9ybWFsUGF0dGVybiA9IC92biggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKS87XG5cblx0XHQvLyB2dCBmbG9hdCBmbG9hdFxuXHRcdGNvbnN0IHV2UGF0dGVybiA9IC92dCggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykvO1xuXG5cdFx0Ly8gZiB2ZXJ0ZXggdmVydGV4IHZlcnRleCAuLi5cblx0XHRjb25zdCBmYWNlUGF0dGVybjEgPSAvZiggKy0/XFxkKykoICstP1xcZCspKCArLT9cXGQrKSggKy0/XFxkKyk/LztcblxuXHRcdC8vIGYgdmVydGV4L3V2IHZlcnRleC91diB2ZXJ0ZXgvdXYgLi4uXG5cdFx0Y29uc3QgZmFjZVBhdHRlcm4yID0gL2YoICsoLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspKT8vO1xuXG5cdFx0Ly8gZiB2ZXJ0ZXgvdXYvbm9ybWFsIHZlcnRleC91di9ub3JtYWwgdmVydGV4L3V2L25vcm1hbCAuLi5cblx0XHRjb25zdCBmYWNlUGF0dGVybjMgPSAvZiggKygtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSk/LztcblxuXHRcdC8vIGYgdmVydGV4Ly9ub3JtYWwgdmVydGV4Ly9ub3JtYWwgdmVydGV4Ly9ub3JtYWwgLi4uIFxuXHRcdGNvbnN0IGZhY2VQYXR0ZXJuNCA9IC9mKCArKC0/XFxkKylcXC9cXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcL1xcLygtP1xcZCspKSggKygtP1xcZCspXFwvXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC9cXC8oLT9cXGQrKSk/LztcblxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VWZXJ0ZXhJbmRleCh2YWx1ZSkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gKGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIHZlcnRpY2VzLmxlbmd0aCAvIDMpICogMztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZU5vcm1hbEluZGV4KHZhbHVlKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IHBhcnNlSW50KHZhbHVlKTtcblx0XHRcdHJldHVybiAoaW5kZXggPj0gMCA/IGluZGV4IC0gMSA6IGluZGV4ICsgbm9ybWFscy5sZW5ndGggLyAzKSAqIDM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VVVkluZGV4KHZhbHVlKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IHBhcnNlSW50KHZhbHVlKTtcblx0XHRcdHJldHVybiAoaW5kZXggPj0gMCA/IGluZGV4IC0gMSA6IGluZGV4ICsgdXZzLmxlbmd0aCAvIDIpICogMjtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIGFkZFZlcnRleChhLCBiLCBjKSB7XG5cdFx0XHRwb3NpdGlvbnMucHVzaChbdmVydGljZXNbYV0sIHZlcnRpY2VzW2EgKyAxXSwgdmVydGljZXNbYSArIDJdXSk7XG5cdFx0XHRwb3NpdGlvbnMucHVzaChbdmVydGljZXNbYl0sIHZlcnRpY2VzW2IgKyAxXSwgdmVydGljZXNbYiArIDJdXSk7XG5cdFx0XHRwb3NpdGlvbnMucHVzaChbdmVydGljZXNbY10sIHZlcnRpY2VzW2MgKyAxXSwgdmVydGljZXNbYyArIDJdXSk7XG5cblx0XHRcdGluZGljZXMucHVzaChjb3VudCAqIDMgKyAwKTtcblx0XHRcdGluZGljZXMucHVzaChjb3VudCAqIDMgKyAxKTtcblx0XHRcdGluZGljZXMucHVzaChjb3VudCAqIDMgKyAyKTtcblxuXHRcdFx0Y291bnQgKys7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBhZGRVVihhLCBiLCBjKSB7XG5cdFx0XHRjb29yZHMucHVzaChbdXZzW2FdLCB1dnNbYSArIDFdXSk7XG5cdFx0XHRjb29yZHMucHVzaChbdXZzW2JdLCB1dnNbYiArIDFdXSk7XG5cdFx0XHRjb29yZHMucHVzaChbdXZzW2NdLCB1dnNbYyArIDFdXSk7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBhZGROb3JtYWwoYSwgYiwgYykge1xuXHRcdFx0ZmluYWxOb3JtYWxzLnB1c2goW25vcm1hbHNbYV0sIG5vcm1hbHNbYSArIDFdLCBub3JtYWxzW2EgKyAyXV0pO1xuXHRcdFx0ZmluYWxOb3JtYWxzLnB1c2goW25vcm1hbHNbYl0sIG5vcm1hbHNbYiArIDFdLCBub3JtYWxzW2IgKyAyXV0pO1xuXHRcdFx0ZmluYWxOb3JtYWxzLnB1c2goW25vcm1hbHNbY10sIG5vcm1hbHNbYyArIDFdLCBub3JtYWxzW2MgKyAyXV0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEZhY2UoYSwgYiwgYywgZCwgIHVhLCB1YiwgdWMsIHVkLCAgbmEsIG5iLCBuYywgbmQpIHtcblx0XHRcdGxldCBpYSA9IHBhcnNlVmVydGV4SW5kZXgoYSk7XG5cdFx0XHRsZXQgaWIgPSBwYXJzZVZlcnRleEluZGV4KGIpO1xuXHRcdFx0bGV0IGljID0gcGFyc2VWZXJ0ZXhJbmRleChjKTtcblx0XHRcdGxldCBpZDtcblxuXHRcdFx0aWYgKGQgPT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRcdGFkZFZlcnRleChpYSwgaWIsIGljKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZCA9IHBhcnNlVmVydGV4SW5kZXgoZCk7XG5cblx0XHRcdFx0YWRkVmVydGV4KGlhLCBpYiwgaWQpO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoaWIsIGljLCBpZCk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRpZiAodWEgIT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRcdGlhID0gcGFyc2VVVkluZGV4KHVhKTtcblx0XHRcdFx0aWIgPSBwYXJzZVVWSW5kZXgodWIpO1xuXHRcdFx0XHRpYyA9IHBhcnNlVVZJbmRleCh1Yyk7XG5cblx0XHRcdFx0aWYgKGQgPT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRcdFx0YWRkVVYoaWEsIGliLCBpYyk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlkID0gcGFyc2VVVkluZGV4KHVkKTtcblxuXHRcdFx0XHRcdGFkZFVWKGlhLCBpYiwgaWQpO1xuXHRcdFx0XHRcdGFkZFVWKGliLCBpYywgaWQpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmEgIT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRcdGlhID0gcGFyc2VOb3JtYWxJbmRleChuYSk7XG5cdFx0XHRcdGliID0gcGFyc2VOb3JtYWxJbmRleChuYik7XG5cdFx0XHRcdGljID0gcGFyc2VOb3JtYWxJbmRleChuYyk7XG5cblx0XHRcdFx0aWYgKGQgPT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRcdFx0YWRkTm9ybWFsKGlhLCBpYiwgaWMpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZCA9IHBhcnNlTm9ybWFsSW5kZXgobmQpO1xuXG5cdFx0XHRcdFx0YWRkTm9ybWFsKGlhLCBpYiwgaWQpO1xuXHRcdFx0XHRcdGFkZE5vcm1hbChpYiwgaWMsIGlkKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrKSB7XG5cdFx0XHRsZXQgbGluZSA9IGxpbmVzW2ldO1xuXHRcdFx0bGluZSA9IGxpbmUudHJpbSgpO1xuXG5cdFx0XHRpZiAobGluZS5sZW5ndGggPT09IDAgfHwgbGluZS5jaGFyQXQoMCkgPT09ICcjJykge1xuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKChyZXN1bHQgPSB2ZXJ0ZXhQYXR0ZXJuLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsxXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbMl0pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzNdKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKChyZXN1bHQgPSBub3JtYWxQYXR0ZXJuLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzFdKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsyXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbM10pXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IHV2UGF0dGVybi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdHV2cy5wdXNoKFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzFdKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsyXSlcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gZmFjZVBhdHRlcm4xLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cblx0XHRcdFx0YWRkRmFjZShcblx0XHRcdFx0XHRyZXN1bHRbMV0sIHJlc3VsdFsyXSwgcmVzdWx0WzNdLCByZXN1bHRbNF1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gZmFjZVBhdHRlcm4yLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cblx0XHRcdFx0YWRkRmFjZShcblx0XHRcdFx0XHRyZXN1bHRbMl0sIHJlc3VsdFs1XSwgcmVzdWx0WzhdLCByZXN1bHRbMTFdLFxuXHRcdFx0XHRcdHJlc3VsdFszXSwgcmVzdWx0WzZdLCByZXN1bHRbOV0sIHJlc3VsdFsxMl1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gZmFjZVBhdHRlcm4zLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WzJdLCByZXN1bHRbNl0sIHJlc3VsdFsxMF0sIHJlc3VsdFsxNF0sXG5cdFx0XHRcdFx0cmVzdWx0WzNdLCByZXN1bHRbN10sIHJlc3VsdFsxMV0sIHJlc3VsdFsxNV0sXG5cdFx0XHRcdFx0cmVzdWx0WzRdLCByZXN1bHRbOF0sIHJlc3VsdFsxMl0sIHJlc3VsdFsxNl1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gZmFjZVBhdHRlcm40LmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WzJdLCByZXN1bHRbNV0sIHJlc3VsdFs4XSwgcmVzdWx0WzExXSxcblx0XHRcdFx0XHR1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsXG5cdFx0XHRcdFx0cmVzdWx0WzNdLCByZXN1bHRbNl0sIHJlc3VsdFs5XSwgcmVzdWx0WzEyXVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IFxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9nZW5lcmF0ZU1lc2hlcyh7XHRcblx0XHRcdHBvc2l0aW9ucyxcblx0XHRcdGNvb3Jkcyxcblx0XHRcdG5vcm1hbHM6ZmluYWxOb3JtYWxzLFxuXHRcdFx0aW5kaWNlc1xuXHRcdH0pO1xuXHRcdFxuXHR9XG5cblx0X2dlbmVyYXRlTWVzaGVzKG8pIHtcblx0XHRjb25zdCBtYXhOdW1WZXJ0aWNlcyA9IDY1NTM1O1xuXHRcdGNvbnN0IGhhc05vcm1hbHMgPSBvLm5vcm1hbHMubGVuZ3RoID4gMDtcblx0XHRjb25zdCBoYXNVVnMgPSBvLmNvb3Jkcy5sZW5ndGggPiAwO1xuXHRcdGxldCBtZXNoO1xuXG5cdFx0aWYoby5wb3NpdGlvbnMubGVuZ3RoID4gbWF4TnVtVmVydGljZXMpIHtcblx0XHRcdGNvbnN0IG1lc2hlcyA9IFtdO1xuXHRcdFx0bGV0IGxhc3RJbmRleCA9IDA7XG5cblx0XHRcdGNvbnN0IG9Db3B5ICAgICAgID0ge307XG5cdFx0XHRvQ29weS5wb3NpdGlvbnMgPSBvLnBvc2l0aW9ucy5jb25jYXQoKTtcblx0XHRcdG9Db3B5LmNvb3JkcyAgICA9IG8uY29vcmRzLmNvbmNhdCgpO1xuXHRcdFx0b0NvcHkuaW5kaWNlcyAgID0gby5pbmRpY2VzLmNvbmNhdCgpO1xuXHRcdFx0b0NvcHkubm9ybWFscyAgID0gby5ub3JtYWxzLmNvbmNhdCgpO1xuXG5cdFx0XHR3aGlsZShvLmluZGljZXMubGVuZ3RoID4gMCkge1xuXG5cdFx0XHRcdGNvbnN0IHNsaWNlTnVtICA9IE1hdGgubWluKG1heE51bVZlcnRpY2VzLCBvLnBvc2l0aW9ucy5sZW5ndGgpO1xuXHRcdFx0XHRjb25zdCBpbmRpY2VzICAgPSBvLmluZGljZXMuc3BsaWNlKDAsIHNsaWNlTnVtKTtcblx0XHRcdFx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdFx0XHRcdGNvbnN0IGNvb3JkcyAgICA9IFtdO1xuXHRcdFx0XHRjb25zdCBub3JtYWxzICAgPSBbXTtcblx0XHRcdFx0bGV0IGluZGV4LCB0bXBJbmRleCA9IDA7XG5cblx0XHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZihpbmRpY2VzW2ldID4gdG1wSW5kZXgpIHtcblx0XHRcdFx0XHRcdHRtcEluZGV4ID0gaW5kaWNlc1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbaV07XG5cblx0XHRcdFx0XHRwb3NpdGlvbnMucHVzaChvQ29weS5wb3NpdGlvbnNbaW5kZXhdKTtcblx0XHRcdFx0XHRpZihoYXNVVnMpIHtcblx0XHRcdFx0XHRcdGNvb3Jkcy5wdXNoKG9Db3B5LmNvb3Jkc1tpbmRleF0pO1x0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGhhc05vcm1hbHMpIHtcblx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaChvQ29weS5ub3JtYWxzW2luZGV4XSk7XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aW5kaWNlc1tpXSAtPSBsYXN0SW5kZXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsYXN0SW5kZXggPSB0bXBJbmRleCArIDE7XG5cblx0XHRcdFx0bWVzaCA9IG5ldyBNZXNoKHRoaXMuX2RyYXdUeXBlKTtcblx0XHRcdFx0bWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKTtcblx0XHRcdFx0aWYoaGFzVVZzKSB7XG5cdFx0XHRcdFx0bWVzaC5idWZmZXJUZXhDb29yZChjb29yZHMpO1x0XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdFx0XHRcdGlmKGhhc05vcm1hbHMpIHtcblx0XHRcdFx0XHRtZXNoLmJ1ZmZlck5vcm1hbChub3JtYWxzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1lc2hlcy5wdXNoKG1lc2gpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLl9jYWxsYmFjaykge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhtZXNoZXMsIG9Db3B5KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lc2hlcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWVzaCA9IG5ldyBNZXNoKHRoaXMuX2RyYXdUeXBlKTtcblx0XHRcdG1lc2guYnVmZmVyVmVydGV4KG8ucG9zaXRpb25zKTtcblx0XHRcdGlmKGhhc1VWcykge1xuXHRcdFx0XHRtZXNoLmJ1ZmZlclRleENvb3JkKG8uY29vcmRzKTtcdFxuXHRcdFx0fVxuXHRcdFx0bWVzaC5idWZmZXJJbmRleChvLmluZGljZXMpO1xuXHRcdFx0aWYoaGFzTm9ybWFscykge1xuXHRcdFx0XHRtZXNoLmJ1ZmZlck5vcm1hbChvLm5vcm1hbHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLl9jYWxsYmFjaykge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhtZXNoLCBvKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lc2g7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBudWxsO1xuXHR9XG59XG5cblxuT2JqTG9hZGVyLnBhcnNlID0gZnVuY3Rpb24gKG9ialN0cikge1xuXHRjb25zdCBsb2FkZXIgPSBuZXcgT2JqTG9hZGVyKCk7XG5cdHJldHVybiBsb2FkZXIucGFyc2VPYmoob2JqU3RyKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE9iakxvYWRlcjsiLCIvLyBSYXkuanNcblxuaW1wb3J0IHsgbWF0NCwgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cblxuY29uc3QgYSA9IHZlYzMuY3JlYXRlKCk7XG5jb25zdCBiID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IGMgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgdGFyZ2V0ID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IGVkZ2UxID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IGVkZ2UyID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IG5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XG5jb25zdCBkaWZmID0gdmVjMy5jcmVhdGUoKTtcblxuY2xhc3MgUmF5IHtcblx0Y29uc3RydWN0b3IobU9yaWdpbiwgbURpcmVjdGlvbikge1xuXHRcdHRoaXMub3JpZ2luID0gdmVjMy5jbG9uZShtT3JpZ2luKTtcblx0XHR0aGlzLmRpcmVjdGlvbiA9IHZlYzMuY2xvbmUobURpcmVjdGlvbik7XG5cdH1cblxuXHRhdCh0KSB7XG5cdFx0dmVjMy5jb3B5KHRhcmdldCwgdGhpcy5kaXJlY3Rpb24pO1xuXHRcdHZlYzMuc2NhbGUodGFyZ2V0LCB0YXJnZXQsIHQpO1xuXHRcdHZlYzMuYWRkKHRhcmdldCwgdGFyZ2V0LCB0aGlzLm9yaWdpbik7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblxuXHRsb29rQXQobVRhcmdldCkge1xuXHRcdHZlYzMuc3ViKHRoaXMuZGlyZWN0aW9uLCBtVGFyZ2V0LCB0aGlzLm9yaWdpbik7XG5cdFx0dmVjMy5ub3JtYWxpemUodGhpcy5vcmlnaW4sIHRoaXMub3JpZ2luKTtcblx0fVxuXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQobVBvaW50KSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gdmVjMy5jcmVhdGUoKTtcblx0XHR2ZWMzLnN1YihtUG9pbnQsIHRoaXMub3JpZ2luKTtcblx0XHRjb25zdCBkaXJlY3Rpb25EaXN0YW5jZSA9IHZlYzMuZG90KHJlc3VsdCwgdGhpcy5kaXJlY3Rpb24pO1xuXG5cdFx0aWYgKGRpcmVjdGlvbkRpc3RhbmNlIDwgMCkge1xuXHRcdFx0cmV0dXJuIHZlYzMuY2xvbmUodGhpcy5vcmlnaW4pO1xuXHRcdH1cblxuXHRcdHZlYzMuY29weShyZXN1bHQsIHRoaXMuZGlyZWN0aW9uKTtcblx0XHR2ZWMzLnNjYWxlKHJlc3VsdCwgcmVzdWx0LCBkaXJlY3Rpb25EaXN0YW5jZSk7XG5cdFx0dmVjMy5hZGQocmVzdWx0LCByZXN1bHQsIHRoaXMub3JpZ2luKTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXG5cdGRpc3RhbmNlVG9Qb2ludChtUG9pbnQpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQobVBvaW50KSk7XG5cdH1cblxuXG5cdGRpc3RhbmNlU3FUb1BvaW50KG1Qb2ludCkge1xuXHRcdGNvbnN0IHYxID0gdmVjMy5jcmVhdGUoKTtcblxuXHRcdHZlYzMuc3ViKHYxLCBtUG9pbnQsIHRoaXMub3JpZ2luKTtcblx0XHRjb25zdCBkaXJlY3Rpb25EaXN0YW5jZSA9IHZlYzMuZG90KHYxLCB0aGlzLmRpcmVjdGlvbik7XG5cblx0XHRpZiAoZGlyZWN0aW9uRGlzdGFuY2UgPCAwKSB7XG5cdFx0XHRyZXR1cm4gdmVjMy5zcXVhcmVkRGlzdGFuY2UodGhpcy5vcmlnaW4sIG1Qb2ludCk7XG5cdFx0fVxuXG5cdFx0dmVjMy5jb3B5KHYxLCB0aGlzLmRpcmVjdGlvbik7XG5cdFx0dmVjMy5zY2FsZSh2MSwgdjEsIGRpcmVjdGlvbkRpc3RhbmNlKTtcblx0XHR2ZWMzLmFkZCh2MSwgdjEsIHRoaXMub3JpZ2luKTtcblx0XHRyZXR1cm4gdmVjMy5zcXVhcmVkRGlzdGFuY2UodjEsIG1Qb2ludCk7XG5cdH1cblxuXG5cdGludGVyc2VjdHNTcGhlcmUobUNlbnRlciwgbVJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludChtQ2VudGVyKSA8PSBtUmFkaXVzO1xuXHR9XG5cblxuXHRpbnRlcnNlY3RTcGhlcmUobUNlbnRlciwgbVJhZGl1cykge1xuXHRcdGNvbnN0IHYxID0gdmVjMy5jcmVhdGUoKTtcblx0XHR2ZWMzLnN1Yih2MSwgbUNlbnRlciwgdGhpcy5vcmlnaW4pO1xuXHRcdGNvbnN0IHRjYSA9IHZlYzMuZG90KHYxLCB0aGlzLmRpcmVjdGlvbik7XG5cdFx0Y29uc3QgZDIgPSB2ZWMzLmRvdCh2MSwgdjEpIC0gdGNhICogdGNhO1xuXHRcdGNvbnN0IHJhZGl1czIgPSBtUmFkaXVzICogbVJhZGl1cztcblxuXHRcdGlmKGQyID4gcmFkaXVzMikgcmV0dXJuIG51bGw7XG5cblx0XHRjb25zdCB0aGMgPSBNYXRoLnNxcnQocmFkaXVzMiAtIGQyKTtcblxuXHRcdGNvbnN0IHQwID0gdGNhIC0gdGhjO1xuXG5cdFx0Y29uc3QgdDEgPSB0Y2EgKyB0aGM7XG5cblx0XHRpZih0MCA8IDAgJiYgdDEgPCAwKSByZXR1cm4gbnVsbDtcblxuXHRcdGlmKHQwIDwgMCkgcmV0dXJuIHRoaXMuYXQodDEpO1xuXG5cdFx0cmV0dXJuIHRoaXMuYXQodDApO1xuXHR9XG5cblxuXHRkaXN0YW5jZVRvUGxhbmUobVBsYW5lQ2VudGVyLCBtTm9ybWFsKSB7XG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSB2ZWMzLmRvdChtTm9ybWFsLCB0aGlzLmRpcmVjdGlvbik7XG5cblx0XHRpZihkZW5vbWluYXRvciA9PT0gMCkge1xuXHRcdH1cblx0fVxuXG5cblx0aW50ZXJzZWN0VHJpYW5nbGUobVBBLCBtUEIsIG1QQywgYmFja2ZhY2VDdWxsaW5nID0gdHJ1ZSkge1xuXHRcdHZlYzMuY29weShhLCBtUEEpO1xuXHRcdHZlYzMuY29weShiLCBtUEIpO1xuXHRcdHZlYzMuY29weShjLCBtUEMpO1xuXG5cdFx0Ly8gY29uc3QgZWRnZTEgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdC8vIGNvbnN0IGVkZ2UyID0gdmVjMy5jcmVhdGUoKTtcblx0XHQvLyBjb25zdCBub3JtYWwgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdC8vIGNvbnN0IGRpZmYgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5cdFx0dmVjMy5zdWIoZWRnZTEsIGIsIGEpO1xuXHRcdHZlYzMuc3ViKGVkZ2UyLCBjLCBhKTtcblx0XHR2ZWMzLmNyb3NzKG5vcm1hbCwgZWRnZTEsIGVkZ2UyKTtcblxuXHRcdGxldCBEZE4gPSB2ZWMzLmRvdCh0aGlzLmRpcmVjdGlvbiwgbm9ybWFsKTtcblx0XHRsZXQgc2lnbjtcblxuXHRcdGlmIChEZE4gPiAwKSB7XG5cdFx0XHRpZiAoYmFja2ZhY2VDdWxsaW5nKSB7XHRyZXR1cm4gbnVsbDtcdH1cblx0XHRcdHNpZ24gPSAxO1xuXHRcdH0gZWxzZSBpZiAoRGROIDwgMCkge1xuXHRcdFx0c2lnbiA9IC0xO1xuXHRcdFx0RGROID0gLSBEZE47XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZlYzMuc3ViKGRpZmYsIHRoaXMub3JpZ2luLCBhKTtcblxuXHRcdHZlYzMuY3Jvc3MoZWRnZTIsIGRpZmYsIGVkZ2UyKTtcblx0XHRjb25zdCBEZFF4RTIgPSBzaWduICogdmVjMy5kb3QodGhpcy5kaXJlY3Rpb24sIGVkZ2UyKTtcblx0XHRpZiAoRGRReEUyIDwgMCkgeyBcdHJldHVybiBudWxsOyBcdH1cblxuXHRcdHZlYzMuY3Jvc3MoZWRnZTEsIGVkZ2UxLCBkaWZmKTtcblx0XHRjb25zdCBEZEUxeFEgPSBzaWduICogdmVjMy5kb3QodGhpcy5kaXJlY3Rpb24sIGVkZ2UxKTtcblx0XHRpZiAoRGRFMXhRIDwgMCkge1x0cmV0dXJuIG51bGw7XHR9XG5cblx0XHRpZihEZFF4RTIgKyBEZEUxeFEgPiBEZE4pIHtcdHJldHVybiBudWxsO1x0fVxuXG5cdFx0Y29uc3QgUWRuID0gLSBzaWduICogdmVjMy5kb3QoZGlmZiwgbm9ybWFsKTtcblx0XHRpZihRZG4gPCAwKSB7XHRyZXR1cm4gbnVsbDtcdH1cblxuXHRcdHJldHVybiB0aGlzLmF0KFFkbiAvIERkTik7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSYXk7XG4iLCIvLyBPYmplY3QzRC5qc1xuXG5pbXBvcnQgeyB2ZWMzLCBtYXQ0LCBxdWF0IH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnc2NoZWR1bGluZyc7XG5cbmNsYXNzIE9iamVjdDNEIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3ggPSAwO1xuXHRcdHRoaXMuX3kgPSAwO1xuXHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0dGhpcy5fc3ggPSAxO1xuXHRcdHRoaXMuX3N5ID0gMTtcblx0XHR0aGlzLl9zeiA9IDE7XG5cblx0XHR0aGlzLl9yeCA9IDA7XG5cdFx0dGhpcy5fcnkgPSAwO1xuXHRcdHRoaXMuX3J6ID0gMDtcblxuXHRcdHRoaXMuX3Bvc2l0aW9uID0gdmVjMy5jcmVhdGUoKTtcblx0XHR0aGlzLl9zY2FsZSA9IHZlYzMuZnJvbVZhbHVlcygxLCAxLCAxKTtcblx0XHR0aGlzLl9yb3RhdGlvbiA9IHZlYzMuY3JlYXRlKCk7XG5cblx0XHR0aGlzLl9tYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX21hdHJpeFBhcmVudCA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fbWF0cml4Um90YXRpb24gPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX21hdHJpeFNjYWxlID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fbWF0cml4UXVhdGVybmlvbiA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fcXVhdCA9IHF1YXQuY3JlYXRlKCk7XG5cblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHR9XG5cblxuXHRhZGRDaGlsZChtQ2hpbGQpIHtcblx0XHR0aGlzLl9jaGlsZHJlbi5wdXNoKG1DaGlsZCk7XG5cdH1cblxuXG5cdHJlbW92ZUNoaWxkKG1DaGlsZCkge1xuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihtQ2hpbGQpO1xuXHRcdGlmKGluZGV4ID09IC0xKSB7XHRjb25zb2xlLndhcm4oJ0NoaWxkIG5vIGV4aXN0Jyk7IHJldHVybjtcdH1cblxuXHRcdHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXG5cdF91cGRhdGUoKSB7XG5cdFx0aWYoIXRoaXMuX25lZWRVcGRhdGUpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmVjMy5zZXQodGhpcy5fc2NhbGUsIHRoaXMuX3N4LCB0aGlzLl9zeSwgdGhpcy5fc3opO1xuXHRcdHZlYzMuc2V0KHRoaXMuX3JvdGF0aW9uLCB0aGlzLl9yeCwgdGhpcy5fcnksIHRoaXMuX3J6KTtcblx0XHR2ZWMzLnNldCh0aGlzLl9wb3NpdGlvbiwgdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feik7XG5cblx0XHRtYXQ0LmlkZW50aXR5KHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uLCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbik7XG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLl9tYXRyaXhTY2FsZSwgdGhpcy5fbWF0cml4U2NhbGUpO1xuXHRcdG1hdDQuaWRlbnRpdHkodGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX21hdHJpeFJvdGF0aW9uKTtcblxuXHRcdG1hdDQucm90YXRlWCh0aGlzLl9tYXRyaXhSb3RhdGlvbiwgdGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX3J4KTtcblx0XHRtYXQ0LnJvdGF0ZVkodGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9yeSk7XG5cdFx0bWF0NC5yb3RhdGVaKHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9tYXRyaXhSb3RhdGlvbiwgdGhpcy5fcnopO1xuXG5cblx0XHRtYXQ0LmZyb21RdWF0KHRoaXMuX21hdHJpeFF1YXRlcm5pb24sIHRoaXMuX3F1YXQpO1xuXHRcdG1hdDQubXVsKHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9tYXRyaXhRdWF0ZXJuaW9uLCB0aGlzLl9tYXRyaXhSb3RhdGlvbik7XG5cblx0XHRtYXQ0LnNjYWxlKHRoaXMuX21hdHJpeFNjYWxlLCB0aGlzLl9tYXRyaXhTY2FsZSwgdGhpcy5fc2NhbGUpO1xuXHRcdG1hdDQudHJhbnNsYXRlKHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uLCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiwgdGhpcy5fcG9zaXRpb24pO1xuXG5cdFx0bWF0NC5tdWwodGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiwgdGhpcy5fbWF0cml4Um90YXRpb24pO1xuXHRcdG1hdDQubXVsKHRoaXMuX21hdHJpeCwgdGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXhTY2FsZSk7XG5cdFx0Ly8gbWF0NC5tdWwodGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXgsIHRoaXMuX21hdHJpeFBhcmVudCk7XG5cdFx0bWF0NC5tdWwodGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXhQYXJlbnQsIHRoaXMuX21hdHJpeCk7XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR9XG5cblxuXHR1cGRhdGVNYXRyaXgobVBhcmVudE1hdHJpeCkge1xuXHRcdGlmKG1QYXJlbnRNYXRyaXgpIHtcblx0XHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0bWF0NC5jb3B5KHRoaXMuX21hdHJpeFBhcmVudCwgbVBhcmVudE1hdHJpeCk7XG5cdFx0fVxuXG5cdFx0aWYoIXRoaXMuX25lZWRVcGRhdGUpIHtcdHJldHVybjtcdH1cblxuXHRcdHRoaXMuX2NoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0Y2hpbGQudXBkYXRlTWF0cml4KHRoaXMuX21hdHJpeCk7XG5cdFx0fSk7XG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKG1RdWF0KSB7XG5cdFx0cXVhdC5jb3B5KHRoaXMuX3F1YXQsIG1RdWF0KTtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRTY2hlZHVsZXIubmV4dCgoKT0+dGhpcy5fdXBkYXRlKCkpO1xuXHR9XG5cblxuXHRnZXQgbWF0cml4KCkge1xuXHRcdGlmKHRoaXMuX25lZWRVcGRhdGUpIHtcdFxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHRcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeDtcblx0fVxuXG5cdGdldCB4KCkge1x0cmV0dXJuIHRoaXMuX3g7XHR9XG5cdHNldCB4KG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3ggPSBtVmFsdWU7XG5cdFx0U2NoZWR1bGVyLm5leHQoKCk9PnRoaXMuX3VwZGF0ZSgpKTtcblx0fVxuXG5cdGdldCB5KCkge1x0cmV0dXJuIHRoaXMuX3k7XHR9XG5cdHNldCB5KG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3kgPSBtVmFsdWU7XG5cdFx0U2NoZWR1bGVyLm5leHQoKCk9PnRoaXMuX3VwZGF0ZSgpKTtcblx0fVxuXG5cdGdldCB6KCkge1x0cmV0dXJuIHRoaXMuX3o7XHR9XG5cdHNldCB6KG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3ogPSBtVmFsdWU7XG5cdFx0U2NoZWR1bGVyLm5leHQoKCk9PnRoaXMuX3VwZGF0ZSgpKTtcblx0fVxuXG5cdFxuXHRnZXQgc2NhbGVYKCkge1x0cmV0dXJuIHRoaXMuX3N4O1x0fVxuXHRzZXQgc2NhbGVYKG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3N4ID0gbVZhbHVlO1xuXHRcdFNjaGVkdWxlci5uZXh0KCgpPT50aGlzLl91cGRhdGUoKSk7XG5cdH1cblxuXHRnZXQgc2NhbGVZKCkge1x0cmV0dXJuIHRoaXMuX3N5O1x0fVxuXHRzZXQgc2NhbGVZKG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3N5ID0gbVZhbHVlO1xuXHRcdFNjaGVkdWxlci5uZXh0KCgpPT50aGlzLl91cGRhdGUoKSk7XG5cdH1cblxuXHRnZXQgc2NhbGVaKCkge1x0cmV0dXJuIHRoaXMuX3N6O1x0fVxuXHRzZXQgc2NhbGVaKG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3N6ID0gbVZhbHVlO1xuXHRcdFNjaGVkdWxlci5uZXh0KCgpPT50aGlzLl91cGRhdGUoKSk7XG5cdH1cblxuXG5cdGdldCByb3RhdGlvblgoKSB7XHRyZXR1cm4gdGhpcy5fcng7XHR9XG5cdHNldCByb3RhdGlvblgobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fcnggPSBtVmFsdWU7XG5cdFx0U2NoZWR1bGVyLm5leHQoKCk9PnRoaXMuX3VwZGF0ZSgpKTtcblx0fVxuXG5cdGdldCByb3RhdGlvblkoKSB7XHRyZXR1cm4gdGhpcy5fcnk7XHR9XG5cdHNldCByb3RhdGlvblkobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fcnkgPSBtVmFsdWU7XG5cdFx0U2NoZWR1bGVyLm5leHQoKCk9PnRoaXMuX3VwZGF0ZSgpKTtcblx0fVxuXG5cdGdldCByb3RhdGlvblooKSB7XHRyZXR1cm4gdGhpcy5fcno7XHR9XG5cdHNldCByb3RhdGlvbloobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fcnogPSBtVmFsdWU7XG5cdFx0U2NoZWR1bGVyLm5leHQoKCk9PnRoaXMuX3VwZGF0ZSgpKTtcblx0fVxuXG5cdGdldCBjaGlsZHJlbigpIHtcdHJldHVybiB0aGlzLl9jaGlsZHJlbjtcdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBPYmplY3QzRDsiLCJleHBvcnQgZGVmYXVsdCBcIi8vIGF4aXMuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0lNUExFX1RFWFRVUkVcXG5cXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXHQvLyB2ZWMzIGNvbG9yID0gdk5vcm1hbDtcXG5cXHR2ZWMzIGNvbG9yID0gdkNvbG9yICsgdk5vcm1hbCAqIDAuMDAwMTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG59XCIiLCJleHBvcnQgZGVmYXVsdCBcIi8vIGF4aXMudmVydFxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQkFTSUNfVkVSVEVYXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFDb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB1Vmlld01hdHJpeCAqIHVNb2RlbE1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApO1xcbiAgICB2Q29sb3IgPSBhQ29sb3I7XFxuICAgIHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIiIsImV4cG9ydCBkZWZhdWx0IFwiLy8gYmFzaWMuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQkFTSUNfRlJBR01FTlRcXG5cXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gZmxvYXQgdGltZTtcXG4vLyB1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodlRleHR1cmVDb29yZCwgc2luKHRpbWUpICogLjUgKyAuNSwgMS4wKTtcXG59XCIiLCJleHBvcnQgZGVmYXVsdCBcIi8vIGJhc2ljLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJBU0lDX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB1Vmlld01hdHJpeCAqIHVNb2RlbE1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICAgdk5vcm1hbCA9IGFOb3JtYWw7XFxufVwiIiwiZXhwb3J0IGRlZmF1bHQgXCIvLyBiaWdUcmlhbmdsZS52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCSUdfVFJJQU5HTEVfVkVSVEVYXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVBvc2l0aW9uICogLjUgKyAuNTtcXG59XCIiLCJleHBvcnQgZGVmYXVsdCBcIi8vIGNvcHkuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQ09QWV9GUkFHTUVOVFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxufVwiIiwiZXhwb3J0IGRlZmF1bHQgXCIvLyBkb3RzUGxhbmUuZnJhZ1xcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMyBjb2xvcjtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXHRpZihkaXN0YW5jZShnbF9Qb2ludENvb3JkLCB2ZWMyKC41KSkgPiAuNSkge1xcblxcdFxcdGRpc2NhcmQ7XFxuXFx0fVxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBvcGFjaXR5KTtcXG59XCIiLCJleHBvcnQgZGVmYXVsdCBcIi8vIGJhc2ljLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIERPVFNfUExBTkVfVkVSVEVYXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gdmVjMiB2aWV3cG9ydDtcXG5cXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG5jb25zdCBmbG9hdCByYWRpdXMgPSAwLjAwODtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiArIGFOb3JtYWwgKiAwLjAwMDAwMSwgMS4wKTtcXG4gICAgLy8gZ2xfUG9pbnRTaXplID0gMS4wO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG5cXG5cXHRmbG9hdCBkaXN0T2Zmc2V0ID0gdmlld3BvcnQueSAqIHVQcm9qZWN0aW9uTWF0cml4WzFdWzFdICogcmFkaXVzIC8gZ2xfUG9zaXRpb24udztcXG4gICAgZ2xfUG9pbnRTaXplID0gZGlzdE9mZnNldDtcXG59XCIiLCJleHBvcnQgZGVmYXVsdCBcIi8vIGdlbmVyYWxXaXRoTm9ybWFsLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEdFTkVSQUxfVkVSVEVYXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcXG5cXG51bmlmb3JtIG1hdDQgdU1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHVOb3JtYWxNYXRyaXg7XFxuXFxudW5pZm9ybSB2ZWMzIHBvc2l0aW9uO1xcbnVuaWZvcm0gdmVjMyBzY2FsZTtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdHZlYzMgcG9zICAgICAgPSBhVmVydGV4UG9zaXRpb24gKiBzY2FsZTtcXG5cXHRwb3MgICAgICAgICAgICs9IHBvc2l0aW9uO1xcblxcdGdsX1Bvc2l0aW9uICAgPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChwb3MsIDEuMCk7XFxuXFx0XFxuXFx0dlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuXFx0dk5vcm1hbCAgICAgICA9IG5vcm1hbGl6ZSh1Tm9ybWFsTWF0cml4ICogYU5vcm1hbCk7XFxufVwiIiwiZXhwb3J0IGRlZmF1bHQgXCIvLyBzaW1wbGVDb2xvci5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBTSU1QTEVfQ09MT1JcXG5cXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMyBjb2xvcjtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgb3BhY2l0eSk7XFxufVwiIiwiZXhwb3J0IGRlZmF1bHQgXCIvLyBza3kudmVydFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0bWF0NCBtYXRWaWV3ID0gdVZpZXdNYXRyaXg7XFxuXFx0bWF0Vmlld1szXVswXSA9IDAuMDtcXG5cXHRtYXRWaWV3WzNdWzFdID0gMC4wO1xcblxcdG1hdFZpZXdbM11bMl0gPSAwLjA7XFxuXFx0XFxuICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiBtYXRWaWV3ICogdU1vZGVsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCIiLCJleHBvcnQgZGVmYXVsdCBcIi8vIGJhc2ljLmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIFNLWUJPWF9GUkFHTUVOVFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudW5pZm9ybSBzYW1wbGVyQ3ViZSB0ZXh0dXJlO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2VmVydGV4O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKHRleHR1cmUsIHZWZXJ0ZXgpO1xcbn1cIiIsImV4cG9ydCBkZWZhdWx0IFwiLy8gYmFzaWMudmVydFxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0tZQk9YX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2VmVydGV4O1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0bWF0NCBtYXRWaWV3ID0gdVZpZXdNYXRyaXg7XFxuXFx0bWF0Vmlld1szXVswXSA9IDAuMDtcXG5cXHRtYXRWaWV3WzNdWzFdID0gMC4wO1xcblxcdG1hdFZpZXdbM11bMl0gPSAwLjA7XFxuXFx0XFxuXFx0Z2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIG1hdFZpZXcgKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG5cXHR2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG5cXHRcXG5cXHR2VmVydGV4ID0gYVZlcnRleFBvc2l0aW9uO1xcblxcdHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIiIsIi8vIEVhc2VOdW1iZXIuanNcblxuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJztcblxuY2xhc3MgRWFzZU51bWJlciB7XG5cdGNvbnN0cnVjdG9yKG1WYWx1ZSwgbUVhc2luZyA9IDAuMSkge1xuXHRcdHRoaXMuZWFzaW5nICAgICAgID0gbUVhc2luZztcblx0XHR0aGlzLl92YWx1ZSAgICAgICA9IG1WYWx1ZTtcblx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl9lZkluZGV4ICAgICA9IFNjaGVkdWxlci5hZGRFRigoKT0+IHRoaXMuX3VwZGF0ZSgpKTtcblx0fVxuXG5cblx0X3VwZGF0ZSgpIHtcblx0XHRjb25zdCBNSU5fRElGRiA9IDAuMDAwMTtcblx0XHR0aGlzLl9jaGVja0xpbWl0KCk7XG5cdFx0dGhpcy5fdmFsdWUgKz0gKHRoaXMuX3RhcmdldFZhbHVlIC0gdGhpcy5fdmFsdWUpICogdGhpcy5lYXNpbmc7XHRcblx0XHRpZihNYXRoLmFicyh0aGlzLl90YXJnZXRWYWx1ZSAtIHRoaXMuX3ZhbHVlKSA8IE1JTl9ESUZGKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSA9IHRoaXMuX3RhcmdldFZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdHNldFRvKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlID0gdGhpcy5fdmFsdWUgPSBtVmFsdWU7XG5cdH1cblxuXG5cdGFkZChtQWRkKSB7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgKz0gbUFkZDtcblx0fVxuXG5cdGxpbWl0KG1NaW4sIG1NYXgpIHtcblx0XHRpZihtTWluID4gbU1heCkge1xuXHRcdFx0dGhpcy5saW1pdChtTWF4LCBtTWluKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9taW4gPSBtTWluO1xuXHRcdHRoaXMuX21heCA9IG1NYXg7XG5cblx0XHR0aGlzLl9jaGVja0xpbWl0KCk7XG5cdH1cblxuXG5cdF9jaGVja0xpbWl0KCkge1xuXHRcdGlmKHRoaXMuX21pbiAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3RhcmdldFZhbHVlIDwgdGhpcy5fbWluKSB7XG5cdFx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX21pbjtcblx0XHR9IFxuXG5cdFx0aWYodGhpcy5fbWF4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fdGFyZ2V0VmFsdWUgPiB0aGlzLl9tYXgpIHtcblx0XHRcdHRoaXMuX3RhcmdldFZhbHVlID0gdGhpcy5fbWF4O1xuXHRcdH0gXG5cdH1cblxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0U2NoZWR1bGVyLnJlbW92ZUVGKHRoaXMuX2VmSW5kZXgpO1xuXHR9XG5cblxuXHQvL1x0R0VUVEVSUyAvIFNFVFRFUlNcblxuXHRzZXQgdmFsdWUobVZhbHVlKSB7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgdmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9XG5cblx0Z2V0IHRhcmdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLl90YXJnZXRWYWx1ZTtcblx0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgRWFzZU51bWJlcjsiLCIvLyBFdmVudERpc3BhdGNoZXIuanNcblxubGV0IHN1cHBvcnRzQ3VzdG9tRXZlbnRzID0gdHJ1ZTtcbnRyeSB7XG5cdGxldCBuZXdUZXN0Q3VzdG9tRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcblx0bmV3VGVzdEN1c3RvbUV2ZW50ID0gbnVsbDtcbn0gY2F0Y2goZSkge1xuXHRzdXBwb3J0c0N1c3RvbUV2ZW50cyA9IGZhbHNlO1xufVxuXG5jbGFzcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzID0ge307XG5cdH1cblxuXG5cdGFkZEV2ZW50TGlzdGVuZXIoYUV2ZW50VHlwZSwgYUZ1bmN0aW9uKSB7XG5cblx0XHRpZih0aGlzLl9ldmVudExpc3RlbmVycyA9PT0gbnVsbCB8fCB0aGlzLl9ldmVudExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9ldmVudExpc3RlbmVycyA9IHt9O1xuXHRcdH1cblxuXHRcdGlmKCF0aGlzLl9ldmVudExpc3RlbmVyc1thRXZlbnRUeXBlXSkge1xuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnNbYUV2ZW50VHlwZV0gPSBbXTtcblx0XHR9XG5cdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnNbYUV2ZW50VHlwZV0ucHVzaChhRnVuY3Rpb24pO1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRvbihhRXZlbnRUeXBlLCBhRnVuY3Rpb24pIHtcdHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoYUV2ZW50VHlwZSwgYUZ1bmN0aW9uKTtcdH1cblxuXHRyZW1vdmVFdmVudExpc3RlbmVyKGFFdmVudFR5cGUsIGFGdW5jdGlvbikge1xuXHRcdGlmKHRoaXMuX2V2ZW50TGlzdGVuZXJzID09PSBudWxsIHx8IHRoaXMuX2V2ZW50TGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzID0ge307XG5cdFx0fVxuXHRcdGNvbnN0IGN1cnJlbnRBcnJheSA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW2FFdmVudFR5cGVdO1xuXHRcdFxuXHRcdGlmICh0eXBlb2YoY3VycmVudEFycmF5KSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRcblx0XHRsZXQgY3VycmVudEFycmF5TGVuZ3RoID0gY3VycmVudEFycmF5Lmxlbmd0aDtcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgY3VycmVudEFycmF5TGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmKGN1cnJlbnRBcnJheVtpXSA9PT0gYUZ1bmN0aW9uKSB7XG5cdFx0XHRcdGN1cnJlbnRBcnJheS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGktLTtcblx0XHRcdFx0Y3VycmVudEFycmF5TGVuZ3RoLS07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0b2ZmKGFFdmVudFR5cGUsIGFGdW5jdGlvbikge1x0cmV0dXJuIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihhRXZlbnRUeXBlLCBhRnVuY3Rpb24pO1x0fVxuXG5cdGRpc3BhdGNoRXZlbnQoYUV2ZW50KSB7XG5cdFx0aWYodGhpcy5fZXZlbnRMaXN0ZW5lcnMgPT09IG51bGwgfHwgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblx0XHR9XG5cdFx0Y29uc3QgZXZlbnRUeXBlID0gYUV2ZW50LnR5cGU7XG5cdFx0XG5cdFx0dHJ5IHtcblx0XHRcdGlmKGFFdmVudC50YXJnZXQgPT09IG51bGwpIHtcblx0XHRcdFx0YUV2ZW50LnRhcmdldCA9IHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRhRXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG5cdFx0fSBjYXRjaCh0aGVFcnJvcikge1xuXHRcdFx0Y29uc3QgbmV3RXZlbnQgPSB7IHR5cGU6IGV2ZW50VHlwZSwgZGV0YWlsOiBhRXZlbnQuZGV0YWlsLCBkaXNwYXRjaGVyOiB0aGlzIH07XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblx0XHR9XG5cdFx0XG5cdFx0Y29uc3QgY3VycmVudEV2ZW50TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRUeXBlXTtcblx0XHRpZihjdXJyZW50RXZlbnRMaXN0ZW5lcnMgIT09IG51bGwgJiYgY3VycmVudEV2ZW50TGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnN0IGN1cnJlbnRBcnJheSA9IHRoaXMuX2NvcHlBcnJheShjdXJyZW50RXZlbnRMaXN0ZW5lcnMpO1xuXHRcdFx0Y29uc3QgY3VycmVudEFycmF5TGVuZ3RoID0gY3VycmVudEFycmF5Lmxlbmd0aDtcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBjdXJyZW50QXJyYXlMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50RnVuY3Rpb24gPSBjdXJyZW50QXJyYXlbaV07XG5cdFx0XHRcdGN1cnJlbnRGdW5jdGlvbi5jYWxsKHRoaXMsIGFFdmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0ZGlzcGF0Y2hDdXN0b21FdmVudChhRXZlbnRUeXBlLCBhRGV0YWlsKSB7XG5cdFx0bGV0IG5ld0V2ZW50O1xuXHRcdGlmIChzdXBwb3J0c0N1c3RvbUV2ZW50cykge1xuXHRcdFx0bmV3RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcblx0XHRcdG5ld0V2ZW50LmRpc3BhdGNoZXIgPSB0aGlzO1xuXHRcdFx0bmV3RXZlbnQuaW5pdEN1c3RvbUV2ZW50KGFFdmVudFR5cGUsIGZhbHNlLCBmYWxzZSwgYURldGFpbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0V2ZW50ID0geyB0eXBlOiBhRXZlbnRUeXBlLCBkZXRhaWw6IGFEZXRhaWwsIGRpc3BhdGNoZXI6IHRoaXMgfTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH1cblxuXHR0cmlnZ2VyKGFFdmVudFR5cGUsIGFEZXRhaWwpIHtcdHJldHVybiB0aGlzLmRpc3BhdGNoQ3VzdG9tRXZlbnQoYUV2ZW50VHlwZSwgYURldGFpbCk7XHR9XG5cblx0X2Rlc3Ryb3koKSB7XG5cdFx0aWYodGhpcy5fZXZlbnRMaXN0ZW5lcnMgIT09IG51bGwpIHtcblx0XHRcdGZvcihjb25zdCBvYmplY3ROYW1lIGluIHRoaXMuX2V2ZW50TGlzdGVuZXJzKSB7XG5cdFx0XHRcdGlmKHRoaXMuX2V2ZW50TGlzdGVuZXJzLmhhc093blByb3BlcnR5KG9iamVjdE5hbWUpKSB7XG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudEFycmF5ID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbb2JqZWN0TmFtZV07XG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudEFycmF5TGVuZ3RoID0gY3VycmVudEFycmF5Lmxlbmd0aDtcblx0XHRcdFx0XHRmb3IobGV0IGkgPSAwOyBpIDwgY3VycmVudEFycmF5TGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGN1cnJlbnRBcnJheVtpXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudExpc3RlbmVyc1tvYmplY3ROYW1lXTtcdFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9ldmVudExpc3RlbmVycyA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0X2NvcHlBcnJheShhQXJyYXkpIHtcblx0XHRjb25zdCBjdXJyZW50QXJyYXkgPSBuZXcgQXJyYXkoYUFycmF5Lmxlbmd0aCk7XG5cdFx0Y29uc3QgY3VycmVudEFycmF5TGVuZ3RoID0gY3VycmVudEFycmF5Lmxlbmd0aDtcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgY3VycmVudEFycmF5TGVuZ3RoOyBpKyspIHtcblx0XHRcdGN1cnJlbnRBcnJheVtpXSA9IGFBcnJheVtpXTtcblx0XHR9XG5cdFx0cmV0dXJuIGN1cnJlbnRBcnJheTtcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50RGlzcGF0Y2hlcjsiLCIvLyBFeHRlbnNpb25zTGlzdC5qc1xuXG5leHBvcnQgZGVmYXVsdCBbXG5cdCdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJywgXG5cdCdFWFRfc1JHQicsIFxuXHQnRVhUX2ZyYWdfZGVwdGgnLCBcblx0J09FU190ZXh0dXJlX2Zsb2F0JywgXG5cdCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JywgXG5cdCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInLCBcblx0J09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJywgXG5cdCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnLCBcblx0J1dFQkdMX2RlcHRoX3RleHR1cmUnLCBcblx0J0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycsIFxuXHQnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnLCBcblx0J0FOR0xFX2luc3RhbmNlZF9hcnJheXMnLCBcblx0J1dFQkdMX2RyYXdfYnVmZmVycydcbl07IiwiLy8gSERSUGFyc2VyLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gQ29kZSBwb3J0ZWQgYnkgTWFyY2luIElnbmFjICgyMDE0KVxuLy8gQmFzZWQgb24gSmF2YSBpbXBsZW1lbnRhdGlvbiBmcm9tXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9yL2N5czEyMzQ1LXJlc2VhcmNoL3NvdXJjZS9icm93c2UvaGRyL2ltYWdlX3Byb2Nlc3Nvci9SR0JFLmphdmE/cj03ZDg0ZTlmZDg2NmIyNDA3OWRiZTYxZmEwYTk2NmNlODM2NWY1NzI2XG5jb25zdCByYWRpYW5jZVBhdHRlcm4gPSAnI1xcXFw/UkFESUFOQ0UnO1xuY29uc3QgY29tbWVudFBhdHRlcm4gPSAnIy4qJztcbi8vIGxldCBnYW1tYVBhdHRlcm4gPSAnR0FNTUE9JztcbmNvbnN0IGV4cG9zdXJlUGF0dGVybiA9ICdFWFBPU1VSRT1cXFxccyooWzAtOV0qWy5dWzAtOV0qKSc7XG5jb25zdCBmb3JtYXRQYXR0ZXJuID0gJ0ZPUk1BVD0zMi1iaXRfcmxlX3JnYmUnO1xuY29uc3Qgd2lkdGhIZWlnaHRQYXR0ZXJuID0gJy1ZIChbMC05XSspIFxcXFwrWCAoWzAtOV0rKSc7XG5cbi8vIGh0dHA6Ly9jcm9xdWV0d2Vhay5ibG9nc3BvdC5jby51ay8yMDE0LzA4L2RlY29uc3RydWN0aW5nLWZsb2F0cy1mcmV4cC1hbmQtbGRleHAuaHRtbFxuLy8gZnVuY3Rpb24gbGRleHAobWFudGlzc2EsIGV4cG9uZW50KSB7XG4vLyAgICAgcmV0dXJuIGV4cG9uZW50ID4gMTAyMyA/IG1hbnRpc3NhICogTWF0aC5wb3coMiwgMTAyMykgKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDEwMjMpIDogZXhwb25lbnQgPCAtMTA3NCA/IG1hbnRpc3NhICogTWF0aC5wb3coMiwgLTEwNzQpICogTWF0aC5wb3coMiwgZXhwb25lbnQgKyAxMDc0KSA6IG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuLy8gfVxuXG5mdW5jdGlvbiByZWFkUGl4ZWxzUmF3UkxFKGJ1ZmZlciwgZGF0YSwgb2Zmc2V0LCBmaWxlT2Zmc2V0LCBzY2FubGluZVdpZHRoLCBudW1TY2FubGluZXMpIHtcblx0Y29uc3QgcmdiZSA9IG5ldyBBcnJheSg0KTtcblx0bGV0IHNjYW5saW5lQnVmZmVyID0gbnVsbDtcblx0bGV0IHB0cjtcblx0bGV0IHB0ckVuZDtcblx0bGV0IGNvdW50O1xuXHRjb25zdCBidWYgPSBuZXcgQXJyYXkoMik7XG5cdGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG5cblx0ZnVuY3Rpb24gcmVhZEJ1ZihidWYpIHtcblx0XHRsZXQgYnl0ZXNSZWFkID0gMDtcblx0XHRkbyB7XG5cdFx0XHRidWZbYnl0ZXNSZWFkKytdID0gYnVmZmVyW2ZpbGVPZmZzZXRdO1xuXHRcdH0gd2hpbGUoKytmaWxlT2Zmc2V0IDwgYnVmZmVyTGVuZ3RoICYmIGJ5dGVzUmVhZCA8IGJ1Zi5sZW5ndGgpO1xuXHRcdHJldHVybiBieXRlc1JlYWQ7XG5cdH1cblxuXHRmdW5jdGlvbiByZWFkQnVmT2Zmc2V0KGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpIHtcblx0XHRsZXQgYnl0ZXNSZWFkID0gMDtcblx0XHRkbyB7XG5cdFx0XHRidWZbb2Zmc2V0ICsgYnl0ZXNSZWFkKytdID0gYnVmZmVyW2ZpbGVPZmZzZXRdO1xuXHRcdH0gd2hpbGUoKytmaWxlT2Zmc2V0IDwgYnVmZmVyTGVuZ3RoICYmIGJ5dGVzUmVhZCA8IGxlbmd0aCk7XG5cdFx0cmV0dXJuIGJ5dGVzUmVhZDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlYWRQaXhlbHNSYXcoYnVmZmVyLCBkYXRhLCBvZmZzZXQsIG51bXBpeGVscykge1xuXHRcdGNvbnN0IG51bUV4cGVjdGVkID0gNCAqIG51bXBpeGVscztcblx0XHRjb25zdCBudW1SZWFkID0gcmVhZEJ1Zk9mZnNldChkYXRhLCBvZmZzZXQsIG51bUV4cGVjdGVkKTtcblx0XHRpZiAobnVtUmVhZCA8IG51bUV4cGVjdGVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHJlYWRpbmcgcmF3IHBpeGVsczogZ290ICR7bnVtUmVhZH0gYnl0ZXMsIGV4cGVjdGVkICR7bnVtRXhwZWN0ZWR9YCk7XG5cdFx0fVxuXHR9XG5cblx0d2hpbGUgKG51bVNjYW5saW5lcyA+IDApIHtcblx0XHRpZiAocmVhZEJ1ZihyZ2JlKSA8IHJnYmUubGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHJlYWRpbmcgYnl0ZXM6IGV4cGVjdGVkICR7cmdiZS5sZW5ndGh9YCk7XG5cdFx0fVxuXG5cdFx0aWYgKChyZ2JlWzBdICE9PSAyKSB8fCAocmdiZVsxXSAhPT0gMikgfHwgKChyZ2JlWzJdICYgMHg4MCkgIT09IDApKSB7XG5cdFx0XHQvLyB0aGlzIGZpbGUgaXMgbm90IHJ1biBsZW5ndGggZW5jb2RlZFxuXHRcdFx0ZGF0YVtvZmZzZXQrK10gPSByZ2JlWzBdO1xuXHRcdFx0ZGF0YVtvZmZzZXQrK10gPSByZ2JlWzFdO1xuXHRcdFx0ZGF0YVtvZmZzZXQrK10gPSByZ2JlWzJdO1xuXHRcdFx0ZGF0YVtvZmZzZXQrK10gPSByZ2JlWzNdO1xuXHRcdFx0cmVhZFBpeGVsc1JhdyhidWZmZXIsIGRhdGEsIG9mZnNldCwgc2NhbmxpbmVXaWR0aCAqIG51bVNjYW5saW5lcyAtIDEpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgoKChyZ2JlWzJdICYgMHhGRikgPDwgOCkgfCAocmdiZVszXSAmIDB4RkYpKSAhPT0gc2NhbmxpbmVXaWR0aCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBXcm9uZyBzY2FubGluZSB3aWR0aCAkeygoKHJnYmVbMl0gJiAweEZGKSA8PCA4KSB8IChyZ2JlWzNdICYgMHhGRikpfSwgZXhwZWN0ZWQgJHtzY2FubGluZVdpZHRofWApO1xuXHRcdH1cblxuXHRcdGlmIChzY2FubGluZUJ1ZmZlciA9PT0gbnVsbCkge1xuXHRcdFx0c2NhbmxpbmVCdWZmZXIgPSBuZXcgQXJyYXkoNCAqIHNjYW5saW5lV2lkdGgpO1xuXHRcdH1cblxuXHRcdHB0ciA9IDA7XG5cdFx0LyogcmVhZCBlYWNoIG9mIHRoZSBmb3VyIGNoYW5uZWxzIGZvciB0aGUgc2NhbmxpbmUgaW50byB0aGUgYnVmZmVyICovXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdHB0ckVuZCA9IChpICsgMSkgKiBzY2FubGluZVdpZHRoO1xuXHRcdFx0d2hpbGUocHRyIDwgcHRyRW5kKSB7XG5cdFx0XHRcdGlmIChyZWFkQnVmKGJ1ZikgPCBidWYubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFcnJvciByZWFkaW5nIDItYnl0ZSBidWZmZXInKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoKGJ1ZlswXSAmIDB4RkYpID4gMTI4KSB7XG5cdFx0XHRcdFx0LyogYSBydW4gb2YgdGhlIHNhbWUgdmFsdWUgKi9cblx0XHRcdFx0XHRjb3VudCA9IChidWZbMF0gJiAweEZGKSAtIDEyODtcblx0XHRcdFx0XHRpZiAoKGNvdW50ID09PSAwKSB8fCAoY291bnQgPiBwdHJFbmQgLSBwdHIpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JhZCBzY2FubGluZSBkYXRhJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlKGNvdW50LS0gPiAwKSB7XG5cdFx0XHRcdFx0XHRzY2FubGluZUJ1ZmZlcltwdHIrK10gPSBidWZbMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qIGEgbm9uLXJ1biAqL1xuXHRcdFx0XHRcdGNvdW50ID0gYnVmWzBdICYgMHhGRjtcblx0XHRcdFx0XHRpZiAoKGNvdW50ID09PSAwKSB8fCAoY291bnQgPiBwdHJFbmQgLSBwdHIpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JhZCBzY2FubGluZSBkYXRhJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNjYW5saW5lQnVmZmVyW3B0cisrXSA9IGJ1ZlsxXTtcblx0XHRcdFx0XHRpZiAoLS1jb3VudCA+IDApIHtcblx0XHRcdFx0XHRcdGlmIChyZWFkQnVmT2Zmc2V0KHNjYW5saW5lQnVmZmVyLCBwdHIsIGNvdW50KSA8IGNvdW50KSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgcmVhZGluZyBub24tcnVuIGRhdGEnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHB0ciArPSBjb3VudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKiBjb3B5IGJ5dGUgZGF0YSB0byBvdXRwdXQgKi9cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgc2NhbmxpbmVXaWR0aDsgaSsrKSB7XG5cdFx0XHRkYXRhW29mZnNldCArIDBdID0gc2NhbmxpbmVCdWZmZXJbaV07XG5cdFx0XHRkYXRhW29mZnNldCArIDFdID0gc2NhbmxpbmVCdWZmZXJbaSArIHNjYW5saW5lV2lkdGhdO1xuXHRcdFx0ZGF0YVtvZmZzZXQgKyAyXSA9IHNjYW5saW5lQnVmZmVyW2kgKyAyICogc2NhbmxpbmVXaWR0aF07XG5cdFx0XHRkYXRhW29mZnNldCArIDNdID0gc2NhbmxpbmVCdWZmZXJbaSArIDMgKiBzY2FubGluZVdpZHRoXTtcblx0XHRcdG9mZnNldCArPSA0O1xuXHRcdH1cblxuXHRcdG51bVNjYW5saW5lcy0tO1xuXHR9XG5cbn1cblxuLy8gUmV0dXJucyBkYXRhIGFzIGZsb2F0cyBhbmQgZmxpcHBlZCBhbG9uZyBZIGJ5IGRlZmF1bHRcbmZ1bmN0aW9uIHBhcnNlSGRyKGJ1ZmZlcikge1xuXHRpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRidWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXHR9XG5cblx0bGV0IGZpbGVPZmZzZXQgPSAwO1xuXHRjb25zdCBidWZmZXJMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuXG5cdGNvbnN0IE5FV19MSU5FID0gMTA7XG5cblx0ZnVuY3Rpb24gcmVhZExpbmUoKSB7XG5cdFx0bGV0IGJ1ZiA9ICcnO1xuXHRcdGRvIHtcblx0XHRcdGNvbnN0IGIgPSBidWZmZXJbZmlsZU9mZnNldF07XG5cdFx0XHRpZiAoYiA9PT0gTkVXX0xJTkUpIHtcblx0XHRcdFx0KytmaWxlT2Zmc2V0O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpO1xuXHRcdH0gd2hpbGUoKytmaWxlT2Zmc2V0IDwgYnVmZmVyTGVuZ3RoKTtcblx0XHRyZXR1cm4gYnVmO1xuXHR9XG5cblx0bGV0IHdpZHRoID0gMDtcblx0bGV0IGhlaWdodCA9IDA7XG5cdGxldCBleHBvc3VyZSA9IDE7XG5cdGNvbnN0IGdhbW1hID0gMTtcblx0bGV0IHJsZSA9IGZhbHNlO1xuXG5cdGZvcihsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG5cdFx0Y29uc3QgbGluZSA9IHJlYWRMaW5lKCk7XG5cdFx0bGV0IG1hdGNoO1xuXHRcdGlmIChtYXRjaCA9IGxpbmUubWF0Y2gocmFkaWFuY2VQYXR0ZXJuKSkge1xuXHRcdH0gZWxzZSBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGZvcm1hdFBhdHRlcm4pKSB7XG5cdFx0XHRybGUgPSB0cnVlO1xuXHRcdH0gZWxzZSBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGV4cG9zdXJlUGF0dGVybikpIHtcblx0XHRcdGV4cG9zdXJlID0gTnVtYmVyKG1hdGNoWzFdKTtcblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaChjb21tZW50UGF0dGVybikpIHtcblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaCh3aWR0aEhlaWdodFBhdHRlcm4pKSB7XG5cdFx0XHRoZWlnaHQgPSBOdW1iZXIobWF0Y2hbMV0pO1xuXHRcdFx0d2lkdGggPSBOdW1iZXIobWF0Y2hbMl0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFybGUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgaXMgbm90IHJ1biBsZW5ndGggZW5jb2RlZCEnKTtcblx0fVxuXG5cdGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuXHRjb25zdCBzY2FubGluZVdpZHRoID0gd2lkdGg7XG5cdGNvbnN0IG51bVNjYW5saW5lcyA9IGhlaWdodDtcblxuXHRyZWFkUGl4ZWxzUmF3UkxFKGJ1ZmZlciwgZGF0YSwgMCwgZmlsZU9mZnNldCwgc2NhbmxpbmVXaWR0aCwgbnVtU2NhbmxpbmVzKTtcblxuXHQvLyBUT0RPOiBTaG91bGQgYmUgRmxvYXQxNlxuXHRjb25zdCBmbG9hdERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG5cdGZvcihsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgZGF0YS5sZW5ndGg7IG9mZnNldCArPSA0KSB7XG5cdFx0bGV0IHIgPSBkYXRhW29mZnNldCArIDBdIC8gMjU1O1xuXHRcdGxldCBnID0gZGF0YVtvZmZzZXQgKyAxXSAvIDI1NTtcblx0XHRsZXQgYiA9IGRhdGFbb2Zmc2V0ICsgMl0gLyAyNTU7XG5cdFx0Y29uc3QgZSA9IGRhdGFbb2Zmc2V0ICsgM107XG5cdFx0Y29uc3QgZiA9IE1hdGgucG93KDIuMCwgZSAtIDEyOC4wKTtcblxuXHRcdHIgKj0gZjtcblx0XHRnICo9IGY7XG5cdFx0YiAqPSBmO1xuXG5cdFx0Y29uc3QgZmxvYXRPZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHRmbG9hdERhdGFbZmxvYXRPZmZzZXQgKyAwXSA9IHI7XG5cdFx0ZmxvYXREYXRhW2Zsb2F0T2Zmc2V0ICsgMV0gPSBnO1xuXHRcdGZsb2F0RGF0YVtmbG9hdE9mZnNldCArIDJdID0gYjtcblx0XHRmbG9hdERhdGFbZmxvYXRPZmZzZXQgKyAzXSA9IDEuMDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c2hhcGU6IFt3aWR0aCwgaGVpZ2h0XSxcblx0XHRleHBvc3VyZSxcblx0XHRnYW1tYSxcblx0XHRkYXRhOiBmbG9hdERhdGFcblx0fTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZUhkcjsiLCIvLyBPcmJpdGFsQ29udHJvbC5qc1xuaW1wb3J0IHsgRWFzZU51bWJlciwgU2NoZWR1bGVyIH0gZnJvbSAnYWxmcmlkJztcblxuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNvbnN0IGdldE1vdXNlID0gZnVuY3Rpb24gKG1FdmVudCwgbVRhcmdldCkge1xuXG5cdGNvbnN0IG8gPSBtVGFyZ2V0IHx8IHt9O1xuXHRpZihtRXZlbnQudG91Y2hlcykge1xuXHRcdG8ueCA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuXHRcdG8ueSA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuXHR9IGVsc2Uge1xuXHRcdG8ueCA9IG1FdmVudC5jbGllbnRYO1xuXHRcdG8ueSA9IG1FdmVudC5jbGllbnRZO1xuXHR9XG5cblx0cmV0dXJuIG87XG59O1xuXG5jbGFzcyBPcmJpdGFsQ29udHJvbCB7XG5cblx0Y29uc3RydWN0b3IobVRhcmdldCwgbUxpc3RlbmVyVGFyZ2V0ID0gd2luZG93LCBtUmFkaXVzID0gNTAwKSB7XG5cdFx0dGhpcy5fdGFyZ2V0ICAgICAgICAgPSBtVGFyZ2V0O1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0ID0gbUxpc3RlbmVyVGFyZ2V0O1xuXHRcdHRoaXMuX21vdXNlICAgICAgICAgID0ge307XG5cdFx0dGhpcy5fcHJlTW91c2UgICAgICAgPSB7fTtcblx0XHR0aGlzLmNlbnRlciAgICAgICAgICA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGhpcy5fdXAgICAgICAgICAgICAgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCk7XG5cdFx0dGhpcy5yYWRpdXMgICAgICAgICAgPSBuZXcgRWFzZU51bWJlcihtUmFkaXVzKTtcblx0XHR0aGlzLnBvc2l0aW9uICAgICAgICA9IHZlYzMuZnJvbVZhbHVlcygwLCAwLCB0aGlzLnJhZGl1cy52YWx1ZSk7XG5cdFx0dGhpcy5wb3NpdGlvbk9mZnNldCAgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3J4ICAgICAgICAgICAgID0gbmV3IEVhc2VOdW1iZXIoMCk7XG5cdFx0dGhpcy5fcngubGltaXQoLU1hdGguUEkgLyAyLCBNYXRoLlBJIC8gMik7XG5cdFx0dGhpcy5fcnkgICAgICAgICAgICAgPSBuZXcgRWFzZU51bWJlcigwKTtcblx0XHR0aGlzLl9wcmVSWCAgICAgICAgICA9IDA7XG5cdFx0dGhpcy5fcHJlUlkgICAgICAgICAgPSAwO1xuXHRcdFxuXHRcdHRoaXMuX2lzTG9ja1pvb20gICAgID0gZmFsc2U7XG5cdFx0dGhpcy5faXNMb2NrUm90YXRpb24gPSBmYWxzZTtcblx0XHR0aGlzLl9pc0ludmVydCAgICAgICA9IGZhbHNlO1xuXHRcdHRoaXMuc2Vuc2l0aXZpdHlcdCA9IDEuMDtcblxuXG5cdFx0dGhpcy5fd2hlZWxCaW5kID0gKGUpID0+IHRoaXMuX29uV2hlZWwoZSk7XG5cdFx0dGhpcy5fZG93bkJpbmQgPSAoZSkgPT4gdGhpcy5fb25Eb3duKGUpO1xuXHRcdHRoaXMuX21vdmVCaW5kID0gKGUpID0+IHRoaXMuX29uTW92ZShlKTtcblx0XHR0aGlzLl91cEJpbmQgPSAoKSA9PiB0aGlzLl9vblVwKCk7XG5cdFxuXHRcdHRoaXMuX2VmSW5kZXggPSBTY2hlZHVsZXIuYWRkRUYoKCkgPT4gdGhpcy5fbG9vcCgpKTtcblx0fVxuXG5cdGNvbm5lY3QobUxpc3RlbmVyVGFyZ2V0KSB7XG5cdFx0aWYgKG1MaXN0ZW5lclRhcmdldCkgdGhpcy5fbGlzdGVuZXJUYXJnZXQgPSBtTGlzdGVuZXJUYXJnZXQ7XG5cdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fd2hlZWxCaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMuX3doZWVsQmluZCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9kb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2Rvd25CaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3ZlQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fbW92ZUJpbmQpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3VwQmluZCk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl91cEJpbmQpO1xuICAgIFxuXHRcdFxuXHR9XG5cblx0ZGlzY29ubmVjdCgpIHtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fd2hlZWxCaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMuX3doZWVsQmluZCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9kb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2Rvd25CaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3ZlQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fbW92ZUJpbmQpO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3VwQmluZCk7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl91cEJpbmQpO1xuXHR9XG5cblxuXHQvL1x0UFVCTElDIE1FVEhPRFNcblxuXHRsb2NrKG1WYWx1ZSA9IHRydWUpIHtcblx0XHR0aGlzLl9pc0xvY2tab29tID0gbVZhbHVlO1xuXHRcdHRoaXMuX2lzTG9ja1JvdGF0aW9uID0gbVZhbHVlO1xuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gZmFsc2U7XG5cdH1cblxuXHRsb2NrWm9vbShtVmFsdWUgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNMb2NrWm9vbSA9IG1WYWx1ZTtcblx0fVxuXG5cblx0bG9ja1JvdGF0aW9uKG1WYWx1ZSA9IHRydWUpIHtcblx0XHR0aGlzLl9pc0xvY2tSb3RhdGlvbiA9IG1WYWx1ZTtcblx0fVxuXG5cblx0aW52ZXJzZUNvbnRyb2woaXNJbnZlcnQgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNJbnZlcnQgPSBpc0ludmVydDtcblx0fVxuXG5cblx0Ly9cdEVWRU5UIEhBTkRMRVJFU1xuXHRfb25Eb3duKG1FdmVudCkge1xuXHRcdGlmKHRoaXMuX2lzTG9ja1JvdGF0aW9uKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gdHJ1ZTtcblx0XHRnZXRNb3VzZShtRXZlbnQsIHRoaXMuX21vdXNlKTtcblx0XHRnZXRNb3VzZShtRXZlbnQsIHRoaXMuX3ByZU1vdXNlKTtcblx0XHR0aGlzLl9wcmVSWCA9IHRoaXMuX3J4LnRhcmdldFZhbHVlO1xuXHRcdHRoaXMuX3ByZVJZID0gdGhpcy5fcnkudGFyZ2V0VmFsdWU7XG5cdH1cblxuXG5cdF9vbk1vdmUobUV2ZW50KSB7XG5cdFx0aWYodGhpcy5faXNMb2NrUm90YXRpb24pIHsgcmV0dXJuOyB9XG5cdFx0Z2V0TW91c2UobUV2ZW50LCB0aGlzLl9tb3VzZSk7XG5cdFx0aWYobUV2ZW50LnRvdWNoZXMpIHsgbUV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH1cblxuXHRcdGlmKHRoaXMuX2lzTW91c2VEb3duKSB7XG5cdFx0XHRsZXQgZGlmZlggPSAtKHRoaXMuX21vdXNlLnggLSB0aGlzLl9wcmVNb3VzZS54KTtcblx0XHRcdGlmKHRoaXMuX2lzSW52ZXJ0KSB7IGRpZmZYICo9IC0xOyB9XG5cdFx0XHR0aGlzLl9yeS52YWx1ZSA9IHRoaXMuX3ByZVJZIC0gZGlmZlggKiAwLjAxICogdGhpcy5zZW5zaXRpdml0eTtcblxuXHRcdFx0bGV0IGRpZmZZID0gLSh0aGlzLl9tb3VzZS55IC0gdGhpcy5fcHJlTW91c2UueSk7XG5cdFx0XHRpZih0aGlzLl9pc0ludmVydCkgeyBkaWZmWSAqPSAtMTsgfVxuXHRcdFx0dGhpcy5fcngudmFsdWUgPSB0aGlzLl9wcmVSWCAtIGRpZmZZICogMC4wMSAqIHRoaXMuc2Vuc2l0aXZpdHk7XG5cdFx0fVxuXHR9XG5cblxuXHRfb25VcCgpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tSb3RhdGlvbikgeyByZXR1cm47IH1cblx0XHR0aGlzLl9pc01vdXNlRG93biA9IGZhbHNlO1xuXHR9XG5cblxuXHRfb25XaGVlbChtRXZlbnQpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tab29tKSB7XHRyZXR1cm47XHR9XG5cdFx0Y29uc3QgdyA9IG1FdmVudC53aGVlbERlbHRhO1xuXHRcdGNvbnN0IGQgPSBtRXZlbnQuZGV0YWlsO1xuXHRcdGxldCB2YWx1ZSA9IDA7XG5cdFx0aWYgKGQpIHtcblx0XHRcdGlmICh3KSB7XG5cdFx0XHRcdHZhbHVlID0gdyAvIGQgLyA0MCAqIGQgPiAwID8gMSA6IC0xOyAvLyBPcGVyYVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSAtZCAvIDM7ICAgICAgICAgICAgICAvLyBGaXJlZm94OyAgICAgICAgIFRPRE86IGRvIG5vdCAvMyBmb3IgT1MgWFxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IHcgLyAxMjA7IFxuXHRcdH1cblxuXHRcdHRoaXMucmFkaXVzLmFkZCgtdmFsdWUgKiAyKTtcblx0fVxuXG5cblx0Ly9cdFBSSVZBVEUgTUVUSE9EU1xuXG5cdF9sb29wKCkge1xuXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuXHRcdGlmKHRoaXMuX3RhcmdldCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlQ2FtZXJhKCk7XG5cdFx0fVxuXHR9XG5cblxuXHRfdXBkYXRlUG9zaXRpb24oKSB7XG5cdFx0dGhpcy5wb3NpdGlvblsxXSA9IE1hdGguc2luKHRoaXMuX3J4LnZhbHVlKSAqIHRoaXMucmFkaXVzLnZhbHVlO1xuXHRcdGNvbnN0IHRyID0gTWF0aC5jb3ModGhpcy5fcngudmFsdWUpICogdGhpcy5yYWRpdXMudmFsdWU7XG5cdFx0dGhpcy5wb3NpdGlvblswXSA9IE1hdGguY29zKHRoaXMuX3J5LnZhbHVlICsgTWF0aC5QSSAqIDAuNSkgKiB0cjtcblx0XHR0aGlzLnBvc2l0aW9uWzJdID0gTWF0aC5zaW4odGhpcy5fcnkudmFsdWUgKyBNYXRoLlBJICogMC41KSAqIHRyO1xuXHRcdHZlYzMuYWRkKHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb25PZmZzZXQpO1xuXHR9XG5cblx0Z2V0UG9zaXRpb24ocngsIHJ5LCByYWRpdXMpIHtcblx0XHRjb25zdCB5ID0gTWF0aC5zaW4ocngpICogcmFkaXVzO1xuXHRcdGNvbnN0IHRyID0gTWF0aC5jb3MocngpICogcmFkaXVzO1xuXHRcdGNvbnN0IHggPSBNYXRoLmNvcyhyeSArIE1hdGguUEkgKiAwLjUpICogdHI7XG5cdFx0Y29uc3QgeiA9IE1hdGguc2luKHJ5ICsgTWF0aC5QSSAqIDAuNSkgKiB0cjtcblx0XHRyZXR1cm4gW3gsIHksIHpdO1xuXHR9XG5cblxuXHRfdXBkYXRlQ2FtZXJhKCkge1xuXHRcdHRoaXMuX3RhcmdldC5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGhpcy5jZW50ZXIsIHRoaXMuX3VwKTtcblx0fVxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cdFx0U2NoZWR1bGVyLnJlbW92ZUVGKHRoaXMuX2VmSW5kZXgpO1xuXHR9XG5cblxuXHQvL1x0R0VUVEVSIC8gU0VUVEVSXG5cblxuXHRnZXQgcngoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3J4O1xuXHR9XG5cblxuXHRnZXQgcnkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3J5O1xuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgT3JiaXRhbENvbnRyb2w7IiwiLy8gUXVhdFJvdGF0aW9uLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgbWF0NCwgdmVjMywgcXVhdCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgRWFzZU51bWJlciBmcm9tICcuL0Vhc2VOdW1iZXInO1xuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJztcblxuY29uc3QgZ2V0TW91c2UgPSBmdW5jdGlvbiAobUV2ZW50LCBtVGFyZ2V0KSB7XG5cblx0Y29uc3QgbyA9IG1UYXJnZXQgfHwge307XG5cdGlmKG1FdmVudC50b3VjaGVzKSB7XG5cdFx0by54ID0gbUV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XG5cdFx0by55ID0gbUV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7XG5cdH0gZWxzZSB7XG5cdFx0by54ID0gbUV2ZW50LmNsaWVudFg7XG5cdFx0by55ID0gbUV2ZW50LmNsaWVudFk7XG5cdH1cblxuXHRyZXR1cm4gbztcbn07XG5cbmNsYXNzIFF1YXRSb3RhdGlvbiB7XG5cdGNvbnN0cnVjdG9yKG1UYXJnZXQsIG1MaXN0ZW5lclRhcmdldCA9IHdpbmRvdywgbUVhc2luZyA9IDAuMSkge1xuXG5cdFx0dGhpcy5fdGFyZ2V0ICAgICAgICAgPSBtVGFyZ2V0O1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0ID0gbUxpc3RlbmVyVGFyZ2V0O1xuXHRcdFxuXHRcdHRoaXMubWF0cml4ICAgICAgICAgID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLm0gICAgICAgICAgICAgICA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fdlpheGlzICAgICAgICAgPSB2ZWMzLmNsb25lKFswLCAwLCAwXSk7XG5cdFx0dGhpcy5fekF4aXMgICAgICAgICAgPSB2ZWMzLmNsb25lKFswLCAwLCAxXSk7XG5cdFx0dGhpcy5wcmVNb3VzZSAgICAgICAgPSB7IHg6MCwgeTowIH07XG5cdFx0dGhpcy5tb3VzZSAgICAgICAgICAgPSB7IHg6MCwgeTowIH07XG5cdFx0dGhpcy5faXNNb3VzZURvd24gICAgPSBmYWxzZTtcblx0XHR0aGlzLl9yb3RhdGlvbiAgICAgICA9IHF1YXQuY3JlYXRlKCk7XG5cdFx0dGhpcy50ZW1wUm90YXRpb24gICAgPSBxdWF0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3JvdGF0ZVpNYXJnaW4gID0gMDtcblx0XHR0aGlzLl9vZmZzZXQgICAgICAgICA9IDAuMDA0O1xuXHRcdHRoaXMuX3NsZXJwICAgICAgICAgID0gLTE7XG5cdFx0dGhpcy5faXNMb2NrZWQgICAgICAgPSBmYWxzZTtcblx0XHRcblx0XHR0aGlzLl9kaWZmWCAgICAgICAgICA9IG5ldyBFYXNlTnVtYmVyKDAsIG1FYXNpbmcpO1xuXHRcdHRoaXMuX2RpZmZZICAgICAgICAgID0gbmV3IEVhc2VOdW1iZXIoMCwgbUVhc2luZyk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4gdGhpcy5fb25Eb3duKGUpKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKGUpID0+IHRoaXMuX29uRG93bihlKSk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHRoaXMuX29uTW92ZShlKSk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgKGUpID0+IHRoaXMuX29uTW92ZShlKSk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKCkgPT4gdGhpcy5fb25VcCgpKTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICgpID0+IHRoaXMuX29uVXAoKSk7XG5cblx0XHRTY2hlZHVsZXIuYWRkRUYoKCkgPT4gdGhpcy5fbG9vcCgpKTtcblx0fVxuXG5cdC8vIFx0UFVCTElDIE1FVEhPRFNcblxuXHRpbnZlcnNlQ29udHJvbChpc0ludmVydCA9IHRydWUpIHtcblx0XHR0aGlzLl9pc0ludmVydCA9IGlzSW52ZXJ0O1xuXHR9XG5cblx0bG9jayhtVmFsdWUgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNMb2NrZWQgPSBtVmFsdWU7XG5cdH1cdFxuXG5cdHNldENhbWVyYVBvcyhtUXVhdCwgc3BlZWQgPSAwLjEpIHtcblx0XHR0aGlzLmVhc2luZyA9IHNwZWVkO1xuXHRcdGlmKHRoaXMuX3NsZXJwID4gMCkgeyByZXR1cm47IH1cblx0XHRcblx0XHRjb25zdCB0ZW1wUm90YXRpb24gID0gcXVhdC5jbG9uZSh0aGlzLl9yb3RhdGlvbik7XG5cdFx0dGhpcy5fdXBkYXRlUm90YXRpb24odGVtcFJvdGF0aW9uKTtcblx0XHR0aGlzLl9yb3RhdGlvbiAgICA9IHF1YXQuY2xvbmUodGVtcFJvdGF0aW9uKTtcblx0XHR0aGlzLl9jdXJyRGlmZlggICA9IHRoaXMuZGlmZlggPSAwO1xuXHRcdHRoaXMuX2N1cnJEaWZmWSAgID0gdGhpcy5kaWZmWSA9IDA7XG5cdFx0XG5cdFx0dGhpcy5faXNNb3VzZURvd24gPSBmYWxzZTtcblx0XHR0aGlzLl9pc1JvdGF0ZVogICA9IDA7XG5cdFx0XG5cdFx0dGhpcy5fdGFyZ2V0UXVhdCAgPSBxdWF0LmNsb25lKG1RdWF0KTtcblx0XHR0aGlzLl9zbGVycCAgICAgICA9IDE7XG5cdH1cblxuXHRyZXNldFF1YXQoKSB7XG5cdFx0dGhpcy5fcm90YXRpb24gICAgPSBxdWF0LmNsb25lKFswLCAwLCAxLCAwXSk7XG5cdFx0dGhpcy50ZW1wUm90YXRpb24gPSBxdWF0LmNsb25lKFswLCAwLCAwLCAwXSk7XG5cdFx0dGhpcy5fdGFyZ2V0UXVhdCAgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5fc2xlcnAgICAgICAgPSAtMTtcblx0fVxuXG5cdC8vXHRFVkVOVCBIQU5ETEVSXG5cblx0X29uRG93bihtRXZlbnQpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tlZCkgeyByZXR1cm47IH1cblxuXHRcdGNvbnN0IG1vdXNlID0gZ2V0TW91c2UobUV2ZW50KTtcblx0XHRjb25zdCB0ZW1wUm90YXRpb24gPSBxdWF0LmNsb25lKHRoaXMuX3JvdGF0aW9uKTtcblx0XHR0aGlzLl91cGRhdGVSb3RhdGlvbih0ZW1wUm90YXRpb24pO1xuXHRcdHRoaXMuX3JvdGF0aW9uID0gdGVtcFJvdGF0aW9uO1xuXG5cdFx0dGhpcy5faXNNb3VzZURvd24gPSB0cnVlO1xuXHRcdHRoaXMuX2lzUm90YXRlWiA9IDA7XG5cdFx0dGhpcy5wcmVNb3VzZSA9IHsgeDptb3VzZS54LCB5Om1vdXNlLnkgfTtcblxuXHRcdGlmKG1vdXNlLnkgPCB0aGlzLl9yb3RhdGVaTWFyZ2luIHx8IG1vdXNlLnkgPiAod2luZG93LmlubmVySGVpZ2h0IC0gdGhpcy5fcm90YXRlWk1hcmdpbikpIHtcdFxuXHRcdFx0dGhpcy5faXNSb3RhdGVaID0gMTtcdFxuXHRcdH0gZWxzZSBpZihtb3VzZS54IDwgdGhpcy5fcm90YXRlWk1hcmdpbiB8fCBtb3VzZS54ID4gKHdpbmRvdy5pbm5lcldpZHRoIC0gdGhpcy5fcm90YXRlWk1hcmdpbikpIHtcdFxuXHRcdFx0dGhpcy5faXNSb3RhdGVaID0gMjtcdFxuXHRcdH1cblxuXHRcdHRoaXMuX2RpZmZYLnNldFRvKDApO1xuXHRcdHRoaXMuX2RpZmZZLnNldFRvKDApO1xuXHR9XG5cblxuXHRfb25Nb3ZlKG1FdmVudCkge1xuXHRcdGlmKHRoaXMuX2lzTG9ja2VkKSB7IHJldHVybjsgfVxuXHRcdGdldE1vdXNlKG1FdmVudCwgdGhpcy5tb3VzZSk7XG5cdH1cblxuXG5cdF9vblVwKCkge1xuXHRcdGlmKHRoaXMuX2lzTG9ja2VkKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gZmFsc2U7XG5cdH1cblxuXG5cdC8vXHRQUklWQVRFIE1FVEhPRFNcblxuXHRfdXBkYXRlUm90YXRpb24obVRlbXBSb3RhdGlvbikge1xuXHRcdGlmKHRoaXMuX2lzTW91c2VEb3duICYmICF0aGlzLl9pc0xvY2tlZCkge1xuXHRcdFx0dGhpcy5fZGlmZlgudmFsdWUgPSAtKHRoaXMubW91c2UueCAtIHRoaXMucHJlTW91c2UueCk7XG5cdFx0XHR0aGlzLl9kaWZmWS52YWx1ZSA9ICAodGhpcy5tb3VzZS55IC0gdGhpcy5wcmVNb3VzZS55KTtcblxuXHRcdFx0aWYodGhpcy5faXNJbnZlcnQpIHtcblx0XHRcdFx0dGhpcy5fZGlmZlgudmFsdWUgPSAtdGhpcy5fZGlmZlgudGFyZ2V0VmFsdWU7XG5cdFx0XHRcdHRoaXMuX2RpZmZZLnZhbHVlID0gLXRoaXMuX2RpZmZZLnRhcmdldFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRsZXQgYW5nbGUsIF9xdWF0O1xuXG5cdFx0aWYodGhpcy5faXNSb3RhdGVaID4gMCkge1xuXHRcdFx0aWYodGhpcy5faXNSb3RhdGVaID09PSAxKSB7XG5cdFx0XHRcdGFuZ2xlID0gLXRoaXMuX2RpZmZYLnZhbHVlICogdGhpcy5fb2Zmc2V0OyBcblx0XHRcdFx0YW5nbGUgKj0gKHRoaXMucHJlTW91c2UueSA8IHRoaXMuX3JvdGF0ZVpNYXJnaW4pID8gLTEgOiAxO1xuXHRcdFx0XHRfcXVhdCA9IHF1YXQuY2xvbmUoWzAsIDAsIE1hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpXSk7XG5cdFx0XHRcdHF1YXQubXVsdGlwbHkoX3F1YXQsIG1UZW1wUm90YXRpb24sIF9xdWF0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFuZ2xlID0gLXRoaXMuX2RpZmZZLnZhbHVlICogdGhpcy5fb2Zmc2V0OyBcblx0XHRcdFx0YW5nbGUgKj0gKHRoaXMucHJlTW91c2UueCA8IHRoaXMuX3JvdGF0ZVpNYXJnaW4pID8gMSA6IC0xO1xuXHRcdFx0XHRfcXVhdCA9IHF1YXQuY2xvbmUoWzAsIDAsIE1hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpXSk7XG5cdFx0XHRcdHF1YXQubXVsdGlwbHkoX3F1YXQsIG1UZW1wUm90YXRpb24sIF9xdWF0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgdiA9IHZlYzMuY2xvbmUoW3RoaXMuX2RpZmZYLnZhbHVlLCB0aGlzLl9kaWZmWS52YWx1ZSwgMF0pO1xuXHRcdFx0Y29uc3QgYXhpcyA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0XHR2ZWMzLmNyb3NzKGF4aXMsIHYsIHRoaXMuX3pBeGlzKTtcblx0XHRcdHZlYzMubm9ybWFsaXplKGF4aXMsIGF4aXMpO1xuXHRcdFx0YW5nbGUgPSB2ZWMzLmxlbmd0aCh2KSAqIHRoaXMuX29mZnNldDtcblx0XHRcdF9xdWF0ID0gcXVhdC5jbG9uZShbTWF0aC5zaW4oYW5nbGUpICogYXhpc1swXSwgTWF0aC5zaW4oYW5nbGUpICogYXhpc1sxXSwgTWF0aC5zaW4oYW5nbGUpICogYXhpc1syXSwgTWF0aC5jb3MoYW5nbGUpXSk7XG5cdFx0XHRxdWF0Lm11bHRpcGx5KG1UZW1wUm90YXRpb24sIF9xdWF0LCBtVGVtcFJvdGF0aW9uKTtcblx0XHR9XG5cdH1cblxuXHRfbG9vcCgpIHtcblx0XHRtYXQ0LmlkZW50aXR5KHRoaXMubSk7XG5cblx0XHRpZih0aGlzLl90YXJnZXRRdWF0ID09PSB1bmRlZmluZWQpIHsgXG5cdFx0XHRxdWF0LnNldCh0aGlzLnRlbXBSb3RhdGlvbiwgdGhpcy5fcm90YXRpb25bMF0sIHRoaXMuX3JvdGF0aW9uWzFdLCB0aGlzLl9yb3RhdGlvblsyXSwgdGhpcy5fcm90YXRpb25bM10pO1xuXHRcdFx0dGhpcy5fdXBkYXRlUm90YXRpb24odGhpcy50ZW1wUm90YXRpb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zbGVycCArPSAoMCAtIHRoaXMuX3NsZXJwKSAqIDAuMTtcblxuXHRcdFx0aWYodGhpcy5fc2xlcnAgPCAwLjAwMDUpIHtcblx0XHRcdFx0cXVhdC5jb3B5KHRoaXMuX3JvdGF0aW9uLCB0aGlzLl90YXJnZXRRdWF0KTtcblx0XHRcdFx0cXVhdC5jb3B5KHRoaXMudGVtcFJvdGF0aW9uLCB0aGlzLl90YXJnZXRRdWF0KTtcblx0XHRcdFx0dGhpcy5fdGFyZ2V0UXVhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0dGhpcy5fZGlmZlguc2V0VG8oMCk7XG5cdFx0XHRcdHRoaXMuX2RpZmZZLnNldFRvKDApO1xuXHRcdFx0XHR0aGlzLl9zbGVycCA9IC0xO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cXVhdC5zZXQodGhpcy50ZW1wUm90YXRpb24sIDAsIDAsIDAsIDApO1xuXHRcdFx0XHRxdWF0LnNsZXJwKHRoaXMudGVtcFJvdGF0aW9uLCB0aGlzLl90YXJnZXRRdWF0LCB0aGlzLl9yb3RhdGlvbiwgdGhpcy5fc2xlcnApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZlYzMudHJhbnNmb3JtUXVhdCh0aGlzLl92WmF4aXMsIHRoaXMuX3ZaYXhpcywgdGhpcy50ZW1wUm90YXRpb24pO1xuXG5cdFx0bWF0NC5mcm9tUXVhdCh0aGlzLm1hdHJpeCwgdGhpcy50ZW1wUm90YXRpb24pO1xuXHR9XG5cblxuXHQvL1x0R0VUVEVSIEFORCBTRVRURVJcblxuXHRzZXQgZWFzaW5nKG1WYWx1ZSkge1xuXHRcdHRoaXMuX2RpZmZYLmVhc2luZyA9IG1WYWx1ZTtcblx0XHR0aGlzLl9kaWZmWS5lYXNpbmcgPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgZWFzaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl9kaWZmWC5lYXNpbmc7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUXVhdFJvdGF0aW9uOyIsIi8vIFNoYWRlckxicy5qc1xuXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHNpbXBsZUNvbG9yRnJhZyBmcm9tICcuLi9zaGFkZXJzL3NpbXBsZUNvbG9yLmZyYWcnXG5pbXBvcnQgYmlnVHJpYW5nbGVWZXJ0IGZyb20gJy4uL3NoYWRlcnMvYmlnVHJpYW5nbGUudmVydCdcbmltcG9ydCBnZW5lcmFsVmVydCBmcm9tICcuLi9zaGFkZXJzL2dlbmVyYWwudmVydCdcbmltcG9ydCBjb3B5RnJhZyBmcm9tICcuLi9zaGFkZXJzL2NvcHkuZnJhZydcbmltcG9ydCBiYXNpY1ZlcnQgZnJvbSAnLi4vc2hhZGVycy9iYXNpYy52ZXJ0J1xuaW1wb3J0IHNreWJveFZlcnQgZnJvbSAnLi4vc2hhZGVycy9za3lib3gudmVydCdcbmltcG9ydCBza3lib3hGcmFnIGZyb20gJy4uL3NoYWRlcnMvc2t5Ym94LmZyYWcnXG5cbmNvbnN0IFNoYWRlckxpYnMgPSB7XG4gIHNpbXBsZUNvbG9yRnJhZyxcbiAgYmlnVHJpYW5nbGVWZXJ0LFxuICBnZW5lcmFsVmVydCxcbiAgY29weUZyYWcsXG4gIGJhc2ljVmVydCxcbiAgc2t5Ym94VmVydCxcbiAgc2t5Ym94RnJhZ1xufVxuXG5leHBvcnQgZGVmYXVsdCBTaGFkZXJMaWJzXG4iLCIvLyBTcHJpbmdOdW1iZXIuanNcblxuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJztcblxuY2xhc3MgU3ByaW5nTnVtYmVyIHtcblxuXHRjb25zdHJ1Y3RvcihtVmFsdWUsIG1TcGVlZD0wLjEsIG1EZWNyZWFzZVJhdGU9MC45KSB7XG5cdFx0dGhpcy5fdmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5zcGVlZCA9IG1TcGVlZDtcblx0XHR0aGlzLmRlY3JlYXNlUmF0ZSA9IG1EZWNyZWFzZVJhdGU7XG5cblx0XHR0aGlzLl92ZWxvY2l0eSA9IDA7XG5cblx0XHR0aGlzLl9lZkluZGV4ICAgICA9IFNjaGVkdWxlci5hZGRFRigoKT0+IHRoaXMuX3VwZGF0ZSgpKTtcblx0fVxuXG5cblx0X3VwZGF0ZSgpIHtcblx0XHRjb25zdCBNSU5fRElGRiA9IDAuMDAwMTtcblx0XHR0aGlzLl9jaGVja0xpbWl0KCk7XG5cdFx0aWYoTWF0aC5hYnModGhpcy5fdGFyZ2V0VmFsdWUgLSB0aGlzLl92YWx1ZSkgPCBNSU5fRElGRikge1xuXHRcdFx0dGhpcy5fdmFsdWUgPSB0aGlzLl90YXJnZXRWYWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl92ZWxvY2l0eSArPSAodGhpcy5fdGFyZ2V0VmFsdWUgLSB0aGlzLl92YWx1ZSkgKiB0aGlzLnNwZWVkO1xuXG5cdFx0dGhpcy5fdmFsdWUgKz0gdGhpcy5fdmVsb2NpdHk7XG5cdFx0dGhpcy5fdmVsb2NpdHkgKj0gdGhpcy5kZWNyZWFzZVJhdGU7XG5cblx0XHRpZihNYXRoLmFicyh0aGlzLl90YXJnZXRWYWx1ZSAtIHRoaXMuX3ZhbHVlKSA8IE1JTl9ESUZGKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSA9IHRoaXMuX3RhcmdldFZhbHVlO1xuXHRcdH1cblx0fVxuXG5cblx0bGltaXQobU1pbiwgbU1heCkge1xuXHRcdGlmKG1NaW4gPiBtTWF4KSB7XG5cdFx0XHR0aGlzLmxpbWl0KG1NYXgsIG1NaW4pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX21pbiA9IG1NaW47XG5cdFx0dGhpcy5fbWF4ID0gbU1heDtcblxuXHRcdHRoaXMuX2NoZWNrTGltaXQoKTtcblx0fVxuXG5cblx0X2NoZWNrTGltaXQoKSB7XG5cdFx0aWYodGhpcy5fbWluICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fdGFyZ2V0VmFsdWUgPCB0aGlzLl9taW4pIHtcblx0XHRcdHRoaXMuX3RhcmdldFZhbHVlID0gdGhpcy5fbWluO1xuXHRcdH0gXG5cblx0XHRpZih0aGlzLl9tYXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLl90YXJnZXRWYWx1ZSA+IHRoaXMuX21heCkge1xuXHRcdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSB0aGlzLl9tYXg7XG5cdFx0fSBcblx0fVxuXG5cblx0ZGVzdHJveSgpIHtcblx0XHRTY2hlZHVsZXIucmVtb3ZlRUYodGhpcy5fZWZJbmRleCk7XG5cdH1cblxuXG5cdHNldCB2YWx1ZShtVmFsdWUpIHtcblx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IG1WYWx1ZTtcblx0fVxuXG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgU3ByaW5nTnVtYmVyOyIsIi8vIFRvdWNoRGV0ZWN0b3IuanNcbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IEV2ZW50RGlzcGF0Y2hlciBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlcic7XG5pbXBvcnQgUmF5IGZyb20gJy4uL21hdGgvUmF5JztcbmltcG9ydCBnZXRNb3VzZSBmcm9tICcuL2dldE1vdXNlJztcblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuXHRjb25zdCBkeCA9IGEueCAtIGIueDtcblx0Y29uc3QgZHkgPSBhLnkgLSBiLnk7XG5cdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xufVxuXG5jbGFzcyBUb3VjaERldGVjdG9yIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0Y29uc3RydWN0b3IobU1lc2gsIG1DYW1lcmEsIG1Ta2lwTW92ZUNoZWNrPWZhbHNlLCBtTGlzdGVuZXJUYXJnZXQ9d2luZG93KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX21lc2ggPSBtTWVzaDtcblx0XHR0aGlzLl9tZXNoLmdlbmVyYXRlRmFjZXMoKTtcblx0XHR0aGlzLl9jYW1lcmEgPSBtQ2FtZXJhO1xuXHRcdHRoaXMuZmFjZVZlcnRpY2VzID0gbU1lc2guZmFjZXMubWFwKChmYWNlKT0+KGZhY2UudmVydGljZXMpKTtcblx0XHR0aGlzLmNsaWNrVG9sZXJhbmNlID0gODtcblxuXHRcdHRoaXMuX3JheSA9IG5ldyBSYXkoWzAsIDAsIDBdLCBbMCwgMCwgLTFdKTtcblx0XHR0aGlzLl9oaXQgPSB2ZWMzLmZyb21WYWx1ZXMoLTk5OSwgLTk5OSwgLTk5OSk7XG5cdFx0dGhpcy5fbGFzdFBvcztcblx0XHR0aGlzLl9maXJzdFBvcztcblx0XHR0aGlzLm10eE1vZGVsID0gbWF0NC5jcmVhdGUoKTtcblxuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0ID0gbUxpc3RlbmVyVGFyZ2V0O1xuXHRcdHRoaXMuX3NraXBwaW5nTW92ZSA9IG1Ta2lwTW92ZUNoZWNrO1xuXG5cdFx0dGhpcy5fb25Nb3ZlQmluZCA9IChlKSA9PiB0aGlzLl9vbk1vdmUoZSk7XG5cdFx0dGhpcy5fb25Eb3duQmluZCA9IChlKSA9PiB0aGlzLl9vbkRvd24oZSk7XG5cdFx0dGhpcy5fb25VcEJpbmQgPSAoKSA9PiB0aGlzLl9vblVwKCk7XG5cblx0XHR0aGlzLmNvbm5lY3QoKTtcblx0fVxuXG5cdGNvbm5lY3QoKSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Eb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlQmluZCk7XHRcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25VcEJpbmQpO1xuXHR9XG5cblx0ZGlzY29ubmVjdCgpIHtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkRvd25CaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmVCaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25VcEJpbmQpO1xuXHR9XG5cblxuXHRfY2hlY2tIaXQobVR5cGU9J29uSGl0Jykge1xuXHRcdGNvbnN0IGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcblx0XHRpZighY2FtZXJhKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cblx0XHRjb25zdCBteCA9ICh0aGlzLl9sYXN0UG9zLnggLyBHTC53aWR0aCkgKiAyLjAgLSAxLjA7XG5cdFx0Y29uc3QgbXkgPSAtICh0aGlzLl9sYXN0UG9zLnkgLyBHTC5oZWlnaHQpICogMi4wICsgMS4wO1xuXG5cdFx0Y2FtZXJhLmdlbmVyYXRlUmF5KFtteCwgbXksIDBdLCB0aGlzLl9yYXkpO1xuXG5cdFx0bGV0IGhpdDtcblx0XHRjb25zdCB2MCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Y29uc3QgdjEgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdGNvbnN0IHYyID0gdmVjMy5jcmVhdGUoKTtcblx0XHRsZXQgZGlzdCA9IDA7XG5cblx0XHRjb25zdCBnZXRWZWN0b3IgPSAodiwgdGFyZ2V0KSA9PiB7XG5cdFx0XHR2ZWMzLnRyYW5zZm9ybU1hdDQodGFyZ2V0LCB2LCB0aGlzLm10eE1vZGVsKTtcblx0XHR9O1xuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZVZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IHRoaXMuZmFjZVZlcnRpY2VzW2ldO1xuXHRcdFx0Z2V0VmVjdG9yKHZlcnRpY2VzWzBdLCB2MCk7IFxuXHRcdFx0Z2V0VmVjdG9yKHZlcnRpY2VzWzFdLCB2MSk7IFxuXHRcdFx0Z2V0VmVjdG9yKHZlcnRpY2VzWzJdLCB2Mik7IFxuXHRcdFx0Y29uc3QgdCA9IHRoaXMuX3JheS5pbnRlcnNlY3RUcmlhbmdsZSh2MCwgdjEsIHYyKTtcblxuXHRcdFx0aWYodCkge1xuXHRcdFx0XHRpZihoaXQpIHtcblx0XHRcdFx0XHRjb25zdCBkaXN0VG9DYW0gPSB2ZWMzLmRpc3QodCwgY2FtZXJhLnBvc2l0aW9uKTtcblx0XHRcdFx0XHRpZihkaXN0VG9DYW0gPCBkaXN0KSB7XG5cdFx0XHRcdFx0XHRoaXQgPSB2ZWMzLmNsb25lKHQpO1xuXHRcdFx0XHRcdFx0ZGlzdCA9IGRpc3RUb0NhbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGl0ID0gdmVjMy5jbG9uZSh0KTtcblx0XHRcdFx0XHRkaXN0ID0gdmVjMy5kaXN0KGhpdCwgY2FtZXJhLnBvc2l0aW9uKTtcblx0XHRcdFx0fVx0XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRpZihoaXQpIHtcblx0XHRcdHRoaXMuX2hpdCA9IHZlYzMuY2xvbmUoaGl0KTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hDdXN0b21FdmVudChtVHlwZSwgeyBoaXQgfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZGlzcGF0Y2hDdXN0b21FdmVudCgnb25VcCcpO1xuXHRcdH1cblx0fVxuXG5cblx0X29uRG93bihlKSB7XG5cdFx0dGhpcy5fZmlyc3RQb3MgPSBnZXRNb3VzZShlKTtcblx0XHR0aGlzLl9sYXN0UG9zID0gZ2V0TW91c2UoZSk7XG5cdFx0dGhpcy5fY2hlY2tIaXQoJ29uRG93bicpO1xuXHR9XG5cblx0X29uTW92ZShlKSB7XG5cdFx0dGhpcy5fbGFzdFBvcyA9IGdldE1vdXNlKGUpO1xuXHRcdGlmKCF0aGlzLl9za2lwcGluZ01vdmUpIHtcblx0XHRcdHRoaXMuX2NoZWNrSGl0KCk7XG5cdFx0fVxuXHR9XG5cblx0X29uVXAoKSB7XG5cdFx0Y29uc3QgZGlzdCA9IGRpc3RhbmNlKHRoaXMuX2ZpcnN0UG9zLCB0aGlzLl9sYXN0UG9zKTtcblx0XHRpZihkaXN0IDwgdGhpcy5jbGlja1RvbGVyYW5jZSkge1xuXHRcdFx0dGhpcy5fY2hlY2tIaXQoKTtcdFxuXHRcdH1cblx0XHRcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvdWNoRGV0ZWN0b3I7IiwiLy8gVHdlZW5OdW1iZXIuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJ3NjaGVkdWxpbmcnO1xuXG5jb25zdCBFYXNpbmcgPSB7XG5cdExpbmVhcjoge1xuXHRcdE5vbmUoaykge1xuXHRcdFx0cmV0dXJuIGs7XG5cdFx0fVxuXHR9LFxuXHRRdWFkcmF0aWM6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gayAqIGs7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0cmV0dXJuIGsgKiAoMiAtIGspO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLSAwLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuXHRcdH1cblx0fSxcblx0Q3ViaWM6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiAtLWsgKiBrICogayArIDE7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBrICogayAqIGs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcblx0XHR9XG5cdH0sXG5cdFF1YXJ0aWM6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrICogaztcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gMSAtICgtLWsgKiBrICogayAqIGspO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcblx0XHRcdH1cblx0XHRcdHJldHVybiAtIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuXHRcdH1cblx0fSxcblx0UXVpbnRpYzoge1xuXHRcdEluKGspIHtcblx0XHRcdHJldHVybiBrICogayAqIGsgKiBrICogaztcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcblx0XHRcdH1cblx0XHRcdHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG5cdFx0fVxuXHR9LFxuXHRTaW51c29pZGFsOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0cmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcblx0XHR9XG5cdH0sXG5cdEV4cG9uZW50aWFsOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtIDEwICogayk7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRpZiAoayA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqICgtIE1hdGgucG93KDIsIC0gMTAgKiAoayAtIDEpKSArIDIpO1xuXHRcdH1cblx0fSxcblx0Q2lyY3VsYXI6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiBNYXRoLnNxcnQoMSAtICgtLWsgKiBrKSk7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAtIDAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChrIC09IDIpICogaykgKyAxKTtcblx0XHR9XG5cdH0sXG5cdEVsYXN0aWM6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRsZXQgcztcblx0XHRcdGxldCBhID0gMC4xO1xuXHRcdFx0Y29uc3QgcCA9IDAuNDtcblx0XHRcdGlmIChrID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGsgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWEgfHwgYSA8IDEpIHtcblx0XHRcdFx0YSA9IDE7XG5cdFx0XHRcdHMgPSBwIC8gNDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLSAoYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0bGV0IHM7XG5cdFx0XHRsZXQgYSA9IDAuMTtcblx0XHRcdGNvbnN0IHAgPSAwLjQ7XG5cdFx0XHRpZiAoayA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFhIHx8IGEgPCAxKSB7XG5cdFx0XHRcdGEgPSAxO1xuXHRcdFx0XHRzID0gcCAvIDQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIChhICogTWF0aC5wb3coMiwgLSAxMCAqIGspICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDEpO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0bGV0IHM7XG5cdFx0XHRsZXQgYSA9IDAuMTtcblx0XHRcdGNvbnN0IHAgPSAwLjQ7XG5cdFx0XHRpZiAoayA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFhIHx8IGEgPCAxKSB7XG5cdFx0XHRcdGEgPSAxO1xuXHRcdFx0XHRzID0gcCAvIDQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gLSAwLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXHRcdH1cblx0fSxcblx0QmFjazoge1xuXHRcdEluKGspIHtcblx0XHRcdGNvbnN0IHMgPSAxLjcwMTU4O1xuXHRcdFx0cmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0Y29uc3QgcyA9IDEuNzAxNTg7XG5cdFx0XHRyZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGNvbnN0IHMgPSAxLjcwMTU4ICogMS41MjU7XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiAoayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG5cdFx0fVxuXHR9LFxuXHRCb3VuY2U6IHtcblx0XHRpbihrKSB7XG5cdFx0XHRyZXR1cm4gMSAtIEVhc2luZy5Cb3VuY2Uub3V0KDEgLSBrKTtcblx0XHR9LFxuXHRcdG91dChrKSB7XG5cdFx0XHRpZiAoayA8ICgxIC8gMi43NSkpIHtcblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuXHRcdFx0fSBlbHNlIGlmIChrIDwgKDIgLyAyLjc1KSkge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKGsgLT0gKDEuNSAvIDIuNzUpKSAqIGsgKyAwLjc1O1xuXHRcdFx0fSBlbHNlIGlmIChrIDwgKDIuNSAvIDIuNzUpKSB7XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi4yNSAvIDIuNzUpKSAqIGsgKyAwLjkzNzU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuNjI1IC8gMi43NSkpICogayArIDAuOTg0Mzc1O1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW5PdXQoaykge1xuXHRcdFx0aWYgKGsgPCAwLjUpIHtcblx0XHRcdFx0cmV0dXJuIEVhc2luZy5Cb3VuY2UuaW4oayAqIDIpICogMC41O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEVhc2luZy5Cb3VuY2Uub3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG5cdFx0fVxuXHR9XG59O1xuXG5mdW5jdGlvbiBnZXRGdW5jKG1FYXNpbmcpIHtcblx0c3dpdGNoIChtRWFzaW5nKSB7XG5cdGRlZmF1bHQ6XG5cdGNhc2UgJ2xpbmVhcicgOlxuXHRcdHJldHVybiBFYXNpbmcuTGluZWFyLk5vbmU7XG5cdGNhc2UgJ2V4cEluJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5FeHBvbmVudGlhbC5Jbjtcblx0Y2FzZSAnZXhwT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5FeHBvbmVudGlhbC5PdXQ7XG5cdGNhc2UgJ2V4cEluT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5FeHBvbmVudGlhbC5Jbk91dDtcblxuXHRjYXNlICdjdWJpY0luJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5DdWJpYy5Jbjtcblx0Y2FzZSAnY3ViaWNPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkN1YmljLk91dDtcblx0Y2FzZSAnY3ViaWNJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQ3ViaWMuSW5PdXQ7XG5cblx0Y2FzZSAncXVhcnRpY0luJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5RdWFydGljLkluO1xuXHRjYXNlICdxdWFydGljT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5RdWFydGljLk91dDtcblx0Y2FzZSAncXVhcnRpY0luT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5RdWFydGljLkluT3V0O1xuXG5cdGNhc2UgJ3F1aW50aWNJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVpbnRpYy5Jbjtcblx0Y2FzZSAncXVpbnRpY091dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVpbnRpYy5PdXQ7XG5cdGNhc2UgJ3F1aW50aWNJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVpbnRpYy5Jbk91dDtcblxuXHRjYXNlICdzaW51c29pZGFsSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLlNpbnVzb2lkYWwuSW47XG5cdGNhc2UgJ3NpbnVzb2lkYWxPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLlNpbnVzb2lkYWwuT3V0O1xuXHRjYXNlICdzaW51c29pZGFsSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLlNpbnVzb2lkYWwuSW5PdXQ7XG5cblx0Y2FzZSAnY2lyY3VsYXJJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuQ2lyY3VsYXIuSW47XG5cdGNhc2UgJ2NpcmN1bGFyT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5DaXJjdWxhci5PdXQ7XG5cdGNhc2UgJ2NpcmN1bGFySW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkNpcmN1bGFyLkluT3V0O1xuXG5cdGNhc2UgJ2VsYXN0aWNJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuRWxhc3RpYy5Jbjtcblx0Y2FzZSAnZWxhc3RpY091dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuRWxhc3RpYy5PdXQ7XG5cdGNhc2UgJ2VsYXN0aWNJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuRWxhc3RpYy5Jbk91dDtcblxuXHRjYXNlICdiYWNrSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLkJhY2suSW47XG5cdGNhc2UgJ2JhY2tPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkJhY2suT3V0O1xuXHRjYXNlICdiYWNrSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkJhY2suSW5PdXQ7XG5cblx0Y2FzZSAnYm91bmNlSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLkJvdW5jZS5pbjtcblx0Y2FzZSAnYm91bmNlT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5Cb3VuY2Uub3V0O1xuXHRjYXNlICdib3VuY2VJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQm91bmNlLmluT3V0O1xuXHR9XG59XG5cbmNsYXNzIFR3ZWVuTnVtYmVyIHtcblx0Y29uc3RydWN0b3IobVZhbHVlLCBtRWFzaW5nID0gJ2V4cE91dCcsIG1TcGVlZCA9IDAuMDEpIHtcblx0XHR0aGlzLl92YWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl9zdGFydFZhbHVlID0gbVZhbHVlO1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlID0gbVZhbHVlO1xuXHRcdHRoaXMuX2NvdW50ZXIgPSAxO1xuXHRcdHRoaXMuc3BlZWQgPSBtU3BlZWQ7XG5cdFx0dGhpcy5lYXNpbmcgPSBtRWFzaW5nO1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5fZWZJbmRleCAgICAgPSBTY2hlZHVsZXIuYWRkRUYoKCk9PiB0aGlzLl91cGRhdGUoKSk7XG5cdH1cblxuXG5cdF91cGRhdGUoKSB7XG5cdFx0bGV0IG5ld0NvdW50ZXIgPSB0aGlzLl9jb3VudGVyICsgdGhpcy5zcGVlZDtcblx0XHRpZihuZXdDb3VudGVyID4gMSkgeyBuZXdDb3VudGVyID0gMTsgfVxuXHRcdGlmKHRoaXMuX2NvdW50ZXIgPT09IG5ld0NvdW50ZXIpIHtcblx0XHRcdHRoaXMuX25lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9jb3VudGVyID0gbmV3Q291bnRlcjtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0fVxuXG5cblx0bGltaXQobU1pbiwgbU1heCkge1xuXHRcdGlmKG1NaW4gPiBtTWF4KSB7XG5cdFx0XHR0aGlzLmxpbWl0KG1NYXgsIG1NaW4pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX21pbiA9IG1NaW47XG5cdFx0dGhpcy5fbWF4ID0gbU1heDtcblxuXHRcdHRoaXMuX2NoZWNrTGltaXQoKTtcblx0fVxuXG5cdHNldFRvKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3ZhbHVlID0gbVZhbHVlO1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlID0gbVZhbHVlO1xuXHRcdHRoaXMuX2NvdW50ZXIgPSAxO1xuXHR9XG5cblxuXHRfY2hlY2tMaW1pdCgpIHtcblx0XHRpZih0aGlzLl9taW4gIT09IHVuZGVmaW5lZCAmJiB0aGlzLl90YXJnZXRWYWx1ZSA8IHRoaXMuX21pbikge1xuXHRcdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSB0aGlzLl9taW47XG5cdFx0fSBcblxuXHRcdGlmKHRoaXMuX21heCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3RhcmdldFZhbHVlID4gdGhpcy5fbWF4KSB7XG5cdFx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX21heDtcblx0XHR9IFxuXHR9XG5cblxuXHRkZXN0cm95KCkge1xuXHRcdFNjaGVkdWxlci5yZW1vdmVFRih0aGlzLl9lZkluZGV4KTtcblx0fVxuXG5cdC8vXHRHRVRURVJTIC8gU0VUVEVSU1xuXG5cdHNldCB2YWx1ZShtVmFsdWUpIHtcblx0XHR0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5fdmFsdWU7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fY2hlY2tMaW1pdCgpO1xuXHRcdHRoaXMuX2NvdW50ZXIgPSAwO1xuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdGlmKHRoaXMuX25lZWRVcGRhdGUpIHtcblx0XHRcdGNvbnN0IGYgPSBnZXRGdW5jKHRoaXMuZWFzaW5nKTtcblx0XHRcdGNvbnN0IHAgPSBmKHRoaXMuX2NvdW50ZXIpO1xuXHRcdFx0dGhpcy5fdmFsdWUgPSB0aGlzLl9zdGFydFZhbHVlICsgcCAqICh0aGlzLl90YXJnZXRWYWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpO1xuXHRcdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fdmFsdWU7XG5cdH1cblxuXHRnZXQgdGFyZ2V0VmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RhcmdldFZhbHVlO1xuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVHdlZW5OdW1iZXI7IiwiLy8gV2ViZ2xDb25zdC5qc1xuXG4vLyBzdG9sZW4gdGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2dsLWNvbnN0YW50cyB0aGFua3MgQG1hdHRkZXNsIF5eXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRBQ1RJVkVfQVRUUklCVVRFUzogMzU3MjEsXG5cdEFDVElWRV9BVFRSSUJVVEVfTUFYX0xFTkdUSDogMzU3MjIsXG5cdEFDVElWRV9URVhUVVJFOiAzNDAxNixcblx0QUNUSVZFX1VOSUZPUk1TOiAzNTcxOCxcblx0QUNUSVZFX1VOSUZPUk1fTUFYX0xFTkdUSDogMzU3MTksXG5cdEFMSUFTRURfTElORV9XSURUSF9SQU5HRTogMzM5MDIsXG5cdEFMSUFTRURfUE9JTlRfU0laRV9SQU5HRTogMzM5MDEsXG5cdEFMUEhBOiA2NDA2LFxuXHRBTFBIQV9CSVRTOiAzNDEzLFxuXHRBTFdBWVM6IDUxOSxcblx0QVJSQVlfQlVGRkVSOiAzNDk2Mixcblx0QVJSQVlfQlVGRkVSX0JJTkRJTkc6IDM0OTY0LFxuXHRBVFRBQ0hFRF9TSEFERVJTOiAzNTcxNyxcblx0QkFDSzogMTAyOSxcblx0QkxFTkQ6IDMwNDIsXG5cdEJMRU5EX0NPTE9SOiAzMjc3Myxcblx0QkxFTkRfRFNUX0FMUEhBOiAzMjk3MCxcblx0QkxFTkRfRFNUX1JHQjogMzI5NjgsXG5cdEJMRU5EX0VRVUFUSU9OOiAzMjc3Nyxcblx0QkxFTkRfRVFVQVRJT05fQUxQSEE6IDM0ODc3LFxuXHRCTEVORF9FUVVBVElPTl9SR0I6IDMyNzc3LFxuXHRCTEVORF9TUkNfQUxQSEE6IDMyOTcxLFxuXHRCTEVORF9TUkNfUkdCOiAzMjk2OSxcblx0QkxVRV9CSVRTOiAzNDEyLFxuXHRCT09MOiAzNTY3MCxcblx0Qk9PTF9WRUMyOiAzNTY3MSxcblx0Qk9PTF9WRUMzOiAzNTY3Mixcblx0Qk9PTF9WRUM0OiAzNTY3Myxcblx0QlJPV1NFUl9ERUZBVUxUX1dFQkdMOiAzNzQ0NCxcblx0QlVGRkVSX1NJWkU6IDM0NjYwLFxuXHRCVUZGRVJfVVNBR0U6IDM0NjYxLFxuXHRCWVRFOiA1MTIwLFxuXHRDQ1c6IDIzMDUsXG5cdENMQU1QX1RPX0VER0U6IDMzMDcxLFxuXHRDT0xPUl9BVFRBQ0hNRU5UMDogMzYwNjQsXG5cdENPTE9SX0JVRkZFUl9CSVQ6IDE2Mzg0LFxuXHRDT0xPUl9DTEVBUl9WQUxVRTogMzEwNixcblx0Q09MT1JfV1JJVEVNQVNLOiAzMTA3LFxuXHRDT01QSUxFX1NUQVRVUzogMzU3MTMsXG5cdENPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTOiAzNDQ2Nyxcblx0Q09OU1RBTlRfQUxQSEE6IDMyNzcxLFxuXHRDT05TVEFOVF9DT0xPUjogMzI3NjksXG5cdENPTlRFWFRfTE9TVF9XRUJHTDogMzc0NDIsXG5cdENVTExfRkFDRTogMjg4NCxcblx0Q1VMTF9GQUNFX01PREU6IDI4ODUsXG5cdENVUlJFTlRfUFJPR1JBTTogMzU3MjUsXG5cdENVUlJFTlRfVkVSVEVYX0FUVFJJQjogMzQzNDIsXG5cdENXOiAyMzA0LFxuXHRERUNSOiA3NjgzLFxuXHRERUNSX1dSQVA6IDM0MDU2LFxuXHRERUxFVEVfU1RBVFVTOiAzNTcxMixcblx0REVQVEhfQVRUQUNITUVOVDogMzYwOTYsXG5cdERFUFRIX0JJVFM6IDM0MTQsXG5cdERFUFRIX0JVRkZFUl9CSVQ6IDI1Nixcblx0REVQVEhfQ0xFQVJfVkFMVUU6IDI5MzEsXG5cdERFUFRIX0NPTVBPTkVOVDogNjQwMixcblx0UkVEOiA2NDAzLFxuXHRERVBUSF9DT01QT05FTlQxNjogMzMxODksXG5cdERFUFRIX0ZVTkM6IDI5MzIsXG5cdERFUFRIX1JBTkdFOiAyOTI4LFxuXHRERVBUSF9TVEVOQ0lMOiAzNDA0MSxcblx0REVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UOiAzMzMwNixcblx0REVQVEhfVEVTVDogMjkyOSxcblx0REVQVEhfV1JJVEVNQVNLOiAyOTMwLFxuXHRESVRIRVI6IDMwMjQsXG5cdERPTlRfQ0FSRTogNDM1Mixcblx0RFNUX0FMUEhBOiA3NzIsXG5cdERTVF9DT0xPUjogNzc0LFxuXHREWU5BTUlDX0RSQVc6IDM1MDQ4LFxuXHRFTEVNRU5UX0FSUkFZX0JVRkZFUjogMzQ5NjMsXG5cdEVMRU1FTlRfQVJSQVlfQlVGRkVSX0JJTkRJTkc6IDM0OTY1LFxuXHRFUVVBTDogNTE0LFxuXHRGQVNURVNUOiA0MzUzLFxuXHRGTE9BVDogNTEyNixcblx0RkxPQVRfTUFUMjogMzU2NzQsXG5cdEZMT0FUX01BVDM6IDM1Njc1LFxuXHRGTE9BVF9NQVQ0OiAzNTY3Nixcblx0RkxPQVRfVkVDMjogMzU2NjQsXG5cdEZMT0FUX1ZFQzM6IDM1NjY1LFxuXHRGTE9BVF9WRUM0OiAzNTY2Nixcblx0RlJBR01FTlRfU0hBREVSOiAzNTYzMixcblx0RlJBTUVCVUZGRVI6IDM2MTYwLFxuXHRGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9OQU1FOiAzNjA0OSxcblx0RlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfVFlQRTogMzYwNDgsXG5cdEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9DVUJFX01BUF9GQUNFOiAzNjA1MSxcblx0RlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xFVkVMOiAzNjA1MCxcblx0RlJBTUVCVUZGRVJfQklORElORzogMzYwMDYsXG5cdEZSQU1FQlVGRkVSX0NPTVBMRVRFOiAzNjA1Myxcblx0RlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOiAzNjA1NCxcblx0RlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOiAzNjA1Nyxcblx0RlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6IDM2MDU1LFxuXHRGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDogMzYwNjEsXG5cdEZST05UOiAxMDI4LFxuXHRGUk9OVF9BTkRfQkFDSzogMTAzMixcblx0RlJPTlRfRkFDRTogMjg4Nixcblx0RlVOQ19BREQ6IDMyNzc0LFxuXHRGVU5DX1JFVkVSU0VfU1VCVFJBQ1Q6IDMyNzc5LFxuXHRGVU5DX1NVQlRSQUNUOiAzMjc3OCxcblx0R0VORVJBVEVfTUlQTUFQX0hJTlQ6IDMzMTcwLFxuXHRHRVFVQUw6IDUxOCxcblx0R1JFQVRFUjogNTE2LFxuXHRHUkVFTl9CSVRTOiAzNDExLFxuXHRISUdIX0ZMT0FUOiAzNjMzOCxcblx0SElHSF9JTlQ6IDM2MzQxLFxuXHRJTkNSOiA3NjgyLFxuXHRJTkNSX1dSQVA6IDM0MDU1LFxuXHRJTkZPX0xPR19MRU5HVEg6IDM1NzE2LFxuXHRJTlQ6IDUxMjQsXG5cdElOVF9WRUMyOiAzNTY2Nyxcblx0SU5UX1ZFQzM6IDM1NjY4LFxuXHRJTlRfVkVDNDogMzU2NjksXG5cdElOVkFMSURfRU5VTTogMTI4MCxcblx0SU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046IDEyODYsXG5cdElOVkFMSURfT1BFUkFUSU9OOiAxMjgyLFxuXHRJTlZBTElEX1ZBTFVFOiAxMjgxLFxuXHRJTlZFUlQ6IDUzODYsXG5cdEtFRVA6IDc2ODAsXG5cdExFUVVBTDogNTE1LFxuXHRMRVNTOiA1MTMsXG5cdExJTkVBUjogOTcyOSxcblx0TElORUFSX01JUE1BUF9MSU5FQVI6IDk5ODcsXG5cdExJTkVBUl9NSVBNQVBfTkVBUkVTVDogOTk4NSxcblx0TElORVM6IDEsXG5cdExJTkVfTE9PUDogMixcblx0TElORV9TVFJJUDogMyxcblx0TElORV9XSURUSDogMjg0OSxcblx0TElOS19TVEFUVVM6IDM1NzE0LFxuXHRMT1dfRkxPQVQ6IDM2MzM2LFxuXHRMT1dfSU5UOiAzNjMzOSxcblx0TFVNSU5BTkNFOiA2NDA5LFxuXHRMVU1JTkFOQ0VfQUxQSEE6IDY0MTAsXG5cdE1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTOiAzNTY2MSxcblx0TUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRTogMzQwNzYsXG5cdE1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlM6IDM2MzQ5LFxuXHRNQVhfUkVOREVSQlVGRkVSX1NJWkU6IDM0MDI0LFxuXHRNQVhfVEVYVFVSRV9JTUFHRV9VTklUUzogMzQ5MzAsXG5cdE1BWF9URVhUVVJFX1NJWkU6IDMzNzksXG5cdE1BWF9WQVJZSU5HX1ZFQ1RPUlM6IDM2MzQ4LFxuXHRNQVhfVkVSVEVYX0FUVFJJQlM6IDM0OTIxLFxuXHRNQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFM6IDM1NjYwLFxuXHRNQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUzogMzYzNDcsXG5cdE1BWF9WSUVXUE9SVF9ESU1TOiAzMzg2LFxuXHRNRURJVU1fRkxPQVQ6IDM2MzM3LFxuXHRNRURJVU1fSU5UOiAzNjM0MCxcblx0TUlSUk9SRURfUkVQRUFUOiAzMzY0OCxcblx0TkVBUkVTVDogOTcyOCxcblx0TkVBUkVTVF9NSVBNQVBfTElORUFSOiA5OTg2LFxuXHRORUFSRVNUX01JUE1BUF9ORUFSRVNUOiA5OTg0LFxuXHRORVZFUjogNTEyLFxuXHROSUNFU1Q6IDQzNTQsXG5cdE5PTkU6IDAsXG5cdE5PVEVRVUFMOiA1MTcsXG5cdE5PX0VSUk9SOiAwLFxuXHROVU1fQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFM6IDM0NDY2LFxuXHRPTkU6IDEsXG5cdE9ORV9NSU5VU19DT05TVEFOVF9BTFBIQTogMzI3NzIsXG5cdE9ORV9NSU5VU19DT05TVEFOVF9DT0xPUjogMzI3NzAsXG5cdE9ORV9NSU5VU19EU1RfQUxQSEE6IDc3Myxcblx0T05FX01JTlVTX0RTVF9DT0xPUjogNzc1LFxuXHRPTkVfTUlOVVNfU1JDX0FMUEhBOiA3NzEsXG5cdE9ORV9NSU5VU19TUkNfQ09MT1I6IDc2OSxcblx0T1VUX09GX01FTU9SWTogMTI4NSxcblx0UEFDS19BTElHTk1FTlQ6IDMzMzMsXG5cdFBPSU5UUzogMCxcblx0UE9MWUdPTl9PRkZTRVRfRkFDVE9SOiAzMjgyNCxcblx0UE9MWUdPTl9PRkZTRVRfRklMTDogMzI4MjMsXG5cdFBPTFlHT05fT0ZGU0VUX1VOSVRTOiAxMDc1Mixcblx0UkVEX0JJVFM6IDM0MTAsXG5cdFJFTkRFUkJVRkZFUjogMzYxNjEsXG5cdFJFTkRFUkJVRkZFUl9BTFBIQV9TSVpFOiAzNjE3OSxcblx0UkVOREVSQlVGRkVSX0JJTkRJTkc6IDM2MDA3LFxuXHRSRU5ERVJCVUZGRVJfQkxVRV9TSVpFOiAzNjE3OCxcblx0UkVOREVSQlVGRkVSX0RFUFRIX1NJWkU6IDM2MTgwLFxuXHRSRU5ERVJCVUZGRVJfR1JFRU5fU0laRTogMzYxNzcsXG5cdFJFTkRFUkJVRkZFUl9IRUlHSFQ6IDM2MTYzLFxuXHRSRU5ERVJCVUZGRVJfSU5URVJOQUxfRk9STUFUOiAzNjE2NCxcblx0UkVOREVSQlVGRkVSX1JFRF9TSVpFOiAzNjE3Nixcblx0UkVOREVSQlVGRkVSX1NURU5DSUxfU0laRTogMzYxODEsXG5cdFJFTkRFUkJVRkZFUl9XSURUSDogMzYxNjIsXG5cdFJFTkRFUkVSOiA3OTM3LFxuXHRSRVBFQVQ6IDEwNDk3LFxuXHRSRVBMQUNFOiA3NjgxLFxuXHRSR0I6IDY0MDcsXG5cdFJHQjVfQTE6IDMyODU1LFxuXHRSR0I1NjU6IDM2MTk0LFxuXHRSR0JBOiA2NDA4LFxuXHRSR0JBNDogMzI4NTQsXG5cdFNBTVBMRVJfMkQ6IDM1Njc4LFxuXHRTQU1QTEVSX0NVQkU6IDM1NjgwLFxuXHRTQU1QTEVTOiAzMjkzNyxcblx0U0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFOiAzMjkyNixcblx0U0FNUExFX0JVRkZFUlM6IDMyOTM2LFxuXHRTQU1QTEVfQ09WRVJBR0U6IDMyOTI4LFxuXHRTQU1QTEVfQ09WRVJBR0VfSU5WRVJUOiAzMjkzOSxcblx0U0FNUExFX0NPVkVSQUdFX1ZBTFVFOiAzMjkzOCxcblx0U0NJU1NPUl9CT1g6IDMwODgsXG5cdFNDSVNTT1JfVEVTVDogMzA4OSxcblx0U0hBREVSX0NPTVBJTEVSOiAzNjM0Nixcblx0U0hBREVSX1NPVVJDRV9MRU5HVEg6IDM1NzIwLFxuXHRTSEFERVJfVFlQRTogMzU2NjMsXG5cdFNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTjogMzU3MjQsXG5cdFNIT1JUOiA1MTIyLFxuXHRTUkNfQUxQSEE6IDc3MCxcblx0U1JDX0FMUEhBX1NBVFVSQVRFOiA3NzYsXG5cdFNSQ19DT0xPUjogNzY4LFxuXHRTVEFUSUNfRFJBVzogMzUwNDQsXG5cdFNURU5DSUxfQVRUQUNITUVOVDogMzYxMjgsXG5cdFNURU5DSUxfQkFDS19GQUlMOiAzNDgxNyxcblx0U1RFTkNJTF9CQUNLX0ZVTkM6IDM0ODE2LFxuXHRTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9GQUlMOiAzNDgxOCxcblx0U1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfUEFTUzogMzQ4MTksXG5cdFNURU5DSUxfQkFDS19SRUY6IDM2MDAzLFxuXHRTVEVOQ0lMX0JBQ0tfVkFMVUVfTUFTSzogMzYwMDQsXG5cdFNURU5DSUxfQkFDS19XUklURU1BU0s6IDM2MDA1LFxuXHRTVEVOQ0lMX0JJVFM6IDM0MTUsXG5cdFNURU5DSUxfQlVGRkVSX0JJVDogMTAyNCxcblx0U1RFTkNJTF9DTEVBUl9WQUxVRTogMjk2MSxcblx0U1RFTkNJTF9GQUlMOiAyOTY0LFxuXHRTVEVOQ0lMX0ZVTkM6IDI5NjIsXG5cdFNURU5DSUxfSU5ERVg6IDY0MDEsXG5cdFNURU5DSUxfSU5ERVg4OiAzNjE2OCxcblx0U1RFTkNJTF9QQVNTX0RFUFRIX0ZBSUw6IDI5NjUsXG5cdFNURU5DSUxfUEFTU19ERVBUSF9QQVNTOiAyOTY2LFxuXHRTVEVOQ0lMX1JFRjogMjk2Nyxcblx0U1RFTkNJTF9URVNUOiAyOTYwLFxuXHRTVEVOQ0lMX1ZBTFVFX01BU0s6IDI5NjMsXG5cdFNURU5DSUxfV1JJVEVNQVNLOiAyOTY4LFxuXHRTVFJFQU1fRFJBVzogMzUwNDAsXG5cdFNVQlBJWEVMX0JJVFM6IDM0MDgsXG5cdFRFWFRVUkU6IDU4OTAsXG5cdFRFWFRVUkUwOiAzMzk4NCxcblx0VEVYVFVSRTE6IDMzOTg1LFxuXHRURVhUVVJFMjogMzM5ODYsXG5cdFRFWFRVUkUzOiAzMzk4Nyxcblx0VEVYVFVSRTQ6IDMzOTg4LFxuXHRURVhUVVJFNTogMzM5ODksXG5cdFRFWFRVUkU2OiAzMzk5MCxcblx0VEVYVFVSRTc6IDMzOTkxLFxuXHRURVhUVVJFODogMzM5OTIsXG5cdFRFWFRVUkU5OiAzMzk5Myxcblx0VEVYVFVSRTEwOiAzMzk5NCxcblx0VEVYVFVSRTExOiAzMzk5NSxcblx0VEVYVFVSRTEyOiAzMzk5Nixcblx0VEVYVFVSRTEzOiAzMzk5Nyxcblx0VEVYVFVSRTE0OiAzMzk5OCxcblx0VEVYVFVSRTE1OiAzMzk5OSxcblx0VEVYVFVSRTE2OiAzNDAwMCxcblx0VEVYVFVSRTE3OiAzNDAwMSxcblx0VEVYVFVSRTE4OiAzNDAwMixcblx0VEVYVFVSRTE5OiAzNDAwMyxcblx0VEVYVFVSRTIwOiAzNDAwNCxcblx0VEVYVFVSRTIxOiAzNDAwNSxcblx0VEVYVFVSRTIyOiAzNDAwNixcblx0VEVYVFVSRTIzOiAzNDAwNyxcblx0VEVYVFVSRTI0OiAzNDAwOCxcblx0VEVYVFVSRTI1OiAzNDAwOSxcblx0VEVYVFVSRTI2OiAzNDAxMCxcblx0VEVYVFVSRTI3OiAzNDAxMSxcblx0VEVYVFVSRTI4OiAzNDAxMixcblx0VEVYVFVSRTI5OiAzNDAxMyxcblx0VEVYVFVSRTMwOiAzNDAxNCxcblx0VEVYVFVSRTMxOiAzNDAxNSxcblx0VEVYVFVSRV8yRDogMzU1Myxcblx0VEVYVFVSRV9CSU5ESU5HXzJEOiAzMjg3Myxcblx0VEVYVFVSRV9CSU5ESU5HX0NVQkVfTUFQOiAzNDA2OCxcblx0VEVYVFVSRV9DVUJFX01BUDogMzQwNjcsXG5cdFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWDogMzQwNzAsXG5cdFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWTogMzQwNzIsXG5cdFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWjogMzQwNzQsXG5cdFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWDogMzQwNjksXG5cdFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWTogMzQwNzEsXG5cdFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWjogMzQwNzMsXG5cdFRFWFRVUkVfTUFHX0ZJTFRFUjogMTAyNDAsXG5cdFRFWFRVUkVfTUlOX0ZJTFRFUjogMTAyNDEsXG5cdFRFWFRVUkVfV1JBUF9TOiAxMDI0Mixcblx0VEVYVFVSRV9XUkFQX1Q6IDEwMjQzLFxuXHRUUklBTkdMRVM6IDQsXG5cdFRSSUFOR0xFX0ZBTjogNixcblx0VFJJQU5HTEVfU1RSSVA6IDUsXG5cdFVOUEFDS19BTElHTk1FTlQ6IDMzMTcsXG5cdFVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0w6IDM3NDQzLFxuXHRVTlBBQ0tfRkxJUF9ZX1dFQkdMOiAzNzQ0MCxcblx0VU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMOiAzNzQ0MSxcblx0VU5TSUdORURfQllURTogNTEyMSxcblx0VU5TSUdORURfSU5UOiA1MTI1LFxuXHRVTlNJR05FRF9TSE9SVDogNTEyMyxcblx0VU5TSUdORURfU0hPUlRfNF80XzRfNDogMzI4MTksXG5cdFVOU0lHTkVEX1NIT1JUXzVfNV81XzE6IDMyODIwLFxuXHRVTlNJR05FRF9TSE9SVF81XzZfNTogMzM2MzUsXG5cdFZBTElEQVRFX1NUQVRVUzogMzU3MTUsXG5cdFZFTkRPUjogNzkzNixcblx0VkVSU0lPTjogNzkzOCxcblx0VkVSVEVYX0FUVFJJQl9BUlJBWV9CVUZGRVJfQklORElORzogMzQ5NzUsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfRU5BQkxFRDogMzQzMzgsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRDogMzQ5MjIsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfUE9JTlRFUjogMzQzNzMsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfU0laRTogMzQzMzksXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFOiAzNDM0MCxcblx0VkVSVEVYX0FUVFJJQl9BUlJBWV9UWVBFOiAzNDM0MSxcblx0VkVSVEVYX1NIQURFUjogMzU2MzMsXG5cdFZJRVdQT1JUOiAyOTc4LFxuXHRaRVJPOiAwLFxuXHRSODogMzMzMjEsXG59OyIsIi8vIHN0b2xlbiB0aGVyZSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvZ2wtY29uc3RhbnRzIHRoYW5rcyBAbWF0dGRlc2wgXl5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHQwOiAnTk9ORScsXG5cdDE6ICdPTkUnLFxuXHQyOiAnTElORV9MT09QJyxcblx0MzogJ0xJTkVfU1RSSVAnLFxuXHQ0OiAnVFJJQU5HTEVTJyxcblx0NTogJ1RSSUFOR0xFX1NUUklQJyxcblx0NjogJ1RSSUFOR0xFX0ZBTicsXG5cdDI1NjogJ0RFUFRIX0JVRkZFUl9CSVQnLFxuXHQ1MTI6ICdORVZFUicsXG5cdDUxMzogJ0xFU1MnLFxuXHQ1MTQ6ICdFUVVBTCcsXG5cdDUxNTogJ0xFUVVBTCcsXG5cdDUxNjogJ0dSRUFURVInLFxuXHQ1MTc6ICdOT1RFUVVBTCcsXG5cdDUxODogJ0dFUVVBTCcsXG5cdDUxOTogJ0FMV0FZUycsXG5cdDc2ODogJ1NSQ19DT0xPUicsXG5cdDc2OTogJ09ORV9NSU5VU19TUkNfQ09MT1InLFxuXHQ3NzA6ICdTUkNfQUxQSEEnLFxuXHQ3NzE6ICdPTkVfTUlOVVNfU1JDX0FMUEhBJyxcblx0NzcyOiAnRFNUX0FMUEhBJyxcblx0NzczOiAnT05FX01JTlVTX0RTVF9BTFBIQScsXG5cdDc3NDogJ0RTVF9DT0xPUicsXG5cdDc3NTogJ09ORV9NSU5VU19EU1RfQ09MT1InLFxuXHQ3NzY6ICdTUkNfQUxQSEFfU0FUVVJBVEUnLFxuXHQxMDI0OiAnU1RFTkNJTF9CVUZGRVJfQklUJyxcblx0MTAyODogJ0ZST05UJyxcblx0MTAyOTogJ0JBQ0snLFxuXHQxMDMyOiAnRlJPTlRfQU5EX0JBQ0snLFxuXHQxMjgwOiAnSU5WQUxJRF9FTlVNJyxcblx0MTI4MTogJ0lOVkFMSURfVkFMVUUnLFxuXHQxMjgyOiAnSU5WQUxJRF9PUEVSQVRJT04nLFxuXHQxMjg1OiAnT1VUX09GX01FTU9SWScsXG5cdDEyODY6ICdJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTicsXG5cdDIzMDQ6ICdDVycsXG5cdDIzMDU6ICdDQ1cnLFxuXHQyODQ5OiAnTElORV9XSURUSCcsXG5cdDI4ODQ6ICdDVUxMX0ZBQ0UnLFxuXHQyODg1OiAnQ1VMTF9GQUNFX01PREUnLFxuXHQyODg2OiAnRlJPTlRfRkFDRScsXG5cdDI5Mjg6ICdERVBUSF9SQU5HRScsXG5cdDI5Mjk6ICdERVBUSF9URVNUJyxcblx0MjkzMDogJ0RFUFRIX1dSSVRFTUFTSycsXG5cdDI5MzE6ICdERVBUSF9DTEVBUl9WQUxVRScsXG5cdDI5MzI6ICdERVBUSF9GVU5DJyxcblx0Mjk2MDogJ1NURU5DSUxfVEVTVCcsXG5cdDI5NjE6ICdTVEVOQ0lMX0NMRUFSX1ZBTFVFJyxcblx0Mjk2MjogJ1NURU5DSUxfRlVOQycsXG5cdDI5NjM6ICdTVEVOQ0lMX1ZBTFVFX01BU0snLFxuXHQyOTY0OiAnU1RFTkNJTF9GQUlMJyxcblx0Mjk2NTogJ1NURU5DSUxfUEFTU19ERVBUSF9GQUlMJyxcblx0Mjk2NjogJ1NURU5DSUxfUEFTU19ERVBUSF9QQVNTJyxcblx0Mjk2NzogJ1NURU5DSUxfUkVGJyxcblx0Mjk2ODogJ1NURU5DSUxfV1JJVEVNQVNLJyxcblx0Mjk3ODogJ1ZJRVdQT1JUJyxcblx0MzAyNDogJ0RJVEhFUicsXG5cdDMwNDI6ICdCTEVORCcsXG5cdDMwODg6ICdTQ0lTU09SX0JPWCcsXG5cdDMwODk6ICdTQ0lTU09SX1RFU1QnLFxuXHQzMTA2OiAnQ09MT1JfQ0xFQVJfVkFMVUUnLFxuXHQzMTA3OiAnQ09MT1JfV1JJVEVNQVNLJyxcblx0MzMxNzogJ1VOUEFDS19BTElHTk1FTlQnLFxuXHQzMzMzOiAnUEFDS19BTElHTk1FTlQnLFxuXHQzMzc5OiAnTUFYX1RFWFRVUkVfU0laRScsXG5cdDMzODY6ICdNQVhfVklFV1BPUlRfRElNUycsXG5cdDM0MDg6ICdTVUJQSVhFTF9CSVRTJyxcblx0MzQxMDogJ1JFRF9CSVRTJyxcblx0MzQxMTogJ0dSRUVOX0JJVFMnLFxuXHQzNDEyOiAnQkxVRV9CSVRTJyxcblx0MzQxMzogJ0FMUEhBX0JJVFMnLFxuXHQzNDE0OiAnREVQVEhfQklUUycsXG5cdDM0MTU6ICdTVEVOQ0lMX0JJVFMnLFxuXHQzNTUzOiAnVEVYVFVSRV8yRCcsXG5cdDQzNTI6ICdET05UX0NBUkUnLFxuXHQ0MzUzOiAnRkFTVEVTVCcsXG5cdDQzNTQ6ICdOSUNFU1QnLFxuXHQ1MTIwOiAnQllURScsXG5cdDUxMjE6ICdVTlNJR05FRF9CWVRFJyxcblx0NTEyMjogJ1NIT1JUJyxcblx0NTEyMzogJ1VOU0lHTkVEX1NIT1JUJyxcblx0NTEyNDogJ0lOVCcsXG5cdDUxMjU6ICdVTlNJR05FRF9JTlQnLFxuXHQ1MTI2OiAnRkxPQVQnLFxuXHQ1Mzg2OiAnSU5WRVJUJyxcblx0NTg5MDogJ1RFWFRVUkUnLFxuXHQ2NDAxOiAnU1RFTkNJTF9JTkRFWCcsXG5cdDY0MDI6ICdERVBUSF9DT01QT05FTlQnLFxuXHQ2NDAzOiAnUkVEJyxcblx0NjQwNjogJ0FMUEhBJyxcblx0NjQwNzogJ1JHQicsXG5cdDY0MDg6ICdSR0JBJyxcblx0NjQwOTogJ0xVTUlOQU5DRScsXG5cdDY0MTA6ICdMVU1JTkFOQ0VfQUxQSEEnLFxuXHQ3NjgwOiAnS0VFUCcsXG5cdDc2ODE6ICdSRVBMQUNFJyxcblx0NzY4MjogJ0lOQ1InLFxuXHQ3NjgzOiAnREVDUicsXG5cdDc5MzY6ICdWRU5ET1InLFxuXHQ3OTM3OiAnUkVOREVSRVInLFxuXHQ3OTM4OiAnVkVSU0lPTicsXG5cdDk3Mjg6ICdORUFSRVNUJyxcblx0OTcyOTogJ0xJTkVBUicsXG5cdDk5ODQ6ICdORUFSRVNUX01JUE1BUF9ORUFSRVNUJyxcblx0OTk4NTogJ0xJTkVBUl9NSVBNQVBfTkVBUkVTVCcsXG5cdDk5ODY6ICdORUFSRVNUX01JUE1BUF9MSU5FQVInLFxuXHQ5OTg3OiAnTElORUFSX01JUE1BUF9MSU5FQVInLFxuXHQxMDI0MDogJ1RFWFRVUkVfTUFHX0ZJTFRFUicsXG5cdDEwMjQxOiAnVEVYVFVSRV9NSU5fRklMVEVSJyxcblx0MTAyNDI6ICdURVhUVVJFX1dSQVBfUycsXG5cdDEwMjQzOiAnVEVYVFVSRV9XUkFQX1QnLFxuXHQxMDQ5NzogJ1JFUEVBVCcsXG5cdDEwNzUyOiAnUE9MWUdPTl9PRkZTRVRfVU5JVFMnLFxuXHQxNjM4NDogJ0NPTE9SX0JVRkZFUl9CSVQnLFxuXHQzMjc2OTogJ0NPTlNUQU5UX0NPTE9SJyxcblx0MzI3NzA6ICdPTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1InLFxuXHQzMjc3MTogJ0NPTlNUQU5UX0FMUEhBJyxcblx0MzI3NzI6ICdPTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEEnLFxuXHQzMjc3MzogJ0JMRU5EX0NPTE9SJyxcblx0MzI3NzQ6ICdGVU5DX0FERCcsXG5cdDMyNzc3OiAnQkxFTkRfRVFVQVRJT05fUkdCJyxcblx0MzI3Nzg6ICdGVU5DX1NVQlRSQUNUJyxcblx0MzI3Nzk6ICdGVU5DX1JFVkVSU0VfU1VCVFJBQ1QnLFxuXHQzMjgxOTogJ1VOU0lHTkVEX1NIT1JUXzRfNF80XzQnLFxuXHQzMjgyMDogJ1VOU0lHTkVEX1NIT1JUXzVfNV81XzEnLFxuXHQzMjgyMzogJ1BPTFlHT05fT0ZGU0VUX0ZJTEwnLFxuXHQzMjgyNDogJ1BPTFlHT05fT0ZGU0VUX0ZBQ1RPUicsXG5cdDMyODU0OiAnUkdCQTQnLFxuXHQzMjg1NTogJ1JHQjVfQTEnLFxuXHQzMjg3MzogJ1RFWFRVUkVfQklORElOR18yRCcsXG5cdDMyOTI2OiAnU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFJyxcblx0MzI5Mjg6ICdTQU1QTEVfQ09WRVJBR0UnLFxuXHQzMjkzNjogJ1NBTVBMRV9CVUZGRVJTJyxcblx0MzI5Mzc6ICdTQU1QTEVTJyxcblx0MzI5Mzg6ICdTQU1QTEVfQ09WRVJBR0VfVkFMVUUnLFxuXHQzMjkzOTogJ1NBTVBMRV9DT1ZFUkFHRV9JTlZFUlQnLFxuXHQzMjk2ODogJ0JMRU5EX0RTVF9SR0InLFxuXHQzMjk2OTogJ0JMRU5EX1NSQ19SR0InLFxuXHQzMjk3MDogJ0JMRU5EX0RTVF9BTFBIQScsXG5cdDMyOTcxOiAnQkxFTkRfU1JDX0FMUEhBJyxcblx0MzMwNzE6ICdDTEFNUF9UT19FREdFJyxcblx0MzMxNzA6ICdHRU5FUkFURV9NSVBNQVBfSElOVCcsXG5cdDMzMTg5OiAnREVQVEhfQ09NUE9ORU5UMTYnLFxuXHQzMzMwNjogJ0RFUFRIX1NURU5DSUxfQVRUQUNITUVOVCcsXG5cdDMzMzIxOiAnUjgnLFxuXHQzMzYzNTogJ1VOU0lHTkVEX1NIT1JUXzVfNl81Jyxcblx0MzM2NDg6ICdNSVJST1JFRF9SRVBFQVQnLFxuXHQzMzkwMTogJ0FMSUFTRURfUE9JTlRfU0laRV9SQU5HRScsXG5cdDMzOTAyOiAnQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFJyxcblx0MzM5ODQ6ICdURVhUVVJFMCcsXG5cdDMzOTg1OiAnVEVYVFVSRTEnLFxuXHQzMzk4NjogJ1RFWFRVUkUyJyxcblx0MzM5ODc6ICdURVhUVVJFMycsXG5cdDMzOTg4OiAnVEVYVFVSRTQnLFxuXHQzMzk4OTogJ1RFWFRVUkU1Jyxcblx0MzM5OTA6ICdURVhUVVJFNicsXG5cdDMzOTkxOiAnVEVYVFVSRTcnLFxuXHQzMzk5MjogJ1RFWFRVUkU4Jyxcblx0MzM5OTM6ICdURVhUVVJFOScsXG5cdDMzOTk0OiAnVEVYVFVSRTEwJyxcblx0MzM5OTU6ICdURVhUVVJFMTEnLFxuXHQzMzk5NjogJ1RFWFRVUkUxMicsXG5cdDMzOTk3OiAnVEVYVFVSRTEzJyxcblx0MzM5OTg6ICdURVhUVVJFMTQnLFxuXHQzMzk5OTogJ1RFWFRVUkUxNScsXG5cdDM0MDAwOiAnVEVYVFVSRTE2Jyxcblx0MzQwMDE6ICdURVhUVVJFMTcnLFxuXHQzNDAwMjogJ1RFWFRVUkUxOCcsXG5cdDM0MDAzOiAnVEVYVFVSRTE5Jyxcblx0MzQwMDQ6ICdURVhUVVJFMjAnLFxuXHQzNDAwNTogJ1RFWFRVUkUyMScsXG5cdDM0MDA2OiAnVEVYVFVSRTIyJyxcblx0MzQwMDc6ICdURVhUVVJFMjMnLFxuXHQzNDAwODogJ1RFWFRVUkUyNCcsXG5cdDM0MDA5OiAnVEVYVFVSRTI1Jyxcblx0MzQwMTA6ICdURVhUVVJFMjYnLFxuXHQzNDAxMTogJ1RFWFRVUkUyNycsXG5cdDM0MDEyOiAnVEVYVFVSRTI4Jyxcblx0MzQwMTM6ICdURVhUVVJFMjknLFxuXHQzNDAxNDogJ1RFWFRVUkUzMCcsXG5cdDM0MDE1OiAnVEVYVFVSRTMxJyxcblx0MzQwMTY6ICdBQ1RJVkVfVEVYVFVSRScsXG5cdDM0MDI0OiAnTUFYX1JFTkRFUkJVRkZFUl9TSVpFJyxcblx0MzQwNDE6ICdERVBUSF9TVEVOQ0lMJyxcblx0MzQwNTU6ICdJTkNSX1dSQVAnLFxuXHQzNDA1NjogJ0RFQ1JfV1JBUCcsXG5cdDM0MDY3OiAnVEVYVFVSRV9DVUJFX01BUCcsXG5cdDM0MDY4OiAnVEVYVFVSRV9CSU5ESU5HX0NVQkVfTUFQJyxcblx0MzQwNjk6ICdURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gnLFxuXHQzNDA3MDogJ1RFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCcsXG5cdDM0MDcxOiAnVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZJyxcblx0MzQwNzI6ICdURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1knLFxuXHQzNDA3MzogJ1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWicsXG5cdDM0MDc0OiAnVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aJyxcblx0MzQwNzY6ICdNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFJyxcblx0MzQzMzg6ICdWRVJURVhfQVRUUklCX0FSUkFZX0VOQUJMRUQnLFxuXHQzNDMzOTogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfU0laRScsXG5cdDM0MzQwOiAnVkVSVEVYX0FUVFJJQl9BUlJBWV9TVFJJREUnLFxuXHQzNDM0MTogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRScsXG5cdDM0MzQyOiAnQ1VSUkVOVF9WRVJURVhfQVRUUklCJyxcblx0MzQzNzM6ICdWRVJURVhfQVRUUklCX0FSUkFZX1BPSU5URVInLFxuXHQzNDQ2NjogJ05VTV9DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUycsXG5cdDM0NDY3OiAnQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMnLFxuXHQzNDY2MDogJ0JVRkZFUl9TSVpFJyxcblx0MzQ2NjE6ICdCVUZGRVJfVVNBR0UnLFxuXHQzNDgxNjogJ1NURU5DSUxfQkFDS19GVU5DJyxcblx0MzQ4MTc6ICdTVEVOQ0lMX0JBQ0tfRkFJTCcsXG5cdDM0ODE4OiAnU1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfRkFJTCcsXG5cdDM0ODE5OiAnU1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfUEFTUycsXG5cdDM0ODc3OiAnQkxFTkRfRVFVQVRJT05fQUxQSEEnLFxuXHQzNDkyMTogJ01BWF9WRVJURVhfQVRUUklCUycsXG5cdDM0OTIyOiAnVkVSVEVYX0FUVFJJQl9BUlJBWV9OT1JNQUxJWkVEJyxcblx0MzQ5MzA6ICdNQVhfVEVYVFVSRV9JTUFHRV9VTklUUycsXG5cdDM0OTYyOiAnQVJSQVlfQlVGRkVSJyxcblx0MzQ5NjM6ICdFTEVNRU5UX0FSUkFZX0JVRkZFUicsXG5cdDM0OTY0OiAnQVJSQVlfQlVGRkVSX0JJTkRJTkcnLFxuXHQzNDk2NTogJ0VMRU1FTlRfQVJSQVlfQlVGRkVSX0JJTkRJTkcnLFxuXHQzNDk3NTogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfQlVGRkVSX0JJTkRJTkcnLFxuXHQzNTA0MDogJ1NUUkVBTV9EUkFXJyxcblx0MzUwNDQ6ICdTVEFUSUNfRFJBVycsXG5cdDM1MDQ4OiAnRFlOQU1JQ19EUkFXJyxcblx0MzU2MzI6ICdGUkFHTUVOVF9TSEFERVInLFxuXHQzNTYzMzogJ1ZFUlRFWF9TSEFERVInLFxuXHQzNTY2MDogJ01BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUycsXG5cdDM1NjYxOiAnTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMnLFxuXHQzNTY2MzogJ1NIQURFUl9UWVBFJyxcblx0MzU2NjQ6ICdGTE9BVF9WRUMyJyxcblx0MzU2NjU6ICdGTE9BVF9WRUMzJyxcblx0MzU2NjY6ICdGTE9BVF9WRUM0Jyxcblx0MzU2Njc6ICdJTlRfVkVDMicsXG5cdDM1NjY4OiAnSU5UX1ZFQzMnLFxuXHQzNTY2OTogJ0lOVF9WRUM0Jyxcblx0MzU2NzA6ICdCT09MJyxcblx0MzU2NzE6ICdCT09MX1ZFQzInLFxuXHQzNTY3MjogJ0JPT0xfVkVDMycsXG5cdDM1NjczOiAnQk9PTF9WRUM0Jyxcblx0MzU2NzQ6ICdGTE9BVF9NQVQyJyxcblx0MzU2NzU6ICdGTE9BVF9NQVQzJyxcblx0MzU2NzY6ICdGTE9BVF9NQVQ0Jyxcblx0MzU2Nzg6ICdTQU1QTEVSXzJEJyxcblx0MzU2ODA6ICdTQU1QTEVSX0NVQkUnLFxuXHQzNTcxMjogJ0RFTEVURV9TVEFUVVMnLFxuXHQzNTcxMzogJ0NPTVBJTEVfU1RBVFVTJyxcblx0MzU3MTQ6ICdMSU5LX1NUQVRVUycsXG5cdDM1NzE1OiAnVkFMSURBVEVfU1RBVFVTJyxcblx0MzU3MTY6ICdJTkZPX0xPR19MRU5HVEgnLFxuXHQzNTcxNzogJ0FUVEFDSEVEX1NIQURFUlMnLFxuXHQzNTcxODogJ0FDVElWRV9VTklGT1JNUycsXG5cdDM1NzE5OiAnQUNUSVZFX1VOSUZPUk1fTUFYX0xFTkdUSCcsXG5cdDM1NzIwOiAnU0hBREVSX1NPVVJDRV9MRU5HVEgnLFxuXHQzNTcyMTogJ0FDVElWRV9BVFRSSUJVVEVTJyxcblx0MzU3MjI6ICdBQ1RJVkVfQVRUUklCVVRFX01BWF9MRU5HVEgnLFxuXHQzNTcyNDogJ1NIQURJTkdfTEFOR1VBR0VfVkVSU0lPTicsXG5cdDM1NzI1OiAnQ1VSUkVOVF9QUk9HUkFNJyxcblx0MzYwMDM6ICdTVEVOQ0lMX0JBQ0tfUkVGJyxcblx0MzYwMDQ6ICdTVEVOQ0lMX0JBQ0tfVkFMVUVfTUFTSycsXG5cdDM2MDA1OiAnU1RFTkNJTF9CQUNLX1dSSVRFTUFTSycsXG5cdDM2MDA2OiAnRlJBTUVCVUZGRVJfQklORElORycsXG5cdDM2MDA3OiAnUkVOREVSQlVGRkVSX0JJTkRJTkcnLFxuXHQzNjA0ODogJ0ZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX1RZUEUnLFxuXHQzNjA0OTogJ0ZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX05BTUUnLFxuXHQzNjA1MDogJ0ZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MRVZFTCcsXG5cdDM2MDUxOiAnRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0NVQkVfTUFQX0ZBQ0UnLFxuXHQzNjA1MzogJ0ZSQU1FQlVGRkVSX0NPTVBMRVRFJyxcblx0MzYwNTQ6ICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQnLFxuXHQzNjA1NTogJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UJyxcblx0MzYwNTc6ICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMnLFxuXHQzNjA2MTogJ0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEJyxcblx0MzYwNjQ6ICdDT0xPUl9BVFRBQ0hNRU5UMCcsXG5cdDM2MDk2OiAnREVQVEhfQVRUQUNITUVOVCcsXG5cdDM2MTI4OiAnU1RFTkNJTF9BVFRBQ0hNRU5UJyxcblx0MzYxNjA6ICdGUkFNRUJVRkZFUicsXG5cdDM2MTYxOiAnUkVOREVSQlVGRkVSJyxcblx0MzYxNjI6ICdSRU5ERVJCVUZGRVJfV0lEVEgnLFxuXHQzNjE2MzogJ1JFTkRFUkJVRkZFUl9IRUlHSFQnLFxuXHQzNjE2NDogJ1JFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVQnLFxuXHQzNjE2ODogJ1NURU5DSUxfSU5ERVg4Jyxcblx0MzYxNzY6ICdSRU5ERVJCVUZGRVJfUkVEX1NJWkUnLFxuXHQzNjE3NzogJ1JFTkRFUkJVRkZFUl9HUkVFTl9TSVpFJyxcblx0MzYxNzg6ICdSRU5ERVJCVUZGRVJfQkxVRV9TSVpFJyxcblx0MzYxNzk6ICdSRU5ERVJCVUZGRVJfQUxQSEFfU0laRScsXG5cdDM2MTgwOiAnUkVOREVSQlVGRkVSX0RFUFRIX1NJWkUnLFxuXHQzNjE4MTogJ1JFTkRFUkJVRkZFUl9TVEVOQ0lMX1NJWkUnLFxuXHQzNjE5NDogJ1JHQjU2NScsXG5cdDM2MzM2OiAnTE9XX0ZMT0FUJyxcblx0MzYzMzc6ICdNRURJVU1fRkxPQVQnLFxuXHQzNjMzODogJ0hJR0hfRkxPQVQnLFxuXHQzNjMzOTogJ0xPV19JTlQnLFxuXHQzNjM0MDogJ01FRElVTV9JTlQnLFxuXHQzNjM0MTogJ0hJR0hfSU5UJyxcblx0MzYzNDY6ICdTSEFERVJfQ09NUElMRVInLFxuXHQzNjM0NzogJ01BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTJyxcblx0MzYzNDg6ICdNQVhfVkFSWUlOR19WRUNUT1JTJyxcblx0MzYzNDk6ICdNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTJyxcblx0Mzc0NDA6ICdVTlBBQ0tfRkxJUF9ZX1dFQkdMJyxcblx0Mzc0NDE6ICdVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wnLFxuXHQzNzQ0MjogJ0NPTlRFWFRfTE9TVF9XRUJHTCcsXG5cdDM3NDQzOiAnVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCcsXG5cdDM3NDQ0OiAnQlJPV1NFUl9ERUZBVUxUX1dFQkdMJ1xufTsiLCIvLyBleHBvc2VBdHRyaWJ1dGVzLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnXG5pbXBvcnQgV2ViZ2xDb25zdCBmcm9tICcuL1dlYmdsQ29uc3QnXG5cbmNvbnN0IGV4cG9zZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAoY29uc3QgcyBpbiBXZWJnbENvbnN0KSB7XG4gICAgaWYgKCFHTFtzXSkge1xuICAgICAgR0xbc10gPSBXZWJnbENvbnN0W3NdXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzICE9PSAnRkxPQVQnKSBjb25zb2xlLmxvZygnYWxyZWFkeSBleGlzdCA6ICcsIHMpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGV4cG9zZUF0dHJpYnV0ZXNcbiIsIi8vIFZlcnRleEFycmF5T2JqZWN0LmpzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFuZEFwcGx5RXh0ZW5zaW9uKGdsLCBuYW1lKSB7XG5cdGNvbnN0IGV4dCA9IGdsLmdldEV4dGVuc2lvbihuYW1lKTtcblx0aWYgKCFleHQpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Y29uc3Qgc3VmZml4ID0gbmFtZS5zcGxpdCgnXycpWzBdO1xuXHRjb25zdCBzdWZmaXhSRSA9IG5ldyBSZWdFeHAoYCR7c3VmZml4fSRgKTtcblxuXHRmb3IgKGNvbnN0IGtleSBpbiBleHQpIHtcblx0XHRjb25zdCB2YWwgPSBleHRba2V5XTtcblx0XHRpZiAodHlwZW9mKHZhbCkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNvbnN0IHVuc3VmZml4ZWRLZXkgPSBrZXkucmVwbGFjZShzdWZmaXhSRSwgJycpO1xuXHRcdFx0aWYgKGtleS5zdWJzdHJpbmcpIHtcblx0XHRcdFx0Z2xbdW5zdWZmaXhlZEtleV0gPSBleHRba2V5XS5iaW5kKGV4dCk7XHRcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ1JlcGxhY2luZyA6Jywga2V5LCAnPT4nLCB1bnN1ZmZpeGVkS2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn0iLCIvLyBnZXRBdHRyaWJMb2MuanNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGdsLCBzaGFkZXJQcm9ncmFtLCBuYW1lKSB7XG5cdGlmKHNoYWRlclByb2dyYW0uY2FjaGVBdHRyaWJMb2MgPT09IHVuZGVmaW5lZCkge1x0c2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvYyA9IHt9O1x0fVxuXHRpZihzaGFkZXJQcm9ncmFtLmNhY2hlQXR0cmliTG9jW25hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRzaGFkZXJQcm9ncmFtLmNhY2hlQXR0cmliTG9jW25hbWVdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgbmFtZSk7XG5cdH1cblxuXHRyZXR1cm4gc2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvY1tuYW1lXTtcbn07IiwiLy8gZ2V0RmxvYXQuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5cbmxldCBoYXNDaGVja2VkID0gZmFsc2U7XG5sZXQgX2Zsb2F0O1xuXG5cbmZ1bmN0aW9uIGNoZWNrRmxvYXQoKSB7XG5cdGlmKEdMLndlYmdsMikge1xuXHRcdHJldHVybiBHTC5nbC5GTE9BVDtcblx0fSBlbHNlIHtcblx0XHRjb25zdCBleHRGbG9hdCA9IEdMLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcblx0XHRpZihleHRGbG9hdCkge1xuXHRcdFx0cmV0dXJuIEdMLmdsLkZMT0FUO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1VTSU5HIEZMT0FUIEJVVCBPRVNfdGV4dHVyZV9mbG9hdCBOT1QgU1VQUE9SVEVEJyk7XG5cdFx0XHRyZXR1cm4gR0wuZ2wuVU5TSUdORURfQllURTtcblx0XHR9XG5cdH1cblxuXHRoYXNDaGVja2VkID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcblx0aWYoIWhhc0NoZWNrZWQpIHtcblx0XHRfZmxvYXQgPSBjaGVja0Zsb2F0KCk7XG5cdH1cblxuXG5cdHJldHVybiBfZmxvYXQ7XG59IiwiLy8gZ2V0SGFsZkZsb2F0LmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuXG5sZXQgaGFzQ2hlY2tlZCA9IGZhbHNlO1xubGV0IGhhbGZGbG9hdDtcblxuZnVuY3Rpb24gY2hlY2tIYWxmRmxvYXQoKSB7XG5cdGlmKEdMLndlYmdsMikge1xuXHRcdHJldHVybiBHTC5nbC5IQUxGX0ZMT0FUO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IGV4dEhhbGZGbG9hdCA9IEdMLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcpO1xuXHRcdGlmKGV4dEhhbGZGbG9hdCkge1xuXHRcdFx0cmV0dXJuIGV4dEhhbGZGbG9hdC5IQUxGX0ZMT0FUX09FUztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKCdVU0lORyBIQUxGIEZMT0FUIEJVVCBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0IE5PVCBTVVBQT1JURUQnKTtcblx0XHRcdHJldHVybiBHTC5nbC5VTlNJR05FRF9CWVRFO1xuXHRcdH1cblx0fVxuXG5cdGhhc0NoZWNrZWQgPSB0cnVlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuXHRpZighaGFzQ2hlY2tlZCkge1xuXHRcdGhhbGZGbG9hdCA9IGNoZWNrSGFsZkZsb2F0KCk7XG5cdH1cblxuXHRyZXR1cm4gaGFsZkZsb2F0O1xufSIsIi8vIGdldE1vdXNlLmpzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChlKSB7XG5cdGxldCB4LCB5O1xuXG5cdGlmKGUudG91Y2hlcykge1xuXHRcdHggPSBlLnRvdWNoZXNbMF0ucGFnZVg7XG5cdFx0eSA9IGUudG91Y2hlc1swXS5wYWdlWTtcblx0fSBlbHNlIHtcblx0XHR4ID0gZS5jbGllbnRYO1xuXHRcdHkgPSBlLmNsaWVudFk7XG5cdH1cblxuXG5cdHJldHVybiB7XG5cdFx0eCwgeVxuXHR9O1xufSIsIi8vIGdldFRleHR1cmVQYXJhbWV0ZXJzLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnXG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byAoeCkge1xuICByZXR1cm4gKHggIT09IDApICYmICghKHggJiAoeCAtIDEpKSlcbn07XG5cbmNvbnN0IGdldFRleHR1cmVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1QYXJhbXMsIG1Tb3VyY2UsIG1XaWR0aCwgbUhlaWdodCkge1xuICBpZiAoIW1QYXJhbXMubWluRmlsdGVyKSB7XG4gICAgbGV0IG1pbkZpbHRlciA9IEdMLkxJTkVBUlxuICAgIGlmIChtV2lkdGggJiYgbVdpZHRoKSB7XG4gICAgICBpZiAoaXNQb3dlck9mVHdvKG1XaWR0aCkgJiYgaXNQb3dlck9mVHdvKG1IZWlnaHQpKSB7XG4gICAgICAgIG1pbkZpbHRlciA9IEdMLk5FQVJFU1RfTUlQTUFQX0xJTkVBUlxuICAgICAgfVxuICAgIH1cblxuICAgIG1QYXJhbXMubWluRmlsdGVyID0gbWluRmlsdGVyXG4gIH1cblxuICBtUGFyYW1zLm1pcG1hcCA9IG1QYXJhbXMubWlwbWFwID09PSB1bmRlZmluZWQgPyB0cnVlIDogbVBhcmFtcy5taXBtYXBcbiAgbVBhcmFtcy5tYWdGaWx0ZXIgPSBtUGFyYW1zLm1hZ0ZpbHRlciB8fCBHTC5MSU5FQVJcbiAgbVBhcmFtcy53cmFwUyA9IG1QYXJhbXMud3JhcFMgfHwgR0wuQ0xBTVBfVE9fRURHRVxuICBtUGFyYW1zLndyYXBUID0gbVBhcmFtcy53cmFwVCB8fCBHTC5DTEFNUF9UT19FREdFXG4gIG1QYXJhbXMuaW50ZXJuYWxGb3JtYXQgPSBtUGFyYW1zLmludGVybmFsRm9ybWF0IHx8IEdMLlJHQkFcbiAgbVBhcmFtcy5mb3JtYXQgPSBtUGFyYW1zLmZvcm1hdCB8fCBHTC5SR0JBXG4gIG1QYXJhbXMucHJlbXVsdGlwbHlBbHBoYSA9IG1QYXJhbXMucHJlbXVsdGlwbHlBbHBoYSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtUGFyYW1zLnByZW11bHRpcGx5QWxwaGFcbiAgbVBhcmFtcy5sZXZlbCA9IG1QYXJhbXMubGV2ZWwgfHwgMFxuICByZXR1cm4gbVBhcmFtc1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRUZXh0dXJlUGFyYW1ldGVyc1xuIiwiaW1wb3J0IHsgQmF0Y2hCYWxsLCBHTCwgR0xTaGFkZXIsIEdlb20gfSBmcm9tICdhbGZyaWQnO1xuaW1wb3J0IHsgZ2V0MmRQb3MsIGdldERpc3RPcHRpbTNELCBnZXRHZW9tZXRyeUZhY2VzLCByZXNpemUgfSBmcm9tICd1dGlscyc7XG5cbmltcG9ydCBDb25maWcgZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4vZ2VvbS9MaW5lJztcbmltcG9ydCBTaWduYWwgZnJvbSAnbWluaS1zaWduYWxzJztcbmltcG9ydCBmcyBmcm9tICdzaGFkZXJzL2NvbG9yLmZyYWcnO1xuaW1wb3J0IGZzTGluZSBmcm9tICdzaGFkZXJzL2xpbmUuZnJhZyc7XG5pbXBvcnQgeyBtYXQ0IH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCB2cyBmcm9tICdzaGFkZXJzL21hcmtlci52ZXJ0JztcbmltcG9ydCB2c0xpbmUgZnJvbSAnc2hhZGVycy9saW5lLnZlcnQnO1xuXG5jb25zdCB0ZW1wVmVjMyA9IHZlYzMuY3JlYXRlKCk7XG5leHBvcnQgY2xhc3MgQ2FtZXJhU3BvdHMge1xuXHRjb25zdHJ1Y3RvcihzY2VuZSwgY29udGFpbmVyLCBzcG90cykge1xuXHRcdHRoaXMuc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cdFx0dGhpcy5zaGFkZXJMaW5lID0gbmV3IEdMU2hhZGVyKHZzTGluZSwgZnNMaW5lKTtcblxuXHRcdHRoaXMub25TcG90Q2xpY2tlZCA9IG5ldyBTaWduYWwoKTtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdFx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcblx0XHR0aGlzLnNob3duID0gdHJ1ZTtcblx0XHR0aGlzLm9yYml0YWxDb250cm9sID0gc2NlbmUub3JiaXRhbENvbnRyb2w7XG5cdFx0dGhpcy5zcG90cyA9IFtdO1xuXHRcdHRoaXMubGluZXMgPSBbXTtcblx0XHRcblx0XHRpZiAoc3BvdHMpIHRoaXMuYWRkU3BvdHMoc3BvdHMpO1xuXHR9XG5cblx0c2hvdygpIHtcblx0XHR0aGlzLnNob3duID0gdHJ1ZTtcblx0fVxuXG5cdGhpZGUoKSB7XG5cdFx0dGhpcy5zaG93biA9IGZhbHNlO1xuXHR9XG5cdFxuXHRzdGFydCgpIHtcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHRzdG9wKCkge1xuXHRcdHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cdH1cblxuXHRhZGRTcG90cyhzcG90cykge1xuXHRcdGlmICghc3BvdHMubGVuZ3RoKSByZXR1cm47XG5cdFx0XG5cdFx0Y29uc3QgcyA9IDAuMDI7XG5cdFx0dGhpcy5tZXNoID0gR2VvbS5zcGhlcmUocywgMjApO1xuXHRcdFxuXHRcdGNvbnN0IHBvc09mZnNldCA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc3BvdHMubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0Y29uc3QgY3VycmVudFNwb3QgPSBzcG90c1tpXTtcblx0XHRcdGNvbnN0IG5hbWUgPSBjdXJyZW50U3BvdC5uYW1lIHx8IGBBbm5vdGF0aW9uICR7aSArIDF9YDtcblxuXHRcdFx0Y29uc3Qgb3JpZ2luID0gY3VycmVudFNwb3QudGFyZ2V0Oy8vIHRoaXMub3JiaXRhbENvbnRyb2wuZ2V0UG9zaXRpb24oY3VycmVudFNwb3QucngsIGN1cnJlbnRTcG90LnJ5LCBjdXJyZW50U3BvdC56b29tKTtcblx0XG5cdFx0XHRjb25zdCBwb3MgPSB0aGlzLm9yYml0YWxDb250cm9sLmdldFBvc2l0aW9uKGN1cnJlbnRTcG90LnJ4LCBjdXJyZW50U3BvdC5yeSwgY3VycmVudFNwb3Quem9vbSk7XG5cdFx0XHRwb3NbMF0gKz0gY3VycmVudFNwb3Qub2Zmc2V0WzBdO1xuXHRcdFx0cG9zWzFdICs9IGN1cnJlbnRTcG90Lm9mZnNldFsxXTtcblx0XHRcdHBvc1syXSArPSBjdXJyZW50U3BvdC5vZmZzZXRbMl07XG5cblx0XHRcdGNvbnN0IGRpc3QgPSBnZXREaXN0T3B0aW0zRChvcmlnaW5bMF0sIHBvc1swXSwgb3JpZ2luWzFdLCBwb3NbMV0sIG9yaWdpblsyXSwgcG9zWzJdKTtcblxuXHRcdFx0aWYgKGRpc3QgPiAyKSB7XG5cdFx0XHRcdGxldCBwID0gMiAvIGRpc3Q7XG5cdFx0XHRcdHBvc1swXSA9IG9yaWdpblswXSArIChwb3NbMF0gLSBvcmlnaW5bMF0pICogcDtcblx0XHRcdFx0cG9zWzFdID0gb3JpZ2luWzFdICsgKHBvc1sxXSAtIG9yaWdpblsxXSkgKiBwO1xuXHRcdFx0XHRwb3NbMl0gPSBvcmlnaW5bMl0gKyAocG9zWzJdIC0gb3JpZ2luWzJdKSAqIHA7XG5cdFx0XHR9XG5cblx0XHRcdHBvc09mZnNldC5wdXNoKG9yaWdpbik7XG5cblx0XHRcdC8vIGNyZWF0ZSBodG1sXG5cdFx0XHRjb25zdCB0ZXh0ID0gdGhpcy5hZGRTcG90VGV4dChuYW1lLCBjdXJyZW50U3BvdCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuc3BvdHMucHVzaCh7IFxuXHRcdFx0XHR0YXJnZXQ6IGN1cnJlbnRTcG90LnRhcmdldCxcblx0XHRcdFx0cG9zLFxuXHRcdFx0XHR0ZXh0LFxuXHRcdFx0XHRvcGFjaXR5OiAwXG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgbGluZSA9IG5ldyBMaW5lKFtwb3MsIGN1cnJlbnRTcG90LnRhcmdldF0pO1xuXHRcdFx0dGhpcy5saW5lcy5wdXNoKGxpbmUpO1xuXHRcdH1cblxuXHRcdHRoaXMubWVzaC5idWZmZXJJbnN0YW5jZShwb3NPZmZzZXQsICdhUG9zT2Zmc2V0Jyk7XG5cdH1cblxuXHRhZGRTcG90VGV4dChuYW1lLCBkYXRhKSB7XG5cdFx0XG5cdFx0Y29uc3QgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHR0ZXh0LmNsYXNzTmFtZSA9ICdzcG90Jztcblx0XHR0ZXh0Lm9uY2xpY2sgPSAgKCkgPT4ge1xuXHRcdFx0dGhpcy5vblNwb3RDbGlja2VkLmRpc3BhdGNoKGRhdGEpO1xuXHRcdH07XG5cdFx0dGV4dC5pbm5lckhUTUwgPSBkYXRhLmxhYmVsO1x0XG5cdFx0dGhpcy5zY2VuZS5jb250YWluZXJIVE1MLmFwcGVuZENoaWxkKHRleHQpO1xuXG5cdFx0cmV0dXJuIHRleHQ7XG5cdH1cblxuXHRnZXRYWShwb3MsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXgsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpIHtcblx0XHR2ZWMzLnRyYW5zZm9ybU1hdDQodGVtcFZlYzMsIHBvcywgdmlld01hdHJpeCk7XG5cdFx0dmVjMy50cmFuc2Zvcm1NYXQ0KHRlbXBWZWMzLCB0ZW1wVmVjMywgcHJvamVjdGlvbk1hdHJpeCk7XG5cblx0XHR0ZW1wVmVjM1swXSAvPSB0ZW1wVmVjM1syXTtcblx0XHR0ZW1wVmVjM1sxXSAvPSB0ZW1wVmVjM1syXTtcblx0XHR0ZW1wVmVjM1swXSA9ICh0ZW1wVmVjM1swXSArIDEpICogc2NyZWVuV2lkdGggLyAyO1xuXHRcdHRlbXBWZWMzWzFdID0gc2NyZWVuSGVpZ2h0IC0gKHRlbXBWZWMzWzFdICsgMSkgKiBzY3JlZW5IZWlnaHQgLyAyO1xuXG5cdFx0cmV0dXJuIHRlbXBWZWMzO1xuXHR9XG5cblx0cmVuZGVyKGN1cnJlbnRTcG90KSB7XG5cdFx0XG5cblx0XHRjb25zdCBvcGFjaXR5ID0gKHRoaXMuYWN0aXZlICYmIHRoaXMuc2hvd24pID8gMSA6IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3BvdHMubGVuZ3RoOyBpKyspIHtcdFx0XHRcblx0XHRcdGNvbnN0IHNwb3QgPSB0aGlzLnNwb3RzW2ldO1xuXG5cdFx0XHRcdFxuXHRcdFx0c3BvdC5vcGFjaXR5ICs9IChvcGFjaXR5IC0gc3BvdC5vcGFjaXR5KSAqIDAuMztcblxuXHRcdFx0aWYgKE1hdGguYWJzKHNwb3Qub3BhY2l0eSAtIG9wYWNpdHkpIDwgMC4wNSAmJiBzcG90Lm9wYWNpdHkgIT09IG9wYWNpdHkpIHtcblx0XHRcdFx0c3BvdC5vcGFjaXR5ID0gb3BhY2l0eTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHNwb3QudGV4dC5zdHlsZS5vcGFjaXR5ICE9PSBzcG90Lm9wYWNpdHkpIHtcblx0XHRcdFx0c3BvdC50ZXh0LnN0eWxlLm9wYWNpdHkgPSBzcG90Lm9wYWNpdHk7XG5cblx0XHRcdFx0aWYgKHNwb3Qub3BhY2l0eSA9PT0gMCkge1xuXHRcdFx0XHRcdHNwb3QudGV4dC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNwb3Qub3BhY2l0eSA9PT0gMSkge1xuXHRcdFx0XHRcdHNwb3QudGV4dC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3BhY2l0eSkge1xuXHRcdFx0XHRjb25zdCByZXMgPSBnZXQyZFBvcyhzcG90LnBvcyk7XG5cdFx0XHRcdHNwb3QudGV4dC5zdHlsZS5sZWZ0ID0gYCR7cmVzWzBdfXB4YDtcblx0XHRcdFx0c3BvdC50ZXh0LnN0eWxlLnRvcCA9IGAke3Jlc1sxXSAtIDIwfXB4YDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuYWN0aXZlIHx8ICF0aGlzLnNob3duIHx8ICF0aGlzLm1lc2gpIHJldHVybjtcblx0XHRcblx0XHRjb25zdCBjb2xvclNwb3QgPSBDb25maWcuYW5ub3RhdGlvbnMuY29sb3IubWFwKCh2KSA9PiB2IC8gMjU1KTtcblxuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1Q29sb3InLCAndmVjMycsIGNvbG9yU3BvdCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndUFscGhhJywgJ2Zsb2F0JywgQ29uZmlnLmFubm90YXRpb25zLmFscGhhKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1U2NhbGUnLCAnZmxvYXQnLCBDb25maWcuYW5ub3RhdGlvbnMuc2NhbGUpO1xuXHRcdEdMLmRyYXcodGhpcy5tZXNoKTtcdFx0XG5cdFx0XG5cdFx0Ly8gRHJhdyB0aGUgbGluZXNcblx0XHR0aGlzLnNoYWRlckxpbmUuYmluZCgpO1xuXHRcdHRoaXMuc2hhZGVyTGluZS51bmlmb3JtKCd1QWxwaGEnLCAnZmxvYXQnLCAxKTtcblx0XHR0aGlzLnNoYWRlckxpbmUudW5pZm9ybSgndGhpY2tuZXNzJywgJ2Zsb2F0JywgLjAyKTtcblx0XHR0aGlzLnNoYWRlckxpbmUudW5pZm9ybSgndUNvbG9yJywgJ3ZlYzMnLCBjb2xvclNwb3QpO1xuXHRcdHRoaXMuc2hhZGVyTGluZS51bmlmb3JtKCdhc3BlY3QnLCAnZmxvYXQnLCBHTC5hc3BlY3RSYXRpbyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuXHRcdFx0R0wuZHJhdyhsaW5lKTtcblx0XHR9XG5cblx0fVxufSIsIi8vIENvbmZpZy5qc1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG1ldGFsbGljOiAwLFxuICBkZWJ1Zzoge1xuICAgIHNoYXBlOiB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgcm90OiB7eDogMCwgeTogMCwgejogMH0sXG4gICAgICBzY2FsZToge3g6IDEsIHk6IDEsIHo6IDF9LFxuICAgICAgcG9zOiB7eDogMCwgeTogMCwgejogMH0sXG4gICAgfVxuICB9LFxuICBlZGl0b3I6IHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIHBvaW50czogW11cbiAgfSxcbiAgYW5ub3RhdGlvbnM6IHtcbiAgICBzY2FsZTogMSxcbiAgICBjb2xvcjogWzAsIDE1NCwgMjIxXSxcbiAgICBhbHBoYTogMSxcbiAgfSxcbiAgaG9tZToge1xuICAgIGNhbWVyYU1vdmVtZW50OiB0cnVlXG4gIH0sXG4gIGRlYnVnU2hhZG93OiBmYWxzZSxcbiAgY2FtZXJhTGlnaHRQb3NpdGlvbjogW1xuICAgIDAuMDEsXG4gICAgNyxcbiAgICAwXG4gIF0sXG4gIGNhbWVyYU9ydGhvOiB7XG4gICAgc2l6ZTogMixcbiAgICBuZWFyOiAzLFxuICAgIGZhcjogNy44XG4gIH0sXG4gIHNoYWRvd01hcFNpemU6IDEwMjQsXG4gIHNoYWRvdzoge1xuICAgIHNwcmVhZDogMS4wLFxuICAgIG9wYWNpdHk6IDAuNyxcbiAgICBjb2xvcjogWzIwNywgMTg5LCAxNzFdXG4gIH0sXG59XG4iLCIvLyBTZXR0aW5ncy5qc1xuXG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vQ29uZmlnJ1xuaW1wb3J0IHVybCBmcm9tICdmYXN0LXVybC1wYXJzZXInXG51cmwucXVlcnlTdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZ3BhcnNlcicpXG5cbmxldCBlbmFibGVkID0gdHJ1ZVxuXG5jb25zdCByZWxvYWQgPSAoKSA9PiB7XG4gIGlmICghZW5hYmxlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArICc/Y29uZmlnPScgKyBKU09OLnN0cmluZ2lmeShDb25maWcpXG59XG5cbmNvbnN0IHJlZnJlc2ggPSAoKSA9PiB7XG4gIGlmICghZW5hYmxlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSgnZXhwZXJpbWVudCcsICdUaXRsZScsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyAnP2NvbmZpZz0nICsgSlNPTi5zdHJpbmdpZnkoQ29uZmlnKSlcbn1cblxuY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZVxufVxuXG5sZXQgZGVsYXlJbmRleCA9IC0xXG5cbmNvbnN0IGRlbGF5UmVsb2FkID0gKCkgPT4ge1xuICBpZiAoIWVuYWJsZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB3aW5kb3cuY2xlYXJUaW1lb3V0KGRlbGF5SW5kZXgpXG5cbiAgZGVsYXlJbmRleCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyAnP2NvbmZpZz0nICsgSlNPTi5zdHJpbmdpZnkoQ29uZmlnKVxuICB9LCA1MDApXG59XG5cbmNvbnN0IGluaXQgPSAobUVuYWJsZWQgPSB0cnVlKSA9PiB7XG4gIGVuYWJsZWQgPSBtRW5hYmxlZFxuICBjb25zdCBwYXJzZWQgPSB1cmwucGFyc2Uod2luZG93LmxvY2F0aW9uLnNlYXJjaCwgdHJ1ZSlcbiAgbGV0IHBhcnNlZEpzb24gPSB7fVxuICBpZiAocGFyc2VkLnF1ZXJ5LmNvbmZpZykge1xuICAgIHBhcnNlZEpzb24gPSBKU09OLnBhcnNlKHBhcnNlZC5xdWVyeS5jb25maWcpXG4gIH1cblxuICBPYmplY3QuYXNzaWduKENvbmZpZywgcGFyc2VkSnNvbilcbiAgcmVmcmVzaCgpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZW5hYmxlZCxcbiAgcmVsb2FkLFxuICByZXNldCxcbiAgcmVmcmVzaCxcbiAgZGVsYXlSZWxvYWQsXG4gIGluaXRcbn1cbiIsImltcG9ydCBhbGZyaWQsIHsgQ2FtZXJhT3J0aG8sIEZyYW1lQnVmZmVyLCBHTCB9IGZyb20gJ2FsZnJpZCc7XG5cbmltcG9ydCBDb25maWcgZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IHsgYmlhc01hdHJpeCB9IGZyb20gJ3V0aWxzLXZpZXdlcic7XG5pbXBvcnQgeyBtYXQ0IH0gZnJvbSAnZ2wtbWF0cml4JztcblxuZXhwb3J0IGNsYXNzIFNoYWRvd01hbmFnZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLnNoYWRvd01hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5jYW1lcmFMaWdodFRhcmdldCA9IFswLCAwLCAwXTtcblx0XHR0aGlzLmNhbWVyYUxpZ2h0ID0gbmV3IENhbWVyYU9ydGhvKCk7XG5cdFx0XG5cdFx0dGhpcy5zaXplID0gQ29uZmlnLmNhbWVyYU9ydGhvLnNpemU7XG5cdFx0dGhpcy5jYW1lcmFMaWdodC5vcnRobygtdGhpcy5zaXplLCB0aGlzLnNpemUsIHRoaXMuc2l6ZSwgLXRoaXMuc2l6ZSwgQ29uZmlnLmNhbWVyYU9ydGhvLm5lYXIsIENvbmZpZy5jYW1lcmFPcnRoby5mYXIpO1xuXHRcdHRoaXMudXBkYXRlTGlnaHRDYW1lcmEoKTtcbiAgICBcblx0XHRjb25zdCBvU2V0dGluZ3MgPSB7IG1pbkZpbHRlcjpHTC5MSU5FQVJfTUlQTUFQX05FQVJFU1QsIG1hZ0ZpbHRlcjpHTC5MSU5FQVIgfTtcblx0XHR0aGlzLmZibyA9IG5ldyBGcmFtZUJ1ZmZlcigxMDI0LCAxMDI0LCBvU2V0dGluZ3MpO1xuXHR9XG5cblx0dXBkYXRlTGlnaHRDYW1lcmEoKSB7XG5cdFx0dGhpcy5jYW1lcmFMaWdodC5sb29rQXQoQ29uZmlnLmNhbWVyYUxpZ2h0UG9zaXRpb24sIFswLCAwLCAwXSk7XG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLnNoYWRvd01hdHJpeCk7XG5cdFx0bWF0NC5tdWx0aXBseSh0aGlzLnNoYWRvd01hdHJpeCwgdGhpcy5jYW1lcmFMaWdodC5wcm9qZWN0aW9uLCB0aGlzLmNhbWVyYUxpZ2h0LnZpZXdNYXRyaXgpO1xuXHRcdGNvbnNvbGUubG9nKGJpYXNNYXRyaXgpO1xuXHRcdG1hdDQubXVsdGlwbHkodGhpcy5zaGFkb3dNYXRyaXgsIGJpYXNNYXRyaXgsIHRoaXMuc2hhZG93TWF0cml4KTtcblx0fVxuICBcblx0c2V0U2l6ZShzaXplKSB7XG5cdFx0dGhpcy5zaXplID0gc2l6ZTtcblx0XHR0aGlzLnJlY2FsY3VsYXRlU2hhZG93KCk7XG5cdH1cblxuXHRyZWNhbGN1bGF0ZVNoYWRvdygpIHtcblx0XHR0aGlzLmNhbWVyYUxpZ2h0Lm9ydGhvKC10aGlzLnNpemUsIHRoaXMuc2l6ZSwgdGhpcy5zaXplLCAtdGhpcy5zaXplLCBDb25maWcuY2FtZXJhT3J0aG8ubmVhciwgQ29uZmlnLmNhbWVyYU9ydGhvLmZhcik7XG5cdFx0dGhpcy51cGRhdGVMaWdodENhbWVyYSgpO1xuXHR9XG5cblx0cmVuZGVyKG1lc2gpIHtcblx0XHR0aGlzLmZiby5iaW5kKCk7XG5cdFx0R0wuY2xlYXIoMCwgMCwgMCwgMSk7XG5cdFx0R0wuc2V0TWF0cmljZXModGhpcy5jYW1lcmFMaWdodCk7XG4gICAgR0wuZ2wuZGVwdGhGdW5jKEdMLmdsLkxFU1MpO1xuICAgIFxuICAgIG1lc2gucmVuZGVyU2hhZG93KCk7XG5cdFx0dGhpcy5mYm8udW5iaW5kKCk7XG5cdH1cbn0iLCJjb25zdCBOT09QID0gKCkgPT57fTtcblxuZXhwb3J0IGNsYXNzIFN0YXRlc01hbmFnZXIge1xuXHRjb25zdHJ1Y3RvcihzY2VuZSkge1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0XHR0aGlzLnN0YXRlcyA9IHt9O1xuXHRcdHRoaXMuY3VycmVudFN0YXRlSWQgPSAnZW1wdHknO1xuXHRcdHRoaXMudHJhbnNpdGlvbk1hcCA9IHt9O1xuXG5cdFx0dGhpcy5hZGQoJ2VtcHR5JywgeyBlbmQ6IE5PT1AsIGJlZ2luOiBOT09QLCB1cGRhdGU6IE5PT1AsIHJlbmRlcjogTk9PUCB9KTtcblx0fVxuXG5cdGdldCBpZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50U3RhdGVJZDtcblx0fVxuXG5cdGFkZFRyYW5zaXRpb24oaWQxLCBpZDIsIGJvdGh3YXlzKSB7XG5cdFx0dGhpcy50cmFuc2l0aW9uTWFwW2lkMV1baWQyXSA9IHRydWU7XG5cblx0XHRpZiAoYm90aHdheXMpIHtcblx0XHRcdHRoaXMudHJhbnNpdGlvbk1hcFtpZDJdW2lkMV0gPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0YWRkKGlkLCBzdGF0ZSkge1xuXHRcdHRoaXMuc3RhdGVzW2lkXSA9IHN0YXRlO1xuXHRcdHN0YXRlLnNjZW5lID0gdGhpcy5zY2VuZTtcblxuXHRcdGlmICghc3RhdGUuZW1wdHkpc3RhdGUuZW1wdHkgPSBOT09QO1xuXHRcdGlmICghc3RhdGUuYmVnaW4pc3RhdGUuYmVnaW4gPSBOT09QO1xuXHRcdGlmICghc3RhdGUudXBkYXRlKXN0YXRlLnVwZGF0ZSA9IE5PT1A7XG5cdFx0aWYgKCFzdGF0ZS5yZW5kZXIpc3RhdGUucmVuZGVyID0gTk9PUDtcblx0XHRpZiAoIXN0YXRlLmVuZClzdGF0ZS5lbmQgPSBOT09QO1xuXG5cdFx0dGhpcy50cmFuc2l0aW9uTWFwW2lkXSA9IHt9O1xuXG5cdFx0dGhpcy5hZGRUcmFuc2l0aW9uKCdlbXB0eScsIGlkLCB0cnVlKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0c2V0KGlkLCBkYXRhKSB7XG5cdFx0aWYgKHRoaXMudHJhbnNpdGlvbk1hcFt0aGlzLmN1cnJlbnRTdGF0ZUlkXVtpZF0pIHtcbiAgICAgIHRoaXMuc3RhdGVzW3RoaXMuY3VycmVudFN0YXRlSWRdLmVuZCgpO1xuXG5cdFx0XHR0aGlzLmN1cnJlbnRTdGF0ZUlkID0gaWQ7XG5cbiAgICAgIHRoaXMuc3RhdGVzW3RoaXMuY3VycmVudFN0YXRlSWRdLmJlZ2luKGRhdGEpO1xuICAgICAgY29uc29sZS5sb2codGhpcy5zdGF0ZXNbdGhpcy5jdXJyZW50U3RhdGVJZF0pXG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHRoaXMuc3RhdGVzW3RoaXMuY3VycmVudFN0YXRlSWRdLnJlbmRlcigpO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBHTCwgUmF5IH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCB7IGdldERpc3RPcHRpbSwgaW50ZXJzZWN0aW9uUmF5TWVzaCB9IGZyb20gJ3V0aWxzJztcblxuaW1wb3J0IFNpZ25hbCBmcm9tICdtaW5pLXNpZ25hbHMnO1xuXG5jb25zdCBnZXRNb3VzZSA9IGZ1bmN0aW9uIChtRXZlbnQsIG1UYXJnZXQpIHtcblxuXHRjb25zdCBvID0gbVRhcmdldCB8fCB7fTtcblx0aWYobUV2ZW50LnRvdWNoZXMpIHtcblx0XHRvLnggPSBtRXZlbnQudG91Y2hlc1swXS5wYWdlWDtcblx0XHRvLnkgPSBtRXZlbnQudG91Y2hlc1swXS5wYWdlWTtcblx0fSBlbHNlIHtcblx0XHRvLnggPSBtRXZlbnQuY2xpZW50WDtcblx0XHRvLnkgPSBtRXZlbnQuY2xpZW50WTtcblx0fVxuXG5cdHJldHVybiBvO1xufTtcblxuZXhwb3J0IGNsYXNzIFRvdWNoQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKHNjZW5lKSB7XG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xuXHRcdHRoaXMuY2FtZXJhID0gdGhpcy5zY2VuZS5jYW1lcmE7XG5cdFx0dGhpcy5tb3VzZURvd24gPSB7eDogMCwgeTogMH07XG5cdFx0dGhpcy5tb3VzZSA9IHt4OiAwLCB5OiAwfTtcblx0XHR0aGlzLnJheSA9IG5ldyBSYXkoWzAsIDAsIDBdLCBbMCwgMSwgMF0pO1xuXG5cdFx0dGhpcy5vbk1vdmVDYWxsYmFjayA9IG51bGw7XG5cdFx0dGhpcy5vbkNsaWNrQ2FsbGJhY2sgPSBudWxsO1xuXHRcdHRoaXMub25VcENhbGxiYWNrID0gbnVsbDtcblx0XHRcblx0XHR0aGlzLnRhcmdldHMgPSBbXTtcblxuXHRcdHRoaXMuX29uRG93biA9IHRoaXMub25Eb3duLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5fb25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcblx0XHR0aGlzLl9vblVwID0gdGhpcy5vblVwLmJpbmQodGhpcyk7XG5cdH1cblxuXHRwYXVzZSAoaWQsIHZhbCA9IHRydWUpIHtcblx0XHRjb25zdCBtZXRob2QgPSB2YWwgPyB0aGlzLnNjZW5lLmNvbnRhaW5lckhUTUwucmVtb3ZlRXZlbnRMaXN0ZW5lciA6IHRoaXMuc2NlbmUuY29udGFpbmVySFRNTC5hZGRFdmVudExpc3RlbmVyO1xuXHRcdGlmIChpZCA9PT0gJ29uTW92ZScpIHtcblx0XHRcdG1ldGhvZCgnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlKTtcblx0XHR9XG5cdH1cblxuXHRnZW5lcmF0ZVJheShlLCBtb3VzZSkge1xuXHRcdGNvbnN0IG8gPSBnZXRNb3VzZShlLCBtb3VzZSk7XG5cdFx0Y29uc3QgbXggPSAoby54IC8gKCh3aW5kb3cuaW5uZXJXaWR0aCkpKSAqIDIuMCAtIDEuMDtcblx0XHRjb25zdCBteSA9IC0oby55IC8gKHdpbmRvdy5pbm5lckhlaWdodCkpICogMi4wICsgMS4wO1xuXG5cblx0XHR0aGlzLmNhbWVyYS5nZW5lcmF0ZVJheShbbXgsIG15LCAwXSwgdGhpcy5yYXkpO1xuXHR9XG5cdFxuXG5cdHNldENhbGxiYWNrcyhjYnMpIHtcblx0XHRcblx0XHRmb3IgKGNvbnN0IGtleSBpbiBjYnMpIHtcblx0XHRcdHRoaXNba2V5XSA9IGNic1trZXldO1xuXHRcdH1cblx0fVxuXHRcblx0c3RhcnQodGFyZ2V0cywgY2JzKSB7XG5cdFx0dGhpcy50YXJnZXRzID0gdGFyZ2V0cztcblx0XHR0aGlzLnNldENhbGxiYWNrcyhjYnMpO1xuXHRcdHRoaXMuc2NlbmUuY29udGFpbmVySFRNTC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkRvd24pO1xuXHRcdHRoaXMuc2NlbmUuY29udGFpbmVySFRNTC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25VcCk7XG5cdFx0dGhpcy5zY2VuZS5jb250YWluZXJIVE1MLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW92ZSk7XG5cdH1cblx0XG5cdHN0b3AoKSB7XG5cdFx0dGhpcy5zY2VuZS5jb250YWluZXJIVE1MLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bik7XG5cdFx0dGhpcy5zY2VuZS5jb250YWluZXJIVE1MLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblVwKTtcblx0XHR0aGlzLnNjZW5lLmNvbnRhaW5lckhUTUwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlKTtcblx0fVxuXHRcblx0c2V0VGFyZ2V0cyh0YXJnZXRzKSB7XG5cdFx0dGhpcy50YXJnZXRzID0gdGFyZ2V0cztcblx0fVxuXG5cdFxuXHRvbkRvd24oZSkge1xuXHRcdHRoaXMuZG93biA9IHRydWU7XG5cdFx0dGhpcy5tb3VzZURvd24gPSBnZXRNb3VzZShlKTtcblx0fVxuXG5cdG9uTW92ZShlKSB7XG5cdFx0aWYgKHRoaXMub25Nb3ZlQ2FsbGJhY2spIHRoaXMub25Nb3ZlQ2FsbGJhY2sodGhpcy5kb3duKTtcdFx0XG5cdH1cblxuXHRvblVwKGUpIHtcblx0XHR0aGlzLmRvd24gPSBmYWxzZTtcblx0XHRjb25zdCBvID0gZ2V0TW91c2UoZSk7XG5cdFx0Y29uc3QgZGlzdCA9IGdldERpc3RPcHRpbShvLngsIG8ueSwgdGhpcy5tb3VzZURvd24ueCwgdGhpcy5tb3VzZURvd24ueSk7XG5cblx0XHRpZiAoZGlzdCA8IDUpIHtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgY2xpY2sgc29tZXdoZXJlXG5cdFx0XHR0aGlzLmdlbmVyYXRlUmF5KGUsIHRoaXMubW91c2UpO1xuXHRcdFx0bGV0IGhpdDtcblx0XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBtZXNoID0gdGhpcy50YXJnZXRzW2ldO1xuXHRcdFx0XHRcblx0XHRcdFx0aGl0ID0gaW50ZXJzZWN0aW9uUmF5TWVzaCh0aGlzLnJheSwgbWVzaC5mYWNlcywgbWVzaC5tYXRyaXgsIGZhbHNlKTtcblx0XHRcdFx0aWYgKGhpdCAmJiB0aGlzLm9uQ2xpY2tDYWxsYmFjaykgdGhpcy5vbkNsaWNrQ2FsbGJhY2sobWVzaCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub25VcENhbGxiYWNrKSB0aGlzLm9uVXBDYWxsYmFjaygpXG5cdH1cbn0iLCIvLyBTY2VuZUFwcC5qc1xuXG5pbXBvcnQgeyBCaXRTd2l0Y2gsIE9yYml0YWxDb250cm9sVHdlZW4gfSBmcm9tICdoZWxwZXJzJztcbmltcG9ydCB7IFN0YXRlQW5ub3RhdGUsIFN0YXRlSG9tZSwgU3RhdGVPcmJpdCB9IGZyb20gJy4vc3RhdGVzJztcbmltcG9ydCBhbGZyaWQsIHsgQ2FtZXJhT3J0aG8sIEZyYW1lQnVmZmVyLCBHTCwgUmF5LCBTY2VuZSB9IGZyb20gJ2FsZnJpZCc7XG5cbmltcG9ydCBBc3NldHMgZnJvbSAnLi4vQXNzZXRzJztcbmltcG9ydCB7IENhbWVyYVNwb3RzIH0gZnJvbSAnLi9DYW1lcmFTcG90cyc7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vQ29uZmlnJztcbmltcG9ydCB7IFNoYWRvd01hbmFnZXIgfSBmcm9tICcuL1NoYWRvd01hbmFnZXInO1xuaW1wb3J0IHsgU3RhdGVzTWFuYWdlciB9IGZyb20gJy4vU3RhdGVzTWFuYWdlcic7XG5pbXBvcnQgeyBUb3VjaENvbnRyb2xsZXIgfSBmcm9tICcuL1RvdWNoQ29udHJvbGxlcic7XG5pbXBvcnQgVmlld0Fubm90YXRpb24gZnJvbSAnLi92aWV3cy9WaWV3QW5ub3RhdGlvbic7XG5pbXBvcnQgVmlld0Zsb29yIGZyb20gJy4vdmlld3MvVmlld0Zsb29yJztcbmltcG9ydCBWaWV3T2JqTW9kZWwgZnJvbSAnLi92aWV3cy9WaWV3T2JqTW9kZWwnO1xuaW1wb3J0IHsgYWRkVUkgfSBmcm9tICcuL2RlYnVnL2FkZFVJJztcbmltcG9ydCBkYXRhQ2FtZXJhUG9pbnRzIGZyb20gJy4vZGF0YS1jYW1lcmEtcG9pbnRzJztcbmltcG9ydCB7IHJlc2l6ZSB9IGZyb20gJ3V0aWxzJztcbmltcG9ydCB7IHN0YXRlcyB9IGZyb20gJ2NvbnN0cy12aWV3ZXInO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNsYXNzIFZpZXdlckFwcCBleHRlbmRzIFNjZW5lIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0bGV0IGNvbnRhaW5lcjtcblx0XHRpZiAob3B0aW9ucy5jb250YWluZXIpIHtcblx0XHRcdG9wdGlvbnMubm9Db250cm9sID0gdHJ1ZTtcblx0XHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0Y29udGFpbmVyLmNsYXNzTmFtZSA9ICdjYW1lcmEtc3BvdHMnO1xuXHRcdFx0b3B0aW9ucy5jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbWVyYS1zcG90cycpO1xuXHRcdFx0b3B0aW9ucy5jb250YWluZXIgPSBjb250YWluZXI7XG5cdFx0fVxuXHRcdFxuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHRcdFxuXHRcdGlmICghb3B0aW9ucy5ub0NvbnRyb2wpIGFkZFVJKHRoaXMsIGNvbnRhaW5lcik7XG5cblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFxuXHRcdEdMLmVuYWJsZUFscGhhQmxlbmRpbmcoKTtcblx0XHR0aGlzLm9yYml0YWxDb250cm9sLnJ4LnZhbHVlID0gdGhpcy5vcmJpdGFsQ29udHJvbC5yeS52YWx1ZSA9IDAuMztcblx0XHR0aGlzLm9yYml0YWxDb250cm9sLnJhZGl1cy52YWx1ZSA9IDU7XG5cblx0XHR0aGlzLm9yYml0YWxDb250cm9sLl9yeC5saW1pdCgwLCBNYXRoLlBJIC8gMik7XG5cdFx0aWYgKCFDb25maWcuZWRpdG9yLmFjdGl2ZSAmJiAhQ29uZmlnLmRlYnVnLnNoYXBlLmFjdGl2ZSkge1xuXHRcdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5yYWRpdXMubGltaXQoMiwgNik7XG5cdFx0fVxuXG5cdFx0dGhpcy5jdXJyZW50U3BvdCA9IG51bGw7XG5cdFx0dGhpcy5yZXNpemUoKTtcblxuXHRcdHRoaXMucG9zaXRpb25EZWJ1ZyA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGhpcy5wb3NpdGlvbkNlbnRlckRlYnVnID0gdmVjMy5jcmVhdGUoKTtcblxuXHRcdHRoaXMuc3RhdGVNYW5hZ2VyID0gbmV3IFN0YXRlc01hbmFnZXIodGhpcyk7XG5cdFx0dGhpcy5zdGF0ZU1hbmFnZXIuYWRkKCdob21lJywgbmV3IFN0YXRlSG9tZSgpKTtcblx0XHR0aGlzLnN0YXRlTWFuYWdlci5hZGQoJ29yYml0JywgbmV3IFN0YXRlT3JiaXQoKSk7XG5cdFx0dGhpcy5zdGF0ZU1hbmFnZXIuYWRkKCdhbm5vdGF0ZScsIG5ldyBTdGF0ZUFubm90YXRlKCkpO1xuXHRcdHRoaXMuc3RhdGVNYW5hZ2VyLmFkZFRyYW5zaXRpb24oJ2hvbWUnLCAnb3JiaXQnLCB0cnVlKTtcblx0XHR0aGlzLnN0YXRlTWFuYWdlci5hZGRUcmFuc2l0aW9uKCdob21lJywgJ2Fubm90YXRlJywgdHJ1ZSk7XG5cdFx0dGhpcy5zdGF0ZU1hbmFnZXIuYWRkVHJhbnNpdGlvbignb3JiaXQnLCAnYW5ub3RhdGUnLCB0cnVlKTtcblxuXHRcdHRoaXMuaG9tZSh0cnVlKTtcblx0fVxuXG5cdF9pbml0IChvcHRpb25zKSB7XG5cdFx0c3VwZXIuX2luaXQob3B0aW9ucyk7XG5cblx0XHR0aGlzLmNvbnRhaW5lckhUTUwgPSBvcHRpb25zLmNvbnRhaW5lcjtcblxuXHRcdE9yYml0YWxDb250cm9sVHdlZW4uaW5pdCh0aGlzLm9yYml0YWxDb250cm9sKTtcblxuXHRcdHRoaXMudG91Y2hDb250cm9sbGVyID0gbmV3IFRvdWNoQ29udHJvbGxlcih0aGlzKTtcblx0XHR0aGlzLmNhbWVyYVNwb3RzID0gbmV3IENhbWVyYVNwb3RzKHRoaXMsIG9wdGlvbnMuY29udGFpbmVyLCBDb25maWcuZWRpdG9yLnBvaW50cyB8fCBkYXRhQ2FtZXJhUG9pbnRzKTtcblx0XHR0aGlzLmNhbWVyYVNwb3RzLm9uU3BvdENsaWNrZWQuYWRkKHRoaXMub25TcG90Q2xpY2tlZC5iaW5kKHRoaXMpKTtcblx0XHR0aGlzLnRvdWNoQ29udHJvbGxlci5zdGFydChbXSwge1xuXHRcdFx0Ly8gb25DbGlja0NhbGxiYWNrOiB0aGlzLm9uU3BvdENsaWNrZWQuYmluZCh0aGlzKSxcblx0XHRcdG9uTW92ZUNhbGxiYWNrOiB0aGlzLm9uVG91Y2hDb250cm9sbGVyTW92ZS5iaW5kKHRoaXMpXG5cdFx0fSk7XG5cblx0fVxuXG5cdGhvbWUoc25hcCA9IGZhbHNlKSB7XG5cdFx0dGhpcy5zdGF0ZU1hbmFnZXIuc2V0KCdob21lJywgeyBzbmFwIH0pO1xuXHRcdC8vIHRoaXMuc3RhdGUgPSBzdGF0ZXMuaG9tZTtcblx0XHQvLyAvLyBtb3ZlIG1vZGVsIHRvIG1hdGNoIGFuIGV4YWN0IHBvc2l0aW9uIC8gcm90YXRpb25cblx0XHQvLyB0aGlzLl92TW9kZWwub25Ib21lKHNuYXApO1xuXG5cdFx0Ly8gLy8gc2FtZSBmb3IgY2FtZXJhXG5cdFx0Ly8gbGlzdGVuZWQgZm9yIHdoZW4gdGhlIGNhbWVyYSBtb3ZlXG5cdFx0Ly8gZGlzcGxheSBwb3B1cFxuXHRcdC8vIGhpZGUgbWFya2Vyc1xuXHR9XG5cblx0YW5ub3RhdGUgKCkge1xuXHRcdGlmICh0aGlzLnN0YXRlTWFuYWdlci5jdXJyZW50U3RhdGVJZCA9PT0gJ2Fubm90YXRlJykge1xuXHRcblx0XHRcdHRoaXMuc3RhdGVNYW5hZ2VyLnNldCgnb3JiaXQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zdGF0ZU1hbmFnZXIuc2V0KCdhbm5vdGF0ZScsIHsgcHJldmlvdXNTdGF0ZTogdGhpcy5zdGF0ZU1hbmFnZXIuY3VycmVudFN0YXRlSWQgfSk7XG5cdFx0fVxuXHR9XG5cblx0b25Nb3ZlKCkge1xuXHRcdC8vIG1vdmUgbW9kZWxcblx0XHQvLyBtb3ZlIGNhbWVyYT9cblx0fVxuXG5cdF9pbml0VGV4dHVyZXMoKSB7XG5cdFx0Y29uc29sZS5sb2coJ2luaXQgdGV4dHVyZXMnKTtcblxuXHRcdHRoaXMuc3R1ZGlvUmFkaWFuY2UgPSBBc3NldHMuZ2V0KCdzdHVkaW9fcmFkaWFuY2UnKTtcblx0XHR0aGlzLmlyciA9IEFzc2V0cy5nZXQoJ2lycicpO1xuXHRcdHRoaXMuYW9tYXAgPSBBc3NldHMuZ2V0KCdhb21hcCcpO1xuXHRcdHRoaXMuY29sb3JtYXAgPSBBc3NldHMuZ2V0KCdjb2xvcm1hcCcpO1xuXHRcdHRoaXMucm91Z2huZXNzbWFwID0gQXNzZXRzLmdldCgncm91Z2huZXNzbWFwJyk7XG5cdH1cblxuXG5cdF9pbml0Vmlld3Mob3B0aW9ucykge1xuXHRcdFxuXHRcdHRoaXMuc2hhZG93TWFuYWdlciA9IG5ldyBTaGFkb3dNYW5hZ2VyKCk7XG5cdFx0dGhpcy5fYkNvcHkgPSBuZXcgYWxmcmlkLkJhdGNoQ29weSgpO1xuXHRcdHRoaXMuX2JBeGlzID0gbmV3IGFsZnJpZC5CYXRjaEF4aXMoKTtcblx0XHR0aGlzLl9iRG90cyA9IG5ldyBhbGZyaWQuQmF0Y2hEb3RzUGxhbmUoKTtcblx0XHRpZiAoQ29uZmlnLmVkaXRvci5hY3RpdmUpIHtcblx0XHRcdHRoaXMuX2JCYWxsID0gbmV3IGFsZnJpZC5CYXRjaEJhbGwoKTtcblx0XHRcdHRoaXMuX2JCYWxsT3JiQ2VudGVyID0gbmV3IGFsZnJpZC5CYXRjaEJhbGwoKTtcblx0XHRcdHRoaXMuX2JCYWxsQ2VudGVyID0gbmV3IGFsZnJpZC5CYXRjaEJhbGwoKTtcblx0XHR9XG5cdFx0dGhpcy5fYlNreSA9IG5ldyBhbGZyaWQuQmF0Y2hTa3koKTtcblxuXHRcdHRoaXMuc2t5bWFwID0gQXNzZXRzLmdldCgnc2t5LWRlZmF1bHQnKTtcblxuXHRcdHRoaXMuX3ZNb2RlbCA9IG5ldyBWaWV3T2JqTW9kZWwoKTtcblx0XHR0aGlzLl92Rmxvb3IgPSBuZXcgVmlld0Zsb29yKCk7XG5cdFx0dGhpcy5fdkFubm90YXRpb24gPSBuZXcgVmlld0Fubm90YXRpb24ob3B0aW9ucy5jb250YWluZXIpOyAvLyBIVE1MXG5cdH1cblxuXHRvblNwb3RDbGlja2VkKHNwb3QpIHtcblx0XHR0aGlzLm9sZFJhZGl1cyA9IHRoaXMub3JiaXRhbENvbnRyb2wucmFkaXVzLnZhbHVlO1xuXHRcdHRoaXMuY3VycmVudFNwb3QgPSBzcG90O1xuXHRcdHRoaXMuY2FtZXJhU3BvdHMuaGlkZSgpO1xuXHRcdHRoaXMudG91Y2hDb250cm9sbGVyLnBhdXNlKCdvbk1vdmUnLCBmYWxzZSk7XG5cdFx0T3JiaXRhbENvbnRyb2xUd2Vlbi50d2Vlbih7XG5cdFx0XHRjZW50ZXJYOiBzcG90LmNlbnRlclswXSwgY2VudGVyWTogc3BvdC5jZW50ZXJbMV0sIGNlbnRlclo6IHNwb3QuY2VudGVyWzJdLFxuXHRcdFx0b2Zmc2V0WDogc3BvdC5vZmZzZXRbMF0sIG9mZnNldFk6IHNwb3Qub2Zmc2V0WzFdLCBvZmZzZXRaOiBzcG90Lm9mZnNldFsyXSxcblx0XHRcdGVhc2U6ICdzaW5lLm91dCcsIGR1cmF0aW9uOiAwLjIgXG5cdFx0fSk7XG5cblx0XHRzZXRUaW1lb3V0KCgpPT57XG5cdFx0XHR0aGlzLl92QW5ub3RhdGlvbi5vblNwb3RDbGlja2VkKHNwb3QpO1xuXHRcdH0sIDEwMDApO1xuXHR9XG5cblx0b25Ub3VjaENvbnRyb2xsZXJNb3ZlKGlzRG93bikge1xuXHRcdGlmIChpc0Rvd24gJiYgdGhpcy5jdXJyZW50U3BvdCkge1xuXHRcdFx0dGhpcy5jYW1lcmFTcG90cy5zaG93KCk7XG5cdFx0XHR0aGlzLmN1cnJlbnRTcG90ID0gbnVsbDtcblx0XHRcdHRoaXMuX3ZBbm5vdGF0aW9uLmhpZGUoKTtcblx0XHRcdE9yYml0YWxDb250cm9sVHdlZW4udHdlZW4oe1xuXHRcdFx0XHRvZmZzZXRYOiAwLCBvZmZzZXRZOiAwLCBvZmZzZXRaOiAwLFxuXHRcdFx0XHRjZW50ZXJYOiAwLCBjZW50ZXJZOiAwLCBjZW50ZXJaOiAwLCBlYXNlOiAnc2luZS5vdXQnLCBkdXJhdGlvbjogMC4zIH0pO1xuXG5cdFx0XHR0aGlzLm9yYml0YWxDb250cm9sLnJhZGl1cy52YWx1ZSA9IHRoaXMub2xkUmFkaXVzO1xuXHRcdFx0dGhpcy50b3VjaENvbnRyb2xsZXIucGF1c2UoJ29uTW92ZScsIHRydWUpO1xuXHRcdH0gXG5cdH1cblxuXHR1cGRhdGVCYWxsQ2VudGVyKHBvcykgeyAvLyBlZGl0b3IgZGVidWdcblx0XHR0aGlzLnBvc2l0aW9uQ2VudGVyRGVidWcgPSBwb3M7XG5cdH1cblxuXHR1cGRhdGVCYWxsUG9zKHBvcykgeyAvLyBlZGl0b3IgZGVidWdcblx0XHR0aGlzLnBvc2l0aW9uRGVidWcgPSBwb3M7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0aWYgKHRoaXMuc3RhdGVNYW5hZ2VyKSB0aGlzLnN0YXRlTWFuYWdlci5yZW5kZXIoKTtcblx0XHRcblx0XHRpZiAodGhpcy5jdXJyZW50U3BvdCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHRoaXMuY3VycmVudFNwb3Q7XG5cdFx0XHR0aGlzLm9yYml0YWxDb250cm9sLnJ4Ll90YXJnZXRWYWx1ZSArPSAoZGF0YS5yeCAtIHRoaXMub3JiaXRhbENvbnRyb2wucnguX3RhcmdldFZhbHVlKSAqIDAuMTtcblx0XHRcdHRoaXMub3JiaXRhbENvbnRyb2wucnkuX3RhcmdldFZhbHVlICs9IChkYXRhLnJ5IC0gdGhpcy5vcmJpdGFsQ29udHJvbC5yeS5fdGFyZ2V0VmFsdWUpICogMC4xO1xuXHRcdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5yYWRpdXMuX3RhcmdldFZhbHVlICs9IChkYXRhLnpvb20gLSB0aGlzLm9yYml0YWxDb250cm9sLnJhZGl1cy5fdGFyZ2V0VmFsdWUpICogMC4xO1xuXHRcdH1cblxuXHRcdEdMLmNsZWFyKDAsIDAsIDAsIDApO1xuXHRcdGlmIChDb25maWcuZWRpdG9yLmFjdGl2ZSkge1xuXHRcdFx0dGhpcy5fYkJhbGwuZHJhdyh0aGlzLnBvc2l0aW9uRGVidWcsIFswLjEsIDAuMSwgMC4xXSwgWzEsIDAsIDBdKTtcblx0XHRcdHRoaXMuX2JCYWxsQ2VudGVyLmRyYXcodGhpcy5wb3NpdGlvbkNlbnRlckRlYnVnLCBbMC4wMjUsIDAuMDI1LCAwLjAyNV0sIFswLCAxLCAxXSk7XG5cdFx0XHR0aGlzLl9iQmFsbE9yYkNlbnRlci5kcmF3KHRoaXMub3JiaXRhbENvbnRyb2wuY2VudGVyLCBbMC4wNSwgMC4wNSwgMC4wNV0sIFswLCAwLCAxXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zaGFkb3dNYW5hZ2VyLnJlbmRlcih0aGlzLl92TW9kZWwpO1xuXHRcdEdMLnNldE1hdHJpY2VzKHRoaXMuY2FtZXJhKTsgLy8gc2V0IGJhY2sgdGhlIGNhbWVyYSBiZWNhdXNlIHNoYWRvd3Mgc3dpdGNoIHRvIGFuIG9ydG9ncmFwaGljIG9uZVxuXG5cdFx0dGhpcy5fYlNreS5kcmF3KHRoaXMuc2t5bWFwKTtcblx0XHQvLyB0aGlzLl9iQXhpcy5kcmF3KCk7XG5cdFx0Ly8gdGhpcy5fYkRvdHMuZHJhdygpO1xuXHRcdFxuXHRcdGlmICh0aGlzLmNhbWVyYVNwb3RzKSB0aGlzLmNhbWVyYVNwb3RzLnJlbmRlcigpO1xuXHRcdHRoaXMuX3ZGbG9vci5yZW5kZXIodGhpcy5zaGFkb3dNYW5hZ2VyLnNoYWRvd01hdHJpeCwgdGhpcy5zaGFkb3dNYW5hZ2VyLmZiby5kZXB0aFRleHR1cmUpO1xuXHRcdHRoaXMuX3ZNb2RlbC5yZW5kZXIodGhpcy5zdHVkaW9SYWRpYW5jZSwgdGhpcy5pcnIsIHRoaXMuYW9tYXAsIHRoaXMuY29sb3JtYXAsIHRoaXMucm91Z2huZXNzbWFwLCB0aGlzLmN1cnJlbnRTcG90KTtcblx0XHRcblx0XHRpZiAoQ29uZmlnLmRlYnVnU2hhZG93KSB7XG5cdFx0XHRHTC5kaXNhYmxlKEdMLkRFUFRIX1RFU1QpO1xuXHRcdFx0Y29uc3QgcyA9IDIwMDtcblx0XHRcdEdMLnZpZXdwb3J0KDAsIDAsIHMsIHMpO1xuXHRcdFx0dGhpcy5fYkNvcHkuZHJhdyh0aGlzLnNoYWRvd01hbmFnZXIuZmJvLmdldERlcHRoVGV4dHVyZSgpKTtcblx0XHRcdEdMLmVuYWJsZShHTC5ERVBUSF9URVNUKTtcblx0XHR9XG5cdH1cblxuXHRyZXNpemUodywgaCkge1xuXHRcdHJlc2l6ZSh3LCBoLCB0aGlzLm9wdGlvbnMuY29udGFpbmVyLmNsaWVudFdpZHRoLCB0aGlzLm9wdGlvbnMuY29udGFpbmVyLmNsaWVudEhlaWdodCk7XG5cdFx0dGhpcy5jYW1lcmEuc2V0QXNwZWN0UmF0aW8oR0wuYXNwZWN0UmF0aW8pO1xuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVmlld2VyQXBwOyIsImltcG9ydCAnLi4vLi4vc2Nzcy9nbG9iYWwuc2Nzcyc7XG5pbXBvcnQgJy4uLy4uL3Njc3MvbW9kZWxWaWV3ZXIuc2Nzcyc7XG5cbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuL1NldHRpbmdzJztcbmltcG9ydCBWaWV3ZXJBcHAgZnJvbSAnLi9WaWV3ZXJBcHAnO1xuaW1wb3J0IGFkZENvbnRyb2xzIGZyb20gJy4vZGVidWcvYWRkQ29udHJvbHMnO1xuaW1wb3J0IHsgYWRkRHJvcFN1cHBvcnQgfSBmcm9tICcuLi9kZWJ1Zy9hZGREcm9wU3VwcG9ydCc7XG5pbXBvcnQgYXNzZXRzIGZyb20gJy4vYXNzZXQtbGlzdCc7XG5pbXBvcnQgcHJlbG9hZCBmcm9tICd1dGlscy9wcmVsb2FkJztcblxuaWYgKGRvY3VtZW50LmJvZHkpIHtcblx0X2luaXQoKTtcbn0gZWxzZSB7XG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgX2luaXQpO1xufVxuXG5mdW5jdGlvbiBfaW5pdCgpIHtcblx0cHJlbG9hZCh7IGFzc2V0cyB9KS50aGVuKGluaXQzRCwgbG9nRXJyb3IpO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvcihlKSB7XG5cdGNvbnNvbGUubG9nKCdFcnJvcicsIGUpO1xufVxuXG5mdW5jdGlvbiBpbml0M0QoKSB7XG5cdFxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcblx0XHRTZXR0aW5ncy5pbml0KCk7XG5cdH1cblx0XG5cdC8vIENSRUFURSBTQ0VORVxuXHRjb25zdCBzY2VuZSA9IG5ldyBWaWV3ZXJBcHAoKTtcblx0XG5cdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuXHRcdGNvbnNvbGUubG9nKCdJU19ERVZFTE9QTUVOVCcpO1xuXHRcdGFkZENvbnRyb2xzKHNjZW5lKTtcblx0XHRhZGREcm9wU3VwcG9ydCgoaW1nKSA9PiB7XG4gICAgICBzY2VuZS5za3ltYXAudXBkYXRlVGV4dHVyZShpbWcpO1xuICAgIH0pO1xuXHR9XG59XG4iLCJcbmNvbnN0IGFzc2V0c1RvTG9hZCA9IFtcblx0e1wiaWRcIjpcIm1vZGVsXCIsXCJ1cmxcIjpcImFzc2V0cy9tb2RlbC12aWV3ZXIvb2JqL21vZGVsLm9ialwiLFwidHlwZVwiOlwidGV4dFwifSxcblx0e1wiaWRcIjpcIm1vZGVsRmxleFwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL29iai9tb2RlbEZsZXgub2JqXCIsXCJ0eXBlXCI6XCJ0ZXh0XCJ9LFxuXHR7XCJpZFwiOlwibW9kZWxGbGV4X2V4cGxvZGVcIixcInVybFwiOlwiYXNzZXRzL21vZGVsLXZpZXdlci9vYmovbW9kZWxGbGV4X2V4cGxvZGUub2JqXCIsXCJ0eXBlXCI6XCJ0ZXh0XCJ9LFxuXHR7XCJpZFwiOlwiYW9tYXBcIixcInVybFwiOlwiYXNzZXRzL21vZGVsLXZpZXdlci9pbWcvYW9tYXAuanBnXCIsXCJ0eXBlXCI6XCJqcGdcIn0sXG5cdHtcImlkXCI6XCJicmRmTFVUXCIsXCJ1cmxcIjpcImFzc2V0cy9tb2RlbC12aWV3ZXIvaW1nL2JyZGZMVVQucG5nXCIsXCJ0eXBlXCI6XCJwbmdcIn0sXG5cdHtcImlkXCI6XCJjb2xvcm1hcFwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL2ltZy9jb2xvcm1hcC5qcGdcIixcInR5cGVcIjpcImpwZ1wifSxcblx0e1wiaWRcIjpcImlycl9uZWd4XCIsXCJ1cmxcIjpcImFzc2V0cy9tb2RlbC12aWV3ZXIvaW1nL2lycl9uZWd4LmhkclwiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwiaXJyX25lZ3lcIixcInVybFwiOlwiYXNzZXRzL21vZGVsLXZpZXdlci9pbWcvaXJyX25lZ3kuaGRyXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJpcnJfbmVnelwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL2ltZy9pcnJfbmVnei5oZHJcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcImlycl9wb3N4XCIsXCJ1cmxcIjpcImFzc2V0cy9tb2RlbC12aWV3ZXIvaW1nL2lycl9wb3N4LmhkclwiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwiaXJyX3Bvc3lcIixcInVybFwiOlwiYXNzZXRzL21vZGVsLXZpZXdlci9pbWcvaXJyX3Bvc3kuaGRyXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJpcnJfcG9zelwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL2ltZy9pcnJfcG9zei5oZHJcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcImx1dE1hcFwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL2ltZy9sdXRNYXAucG5nXCIsXCJ0eXBlXCI6XCJwbmdcIn0sXG5cdHtcImlkXCI6XCJub2lzZVwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL2ltZy9ub2lzZS5wbmdcIixcInR5cGVcIjpcInBuZ1wifSxcblx0e1wiaWRcIjpcInJvdWdobmVzc21hcFwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL2ltZy9yb3VnaG5lc3NtYXAuanBnXCIsXCJ0eXBlXCI6XCJqcGdcIn0sXG5cdHtcImlkXCI6XCJza3ktZGVmYXVsdFwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL2ltZy9za3ktZGVmYXVsdC5qcGdcIixcInR5cGVcIjpcImpwZ1wifSxcblx0e1wiaWRcIjpcInN0dWRpb19yYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL2ltZy9zdHVkaW9fcmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJib2R5X2FvbWFwXCIsXCJ1cmxcIjpcImFzc2V0cy9tb2RlbC12aWV3ZXIvaW1nL3RleF9leHBsb2RlL2JvZHlfYW9tYXAuanBnXCIsXCJ0eXBlXCI6XCJqcGdcIn0sXG5cdHtcImlkXCI6XCJib2R5X2NvbG9ybWFwXCIsXCJ1cmxcIjpcImFzc2V0cy9tb2RlbC12aWV3ZXIvaW1nL3RleF9leHBsb2RlL2JvZHlfY29sb3JtYXAuanBnXCIsXCJ0eXBlXCI6XCJqcGdcIn0sXG5cdHtcImlkXCI6XCJib2R5X3JvdWdobmVzc21hcFwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL2ltZy90ZXhfZXhwbG9kZS9ib2R5X3JvdWdobmVzc21hcC5qcGdcIixcInR5cGVcIjpcImpwZ1wifSxcblx0e1wiaWRcIjpcInBlbl9hb21hcFwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL2ltZy90ZXhfZXhwbG9kZS9wZW5fYW9tYXAuanBnXCIsXCJ0eXBlXCI6XCJqcGdcIn0sXG5cdHtcImlkXCI6XCJwZW5fY29sb3JtYXBcIixcInVybFwiOlwiYXNzZXRzL21vZGVsLXZpZXdlci9pbWcvdGV4X2V4cGxvZGUvcGVuX2NvbG9ybWFwLmpwZ1wiLFwidHlwZVwiOlwianBnXCJ9LFxuXHR7XCJpZFwiOlwicGVuX3JvdWdobmVzc21hcFwiLFwidXJsXCI6XCJhc3NldHMvbW9kZWwtdmlld2VyL2ltZy90ZXhfZXhwbG9kZS9wZW5fcm91Z2huZXNzbWFwLmpwZ1wiLFwidHlwZVwiOlwianBnXCJ9XG5dO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFzc2V0c1RvTG9hZDsiLCJleHBvcnQgZGVmYXVsdCBbXSIsImltcG9ydCB7IEdMLCBSYXkgfSBmcm9tICdhbGZyaWQnO1xuaW1wb3J0IHsgZ2V0RGlzdE9wdGltLCBnZXREaXN0T3B0aW0zRCwgaW50ZXJzZWN0aW9uUmF5TWVzaCB9IGZyb20gJ3V0aWxzJztcblxuaW1wb3J0IENvbmZpZyBmcm9tICcuLi9Db25maWcnO1xuaW1wb3J0IFNpZ25hbCBmcm9tICdtaW5pLXNpZ25hbHMnO1xuaW1wb3J0IHsgdmVjMiB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNvbnN0IGdldE1vdXNlID0gZnVuY3Rpb24gKG1FdmVudCwgbVRhcmdldCkge1xuXG5cdGNvbnN0IG8gPSBtVGFyZ2V0IHx8IHt9O1xuXHRpZihtRXZlbnQudG91Y2hlcykge1xuXHRcdG8ueCA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuXHRcdG8ueSA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuXHR9IGVsc2Uge1xuXHRcdG8ueCA9IG1FdmVudC5jbGllbnRYO1xuXHRcdG8ueSA9IG1FdmVudC5jbGllbnRZO1xuXHR9XG5cblx0cmV0dXJuIG87XG59O1xuXG5jb25zdCB0ZW1wTWF0NCA9IG1hdDQuY3JlYXRlKCk7XG5jb25zdCBpZGVudGl0eU1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbmNsYXNzIFBvaW50c0VkaXRvciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmVkaXRvci1wb2ludHMnKTtcbiAgICBcblx0XHR0aGlzLm5iUG9pbnRzID0gMDtcblx0XHR0aGlzLm9uUG9pbnRDbGljayA9IG5ldyBTaWduYWwoKTtcblx0XHR0aGlzLm9uUG9pbnREZWxldGUgPSBuZXcgU2lnbmFsKCk7XG5cblx0XHR0aGlzLm1vdXNlRG93biA9IHt4OiAwLCB5OiAwfTtcblx0XHR0aGlzLm1vdXNlID0ge3g6IDAsIHk6IDB9O1xuXHRcdHRoaXMucmF5ID0gbmV3IFJheShbMCwgMCwgMF0sIFswLCAwLCAtMV0pO1xuXHRcdHRoaXMuY3VycmVudFBvcyA9IG51bGw7XG5cdH1cblxuXHRpbml0KHNjZW5lLCB0YXJnZXRzKSB7XG4gICAgdGhpcy50YXJnZXRzID0gdGFyZ2V0cztcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5jYW1lcmEgPSBzY2VuZS5jYW1lcmE7XG5cblx0XHRpZiAoQ29uZmlnLmVkaXRvci5hY3RpdmUpIHtcblx0XHRcdHRoaXMuYWRkUG9pbnRzVG9ET00oKTtcbiAgICAgIFxuXHRcdFx0dGhpcy5zY2VuZS5jb250YWluZXJIVE1MLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Eb3duLmJpbmQodGhpcykpO1xuXHRcdFx0dGhpcy5zY2VuZS5jb250YWluZXJIVE1MLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3ZlLmJpbmQodGhpcykpO1xuXHRcdFx0dGhpcy5zY2VuZS5jb250YWluZXJIVE1MLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uVXAuYmluZCh0aGlzKSk7XG5cblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG5cdFx0XHRcdGNvbnN0IGtleSA9IGV2ZW50LmtleUNvZGU7XG5cdFx0XHRcdGlmIChrZXkgPCAzNyB8fCBrZXkgPiA0MCkgcmV0dXJuO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc29sZS5sb2coZXZlbnQua2V5Q29kZSk7XG5cdFx0XHRcdGNvbnN0IG9yYiA9IHRoaXMuc2NlbmUub3JiaXRhbENvbnRyb2w7XG5cdFx0XHRcdGNvbnN0IGRpclggPSBvcmIuY2VudGVyWzBdIC0gKG9yYi5wb3NpdGlvblswXSk7Ly8gKyBvcmIucG9zaXRpb25PZmZzZXRbMF0pO1xuXHRcdFx0XHRjb25zdCBkaXJaID0gb3JiLmNlbnRlclsyXSAtIChvcmIucG9zaXRpb25bMl0pOy8vICsgb3JiLnBvc2l0aW9uT2Zmc2V0WzJdKTtcblx0XHRcdFx0bGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXJaLCBkaXJYKTtcblxuXHRcdFx0XHRpZiAoa2V5ID09PSA0MCkgYW5nbGUgKz0gTWF0aC5QSTtcblx0XHRcdFx0ZWxzZSBpZiAoa2V5ID09PSAzOSkgYW5nbGUgKz0gTWF0aC5QSSAvIDI7XG5cdFx0XHRcdGVsc2UgaWYgKGtleSA9PT0gMzcpIGFuZ2xlIC09IE1hdGguUEkgLyAyO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgeCA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0Y29uc3QgeiA9IE1hdGguc2luKGFuZ2xlKTtcblxuXHRcdFx0XHRvcmIucG9zaXRpb25PZmZzZXRbMF0gKz0geCAqIDAuMTtcblx0XHRcdFx0b3JiLnBvc2l0aW9uT2Zmc2V0WzJdICs9IHogKiAwLjE7XG5cdFx0XHRcdG9yYi5jZW50ZXJbMF0gKz0geCAqIDAuMTtcblx0XHRcdFx0b3JiLmNlbnRlclsyXSArPSB6ICogMC4xO1xuXHRcdFx0fSk7XG5cdFx0fVxuICB9XG4gIFxuICBnZW5lcmF0ZVJheShlLCBtb3VzZSkge1xuXHRcdGNvbnN0IG8gPSBnZXRNb3VzZShlLCBtb3VzZSk7XG5cdFx0Y29uc3QgbXggPSAoby54IC8gKCh3aW5kb3cuaW5uZXJXaWR0aCkpKSAqIDIuMCAtIDEuMDtcblx0XHRjb25zdCBteSA9IC0oby55IC8gKHdpbmRvdy5pbm5lckhlaWdodCkpICogMi4wICsgMS4wO1xuXG5cblx0XHR0aGlzLmNhbWVyYS5nZW5lcmF0ZVJheShbbXgsIG15LCAwXSwgdGhpcy5yYXkpO1xuXHR9XG4gIFxuXHRvbkRvd24oZSkge1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR0aGlzLm1vdXNlRG93biA9IGdldE1vdXNlKGUpO1xuXHR9XG5cblx0b25Nb3ZlKGUpIHtcblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRjb25zdCB2aWV3cyA9IHRoaXMudGFyZ2V0cztcbiAgICBcblx0XHRpZiAodmlld3MubGVuZ3RoID09PSAwKSByZXR1cm47XG5cblx0XHR0aGlzLmdlbmVyYXRlUmF5KGUsIHRoaXMubW91c2UpO1xuXG5cdFx0bGV0IGhpdDtcblx0XHRcblx0XHRsZXQgY2xvc2VzdEhpdDtcblx0XHRsZXQgcHJldmlvdXNEaXN0ID0gMTAwMDAwMDAwO1xuXHRcdGxldCBkaXN0O1xuXG5cdFx0Zm9yIChsZXQgayA9IDA7IGsgPCB2aWV3cy5sZW5ndGg7IGsrKykge1xuXHRcdFx0Y29uc3QgdmlldyA9IHZpZXdzW2tdO1xuXHRcdFx0Y29uc3QgbWVzaGVzID0gdmlldy5kZWJ1Z1NoYXBlcztcblxuXG5cdFx0XHRpZiAoIW1lc2hlcykgY29udGludWU7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbWVzaGVzLmxlbmd0aDsgaSsrKSB7XG5cblxuXHRcdFx0XHRjb25zdCBtZXNoID0gbWVzaGVzW2ldO1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdG1hdDQubXVsdGlwbHkodGVtcE1hdDQsIHZpZXcuX21hdHJpeCB8fCBpZGVudGl0eU1hdHJpeCwgbWVzaC5tYXRyaXgpO1xuXG5cblx0XHRcdFx0aGl0ID0gaW50ZXJzZWN0aW9uUmF5TWVzaCh0aGlzLnJheSwgbWVzaC5mYWNlcywgdGVtcE1hdDQsIHRydWUpO1xuXG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaGl0KSB7XG5cdFx0XHRcdFx0ZGlzdCA9IGdldERpc3RPcHRpbTNEKHRoaXMucmF5Lm9yaWdpblswXSwgdGhpcy5yYXkub3JpZ2luWzFdLCB0aGlzLnJheS5vcmlnaW5bMl0sIGhpdFswXSwgaGl0WzFdLCBoaXRbMl0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChkaXN0IDwgcHJldmlvdXNEaXN0KSB7XG5cdFx0XHRcdFx0XHRwcmV2aW91c0Rpc3QgPSBkaXN0O1xuXHRcdFx0XHRcdFx0Y2xvc2VzdEhpdCA9IFsuLi5oaXRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRpZiAoY2xvc2VzdEhpdCkge1xuXHRcdFx0dGhpcy5zY2VuZS51cGRhdGVCYWxsUG9zKGNsb3Nlc3RIaXQpO1xuXHRcdH1cblx0fVxuXG5cdG9uVXAoZSkge1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdGNvbnN0IG8gPSBnZXRNb3VzZShlKTtcblx0XHRjb25zdCBkaXN0ID0gZ2V0RGlzdE9wdGltKG8ueCwgby55LCB0aGlzLm1vdXNlRG93bi54LCB0aGlzLm1vdXNlRG93bi55KTtcblxuXHRcdGlmIChkaXN0IDwgNSkge1xuXHRcdFx0dGhpcy5zY2VuZS51cGRhdGVCYWxsQ2VudGVyKFsuLi50aGlzLnNjZW5lLnBvc2l0aW9uRGVidWddKTtcblx0XHRcdHRoaXMuY3VycmVudFBvcyA9IFsuLi50aGlzLnNjZW5lLnBvc2l0aW9uRGVidWddO1xuICAgICAgLy8gdGhpcy5zY2VuZS5vcmJpdGFsQ29udHJvbC5wb3NpdGlvbk9mZnNldCA9IFswLCAwLCAwXTtcbiAgICAgIHRoaXMuc2NlbmUub3JiaXRhbENvbnRyb2wuY2VudGVyID0gWy4uLnRoaXMuc2NlbmUucG9zaXRpb25EZWJ1Z107XG5cdFx0fVxuXHR9XG5cblx0YWRkUG9pbnRzVG9ET00oKSB7XG5cdFx0Q29uZmlnLmVkaXRvci5wb2ludHMuZm9yRWFjaChwb2ludCA9PiB7XG5cdFx0XHR0aGlzLmFkZFBvaW50KHBvaW50KTtcblx0XHR9KTtcblx0fVxuICBcblx0YWRkUG9pbnQocG9pbnQpIHtcblxuXHRcdHRoaXMubmJQb2ludHMrKztcblx0XHRjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXHRcdHAub25jbGljayA9ICgpID0+IHRoaXMub25Qb2ludENsaWNrLmRpc3BhdGNoKHBvaW50KTtcblx0XHQvLyBwLmlubmVyVGV4dCA9IGByeDogJHtwb2ludC5yeH0sIHJ5OiAke3BvaW50LnJ5fSwgem9vbTogJHtwb2ludC56b29tfWA7XG5cdFx0cC5pbm5lclRleHQgPSBwb2ludC5sYWJlbDtcbiAgICBcblx0XHRjb25zdCBwMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRwMi5jbGFzc05hbWUgPSAnZGVsZXRlJztcblx0XHRwMi5vbmNsaWNrID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQoZGl2KTtcblx0XHRcdHRoaXMub25Qb2ludERlbGV0ZS5kaXNwYXRjaChwb2ludCk7XG5cdFx0fTtcblx0XHRwMi5pbm5lclRleHQgPSAnWCc7XG4gICAgXG5cdFx0ZGl2LmFwcGVuZENoaWxkKHApO1xuXHRcdGRpdi5hcHBlbmRDaGlsZChwMik7XG5cdFx0dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgUG9pbnRzRWRpdG9yKCk7IiwiLy8gYWRkQ29udHJvbHMuanNcblxuaW1wb3J0IENvbmZpZyBmcm9tICcuLi9Db25maWcnO1xuaW1wb3J0IFBvaW50c0VkaXRvciBmcm9tICcuL1BvaW50c0VkaXRvcic7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnO1xuaW1wb3J0IGhleFJnYiBmcm9tICdoZXgtcmdiJztcbmltcG9ydCB7IHNhdmVKc29uIH0gZnJvbSAndXRpbHMnO1xuXG5jb25zdCBkZWJ1Z0NvbG9yID0gKGRlYnVnVGFyZ2V0LCB0YXJnZXQsIGlkLCByZWxvYWQgPSBmYWxzZSwgbmFtZSkgPT4ge1xuXHRkZWJ1Z1RhcmdldC5hZGRDb2xvcih0YXJnZXQsIGlkKS5vbkNoYW5nZSgoKSA9PiB7XG5cdFx0Y2hlY2tDb2xvcih0YXJnZXQsIGlkLCByZWxvYWQpO1xuXHR9KS5uYW1lKG5hbWUgfHwgaWQpO1xufTtcblxuY29uc3QgY2hlY2tDb2xvciA9ICh0YXJnZXQsIGlkLCByZWxvYWQgPSBmYWxzZSkgPT4ge1xuXHRpZiAodGFyZ2V0W2lkXS5pbmRleE9mKCcjJykgPiAtMSkge1xuXHRcdGNvbnN0IG9Db2xvciA9IGhleFJnYih0YXJnZXRbaWRdKTtcblxuXHRcdHRhcmdldFtpZF0gPSBbb0NvbG9yLnJlZCwgb0NvbG9yLmdyZWVuLCBvQ29sb3IuYmx1ZV07XG5cdH1cblx0aWYgKHJlbG9hZCkge1xuXHRcdFNldHRpbmdzLnJlbG9hZCgpO1xuXHR9IGVsc2Uge1xuXHRcdFNldHRpbmdzLnJlZnJlc2goKTtcblx0fVxufTtcblxuXG5jb25zdCBhZGRDb250cm9scyA9IChzY2VuZSkgPT4ge1xuXG5cdGNvbnN0IG9Db250cm9sID0ge1xuXHRcdHNhdmU6KCkgPT4ge1xuXHRcdFx0c2F2ZUpzb24oQ29uZmlnLCAnU2V0dGluZ3MnKTtcblx0XHR9XG5cdH07XG5cblx0c2V0VGltZW91dCgoKT0+IHtcblx0XHQvKipcblx0XHQgKiBFRElUT1Jcblx0XHQgKi9cblx0XHRjb25zdCBlZGl0b3JPID0ge1xuXHRcdFx0cmVzZXRDZW50ZXI6KCkgPT4ge1xuXHRcdFx0XHRzY2VuZS5vcmJpdGFsQ29udHJvbC5jZW50ZXIgPSBbMCwgMCwgMF07XG5cdFx0XHR9LFxuXHRcdFx0c2F2ZVBvaW50czooKSA9PiB7XG5cdFx0XHRcdHNhdmVKc29uKENvbmZpZy5lZGl0b3IucG9pbnRzLCAnU2F2ZSBwb2ludHMnKTtcblx0XHRcdH0sXG5cdFx0XHRhZGRQb2ludDogKCkgPT4ge1xuXG5cdFx0XHRcdGlmIChQb2ludHNFZGl0b3IuY3VycmVudFBvcyA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdFx0XHRcdGNvbnN0IGxhYmVsID0gcHJvbXB0KFwiTGFiZWxcIiwgXCJcIik7XG5cdFxuXHRcdFx0XHRpZiAobGFiZWwgPT09IG51bGwpIHJldHVybjtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSBzY2VuZS5vcmJpdGFsQ29udHJvbC5wb3NpdGlvbk9mZnNldDtcblx0XHRcdFx0Y29uc3QgY2VudGVyID0gUG9pbnRzRWRpdG9yLmN1cnJlbnRQb3M7XG5cdFx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdFx0cng6IHNjZW5lLm9yYml0YWxDb250cm9sLl9yeC52YWx1ZSxcblx0XHRcdFx0XHRyeTogc2NlbmUub3JiaXRhbENvbnRyb2wuX3J5LnZhbHVlLFxuXHRcdFx0XHRcdGNlbnRlcjogc2NlbmUub3JiaXRhbENvbnRyb2wuY2VudGVyLFxuXHRcdFx0XHRcdHRhcmdldDogUG9pbnRzRWRpdG9yLmN1cnJlbnRQb3MsXG5cdFx0XHRcdFx0b2Zmc2V0LFxuXHRcdFx0XHRcdHpvb206IHNjZW5lLm9yYml0YWxDb250cm9sLnJhZGl1cy52YWx1ZSxcblx0XHRcdFx0XHRsYWJlbFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Q29uZmlnLmVkaXRvci5wb2ludHMucHVzaChkYXRhKTtcblx0XHRcdFx0XG5cdFx0XHRcdFBvaW50c0VkaXRvci5hZGRQb2ludChkYXRhKTtcblx0XHRcdFx0U2V0dGluZ3MucmVmcmVzaCgpO1xuXHRcdFx0XHRQb2ludHNFZGl0b3IuY3VycmVudFBvcyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IGZFZGl0b3IgPSBndWkuYWRkRm9sZGVyKCdFZGl0b3InKTtcblx0XHRmRWRpdG9yLmFkZChDb25maWcuZWRpdG9yLCAnYWN0aXZlJykub25DaGFuZ2UoU2V0dGluZ3MucmVsb2FkKTtcblx0XHRcblx0XG5cdFx0Y29uc3QgZkRlYnVnID0gZ3VpLmFkZEZvbGRlcignbWVzaCBlZGl0b3InKTtcblx0XHRmRGVidWcuYWRkKENvbmZpZy5kZWJ1Zy5zaGFwZSwgJ2FjdGl2ZScpLm9uQ2hhbmdlKFNldHRpbmdzLnJlbG9hZCk7XG5cdFx0ZkRlYnVnLmFkZChDb25maWcuZGVidWcuc2hhcGUucm90LCAneCcsIDAsIE1hdGguUEkgKiAyKS5zdGVwKDAuMSkubmFtZSgncm90IHgnKS5vbkNoYW5nZShTZXR0aW5ncy5yZWZyZXNoKTtcblx0XHRmRGVidWcuYWRkKENvbmZpZy5kZWJ1Zy5zaGFwZS5yb3QsICd5JywgMCwgTWF0aC5QSSAqIDIpLnN0ZXAoMC4xKS5uYW1lKCdyb3QgeScpLm9uQ2hhbmdlKFNldHRpbmdzLnJlZnJlc2gpO1xuXHRcdGZEZWJ1Zy5hZGQoQ29uZmlnLmRlYnVnLnNoYXBlLnJvdCwgJ3onLCAwLCBNYXRoLlBJICogMikuc3RlcCgwLjEpLm5hbWUoJ3JvdCB6Jykub25DaGFuZ2UoU2V0dGluZ3MucmVmcmVzaCk7XG5cblx0XHRmRGVidWcuYWRkKENvbmZpZy5kZWJ1Zy5zaGFwZS5zY2FsZSwgJ3gnLCAwLCAyKS5zdGVwKDAuMDAxKS5uYW1lKCdzY2FsZSB4Jykub25DaGFuZ2UoU2V0dGluZ3MucmVmcmVzaCk7XG5cdFx0ZkRlYnVnLmFkZChDb25maWcuZGVidWcuc2hhcGUuc2NhbGUsICd5JywgMCwgMikuc3RlcCgwLjAwMSkubmFtZSgnc2NhbGUgeScpLm9uQ2hhbmdlKFNldHRpbmdzLnJlZnJlc2gpO1xuXHRcdGZEZWJ1Zy5hZGQoQ29uZmlnLmRlYnVnLnNoYXBlLnNjYWxlLCAneicsIDAsIDIpLnN0ZXAoMC4wMDEpLm5hbWUoJ3NjYWxlIHonKS5vbkNoYW5nZShTZXR0aW5ncy5yZWZyZXNoKTtcblxuXHRcdGZEZWJ1Zy5hZGQoQ29uZmlnLmRlYnVnLnNoYXBlLnBvcywgJ3gnLCAtMSwgMSkuc3RlcCgwLjAxKS5uYW1lKCdwb3MgeCcpLm9uQ2hhbmdlKFNldHRpbmdzLnJlZnJlc2gpO1xuXHRcdGZEZWJ1Zy5hZGQoQ29uZmlnLmRlYnVnLnNoYXBlLnBvcywgJ3knLCAtMi41LCAyLjUpLnN0ZXAoMC4wMSkubmFtZSgncG9zIHknKS5vbkNoYW5nZShTZXR0aW5ncy5yZWZyZXNoKTtcblx0XHRmRGVidWcuYWRkKENvbmZpZy5kZWJ1Zy5zaGFwZS5wb3MsICd6JywgLTEsIDEpLnN0ZXAoMC4wMSkubmFtZSgncG9zIHonKS5vbkNoYW5nZShTZXR0aW5ncy5yZWZyZXNoKTtcblxuXHRcdGNvbnN0IG8gPSB7IHRvZ2dsZU9yYml0YWw6ICgpID0+IHNjZW5lLm9yYml0YWxDb250cm9sLmxvY2soIXNjZW5lLm9yYml0YWxDb250cm9sLl9pc0xvY2tab29tKX1cblx0XHRmRGVidWcuYWRkKG8sICd0b2dnbGVPcmJpdGFsJyk7XG5cblx0XHRpZiAoQ29uZmlnLmVkaXRvci5hY3RpdmUpIHtcblx0XHRcdFxuXHRcdFx0UG9pbnRzRWRpdG9yLmluaXQoc2NlbmUsIFtzY2VuZS5fdk1vZGVsXSk7XG5cdFx0XHRmRWRpdG9yLmFkZChlZGl0b3JPLCAnYWRkUG9pbnQnKS5uYW1lKCdhZGQgcG9pbnQnKTtcblx0XHRcdGZFZGl0b3IuYWRkKGVkaXRvck8sICdyZXNldENlbnRlcicpLm5hbWUoJ1Jlc2V0IHRhcmdldCcpO1xuXHRcdFx0ZkVkaXRvci5hZGQoZWRpdG9yTywgJ3NhdmVQb2ludHMnKS5uYW1lKCdzYXZlJyk7XG5cdFx0XHRcblx0XHRcdFBvaW50c0VkaXRvci5vblBvaW50RGVsZXRlLmFkZCgocHQpID0+IHtcblx0XHRcdFx0Y29uc3QgaW5kZXhQdCA9IENvbmZpZy5lZGl0b3IucG9pbnRzLmluZGV4T2YocHQpO1xuXHRcdFx0XHRcdENvbmZpZy5lZGl0b3IucG9pbnRzLnNwbGljZShpbmRleFB0LCAxKTtcblx0XHRcdFx0XHRTZXR0aW5ncy5yZWZyZXNoKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0UG9pbnRzRWRpdG9yLm9uUG9pbnRDbGljay5hZGQoKHB0KSA9PiB7XG5cdFx0XHRcdHNjZW5lLm9yYml0YWxDb250cm9sLnJ4LnNldFRvKHB0LnJ4KTtcblx0XHRcdFx0c2NlbmUub3JiaXRhbENvbnRyb2wucnkuc2V0VG8ocHQucnkpO1xuXHRcdFx0XHRzY2VuZS5vcmJpdGFsQ29udHJvbC5yYWRpdXMuc2V0VG8ocHQuem9vbSk7XG5cdFx0XHRcdHNjZW5lLm9yYml0YWxDb250cm9sLmNlbnRlciA9IHB0LmNlbnRlcjtcblx0XHRcdH0pO1xuXG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogU0hBRE9XU1xuXHRcdCAqL1xuXG5cdFx0Y29uc3Qgb0NhbWVyYUxpZ2h0UG9zaXRpb24gPSB7XG5cdFx0XHR4OiBDb25maWcuY2FtZXJhTGlnaHRQb3NpdGlvblswXSxcblx0XHRcdHk6IENvbmZpZy5jYW1lcmFMaWdodFBvc2l0aW9uWzFdLFxuXHRcdFx0ejogQ29uZmlnLmNhbWVyYUxpZ2h0UG9zaXRpb25bMl0sXG5cdFx0fTtcblxuXHRcdGNvbnN0IGZDYW1MaWdodCA9IGd1aS5hZGRGb2xkZXIoJ0NhbWVyYSBMaWdodCcpO1xuXHRcdGZDYW1MaWdodC5hZGQoQ29uZmlnLCAnZGVidWdTaGFkb3cnKS5vbkNoYW5nZShTZXR0aW5ncy5yZWZyZXNoKTtcblx0XHRmQ2FtTGlnaHQuYWRkKENvbmZpZy5jYW1lcmFPcnRobywgJ3NpemUnLCAwLjEsIDEwKS5vbkNoYW5nZSgoKSA9PiB7XG5cdFx0XHRzY2VuZS5zaGFkb3dNYW5hZ2VyLnNldFNpemUoQ29uZmlnLmNhbWVyYU9ydGhvLnNpemUpO1xuXHRcdFx0U2V0dGluZ3MucmVmcmVzaCgpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdGRlYnVnQ29sb3IoZkNhbUxpZ2h0LCBDb25maWcuc2hhZG93LCAnY29sb3InLCBmYWxzZSwgJ3NoYWRvdyBjb2xvcicpO1xuXG5cdFx0ZkNhbUxpZ2h0LmFkZChDb25maWcuY2FtZXJhT3J0aG8sICduZWFyJywgMSwgMTApLnN0ZXAoMC4xKS5vbkNoYW5nZSgoKSA9PiB7XG5cdFx0XHRzY2VuZS5zaGFkb3dNYW5hZ2VyLnJlY2FsY3VsYXRlU2hhZG93KCk7XG5cdFx0XHRTZXR0aW5ncy5yZWZyZXNoKCk7XG5cdFx0fSk7XG5cdFxuXHRcdGZDYW1MaWdodC5hZGQoQ29uZmlnLmNhbWVyYU9ydGhvLCAnZmFyJywgMiwgMTApLnN0ZXAoMC4xKS5vbkNoYW5nZSgoKSA9PiB7XG5cdFx0XHRzY2VuZS5zaGFkb3dNYW5hZ2VyLnJlY2FsY3VsYXRlU2hhZG93KCk7XG5cdFx0XHRTZXR0aW5ncy5yZWZyZXNoKCk7XG5cdFx0fSk7XG5cblx0XHRjb25zdCByYW5nZSA9IDI7XG5cblx0XHRmQ2FtTGlnaHQuYWRkKG9DYW1lcmFMaWdodFBvc2l0aW9uLCAneCcsIC1yYW5nZSwgcmFuZ2UpLm9uQ2hhbmdlKCgpID0+IHtcblx0XHRcdENvbmZpZy5jYW1lcmFMaWdodFBvc2l0aW9uWzBdID0gb0NhbWVyYUxpZ2h0UG9zaXRpb24ueDtcblx0XHRcdHNjZW5lLnNoYWRvd01hbmFnZXIudXBkYXRlTGlnaHRDYW1lcmEoKTtcblx0XHRcdFNldHRpbmdzLnJlZnJlc2goKTtcblx0XHR9KTtcblx0XG5cdFx0ZkNhbUxpZ2h0LmFkZChvQ2FtZXJhTGlnaHRQb3NpdGlvbiwgJ3knLCAwLCAxMCkub25DaGFuZ2UoKCkgPT4ge1xuXHRcdFx0Q29uZmlnLmNhbWVyYUxpZ2h0UG9zaXRpb25bMV0gPSBvQ2FtZXJhTGlnaHRQb3NpdGlvbi55O1xuXHRcdFx0c2NlbmUuc2hhZG93TWFuYWdlci51cGRhdGVMaWdodENhbWVyYSgpO1xuXHRcdFx0U2V0dGluZ3MucmVmcmVzaCgpO1xuXHRcdH0pO1xuXHRcblx0XHRmQ2FtTGlnaHQuYWRkKG9DYW1lcmFMaWdodFBvc2l0aW9uLCAneicsIC1yYW5nZSwgcmFuZ2UpLm9uQ2hhbmdlKCgpID0+IHtcblx0XHRcdENvbmZpZy5jYW1lcmFMaWdodFBvc2l0aW9uWzJdID0gb0NhbWVyYUxpZ2h0UG9zaXRpb24uejtcblx0XHRcdHNjZW5lLnNoYWRvd01hbmFnZXIudXBkYXRlTGlnaHRDYW1lcmEoKTtcblx0XHRcdFNldHRpbmdzLnJlZnJlc2goKTtcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIE9USEVSXG5cdFx0ICovXG5cdFx0Y29uc3QgZlVJTyA9IHtcblx0XHRcdGhvbWU6ICgpID0+IHsgc2NlbmUuaG9tZSgpIH0sXG5cdFx0XHRhbm5vdGF0ZTogKCkgPT4geyBcblx0XHRcdFx0c2NlbmUuYW5ub3RhdGUoKSBcblx0XHRcdH1cblx0XHR9O1xuXHRcdGd1aS5hZGQoZlVJTywgJ2hvbWUnKS5uYW1lKCdHbzogaG9tZScpO1xuXHRcdGd1aS5hZGQoZlVJTywgJ2Fubm90YXRlJykubmFtZSgnVG9nZ2xlOiBhbm5vdGF0ZScpO1xuXG5cblx0XHRndWkuYWRkKENvbmZpZy5hbm5vdGF0aW9ucywgJ3NjYWxlJywgMC4xLCAyKS5zdGVwKDAuMSkubmFtZSgnTWFya2VyIHNjYWxlJyk7XG5cdFx0Z3VpLmFkZChDb25maWcuYW5ub3RhdGlvbnMsICdhbHBoYScsIDAsIDEpLnN0ZXAoMC4wMSkubmFtZSgnTWFya2VyIGFscGhhJyk7XG5cdFx0ZGVidWdDb2xvcihndWksIENvbmZpZy5hbm5vdGF0aW9ucywgJ2NvbG9yJywgZmFsc2UsICdNYXJrZXIgY29sb3InKTtcblx0XHRndWkuYWRkKENvbmZpZy5ob21lLCAnY2FtZXJhTW92ZW1lbnQnKS5uYW1lKCd0b2dnbGUgaG9tZS1tb3Rpb24nKTtcblxuXHRcdGNvbnN0IGZNb2RlbCA9IGd1aS5hZGRGb2xkZXIoJ21vZGVsJyk7XG5cdFx0Zk1vZGVsLmFkZChDb25maWcsICdtZXRhbGxpYycsIDAsIDEpLnN0ZXAoMC4wMSk7XG5cdCBcblx0XHRndWkuYWRkKG9Db250cm9sLCAnc2F2ZScpLm5hbWUoJ1NhdmUgU2V0dGluZ3MnKTtcblx0XHRndWkuYWRkKFNldHRpbmdzLCAncmVzZXQnKS5uYW1lKCdSZXNldCBEZWZhdWx0Jyk7XG5cblx0fSwgMjAwKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgYWRkQ29udHJvbHM7IiwiY29uc3QgYWRkVUkgPSAoc2NlbmUsIGNvbnRhaW5lcikgPT4ge1xuICBjb25zdCBuYXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCduYXYnKTtcbiAgbmF2LmNsYXNzTmFtZSA9ICduYXYnO1xuXG4gIGNvbnN0IHAxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICBwMS5pbm5lclRleHQgPSAnSE9NRSc7XG4gIHAxLm9uY2xpY2sgPSAoKSA9PiB7IHNjZW5lLmhvbWUoKSB9O1xuICBuYXYuYXBwZW5kQ2hpbGQocDEpO1xuXG4gIGNvbnN0IHAyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICBwMi5pbm5lclRleHQgPSAnQU5OT1RBVEUnO1xuICBwMi5vbmNsaWNrID0gKCk9Pnsgc2NlbmUuYW5ub3RhdGUoKSB9O1xuICBuYXYuYXBwZW5kQ2hpbGQocDIpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQobmF2KTtcbn1cblxuZXhwb3J0IHsgYWRkVUkgfTsiLCJpbXBvcnQgeyBHTCwgR2VvbSB9IGZyb20gJ2FsZnJpZCc7XG5cbmltcG9ydCB7IGdldEdlb21ldHJ5RmFjZXMgfSBmcm9tICd1dGlscyc7XG5pbXBvcnQgeyBtYXQ0IH0gZnJvbSAnZ2wtbWF0cml4JztcblxuZXhwb3J0IGNvbnN0IGdldEN1YmUgPSAod2lkdGgsIGhlaWdodCwgZGVwdGgsIHBvcywgcm90KSA9PiB7XG4gIFxuXHRjb25zdCBtID0gbWF0NC5jcmVhdGUoKTtcblx0aWYgKHJvdCkgbWF0NC5yb3RhdGUobSwgbSwgcm90KTtcblx0aWYgKHBvcykgbWF0NC50cmFuc2xhdGUobSwgbSwgcG9zKTtcblx0aWYgKHBvcykgbWF0NC5zY2FsZShtLCBtLCBbd2lkdGgsIGhlaWdodCwgZGVwdGhdKTtcbiAgXG4gIGNvbnN0IGN1YmUgPSBHZW9tLmN1YmUoMSwgMSwgMSk7XG5cdHJldHVybiB7XG4gICAgbWVzaDogY3ViZSxcbiAgICBmYWNlczogZ2V0R2VvbWV0cnlGYWNlcyhjdWJlKSxcbiAgICBtYXRyaXg6IG1cblx0fVxufSIsImltcG9ydCBhbGZyaWQsIHsgR0wgfSBmcm9tICdhbGZyaWQnO1xuXG5sZXQgZ2w7IGxldCBwaXZvdFg7IGxldCBwaXZvdFk7IGxldCBcblx0YXhpcztcblxuY29uc3QgdGVtcEFycmF5MSA9IFtdO1xuY29uc3QgdGVtcEFycmF5MiA9IFtdO1xuXG5jbGFzcyBMaW5lIGV4dGVuZHMgYWxmcmlkLk1lc2gge1xuXHRjb25zdHJ1Y3Rvcih2ZXJ0aWNlcywgYywgZHJhd01vZGUgPSBHTC5UUklBTkdMRVMpIHtcblx0XHRnbCA9IEdMO1xuXHRcdHN1cGVyKGRyYXdNb2RlKTtcblx0XHR0aGlzLndpZHRoQ2FsbGJhY2sgPSBjO1xuXG5cdFx0Y29uc3QgdmVydCA9IFtcblx0XHRcdFswLCAwLCAwXSxcblx0XHRcdFsxMDAgLyA4MDAsIDI1MCAvIDgwMCwgMF0sXG5cdFx0XHRbNTAgLyA4MDAsIDIwMCAvIDgwMCwgMF0sXG5cdFx0XHRbMCwgMjAwIC8gODAwLCAwXSxcblx0XHRcdFstMTAwIC8gODAwLCAyMjAgLyA4MDAsIDBdLFxuXHRcdFx0Wy03MCAvIDgwMCwgMzAwIC8gODAwLCAwXVxuXHRcdF07XG5cblx0XHR0aGlzLnBvc2l0aW9ucyA9IFtdO1xuXHRcdHRoaXMuZGlyZWN0aW9ucyA9IFtdO1xuXHRcdHRoaXMuaW5kaWNlc0FycmF5ID0gW107XG5cdFx0dGhpcy5jb3VudGVycyA9IFtdO1xuXHRcdHRoaXMud2lkdGggPSBbXTtcblx0XHR0aGlzLnV2cyA9IFtdO1xuXHRcdHRoaXMucHJldmlvdXMgPSBbXTtcblx0XHR0aGlzLm5leHQgPSBbXTtcblxuXHRcdHRoaXMudmVydCA9IHZlcnRpY2VzIHx8IHZlcnQ7XG5cblx0XHR0aGlzLmxpbmUodHJ1ZSk7XG5cdH1cblxuXHRsaW5lKG5lZWRzVXBkYXRlID0gdHJ1ZSkge1xuXHRcdGNvbnN0IHYgPSB0aGlzLnZlcnQ7XG5cblx0XHR0aGlzLnBvc2l0aW9ucy5sZW5ndGggPSB2Lmxlbmd0aCAqIDI7XG5cdFx0dGhpcy5jb3VudGVycy5sZW5ndGggPSB2Lmxlbmd0aCAqIDI7XG5cblx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdGxldCBpbmRleEMgPSAwO1xuXG5cdFx0dGhpcy5wcmV2aW91cy5sZW5ndGggPSB0aGlzLnBvc2l0aW9ucy5sZW5ndGg7XG5cdFx0dGhpcy5uZXh0Lmxlbmd0aCA9IHRoaXMucG9zaXRpb25zLmxlbmd0aDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKG5lZWRzVXBkYXRlKSB7XG5cdFx0XHRcdGNvbnN0IGMgPSBpIC8gdi5sZW5ndGg7XG5cdFx0XHRcdHRoaXMuY291bnRlcnNbaW5kZXhDKytdID0gW2NdO1xuXHRcdFx0XHR0aGlzLmNvdW50ZXJzW2luZGV4QysrXSA9IFtjXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY29uc29sZS5sb2codGhpcy5wb3NpdGlvbnMubGVuZ3RoKTtcblx0XHRcdHRoaXMucG9zaXRpb25zW2luZGV4KytdID0gdltpXVswXTtcblx0XHRcdHRoaXMucG9zaXRpb25zW2luZGV4KytdID0gdltpXVsxXTtcblx0XHRcdHRoaXMucG9zaXRpb25zW2luZGV4KytdID0gdltpXVsyXTtcblxuXHRcdFx0dGhpcy5wb3NpdGlvbnNbaW5kZXgrK10gPSB2W2ldWzBdO1xuXHRcdFx0dGhpcy5wb3NpdGlvbnNbaW5kZXgrK10gPSB2W2ldWzFdO1xuXHRcdFx0dGhpcy5wb3NpdGlvbnNbaW5kZXgrK10gPSB2W2ldWzJdO1xuXHRcdH1cblxuXHRcdHRoaXMucHJvY2VzcyhuZWVkc1VwZGF0ZSk7XG5cdH1cblxuXHRwcm9jZXNzKG5lZWRzVXBkYXRlKSB7XG5cdFx0Y29uc3QgY29tcGFyZVYzID0gKGEsIGIpID0+IHtcblx0XHRcdGNvbnN0IGFhID0gYSAqIDY7XG5cdFx0XHRjb25zdCBhYiA9IGIgKiA2O1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHR0aGlzLnBvc2l0aW9uc1thYV0gPT09IHRoaXMucG9zaXRpb25zW2FiXSAmJlxuICAgICAgICB0aGlzLnBvc2l0aW9uc1thYSArIDFdID09PSB0aGlzLnBvc2l0aW9uc1thYiArIDFdICYmXG4gICAgICAgIHRoaXMucG9zaXRpb25zW2FhICsgMl0gPT09IHRoaXMucG9zaXRpb25zW2FiICsgMl1cblx0XHRcdCk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IGNvcHlWMyA9IChhLCBvdXQpID0+IHtcblx0XHRcdGlmICghb3V0KSBvdXQgPSB0ZW1wQXJyYXkxO1xuXG5cdFx0XHRjb25zdCBhYSA9IGEgKiA2O1xuXG5cdFx0XHRvdXRbMF0gPSB0aGlzLnBvc2l0aW9uc1thYV07XG5cdFx0XHRvdXRbMV0gPSB0aGlzLnBvc2l0aW9uc1thYSArIDFdO1xuXHRcdFx0b3V0WzJdID0gdGhpcy5wb3NpdGlvbnNbYWEgKyAyXTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgbCA9IHRoaXMucG9zaXRpb25zLmxlbmd0aCAvIDY7XG5cblx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdGxldCBpbmRleE4gPSAwO1xuXG5cdFx0aWYgKGNvbXBhcmVWMygwLCBsIC0gMSkpIHtcblx0XHRcdGNvcHlWMyhsIC0gMik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvcHlWMygwKTtcblx0XHR9XG5cblx0XHR0aGlzLnByZXZpb3VzW2luZGV4KytdID0gdGVtcEFycmF5MVswXTtcblx0XHR0aGlzLnByZXZpb3VzW2luZGV4KytdID0gdGVtcEFycmF5MVsxXTtcblx0XHR0aGlzLnByZXZpb3VzW2luZGV4KytdID0gdGVtcEFycmF5MVsyXTtcblxuXHRcdHRoaXMucHJldmlvdXNbaW5kZXgrK10gPSB0ZW1wQXJyYXkxWzBdO1xuXHRcdHRoaXMucHJldmlvdXNbaW5kZXgrK10gPSB0ZW1wQXJyYXkxWzFdO1xuXHRcdHRoaXMucHJldmlvdXNbaW5kZXgrK10gPSB0ZW1wQXJyYXkxWzJdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdC8vIGNhbHVjbGF0ZSBwb3MgYW5kIG5leHRcblx0XHRcdGNvcHlWMyhpLCB0ZW1wQXJyYXkxKTtcblxuXHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdC8vIHdlIGNhbiBmaWxsIHRoZSBuZXh0c1xuXHRcdFx0XHR0aGlzLm5leHRbaW5kZXhOKytdID0gdGVtcEFycmF5MVswXTtcblx0XHRcdFx0dGhpcy5uZXh0W2luZGV4TisrXSA9IHRlbXBBcnJheTFbMV07XG5cdFx0XHRcdHRoaXMubmV4dFtpbmRleE4rK10gPSB0ZW1wQXJyYXkxWzJdO1xuXG5cdFx0XHRcdHRoaXMubmV4dFtpbmRleE4rK10gPSB0ZW1wQXJyYXkxWzBdO1xuXHRcdFx0XHR0aGlzLm5leHRbaW5kZXhOKytdID0gdGVtcEFycmF5MVsxXTtcblx0XHRcdFx0dGhpcy5uZXh0W2luZGV4TisrXSA9IHRlbXBBcnJheTFbMl07XG5cblx0XHRcdFx0dGhpcy5wcmV2aW91c1tpbmRleCsrXSA9IHRlbXBBcnJheTJbMF07XG5cdFx0XHRcdHRoaXMucHJldmlvdXNbaW5kZXgrK10gPSB0ZW1wQXJyYXkyWzFdO1xuXHRcdFx0XHR0aGlzLnByZXZpb3VzW2luZGV4KytdID0gdGVtcEFycmF5MlsyXTtcblxuXHRcdFx0XHR0aGlzLnByZXZpb3VzW2luZGV4KytdID0gdGVtcEFycmF5MlswXTtcblx0XHRcdFx0dGhpcy5wcmV2aW91c1tpbmRleCsrXSA9IHRlbXBBcnJheTJbMV07XG5cdFx0XHRcdHRoaXMucHJldmlvdXNbaW5kZXgrK10gPSB0ZW1wQXJyYXkyWzJdO1xuXHRcdFx0fVxuXG5cdFx0XHR0ZW1wQXJyYXkyWzBdID0gdGVtcEFycmF5MVswXTtcblx0XHRcdHRlbXBBcnJheTJbMV0gPSB0ZW1wQXJyYXkxWzFdO1xuXHRcdFx0dGVtcEFycmF5MlsyXSA9IHRlbXBBcnJheTFbMl07XG5cdFx0fVxuXG5cdFx0aWYgKGNvbXBhcmVWMyhsIC0gMSwgMCkpIHtcblx0XHRcdGNvcHlWMygxLCB0ZW1wQXJyYXkxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29weVYzKGwgLSAxLCB0ZW1wQXJyYXkxKTtcblx0XHR9XG5cblx0XHR0aGlzLm5leHRbaW5kZXhOKytdID0gdGVtcEFycmF5MVswXTtcblx0XHR0aGlzLm5leHRbaW5kZXhOKytdID0gdGVtcEFycmF5MVsxXTtcblx0XHR0aGlzLm5leHRbaW5kZXhOKytdID0gdGVtcEFycmF5MVsyXTtcblxuXHRcdHRoaXMubmV4dFtpbmRleE4rK10gPSB0ZW1wQXJyYXkxWzBdO1xuXHRcdHRoaXMubmV4dFtpbmRleE4rK10gPSB0ZW1wQXJyYXkxWzFdO1xuXHRcdHRoaXMubmV4dFtpbmRleE4rK10gPSB0ZW1wQXJyYXkxWzJdO1xuXG5cdFx0aW5kZXggPSAwO1xuXG5cdFx0dGhpcy5idWZmZXJGbGF0dGVuRGF0YSh0aGlzLnBvc2l0aW9ucywgJ2FWZXJ0ZXhQb3NpdGlvbicsIDMpO1xuXHRcdHRoaXMuYnVmZmVyRmxhdHRlbkRhdGEodGhpcy5uZXh0LCAnYU5leHQnLCAzKTtcblx0XHR0aGlzLmJ1ZmZlckZsYXR0ZW5EYXRhKHRoaXMucHJldmlvdXMsICdhUHJldmlvdXMnLCAzKTtcblxuXHRcdGlmIChuZWVkc1VwZGF0ZSkge1xuXHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0dGhpcy51dnMgPSBbXTtcblx0XHRcdGxldCB3O1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0aWYgKHRoaXMud2lkdGhDYWxsYmFjaykge1xuXHRcdFx0XHRcdHcgPSB0aGlzLndpZHRoQ2FsbGJhY2soaiAvIChsIC0gMSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHcgPSAwLjE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLndpZHRoW2luZGV4KytdID0gdztcblx0XHRcdFx0dGhpcy53aWR0aFtpbmRleCsrXSA9IHc7XG5cdFx0XHRcdHRoaXMudXZzLnB1c2goW2ogLyAobCAtIDEpLCAwXSk7XG5cdFx0XHRcdHRoaXMudXZzLnB1c2goW2ogLyAobCAtIDEpLCAxXSk7XG5cdFx0XHR9XG5cblx0XHRcdGluZGV4ID0gMDtcblx0XHRcdHRoaXMuaW5kaWNlc0FycmF5ID0gW107XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGwgLSAxOyBqKyspIHtcblx0XHRcdFx0Y29uc3QgbiA9IGogKiAyO1xuXG5cdFx0XHRcdHRoaXMuaW5kaWNlc0FycmF5W2luZGV4KytdID0gbjtcblx0XHRcdFx0dGhpcy5pbmRpY2VzQXJyYXlbaW5kZXgrK10gPSBuICsgMTtcblx0XHRcdFx0dGhpcy5pbmRpY2VzQXJyYXlbaW5kZXgrK10gPSBuICsgMjtcblxuXHRcdFx0XHR0aGlzLmluZGljZXNBcnJheVtpbmRleCsrXSA9IG4gKyAyO1xuXHRcdFx0XHR0aGlzLmluZGljZXNBcnJheVtpbmRleCsrXSA9IG4gKyAxO1xuXHRcdFx0XHR0aGlzLmluZGljZXNBcnJheVtpbmRleCsrXSA9IG4gKyAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpbmRleCA9IDA7XG5cdFx0XHR0aGlzLmRpcmVjdGlvbnMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSsrKSB7XG5cdFx0XHRcdGlmIChpICUgMiA9PT0gMCkge1xuXHRcdFx0XHRcdHRoaXMuZGlyZWN0aW9uc1tpbmRleCsrXSA9IFsxXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmRpcmVjdGlvbnNbaW5kZXgrK10gPSBbLTFdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYnVmZmVySW5kZXgodGhpcy5pbmRpY2VzQXJyYXkpO1xuXHRcdFx0dGhpcy5idWZmZXJGbGF0dGVuRGF0YSh0aGlzLmRpcmVjdGlvbnMsICdhRGlyZWN0aW9uJywgMSk7XG5cblx0XHRcdHRoaXMuYnVmZmVyVGV4Q29vcmQodGhpcy51dnMpO1xuXHRcdFx0dGhpcy5idWZmZXJGbGF0dGVuRGF0YSh0aGlzLmNvdW50ZXJzLCAnYUNvdW50ZXJzJywgMSk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKHBvaW50cywgbmVlZHNVcGRhdGUgPSBmYWxzZSkge1xuXHRcdHRoaXMudmVydCA9IHBvaW50cyB8fCB0aGlzLnZlcnQ7XG5cblx0XHR0aGlzLmxpbmUobmVlZHNVcGRhdGUpO1xuXHR9XG59XG5cbmV4cG9ydCB7IExpbmUgfTtcbiIsImltcG9ydCB7IE9yYml0YWxDb250cm9sVHdlZW4gfSBmcm9tICdoZWxwZXJzJztcbmltcG9ydCB7IFN0YXRlRGVmYXVsdCB9IGZyb20gJy4vU3RhdGVEZWZhdWx0JztcblxuZXhwb3J0IGNsYXNzIFN0YXRlQW5ub3RhdGUgZXh0ZW5kcyBTdGF0ZURlZmF1bHQge1xuXHRiZWdpbihkYXRhID0ge30pIHtcblx0XHQvLyBpZiAoZGF0YS5wcmV2aW91c1N0YXRlICE9PSAnaG9tZScpIHtcblx0XHRPcmJpdGFsQ29udHJvbFR3ZWVuLnR3ZWVuKHtcblx0XHRcdGR1cmF0aW9uOiAxLFxuXHRcdFx0cng6IDAuNTE1LFxuXHRcdFx0cnk6IDAuODI4LFxuXHRcdFx0cmFkaXVzOiAzLjk0LFxuXHRcdFx0ZWFzZTogJ2NpcmMuaW5vdXQnXG5cdFx0fSk7XG5cdFx0Ly8gfVxuXHRcdHRoaXMuc2NlbmUuY2FtZXJhU3BvdHMuc3RhcnQoKTtcblx0XHR0aGlzLnNjZW5lLmNhbWVyYVNwb3RzLnNob3coKTtcblx0fVxuXHRcblx0ZW5kKCkge1xuXHRcdHRoaXMuc2NlbmUuY2FtZXJhU3BvdHMuc3RvcCgpO1xuXHR9XG59XG4iLCJleHBvcnQgY2xhc3MgU3RhdGVEZWZhdWx0IHtcblx0Y29uc3RydWN0b3Ioc2NlbmUpIHtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdH1cblxuXHRiZWdpbigpIHt9XG5cdHVwZGF0ZSgpIHt9XG5cdGVuZCgpIHt9XG59XG4iLCJpbXBvcnQgQ29uZmlnIGZyb20gJy4uL0NvbmZpZyc7XG5pbXBvcnQgeyBTdGF0ZURlZmF1bHQgfSBmcm9tICcuL1N0YXRlRGVmYXVsdCc7XG5pbXBvcnQgeyBTY2hlZHVsZXIsIEdMIH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCB7IGdldE1vdXNlLCBnZXREaXN0T3B0aW0gfSBmcm9tICd1dGlscyc7XG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwJztcbmltcG9ydCB7IE9yYml0YWxDb250cm9sVHdlZW4gfSBmcm9tICdoZWxwZXJzJztcblxuZXhwb3J0IGNsYXNzIFN0YXRlSG9tZSBleHRlbmRzIFN0YXRlRGVmYXVsdCB7XG5cdGNvbnN0cnVjdG9yKHNjZW5lKSB7XG5cdFx0c3VwZXIoc2NlbmUpO1xuXG5cdFx0dGhpcy5fb25Eb3duID0gdGhpcy5vbkRvd24uYmluZCh0aGlzKTtcblx0XHR0aGlzLl9vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuX29uVXAgPSB0aGlzLm9uVXAuYmluZCh0aGlzKTtcblx0fVxuXG5cdGJlZ2luKGRhdGEgPSB7fSkge1xuXHRcdHRoaXMuZG93biA9IGZhbHNlO1xuXHRcdHRoaXMudGljayA9IDA7XG5cdFx0dGhpcy5tb2RlbCA9IHRoaXMuc2NlbmUuX3ZNb2RlbDtcblx0XHR0aGlzLm9yYiA9IHRoaXMuc2NlbmUub3JiaXRhbENvbnRyb2w7XG5cdFx0dGhpcy5yZWFkeSA9IGZhbHNlO1xuXHRcdHRoaXMucG9zID0ge3g6IDAsIHk6IDB9XG5cdFx0XG5cdFx0dGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcblx0XHRpZiAoZGF0YS5zbmFwKSB7XG5cdFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0dGhpcy5tb2RlbC5yb3RhdGlvblggPSAtTWF0aC5QSSAvIDQ7XG5cdFx0XHR0aGlzLm1vZGVsLnJvdGF0aW9uWSA9IC1NYXRoLlBJIC8gODtcblx0XHRcdHRoaXMubW9kZWwueSA9IDE7XG5cblx0XHRcdFxuXHRcdFx0dGhpcy5vcmIuY2VudGVyWzFdID0gMC43NTtcblx0XHRcdHRoaXMub3JiLnJ4LnNldFRvKDAuMzU1KTtcblx0XHRcdHRoaXMub3JiLnJ5LnNldFRvKDEuMjE4KTtcblx0XHRcdHRoaXMuYWRkTGlzdGVuZXJzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdE9yYml0YWxDb250cm9sVHdlZW4udHdlZW4oeyBjZW50ZXJZOiAwLjc1LCByeDogMC4zNTUsIHJ5OiAxLjIxOCwgZHVyYXRpb246IDEsIGVhc2U6ICdjaXJjLmlub3V0JyB9KTtcblx0XHRcdGdzYXAudG8odGhpcy5tb2RlbCwgMSwge1xuXHRcdFx0XHR5OiAxLFxuXHRcdFx0XHRyb3RhdGlvblg6IC1NYXRoLlBJIC8gNCxcblx0XHRcdFx0cm90YXRpb25ZOiAtTWF0aC5QSSAvIDgsXG5cdFx0XHRcdGVhc2U6ICdjaXJjLmlub3V0Jyxcblx0XHRcdFx0b25Db21wbGV0ZTogKCk9PiB7XG5cdFx0XHRcdFx0dGhpcy5hZGRMaXN0ZW5lcnMoKTtcblx0XHRcdFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdH1cdFx0XG5cdH1cblxuXHRyZW1vdmVMaXN0ZW5lcnMoKSB7XG5cdFx0dGhpcy5zY2VuZS5jb250YWluZXJIVE1MLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bik7XG5cdFx0dGhpcy5zY2VuZS5jb250YWluZXJIVE1MLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblVwKTtcblx0XHR0aGlzLnNjZW5lLmNvbnRhaW5lckhUTUwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlKTtcblx0fVxuXG5cdGFkZExpc3RlbmVycygpIHtcblx0XHR0aGlzLnNjZW5lLmNvbnRhaW5lckhUTUwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Eb3duKTtcblx0XHR0aGlzLnNjZW5lLmNvbnRhaW5lckhUTUwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uVXApO1xuXHRcdHRoaXMuc2NlbmUuY29udGFpbmVySFRNTC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuXHR9XG5cblx0b25Eb3duKGUpIHtcblx0XHR0aGlzLmRvd24gPSB0cnVlO1xuXHRcdHRoaXMucG9zID0gZ2V0TW91c2UoZSk7XG5cdH1cblxuXHRvbk1vdmUoZSkge1xuXHRcdFxuXHRcdGlmICghdGhpcy5kb3duKSByZXR1cm47XG5cdFx0XG5cdFx0Y29uc3QgcG9zID0gZ2V0TW91c2UoZSk7XG5cdFx0Y29uc3QgZGlzdCA9IGdldERpc3RPcHRpbSh0aGlzLnBvcy54LCBwb3MueCwgdGhpcy5wb3MueSwgcG9zLnkpO1xuXHRcdGlmIChkaXN0ID4gMjAgKiAyMCkge1xuXHRcdFx0dGhpcy5zY2VuZS5zdGF0ZU1hbmFnZXIuc2V0KCdvcmJpdCcpO1xuXHRcdH1cblx0fVxuXG5cdG9uVXAoZSkge1xuXHRcdHRoaXMuZG93biA9IGZhbHNlO1xuXHR9XG5cblx0ZW5kKCkge1xuXHRcdGdzYXAudG8odGhpcy5tb2RlbCwgMSwge1xuXHRcdFx0eTogMCxcblx0XHRcdHJvdGF0aW9uWDogLU1hdGguUEkgLyAyLFxuXHRcdFx0cm90YXRpb25ZOiAwLFxuXHRcdFx0ZWFzZTogJ2NpcmMuaW5vdXQnXG5cdFx0fSk7XG5cblx0XHRPcmJpdGFsQ29udHJvbFR3ZWVuLnR3ZWVuKHtcblx0XHRcdGNlbnRlclg6IDAsXG5cdFx0XHRjZW50ZXJZOiAwLFxuXHRcdFx0Y2VudGVyWjogMCxcblx0XHRcdGVhc2U6ICdjaXJjLmlub3V0Jyxcblx0XHRcdGR1cmF0aW9uOiAxLFxuXHRcdH0pO1xuXHRcdHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0aWYgKENvbmZpZy5ob21lLmNhbWVyYU1vdmVtZW50ICYmIHRoaXMucmVhZHkpIHtcblx0XHRcdHRoaXMub3JiLnJ5LnZhbHVlICs9IE1hdGguc2luKFNjaGVkdWxlci5kZWx0YVRpbWUgKiAwLjI1KSAqIDAuMDA1O1xuXHRcdFx0dGhpcy5tb2RlbC55ID0gMSArIE1hdGguY29zKFNjaGVkdWxlci5kZWx0YVRpbWUgKiAwLjUpICogMC4xO1xuXHRcdFx0dGhpcy5tb2RlbC5yb3RhdGlvblggPSAtTWF0aC5QSSAvIDQgLSAwLjAyNSArIE1hdGguY29zKFNjaGVkdWxlci5kZWx0YVRpbWUgKiAwLjUpICogMC4wMjVcblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCB7IFN0YXRlRGVmYXVsdCB9IGZyb20gJy4vU3RhdGVEZWZhdWx0JztcblxuXG5leHBvcnQgY2xhc3MgU3RhdGVPcmJpdCBleHRlbmRzIFN0YXRlRGVmYXVsdCB7XG5cdGJlZ2luKCkge1xuXHRcdHRoaXMubW9kZWwgPSB0aGlzLnNjZW5lLl92TW9kZWw7XG5cdFx0dGhpcy5vcmIgPSB0aGlzLnNjZW5lLm9yYml0YWxDb250cm9sO1xuXHR9XG59XG4iLCJleHBvcnQgeyBTdGF0ZUhvbWUgfSBmcm9tICcuL1N0YXRlSG9tZSc7XG5leHBvcnQgeyBTdGF0ZU9yYml0IH0gZnJvbSAnLi9TdGF0ZU9yYml0JztcbmV4cG9ydCB7IFN0YXRlQW5ub3RhdGUgfSBmcm9tICcuL1N0YXRlQW5ub3RhdGUnOyIsImltcG9ydCB7IG1hdDQgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5jb25zdCBiaWFzTWF0cml4ID0gbWF0NC5mcm9tVmFsdWVzKFxuICAwLjUsIDAuMCwgMC4wLCAwLjAsXG4gIDAuMCwgMC41LCAwLjAsIDAuMCxcbiAgMC4wLCAwLjAsIDAuNSwgMC4wLFxuICAwLjUsIDAuNSwgMC41LCAxLjBcbik7XG5cbmV4cG9ydCB7IGJpYXNNYXRyaXggfTsiLCJleHBvcnQgeyBiaWFzTWF0cml4IH0gZnJvbSAnLi9iaWFzTWF0cml4JyIsImltcG9ydCB7IGdldDJkUG9zIH0gZnJvbSAndXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3QW5ub3RhdGlvbiB7XG5cdGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuXHRcdHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXHRcdHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSAnYW5ub3RhdGlvbic7XG5cdFx0dGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cblx0XHR0aGlzLnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cdFx0dGhpcy50ZXh0LmlubmVyVGV4dCA9ICdUaXRsZSBvZiB0aGUgYW5ub3RhdGlvbiBwbHVzIGEgZGVzY3JpcHRpb24uJztcblx0XHR0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50ZXh0KTtcblxuXHRcdHRoaXMuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cdFx0dGhpcy5pbWcuY2xhc3NOYW1lID0gJ2ltYWdlLXNwb3QnO1xuXHRcdHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmltZyk7XG5cblx0XHRjb25zdCBjbG9zZUljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblx0XHRjbG9zZUljb24uY2xhc3NOYW1lID0gJ2Nsb3NlJztcblx0XHRjbG9zZUljb24ub25jbGljayA9IHRoaXMuaGlkZS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChjbG9zZUljb24pO1xuXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG5cdH1cblxuXHRzaG93KCkge1xuXHRcdHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0fVxuXHRcblx0aGlkZSgpIHtcblx0XHR0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0fVxuXG5cdG9uU3BvdENsaWNrZWQoc3BvdCkge1xuXHRcdHRoaXMuc2hvdygpO1xuXG5cdFx0Y29uc3QgdyA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoO1xuXHRcdHRoaXMudGV4dC5pbm5lckhUTUwgPSBzcG90LmxhYmVsO1xuXG5cdFx0Y29uc3QgcG9zMmQgPSBnZXQyZFBvcyhzcG90LnRhcmdldCk7XG5cdFx0Y29uc3QgeCA9IHBvczJkWzBdO1xuXHRcdGNvbnN0IHkgPSBwb3MyZFsxXTtcblxuXHRcdGlmICh4IDwgdyAvIDIpIHtcblx0XHRcdHRoaXMuZWxlbWVudC5zdHlsZS5yaWdodCA9ICdhdXRvJztcblx0XHRcdHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7TWF0aC5tYXgodyAvIDIsIHggKyA4MCl9cHhgO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9ICdhdXRvJztcblx0XHRcdHRoaXMuZWxlbWVudC5zdHlsZS5yaWdodCA9IGAke01hdGgubWluKHcgLyAyLCB4IC0gODApfXB4YDtcblx0XHR9XG5cdH1cblxuXHRzZXRQb3NpdGlvbih4LCB5KSB7XG5cdFx0XG5cdH1cbn0iLCIvLyBWaWV3Rmxvb3IuanNcblxuaW1wb3J0IHsgR0wsIEdMVGV4dHVyZSwgR2VvbSwgTWVzaCwgVmlldzNEIH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCB7IG1hdDQsIHZlYzIgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5pbXBvcnQgQ29uZmlnIGZyb20gJy4uL0NvbmZpZyc7XG5pbXBvcnQgZnMgZnJvbSAnc2hhZGVycy9mbG9vci5mcmFnJztcbmltcG9ydCB2cyBmcm9tICdzaGFkZXJzL2Zsb29yLnZlcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3Rmxvb3IgZXh0ZW5kcyBWaWV3M0Qge1xuICBcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIodnMsIGZzKTtcblxuICAgIHRoaXMuc2hhZG93Q29sb3IgPSBbMCwgMCwgMF07XG4gICAgdGhpcy5jb2xvciA9IFsxLCAxLCAxXTtcbiAgICB0aGlzLnkgPSAtMC42O1xuICAgIC8vIHRoaXMucm90YXRpb25YID0gLU1hdGguUEkgLyAyO1xuICAgIGNvbnN0IHNpemUgPSAxMDtcbiAgICB0aGlzLm1lc2ggPSBHZW9tLnBsYW5lKHNpemUsIHNpemUsIDEsICd4eicpO1xuICB9XG5cbiAgcmVuZGVyKHNoYWRvd01hdHJpeCwgdGV4dHVyZURlcHRoKSB7XG4gICAgY29uc3QgY29sb3JTaGFkb3cgPSBDb25maWcuc2hhZG93LmNvbG9yLm1hcCgodikgPT4gdiAvIDI1NSk7XG5cbiAgICB0aGlzLnNoYWRlci5iaW5kKCk7XG4gICAgLy8gdGhpcy5zaGFkZXIudW5pZm9ybSgndUNvbG9yJywgJ3ZlYzMnLCB0aGlzLmNvbG9yKTtcbiAgICB0aGlzLnNoYWRlci51bmlmb3JtKCd1Q29sb3InLCAndmVjMycsIFsxLCAxLCAxXSk7XG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybSgndVNoYWRvd0NvbG9yJywgJ3ZlYzMnLCBjb2xvclNoYWRvdyk7XG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybSgndVNoYWRvd09wYWNpdHknLCAnZmxvYXQnLCAwLjYpO1xuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3RleHR1cmVEZXB0aCcsICd1bmlmb3JtMWknLCAwKTtcbiAgICB0ZXh0dXJlRGVwdGguYmluZCgwKTtcblxuICAgIC8vIHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VDYW1lcmFQb3MnLCAndmVjMycsIFswLCA1LCAwXSk7XG4gICAgLy8gdGhpcy5zaGFkZXIudW5pZm9ybSgndUNhbWVyYVBvcycsICd2ZWMzJywgR0wuY2FtZXJhLnBvc2l0aW9uKTtcbiAgICB0aGlzLnNoYWRlci51bmlmb3JtKCd1TWFwU2l6ZScsICdmbG9hdCcsIENvbmZpZy5zaGFkb3dNYXBTaXplKTtcbiAgICAvLyB0aGlzLnNoYWRlci51bmlmb3JtKCd1U3ByZWFkJywgJ2Zsb2F0JywgQ29uZmlnLnNoYWRvdy5zcHJlYWQpO1xuXG4gICAgXG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybSgndVNoYWRvd01hdHJpeCcsICd1bmlmb3JtTWF0cml4NGZ2Jywgc2hhZG93TWF0cml4KTtcblxuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VTaGFkb3dDb2xvcicsICd2ZWMzJywgY29sb3JTaGFkb3cpO1xuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgXG4gICAgXG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybSgndU1hdHJpeCcsICdtYXQ0JywgdGhpcy5fbWF0cml4KTtcblxuICAgIEdMLmRyYXcodGhpcy5tZXNoKTtcbiAgfVxufVxuIiwiLy8gVmlld09iak1vZGVsLmpzXG5cbmltcG9ydCBhbGZyaWQsIHsgR0wsIEdMU2hhZGVyLCBWaWV3M0QgfSBmcm9tICdhbGZyaWQnO1xuXG5pbXBvcnQgQXNzZXRzIGZyb20gJy4uLy4uL0Fzc2V0cyc7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4uL0NvbmZpZyc7XG5pbXBvcnQgZnMgZnJvbSAnc2hhZGVycy9wYnIuZnJhZyc7XG5pbXBvcnQgZnNEZXB0aCBmcm9tICdzaGFkZXJzL2RlcHRoLmZyYWcnO1xuaW1wb3J0IGZzRWRpdG9yIGZyb20gJ3NoYWRlcnMvY29sb3IuZnJhZyc7XG5pbXBvcnQgeyBnZXRDdWJlIH0gZnJvbSAnLi4vZGVidWcvZGVidWdTaGFwZSc7XG5pbXBvcnQgeyBnZXRHZW9tZXRyeUZhY2VzIH0gZnJvbSAndXRpbHMnO1xuaW1wb3J0IHsgbWF0NCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgdnMgZnJvbSAnc2hhZGVycy9wYnIudmVydCc7XG5pbXBvcnQgdnNFZGl0b3IgZnJvbSAnc2hhZGVycy9iYXNpYy52ZXJ0JztcblxuY29uc3QgdGVtcE1hdDQgPSBtYXQ0LmNyZWF0ZSgpO1xuXG5jb25zdCBkZWZpbmVzVG9TdHJpbmcgPSBmdW5jdGlvbiAoZGVmaW5lcykge1xuXHRsZXQgb3V0U3RyID0gJyc7XG5cdGZvciAoY29uc3QgZGVmIGluIGRlZmluZXMpIHtcbiAgICBcdGlmKGRlZmluZXNbZGVmXSkge1xuICAgIFx0XHRvdXRTdHIgKz0gYCNkZWZpbmUgJHtkZWZ9ICR7ZGVmaW5lc1tkZWZdfVxcbmA7XHRcbiAgICBcdH1cbiAgICAgICAgXG5cdH1cblx0cmV0dXJuIG91dFN0cjtcbn07XG5cbmNsYXNzIFZpZXdPYmpNb2RlbCBleHRlbmRzIFZpZXczRCB7XG5cdFxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBkZWZpbmVzID0ge1xuXHRcdFx0VVNFX1RFWF9MT0Q6ICEhR0wuZ2V0RXh0ZW5zaW9uKCdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJykgPyAxIDogMCxcblx0XHRcdFVTRV9JQkw6IDEsXG5cdFx0XHRIQVNfQkFTRUNPTE9STUFQOiAxLFxuXHRcdFx0SEFTX05PUk1BTE1BUDogMCxcblx0XHRcdEhBU19FTUlTU0lWRU1BUDogMCxcblx0XHRcdEhBU19PQ0NMVVNJT05NQVA6IDEsXG5cdFx0fTtcblx0XHRjb25zdCBkZWZpbmVTdHIgPSBkZWZpbmVzVG9TdHJpbmcoZGVmaW5lcyk7XG5cdFx0Ly8gY29uc29sZS5sb2coZGVmaW5lU3RyKTtcblx0XHRjb25zdCBfdnMgPSBgJHtkZWZpbmVTdHJ9XFxuJHt2c31gO1xuXHRcdGNvbnN0IF9mcyA9IGAke2RlZmluZVN0cn1cXG4ke2ZzfWA7XG5cblx0XHQvLyBjb25zb2xlLmxvZyhfZnMpO1xuXHRcdHN1cGVyKF92cywgX2ZzKTtcblxuXHRcdFxuXHRcdHRoaXMuc2hhZGVyRGVwdGggPSBuZXcgR0xTaGFkZXIodnMsIGZzRGVwdGgpO1xuXHRcdHRoaXMuc2hhZGVyRWRpdG9yID0gbmV3IEdMU2hhZGVyKHZzRWRpdG9yLCBmc0VkaXRvcik7XG5cdH1cblxuXHRnZXRGYWNlcygpIHtcblx0XHR0aGlzLmZhY2VzID0gW11cblxuXHRcdHRoaXMuZGVidWdTaGFwZXMuZm9yRWFjaChtZXNoID0+IHtcblx0XHRcdGNvbnN0IGZhY2VzID0gZ2V0R2VvbWV0cnlGYWNlcyhtZXNoKTtcblx0XHRcdHRoaXMuZmFjZXMgPSBbLi4udGhpcy5mYWNlcywgLi4uZmFjZXNdXHRcblx0XHR9KTtcblx0fVxuXG5cdF9pbml0KCkge1xuXHRcdFxuXHRcdFxuXHRcdGlmIChDb25maWcuZWRpdG9yLmFjdGl2ZSB8fCBDb25maWcuZGVidWcuc2hhcGUuYWN0aXZlKSB7XG5cdFx0XHR0aGlzLm1hdHJpeERlYnVnID0gbWF0NC5jcmVhdGUoKTtcblx0XHRcdHRoaXMuY3ViZURlYnVnID0gYWxmcmlkLkdlb20uY3ViZSgxLCAxLCAxKTtcblxuXHRcdFx0dGhpcy5kZWJ1Z1NoYXBlcyA9IFtdO1xuXHRcdFx0dGhpcy5kZWJ1Z1NoYXBlcy5wdXNoKGdldEN1YmUoMC45NjcsIDEuNCwgMC41MTQsIFswLCAtMC4yMjQsIDBdKSk7XG5cdFx0XHR0aGlzLmRlYnVnU2hhcGVzLnB1c2goZ2V0Q3ViZSgwLjc5LCAwLjkxNCwgMC41MSwgWzAsIDAuODk3LCAwXSkpO1xuXHRcdFx0dGhpcy5kZWJ1Z1NoYXBlcy5wdXNoKGdldEN1YmUoMC4zMzMsIDAuNTEsIDAuMDk4LCBbLTAuMTk2LCAtMS4xNjksIC0wLjAxNV0pKTtcblx0XHRcdFxuXHRcdFx0Ly8gdGhpcy5nZXRGYWNlcygpO1xuXHRcdH1cblxuXHRcdFxuXHRcdFxuXHRcdHRoaXMubWVzaCA9IEFzc2V0cy5nZXQoJ21vZGVsRmxleCcpO1xuXHRcdHRoaXMuYmFzZUNvbG9yID0gWzEsIDEsIDFdO1xuXHRcdC8vIHRoaXMucm90YXRpb25YID0gLU1hdGguUEkgLyAyO1xuXHR9XG5cdFxuXHRyZW5kZXJTaGFkb3coKSB7XG5cdFx0dGhpcy5zaGFkZXJEZXB0aC5iaW5kKCk7XG5cdFx0R0wucm90YXRlKHRoaXMuX21hdHJpeCk7XG5cblx0XHRHTC5kcmF3KHRoaXMubWVzaCk7XG5cdH1cblxuXHRyZW5kZXIodGV4dHVyZVJhZCwgdGV4dHVyZUlyciwgdGV4dHVyZUFPLCB0ZXh0dXJlQ29sb3IsIHRleHR1cmVSb3VnaCwgY3VycmVudFNwb3RBbm5vdGF0aW9uKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndUFvTWFwJywgJ3VuaWZvcm0xaScsIDApO1xuXHRcdHRleHR1cmVBTy5iaW5kKDApO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VCUkRGTWFwJywgJ3VuaWZvcm0xaScsIDEpO1xuXHRcdEFzc2V0cy5nZXQoJ2JyZGZMVVQnKS5iaW5kKDEpO1xuXG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndVJhZGlhbmNlTWFwJywgJ3VuaWZvcm0xaScsIDMpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VJcnJhZGlhbmNlTWFwJywgJ3VuaWZvcm0xaScsIDIpO1xuXHRcdFxuXHRcdHRleHR1cmVSYWQuYmluZCgzKTtcblx0XHR0ZXh0dXJlSXJyLmJpbmQoMik7XG5cblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1Q29sb3JNYXAnLCAndW5pZm9ybTFpJywgNCk7XG5cdFx0dGV4dHVyZUNvbG9yLmJpbmQoNCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndVJvdWdobmVzc01hcCcsICd1bmlmb3JtMWknLCA1KTtcblx0XHR0ZXh0dXJlUm91Z2guYmluZCg1KTtcblxuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VNZXRhbGxpYycsICd1bmlmb3JtMWYnLCBDb25maWcubWV0YWxsaWMpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VTcGVjdWxhcicsICd1bmlmb3JtMWYnLCB0aGlzLnNwZWN1bGFyKTtcblxuXHRcdC8vXHRwYnJcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1TGlnaHREaXJlY3Rpb24nLCAndmVjMycsIFswLjUsIDAuNSwgMC41XSk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndUxpZ2h0Q29sb3InLCAndmVjMycsIFsxLCAxLCAxXSk7XG5cblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1U2NhbGVEaWZmQmFzZU1SJywgJ3ZlYzQnLCBbMCwgMCwgMCwgMF0pO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VTY2FsZUZHRFNwZWMnLCAndmVjNCcsIFswLCAwLCAwLCAwXSk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndVNjYWxlSUJMQW1iaWVudCcsICd2ZWM0JywgWzEsIDEsIDEsIDFdKTtcblxuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VDYW1lcmFQb3MnLCAndmVjMycsIEdMLmNhbWVyYS5wb3NpdGlvbik7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndU9jY2x1c2lvblN0cmVuZ3RoJywgJ2Zsb2F0JywgMSk7XG5cdFx0XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndVBvc0Fubm90YXRpb24nLCAndmVjMycsIGN1cnJlbnRTcG90QW5ub3RhdGlvbiA/IGN1cnJlbnRTcG90QW5ub3RhdGlvbi50YXJnZXQgOiBbMTAwMCwgMTAwMCwgMTAwMF0pO1xuXG5cdFx0R0wucm90YXRlKHRoaXMuX21hdHJpeCk7XHRcdFxuXHRcdEdMLmRyYXcodGhpcy5tZXNoKTtcblxuXHRcdGlmIChDb25maWcuZGVidWcuc2hhcGUuYWN0aXZlKSB7XG5cdFx0XHR0aGlzLnNoYWRlckVkaXRvci5iaW5kKCk7XG5cdFx0XHR0aGlzLnNoYWRlckVkaXRvci51bmlmb3JtKCd1QWxwaGEnLCAnZmxvYXQnLCAuNCk7XG5cdFx0XHR0aGlzLnNoYWRlckVkaXRvci51bmlmb3JtKCd1Q29sb3InLCAndmVjMycsIFsxLCAwLCAwXSk7XG5cdFx0XHRtYXQ0LmlkZW50aXR5KHRoaXMubWF0cml4RGVidWcpO1xuXHRcdFx0Y29uc3Qgcm90ID0gQ29uZmlnLmRlYnVnLnNoYXBlLnJvdDtcblx0XHRcdG1hdDQucm90YXRlWCh0aGlzLm1hdHJpeERlYnVnLCB0aGlzLm1hdHJpeERlYnVnLCByb3QueCk7XG5cdFx0XHRtYXQ0LnJvdGF0ZVkodGhpcy5tYXRyaXhEZWJ1ZywgdGhpcy5tYXRyaXhEZWJ1Zywgcm90LnkpO1xuXHRcdFx0bWF0NC5yb3RhdGVaKHRoaXMubWF0cml4RGVidWcsIHRoaXMubWF0cml4RGVidWcsIHJvdC56KTtcblx0XHRcdGNvbnN0IHBvcyA9IENvbmZpZy5kZWJ1Zy5zaGFwZS5wb3M7XG5cdFx0XHRtYXQ0LnRyYW5zbGF0ZSh0aGlzLm1hdHJpeERlYnVnLCB0aGlzLm1hdHJpeERlYnVnLCBbcG9zLngsIHBvcy55LCBwb3Muel0pO1xuXHRcdFx0Y29uc3Qgc2NhbGUgPSBDb25maWcuZGVidWcuc2hhcGUuc2NhbGU7XG5cdFx0XHRtYXQ0LnNjYWxlKHRoaXMubWF0cml4RGVidWcsIHRoaXMubWF0cml4RGVidWcsIFtzY2FsZS54LCBzY2FsZS55LCBzY2FsZS56XSk7XG5cblx0XHRcdG1hdDQubXVsdGlwbHkodGVtcE1hdDQsIHRoaXMuX21hdHJpeCwgdGhpcy5tYXRyaXhEZWJ1Zyk7XG5cblx0XHRcdEdMLnJvdGF0ZSh0ZW1wTWF0NCk7XG5cdFx0XHRHTC5kcmF3KHRoaXMuY3ViZURlYnVnKTtcblxuXHRcdFx0dGhpcy5zaGFkZXJFZGl0b3IudW5pZm9ybSgndUNvbG9yJywgJ3ZlYzMnLCBbMCwgMCwgMF0pO1xuXHRcdFx0dGhpcy5zaGFkZXJFZGl0b3IudW5pZm9ybSgndUFscGhhJywgJ2Zsb2F0JywgLjIpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlYnVnU2hhcGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGRTaGFwZSA9IHRoaXMuZGVidWdTaGFwZXNbaV07XG5cdFx0XHRcdG1hdDQubXVsdGlwbHkodGVtcE1hdDQsIHRoaXMuX21hdHJpeCwgZFNoYXBlLm1hdHJpeCk7XG5cdFx0XHRcdEdMLnJvdGF0ZSh0ZW1wTWF0NCk7XG5cdFx0XHRcdEdMLmRyYXcoZFNoYXBlLm1lc2gpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRcblx0fVxuXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlld09iak1vZGVsOyIsIi8vIENhcHR1cmUuanNcblxuaW1wb3J0IHsgR0wgfSBmcm9tICdhbGZyaWQnO1xuaW1wb3J0IHsgc2F2ZUltYWdlIH0gZnJvbSAnLi8nO1xuXG5TdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwgPSBmdW5jdGlvbihzZWFyY2gsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgcmV0dXJuIHRhcmdldC5yZXBsYWNlKG5ldyBSZWdFeHAoc2VhcmNoLCAnZycpLCByZXBsYWNlbWVudCk7XG59O1xuXG5jb25zdCBjYXB0dXJlID0gKCkgPT4ge1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG5cdFx0aWYoZS5rZXlDb2RlID09PSA4MyAmJiBlLm1ldGFLZXkpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0bGV0IHN0ckRhdGUgPSBcblx0XHRcdFx0YCR7ZGF0ZS5nZXRGdWxsWWVhcigpfS5gICsgXG5cdFx0XHRcdGAke2RhdGUuZ2V0TW9udGgoKSArIDF9LmAgKyBcblx0XHRcdFx0YCR7ZGF0ZS5nZXREYXRlKCl9LWAgKyBcblx0XHRcdFx0YCR7ZGF0ZS5nZXRIb3VycygpfS5gICsgXG5cdFx0XHRcdGAke2RhdGUuZ2V0TWludXRlcygpfS5gICsgXG5cdFx0XHRcdGAke2RhdGUuZ2V0U2Vjb25kcygpfWA7XG5cdFx0XHRcblx0XHRcdHNhdmVJbWFnZShHTC5jYW52YXMsIHN0ckRhdGUpO1xuXHRcdH1cblx0fSk7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgY2FwdHVyZSgpOyIsImNvbnN0IGRlc3Ryb3lHTCA9IChnbCkgPT4ge1xuXHRjb25zdCBudW1UZXh0dXJlVW5pdHMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuXHRmb3IgKGxldCB1bml0ID0gMDsgdW5pdCA8IG51bVRleHR1cmVVbml0czsgdW5pdCsrKSB7XG5cdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHVuaXQpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuXHR9XG5cblx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuXHRnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcblx0Z2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xufTtcblxuZXhwb3J0IHsgZGVzdHJveUdMIH07IiwiY29uc3QgZGVzdHJveVNoYWRlciA9IChzaGFkZXIsIGdsKSA9PiB7XG4gIGdsLnVzZVByb2dyYW0obnVsbCk7XG4gIGdsLmRlbGV0ZVByb2dyYW0oc2hhZGVyLnNoYWRlclByb2dyYW0pO1xufVxuXG5leHBvcnQgeyBkZXN0cm95U2hhZGVyIH0iLCJpbXBvcnQgeyBHTCB9IGZyb20gJ2FsZnJpZCc7XG5pbXBvcnQgeyB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY29uc3QgdGVtcFZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuLy8gcmV0dXJuIHRoaXMuZ2V0WFkocG9zLCB0aGlzLnNjZW5lLmNhbWVyYS5fbWF0cml4LCB0aGlzLnNjZW5lLmNhbWVyYS5wcm9qZWN0aW9uLCBHTC53aWR0aCwgR0wuaGVpZ2h0KTtcblxuY29uc3QgZ2V0MmRQb3MgPSAocG9zKSA9PiB7XG4gIHZlYzMudHJhbnNmb3JtTWF0NCh0ZW1wVmVjMywgcG9zLCBHTC5jYW1lcmEuX21hdHJpeCk7XG4gIHZlYzMudHJhbnNmb3JtTWF0NCh0ZW1wVmVjMywgdGVtcFZlYzMsIEdMLmNhbWVyYS5wcm9qZWN0aW9uKTtcblxuICB0ZW1wVmVjM1swXSAvPSB0ZW1wVmVjM1syXTtcbiAgdGVtcFZlYzNbMV0gLz0gdGVtcFZlYzNbMl07XG4gIHRlbXBWZWMzWzBdID0gKHRlbXBWZWMzWzBdICsgMSkgKiBHTC53aWR0aCAvIDI7XG4gIHRlbXBWZWMzWzFdID0gR0wuaGVpZ2h0IC0gKHRlbXBWZWMzWzFdICsgMSkgKiBHTC5oZWlnaHQgLyAyO1xuXG4gIHJldHVybiB0ZW1wVmVjMztcbn1cblxuZXhwb3J0IHsgZ2V0MmRQb3MgfTsiLCJjb25zdCBnZXREaXN0T3B0aW0gPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICBsZXQgeERpc3QgPSB4MSAtIHgyXG4gIGxldCB5RGlzdCA9IHkxIC0geTJcblxuICByZXR1cm4geERpc3QgKiB4RGlzdCArIHlEaXN0ICogeURpc3Rcbn1cblxuZXhwb3J0IHsgZ2V0RGlzdE9wdGltIH0iLCJjb25zdCBnZXREaXN0T3B0aW0zRCA9IGZ1bmN0aW9uKHgxLCB5MSwgejEsIHgyLCB5MiwgejIpIHtcbiAgbGV0IHhEaXN0ID0geDEgLSB4MlxuICBsZXQgeURpc3QgPSB5MSAtIHkyXG4gIGxldCB6RGlzdCA9IHoxIC0gejJcblxuICByZXR1cm4geERpc3QgKiB4RGlzdCArIHlEaXN0ICogeURpc3QgKyB6RGlzdCAqIHpEaXN0XG59XG5cbmV4cG9ydCB7IGdldERpc3RPcHRpbTNEIH0iLCJjb25zdCBnZXRHZW9tZXRyeUZhY2VzID0gKG1lc2gpID0+IHtcbiAgY29uc3QgZmFjZXMgPSBbXTtcbiAgXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtZXNoLmluZGljZXMubGVuZ3RoOyBpbmRleCArPSAzKSB7XG4gICAgY29uc3QgaW5kaWNlMSA9IG1lc2guaW5kaWNlc1tpbmRleF07XG4gICAgY29uc3QgaW5kaWNlMiA9IG1lc2guaW5kaWNlc1tpbmRleCArIDFdO1xuICAgIGNvbnN0IGluZGljZTMgPSBtZXNoLmluZGljZXNbaW5kZXggKyAyXTtcbiAgICBjb25zdCB2MSA9IG1lc2gudmVydGljZXNbaW5kaWNlMV07XG4gICAgY29uc3QgdjIgPSBtZXNoLnZlcnRpY2VzW2luZGljZTJdO1xuICAgIGNvbnN0IHYzID0gbWVzaC52ZXJ0aWNlc1tpbmRpY2UzXTtcblxuICAgIGZhY2VzLnB1c2goW3YxLCB2MiwgdjNdKTtcbiAgfVxuXG4gIHJldHVybiBmYWNlcztcbn07XG5cbmV4cG9ydCB7IGdldEdlb21ldHJ5RmFjZXMgfTtcblxuIiwiaW1wb3J0IHsgdmVjMiB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNvbnN0IGdldE1vdXNlID0gZnVuY3Rpb24gKG1FdmVudCwgbVRhcmdldCkge1xuXG5cdGNvbnN0IG8gPSBtVGFyZ2V0IHx8IHt9O1xuXHRpZihtRXZlbnQudG91Y2hlcykge1xuXHRcdG8ueCA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuXHRcdG8ueSA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuXHR9IGVsc2Uge1xuXHRcdG8ueCA9IG1FdmVudC5jbGllbnRYO1xuXHRcdG8ueSA9IG1FdmVudC5jbGllbnRZO1xuXHR9XG5cblx0cmV0dXJuIG87XG59O1xuXG5cbmV4cG9ydCB7IGdldE1vdXNlIH07XG4iLCIvLyBpbmRleC5qc1xuXG5leHBvcnQgeyBzYXZlSW1hZ2UgfSBmcm9tICcuL3NhdmVJbWFnZSc7XG5leHBvcnQgeyBzYXZlSnNvbiB9IGZyb20gJy4vc2F2ZUpzb24nO1xuZXhwb3J0IHsgZGVzdHJveUdMIH0gZnJvbSAnLi9kZXN0cm95R0wnO1xuZXhwb3J0IHsgZGVzdHJveVNoYWRlciB9IGZyb20gJy4vZGVzdHJveVNoYWRlcic7XG5leHBvcnQgeyBnZXRNb3VzZSB9IGZyb20gJy4vZ2V0TW91c2UnO1xuZXhwb3J0IHsgcmVzaXplIH0gZnJvbSAnLi9yZXNpemVDYW5hdnMnO1xuZXhwb3J0IHsgc21hbGxlc3RBbmdsZSB9IGZyb20gJy4vc21hbGxlc3RBbmdsZSc7XG5leHBvcnQgeyBpbnRlcnNlY3Rpb25SYXlNZXNoIH0gZnJvbSAnLi9pbnRlcnNlY3Rpb25SYXlNZXNoJztcbmV4cG9ydCB7IGdldEdlb21ldHJ5RmFjZXMgfSBmcm9tICcuL2dldEdlb21ldHJ5RmFjZXMnO1xuZXhwb3J0IHsgZ2V0RGlzdE9wdGltIH0gZnJvbSAnLi9nZXREaXN0T3B0aW0nO1xuZXhwb3J0IHsgZ2V0RGlzdE9wdGltM0QgfSBmcm9tICcuL2dldERpc3RPcHRpbTNEJztcbmV4cG9ydCB7IGdldDJkUG9zIH0gZnJvbSAnLi9nZXQyZFBvcyc7XG5leHBvcnQgeyBtYXAgfSBmcm9tICcuL21hcCc7IiwiaW1wb3J0IHsgbWF0NCwgdmVjMywgdmVjNCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmltcG9ydCB7IFJheSB9IGZyb20gJ2FsZnJpZCc7XG5pbXBvcnQgeyBnZXREaXN0T3B0aW0zRCB9IGZyb20gJ3V0aWxzJztcblxuY29uc3QgdiA9IHZlYzQuY3JlYXRlKCk7XG5cbmZ1bmN0aW9uIHJvdGF0ZSh2ZWMsIG1hdHJpeCkge1xuXHR2ZWM0LmNvcHkodiwgW3ZlY1swXSwgdmVjWzFdLCB2ZWNbMl0sIDEuMF0pO1xuXHR2ZWM0LnRyYW5zZm9ybU1hdDQodiwgdiwgbWF0cml4KTtcblxuXHRyZXR1cm4gdmVjNC5jbG9uZSh2KTtcbn1cblxuY29uc3QgaW50ZXJzZWN0aW9uUmF5TWVzaCA9IChyYXksIGZhY2VzLCBtYXRyaXgsIGdldENsb3Nlc3QgPSBmYWxzZSkgPT4ge1xuXHRsZXQgaGl0OyBsZXQgdjA7IGxldCB2MTsgbGV0IFxuXHRcdHYyO1xuICAgIFxuXHRsZXQgY2xvc2VzdEhpdDtcblx0bGV0IHByZXZpb3VzRGlzdCA9IDEwMDAwMDAwMDtcblx0bGV0IGRpc3Q7XG4gIFxuXHRmb3IobGV0IGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCB2ZXJ0aWNlID0gZmFjZXNbaV1bMF07XG5cdFx0Y29uc3QgdmVydGljZTEgPSBmYWNlc1tpXVsxXTtcblx0XHRjb25zdCB2ZXJ0aWNlMiA9IGZhY2VzW2ldWzJdO1xuICAgICAgXG5cdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0djAgPSByb3RhdGUodmVydGljZSwgbWF0cml4KTtcblx0XHRcdHYxID0gcm90YXRlKHZlcnRpY2UxLCBtYXRyaXgpO1xuXHRcdFx0djIgPSByb3RhdGUodmVydGljZTIsIG1hdHJpeCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHYwID0gdmVydGljZTtcblx0XHRcdHYxID0gdmVydGljZTE7XG5cdFx0XHR2MiA9IHZlcnRpY2UyO1xuXHRcdH1cblxuXHRcdGhpdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSh2MCwgdjEsIHYyLCBmYWxzZSk7XG5cbiAgICAgIFxuXHRcdGlmKGhpdCkge1xuXHRcdFx0aWYgKGdldENsb3Nlc3QpIHtcbiAgICAgICAgZGlzdCA9IGdldERpc3RPcHRpbTNEKHJheS5vcmlnaW5bMF0sIHJheS5vcmlnaW5bMV0sIHJheS5vcmlnaW5bMl0sIGhpdFswXSwgaGl0WzFdLCBoaXRbMl0pO1xuICAgICAgICBcblx0XHRcdFx0aWYgKGRpc3QgPCBwcmV2aW91c0Rpc3QpIHtcblx0XHRcdFx0XHRwcmV2aW91c0Rpc3QgPSBkaXN0O1xuXHRcdFx0XHRcdGNsb3Nlc3RIaXQgPSBbLi4uaGl0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGhpdDtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG4gICAgXG5cdHJldHVybiBjbG9zZXN0SGl0O1xufTtcblxuZXhwb3J0IHsgaW50ZXJzZWN0aW9uUmF5TWVzaCB9OyIsImNvbnN0IG1hcCA9ICh2YWwsIGlucHV0TWluLCBpbnB1dE1heCwgb3V0cHV0TWluLCBvdXRwdXRNYXgpID0+ICgob3V0cHV0TWF4IC0gb3V0cHV0TWluKSAqICgodmFsIC0gaW5wdXRNaW4pIC8gKGlucHV0TWF4IC0gaW5wdXRNaW4pKSkgKyBvdXRwdXRNaW47XG5cbmV4cG9ydCB7IG1hcCB9O1xuIiwiaW1wb3J0IEFzc2V0cyBmcm9tICcuLi9Bc3NldHMnO1xuaW1wb3J0IEFzc2V0c0xvYWRlciBmcm9tICdhc3NldHMtbG9hZGVyJztcbmltcG9ydCBDYXB0dXJlIGZyb20gJy4vQ2FwdHVyZSc7XG5pbXBvcnQgeyBHTCB9IGZyb20gJ2FsZnJpZCc7XG4vLyBwcmVsb2FkLmpzXG5pbXBvcnQgZGVidWdQb2x5ZmlsbCBmcm9tICcuLi9kZWJ1Zy9kZWJ1Z1BvbHlmaWxsJztcblxuY29uc3QgZ2V0TG9hZGluZ0ltYWdlID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuXHRpbWcub25sb2FkID0gKCkgPT4ge1xuXHRcdGNvbnNvbGUubG9nKCdpbWcgbG9hZGVkJywgaW1nKTtcblx0XHRyZXNvbHZlKGltZyk7XG5cdH07XG5cblx0aW1nLnNyYyA9ICdhc3NldHMvY3NzLWltZy9sb2FkaW5nLnBuZyc7XG59KTtcblxuXG5jb25zdCBpbml0QWxmcmlkID0gKG9wdGlvbnMgPSB7fSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHQvLyBDUkVBVEUgQ0FOVkFTXG5cdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRjb25zdCBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXInKTtcblx0Y2FudmFzLmNsYXNzTmFtZSA9ICdNYWluLUNhbnZhcyc7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuXG5cdC8vIElOSVQgM0QgVE9PTFxuXHRHTC5pbml0KGNhbnZhcywgeyBpZ25vcmVXZWJnbDI6IGZhbHNlLCBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUgfSk7XG5cblx0cmVzb2x2ZSgpO1xufSk7XG5cbmNvbnN0IGNyZWF0ZUxvYWRpbmdBbmltID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zb2xlLmxvZygnY3JlYXRlIGxvYWRpbmcgYW5pbWF0aW9uJyk7XG5cdHJlc29sdmUoKTtcbn0pO1xuXG5jb25zdCBsb2FkQXNzZXRzID0gKGFzc2V0cykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zb2xlLmxvZygnTG9hZCBBc3NldHMnKTtcblx0aWYgKGFzc2V0cy5sZW5ndGggPiAwKSB7XG5cdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdpc0xvYWRpbmcnKTtcblxuXHRcdG5ldyBBc3NldHNMb2FkZXIoe1xuXHRcdFx0YXNzZXRzXG5cdFx0fSlcblx0XHRcdC5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0Vycm9yIDonLCBlcnJvcik7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdwcm9ncmVzcycsIChwKSA9PiB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdQcm9ncmVzcyA6ICcsIHApO1xuXHRcdFx0XHRjb25zdCBsb2FkZXIgPSBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoJy5Mb2FkaW5nLUJhcicpO1xuXHRcdFx0XHRpZiAobG9hZGVyKSBsb2FkZXIuc3R5bGUud2lkdGggPSBgJHsocCAqIDEwMCl9JWA7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdjb21wbGV0ZScsIChvKSA9PiB7XG5cdFx0XHRcdHJlc29sdmUobyk7XG5cdFx0XHR9KVxuXHRcdFx0LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0cmVzb2x2ZShbXSk7XG5cdH1cbn0pO1xuXG5jb25zdCBsb2FkQXNzZXRzQnVpbGQgPSAob3B0aW9ucyA9IHt9KSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnNvbGUubG9nKCdMb2FkIEFzc2V0cycpO1xuXHRpZiAob3B0aW9ucy5hc3NldHMubGVuZ3RoID4gMCkge1xuXHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnaXNMb2FkaW5nJyk7XG5cbiAgICBcblx0XHRjb25zdCBhc3NldHNXaXRoVXJsID0gb3B0aW9ucy5hc3NldHMubWFwKChhc3NldCk9PiB7XG5cdFx0XHRhc3NldC51cmwgPSAob3B0aW9ucy5hc3NldHNQYXRoIHx8ICcnKSAgKyBhc3NldC51cmw7XG5cblx0XHRcdHJldHVybiBhc3NldDtcblx0XHR9KTtcbiAgICBcblx0XHRuZXcgQXNzZXRzTG9hZGVyKHtcblx0XHRcdGFzc2V0czogYXNzZXRzV2l0aFVybFxuXHRcdH0pXG5cdFx0XHQub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdFcnJvciA6JywgZXJyb3IpO1xuXHRcdFx0fSlcblx0XHRcdC5vbigncHJvZ3Jlc3MnLCAocCkgPT4ge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnUHJvZ3Jlc3MgOiAnLCBwKTtcblx0XHRcdFx0aWYgKG9wdGlvbnMub25Qcm9ncmVzcykgb3B0aW9ucy5vblByb2dyZXNzKCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdjb21wbGV0ZScsIChvKSA9PiB7XG5cdFx0XHRcdGlmIChvcHRpb25zLm9uQ29tcGxldGUpIG9wdGlvbnMub25Db21wbGV0ZSgpO1xuXHRcdFx0XHRyZXNvbHZlKG8pO1xuXHRcdFx0fSlcblx0XHRcdC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdHJlc29sdmUoW10pO1xuXHR9XG59KTtcblxuY29uc3QgaW5pdEFzc2V0cyA9IChsaXN0QXNzZXRzLCBtQXNzZXRzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnNvbGUubG9nKCdJbml0IEFzc2V0cycsIG1Bc3NldHMpO1xuXHRjb25zdCBsb2FkZXIgPSBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoJy5Mb2FkaW5nLUJhcicpO1xuXHRsb2FkZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cblx0Ly8gSU5JVCBBU1NFVFNcblx0QXNzZXRzLmluaXQobUFzc2V0cywgbGlzdEFzc2V0cyk7XG5cblx0cmVzb2x2ZSgpO1xufSk7XG5cbmNvbnN0IGluaXRBc3NldHNCdWlsZCA9IChsaXN0QXNzZXRzLCBtQXNzZXRzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnNvbGUubG9nKCdJbml0IEFzc2V0cycsIG1Bc3NldHMpO1xuXHQvLyBJTklUIEFTU0VUU1xuXHRBc3NldHMuaW5pdChtQXNzZXRzLCBsaXN0QXNzZXRzKTtcblxuXHRyZXNvbHZlKCk7XG59KTtcblxuY29uc3QgY2xvc2VMb2FkaW5nQW5pbSA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc29sZS5sb2coJ0Nsb3NlIGxvYWRpbmcgYW5pbWF0aW9uJyk7XG5cdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnaXNMb2FkaW5nJyk7XG5cdH0sIDI1MCk7XG5cblx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0cmVzb2x2ZSgpO1xuXHR9LCA1MDApO1xufSk7XG5cbmNvbnN0IHByZWxvYWQgPSAob3B0aW9ucykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zb2xlLmxvZygncHJlbG9hZCcsIG9wdGlvbnMpXG5cdGluaXRBbGZyaWQoKVxuXHRcdC50aGVuKGdldExvYWRpbmdJbWFnZSlcblx0XHQudGhlbihjcmVhdGVMb2FkaW5nQW5pbSlcblx0XHQudGhlbihsb2FkQXNzZXRzLmJpbmQobnVsbCwgb3B0aW9ucy5hc3NldHMpKVxuXHRcdC50aGVuKGluaXRBc3NldHMuYmluZChudWxsLCBvcHRpb25zLmFzc2V0cykpXG5cdFx0LnRoZW4oY2xvc2VMb2FkaW5nQW5pbSlcblx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRyZXNvbHZlKCk7XG5cdFx0fSlcblx0XHQuY2F0Y2goKGUpID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKCdFcnJvcicsIGUpO1xuXHRcdH0pO1xufSk7XG5cbmV4cG9ydCBjb25zdCBwcmVsb2FkQnVpbGQgPSAob3B0aW9ucykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRpbml0QWxmcmlkKG9wdGlvbnMpXG5cdFx0LnRoZW4obG9hZEFzc2V0c0J1aWxkLmJpbmQobnVsbCwgb3B0aW9ucykpXG5cdFx0LnRoZW4oaW5pdEFzc2V0c0J1aWxkLmJpbmQobnVsbCwgb3B0aW9ucy5hc3NldHMpKVxuXHRcdC50aGVuKCgpID0+IHtcblx0XHRcdHJlc29sdmUoKTtcblx0XHR9KVxuXHRcdC5jYXRjaCgoZSkgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coJ0Vycm9yJywgZSk7XG5cdFx0fSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcHJlbG9hZDtcbiIsIi8vIHJlc2l6ZUNhbmF2cy5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMIH0gZnJvbSAnYWxmcmlkJztcblxuY29uc3QgcmVzaXplID0gKHcsIGgsIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQgKSA9PiB7XG5cblx0Y29udGFpbmVyV2lkdGggfD0gd2luZG93LmlubmVyV2lkdGg7XG5cdGNvbnRhaW5lckhlaWdodCB8PSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cdFxuXHR3ICAgICAgICAgICA9IHcgfHwgY29udGFpbmVyV2lkdGg7XG5cdGggICAgICAgICAgID0gaCB8fCBjb250YWluZXJIZWlnaHQ7XG5cdFxuXHRHTC5zZXRTaXplKHcsIGgpO1xuXHRsZXQgdHcgICAgICA9IE1hdGgubWluKHcsIGNvbnRhaW5lcldpZHRoKTtcblx0bGV0IHRoICAgICAgPSBNYXRoLm1pbihoLCBjb250YWluZXJIZWlnaHQpO1xuXHRcblx0Y29uc3Qgc3ggICAgPSBjb250YWluZXJXaWR0aCAvIHc7XG5cdGNvbnN0IHN5ICAgID0gY29udGFpbmVySGVpZ2h0IC8gaDtcblx0Y29uc3Qgc2NhbGUgPSBNYXRoLm1pbihzeCwgc3kpO1xuXHR0dyAgICAgICAgICA9IHcgKiBzY2FsZTtcblx0dGggICAgICAgICAgPSBoICogc2NhbGU7XG5cblx0R0wuY2FudmFzLnN0eWxlLndpZHRoICA9IGAke3R3fXB4YDtcblx0R0wuY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke3RofXB4YDtcbn1cblxuXG5leHBvcnQgeyByZXNpemUgfTsiLCIvLyBzYXZlSW1hZ2UuanNcblxuY29uc3QgRklMRV9FWFRFTlRJT04gPSAnanBnJztcbmNvbnN0IE1JTUVfVFlQRSA9IFwiaW1hZ2UvanBlZ1wiO1xuXG5cbmNvbnN0IGRhdGFVUkx0b0Jsb2IgPSAoZGF0YXVybCkgPT4ge1xuICAgIHZhciBhcnIgPSBkYXRhdXJsLnNwbGl0KCcsJyksIG1pbWUgPSBhcnJbMF0ubWF0Y2goLzooLio/KTsvKVsxXSxcbiAgICAgICAgYnN0ciA9IGF0b2IoYXJyWzFdKSwgbiA9IGJzdHIubGVuZ3RoLCB1OGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgIHdoaWxlKG4tLSl7XG4gICAgICAgIHU4YXJyW25dID0gYnN0ci5jaGFyQ29kZUF0KG4pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJsb2IoW3U4YXJyXSwge3R5cGU6bWltZX0pO1xufVxuXG5jb25zdCBzYXZlSW1hZ2UgPSAoY2FudmFzLCBmaWxlbmFtZSkgPT4ge1xuXG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cdHZhciBpbWdEYXRhID0gY2FudmFzLnRvRGF0YVVSTCh7ICAgIFxuXHRcdGZvcm1hdDogJ3BuZycsXG5cdFx0bXVsdGlwbGllcjogNH0pO1xuXHQvLyB2YXIgc3RyRGF0YVVSSSA9IGltZ0RhdGEuc3Vic3RyKDIyLCBpbWdEYXRhLmxlbmd0aCk7XG5cdHZhciBibG9iID0gZGF0YVVSTHRvQmxvYihpbWdEYXRhKTtcblx0dmFyIG9ianVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0bGluay5kb3dubG9hZCA9IGAke2ZpbGVuYW1lfS5wbmdgO1xuXG5cdGxpbmsuaHJlZiA9IG9ianVybDtcblxuXHRsaW5rLmNsaWNrKCk7XG59O1xuXG5cbmV4cG9ydCB7IHNhdmVJbWFnZSB9OyIsIi8vIHNhdmVKc29uLmpzXG5cbmNvbnN0IHNhdmVKc29uID0gKG9iaiwgbU5hbWU9J2RhZ3RhJywgbVByZXR0eT10cnVlKSA9PiB7XG5cdHZhciBzdHIgPSBtUHJldHR5ID8gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCA0KSA6IEpTT04uc3RyaW5naWZ5KG9iaik7XG5cdHZhciBkYXRhID0gZW5jb2RlKCBzdHIgKTtcblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKCBbIGRhdGEgXSwge1xuXHRcdHR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG5cdH0pO1xuXHRcblx0dmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoIGJsb2IgKTtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnYScgKTtcblx0bGluay5zZXRBdHRyaWJ1dGUoICdocmVmJywgdXJsICk7XG5cdGxpbmsuc2V0QXR0cmlidXRlKCAnZG93bmxvYWQnLCBgJHttTmFtZX0uanNvbmAgKTtcblx0dmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoICdNb3VzZUV2ZW50cycgKTtcblx0ZXZlbnQuaW5pdE1vdXNlRXZlbnQoICdjbGljaycsIHRydWUsIHRydWUsIHdpbmRvdywgMSwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHRsaW5rLmRpc3BhdGNoRXZlbnQoIGV2ZW50ICk7XG59XG5cblxuY29uc3QgZW5jb2RlID0gKCBzICkgPT4ge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0b3V0W2ldID0gcy5jaGFyQ29kZUF0KGkpO1xuXHR9XG5cdHJldHVybiBuZXcgVWludDhBcnJheSggb3V0ICk7XG59XG5cblxuZXhwb3J0IHsgc2F2ZUpzb24gfTsiLCJjb25zdCBzbWFsbGVzdEFuZ2xlID0gKGFuZ2xlLCB0YXJnZXRBbmdsZSkgPT4ge1xuICB0YXJnZXRBbmdsZSAlPSBNYXRoLlBJICogMlxuICBhbmdsZSAlPSBNYXRoLlBJICogMlxuICBpZiAoYW5nbGUgPCAwKWFuZ2xlICs9IE1hdGguUEkgKiAyXG4gIGlmICh0YXJnZXRBbmdsZSA8IDApdGFyZ2V0QW5nbGUgKz0gTWF0aC5QSSAqIDJcbiAgbGV0IGRpZmZlcmVuY2UxID0gdGFyZ2V0QW5nbGUgLSBhbmdsZVxuICBsZXQgZGlmZmVyZW5jZTIgPSAodGFyZ2V0QW5nbGUgKyAoTWF0aC5QSSAqIDIpKSAtIGFuZ2xlXG4gIGxldCBkaWZmZXJlbmNlMyA9ICh0YXJnZXRBbmdsZSAtIChNYXRoLlBJICogMikpIC0gYW5nbGVcbiAgbGV0IGFic0RpZmZlcmVuY2UxID0gTWF0aC5hYnMoZGlmZmVyZW5jZTEpXG4gIGxldCBhYnNEaWZmZXJlbmNlMiA9IE1hdGguYWJzKGRpZmZlcmVuY2UyKVxuICBsZXQgYWJzRGlmZmVyZW5jZTMgPSBNYXRoLmFicyhkaWZmZXJlbmNlMylcbiAgbGV0IGRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlMVxuICBpZiAoYWJzRGlmZmVyZW5jZTIgPCBhYnNEaWZmZXJlbmNlMSAmJiBhYnNEaWZmZXJlbmNlMiA8IGFic0RpZmZlcmVuY2UzKSB7XG4gICAgZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2UyXG4gIH0gZWxzZSBpZiAoYWJzRGlmZmVyZW5jZTMgPCBhYnNEaWZmZXJlbmNlMSAmJiBhYnNEaWZmZXJlbmNlMyA8IGFic0RpZmZlcmVuY2UyKSB7XG4gICAgZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2UzXG4gIH1cbiAgcmV0dXJuIGRpZmZlcmVuY2Vcbn07XG5cbmV4cG9ydCB7IHNtYWxsZXN0QW5nbGUgfTsiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZ2xvYmFsLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2dsb2JhbC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZ2xvYmFsLnNjc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbW9kZWxWaWV3ZXIuc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbW9kZWxWaWV3ZXIuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL21vZGVsVmlld2VyLnNjc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBcIi8vIGJhc2ljLnZlcnRcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDQgdU1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbn1cIiIsImV4cG9ydCBkZWZhdWx0IFwiLy8gY29weS5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBTSU1QTEVfVEVYVFVSRVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnVuaWZvcm0gdmVjMyB1Q29sb3I7XFxudW5pZm9ybSBmbG9hdCB1QWxwaGE7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1Q29sb3IsIHVBbHBoYSk7XFxufVwiIiwiZXhwb3J0IGRlZmF1bHQgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xcblxcbnZvaWQgbWFpbih2b2lkKXsgICAgICAgIFxcbiAgICBnbF9GcmFnQ29sb3I9dmVjNCgxLik7XFxufVwiIiwiZXhwb3J0IGRlZmF1bHQgXCIvLyBjb3B5LmZyYWdcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XFxudmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlRGVwdGg7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZUFscGhhO1xcbnVuaWZvcm0gdmVjMyB1Q2FtZXJhUG9zO1xcbnVuaWZvcm0gdmVjMyB1Q29sb3I7XFxudW5pZm9ybSB2ZWMzIHVTaGFkb3dDb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVTaGFkb3dPcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgdVNwcmVhZDtcXG51bmlmb3JtIGZsb2F0IHVNYXBTaXplO1xcbnVuaWZvcm0gdmVjMiB1U2hhZG93RGlzdGFuY2U7XFxuXFxuY29uc3QgaW50ICAgY19zYW1wbGVzWCAgICA9IDE3OyAgLy8gbXVzdCBiZSBvZGRcXG5jb25zdCBpbnQgICBjX3NhbXBsZXNZICAgID0gMTc7ICAvLyBtdXN0IGJlIG9kZFxcbmNvbnN0IGZsb2F0IGNfdGV4dHVyZVNpemUgPSAyNTYuMDtcXG5cXG5jb25zdCBpbnQgICBjX2hhbGZTYW1wbGVzWCA9IGNfc2FtcGxlc1ggLyAyO1xcbmNvbnN0IGludCAgIGNfaGFsZlNhbXBsZXNZID0gY19zYW1wbGVzWSAvIDI7XFxuY29uc3QgZmxvYXQgY19waXhlbFNpemUgPSAoMS4wIC8gY190ZXh0dXJlU2l6ZSk7XFxuXFxuZmxvYXQgR2F1c3NpYW4gKGZsb2F0IHNpZ21hLCBmbG9hdCB4KXtcXG4gICAgcmV0dXJuIGV4cCgtKHgqeCkgLyAoMi4wICogc2lnbWEqc2lnbWEpKTtcXG59XFxuXFxudmVjMyBCbHVycmVkUGl4ZWwgKGluIHZlYzIgdXYpe1xcbiAgICBmbG9hdCBjX3NpZ21hWCAgICAgID0gMjAuMDtcXG5cXHRmbG9hdCBjX3NpZ21hWSAgICAgID0gY19zaWdtYVg7XFxuICAgIFxcbiAgICBmbG9hdCB0b3RhbCA9IDAuMDtcXG4gICAgdmVjMyByZXQgPSB2ZWMzKDApO1xcbiAgICAgICAgXFxuICAgIGZvciAoaW50IGl5ID0gMDsgaXkgPCBjX3NhbXBsZXNZOyArK2l5KVxcbiAgICB7XFxuICAgICAgICBmbG9hdCBmeSA9IEdhdXNzaWFuIChjX3NpZ21hWSwgZmxvYXQoaXkpIC0gZmxvYXQoY19oYWxmU2FtcGxlc1kpKTtcXG4gICAgICAgIGZsb2F0IG9mZnNldHkgPSBmbG9hdChpeS1jX2hhbGZTYW1wbGVzWSkgKiBjX3BpeGVsU2l6ZTtcXG4gICAgICAgIGZvciAoaW50IGl4ID0gMDsgaXggPCBjX3NhbXBsZXNYOyArK2l4KVxcbiAgICAgICAge1xcbiAgICAgICAgICAgIGZsb2F0IGZ4ID0gR2F1c3NpYW4gKGNfc2lnbWFYLCBmbG9hdChpeCkgLSBmbG9hdChjX2hhbGZTYW1wbGVzWCkpO1xcbiAgICAgICAgICAgIGZsb2F0IG9mZnNldHggPSBmbG9hdChpeC1jX2hhbGZTYW1wbGVzWCkgKiBjX3BpeGVsU2l6ZTtcXG4gICAgICAgICAgICB0b3RhbCArPSBmeCAqIGZ5OyAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHJldCArPSB0ZXh0dXJlMkQodGV4dHVyZURlcHRoLCB1diArIHZlYzIob2Zmc2V0eCwgb2Zmc2V0eSkpLnJnYiAqIGZ4KmZ5O1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiByZXQgLyB0b3RhbDtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpe1xcbiAgICB2ZWM0IHNoYWRvd0Nvb3JkID0gdlNoYWRvd0Nvb3JkIC8gdlNoYWRvd0Nvb3JkLnc7XFxuXFx0dmVjMiBvZmZzZXQgPSB2ZWMyKDAuOTkpO1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQodVNoYWRvd0NvbG9yLCAxLjAtQmx1cnJlZFBpeGVsKG9mZnNldCpzaGFkb3dDb29yZC54eSkucik7XFx0ICBcXG59XCIiLCJleHBvcnQgZGVmYXVsdCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1U2hhZG93TWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbnZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcXG5cXG52YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkO1xcblxcbnZvaWQgbWFpbih2b2lkKXtcXG4gICAgdldvcmxkUG9zaXRpb24gICAgICAgPSB1TWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24gLDEuMCk7XFxuXFxuICAgIGdsX1Bvc2l0aW9uICAgICAgICAgID0gdVByb2plY3Rpb25NYXRyaXggKiB1Vmlld01hdHJpeCAqIHZXb3JsZFBvc2l0aW9uO1xcbiAgICAgICAgICAgIFxcbiAgICB2VGV4dHVyZUNvb3JkICAgICAgICA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgIHZOb3JtYWwgICAgICAgICAgICAgID0gYU5vcm1hbDtcXG4gICAgdlNoYWRvd0Nvb3JkICAgICAgICAgPSB1U2hhZG93TWF0cml4ICogdldvcmxkUG9zaXRpb247XFxufVwiIiwiZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIFNIQURFUl9OQU1FIFNJTVBMRV9URVhUVVJFXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudW5pZm9ybSB2ZWMzIHVDb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVBbHBoYTtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIGZsb2F0IHZDb3VudGVycztcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVDb2xvciwgMS4wKTtcXG4gICAgZ2xfRnJhZ0NvbG9yLmEgKj0gKCh2Q291bnRlcnMpICogdUFscGhhKTtcXG59XCIiLCJleHBvcnQgZGVmYXVsdCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSBmbG9hdCBhRGlyZWN0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFQcmV2aW91cztcXG5hdHRyaWJ1dGUgdmVjMyBhTmV4dDtcXG5hdHRyaWJ1dGUgZmxvYXQgYUNvdW50ZXJzO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdVRpbWU7XFxuXFxudW5pZm9ybSBmbG9hdCB0aGlja25lc3M7XFxudW5pZm9ybSBmbG9hdCBhc3BlY3Q7XFxuXFxudmFyeWluZyB2ZWMyIHZVVjtcXG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxudmFyeWluZyBmbG9hdCB2Q291bnRlcnM7XFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgLy8gZmxvYXQgdGhpY2tuZXNzID0gLjE7XFxuICBpbnQgbWl0ZXIgPSAwO1xcblxcbiAgdmVjMiBhc3BlY3RWZWMgPSB2ZWMyKGFzcGVjdCwgMS4wKTtcXG4gIG1hdDQgcHJvalZpZXdNb2RlbCA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXg7Ly9wcm9qZWN0aW9uICogdmlldyAqIG1vZGVsO1xcblxcbiAgdmVjNCBwcmV2aW91c1Byb2plY3RlZCA9IHByb2pWaWV3TW9kZWwgKiB2ZWM0KGFQcmV2aW91cy54LCBhUHJldmlvdXMueSwgYVByZXZpb3VzLnosIDEuMCk7XFxuICB2ZWM0IGN1cnJlbnRQcm9qZWN0ZWQgPSBwcm9qVmlld01vZGVsICogdmVjNChhVmVydGV4UG9zaXRpb24ueCwgYVZlcnRleFBvc2l0aW9uLnksIGFWZXJ0ZXhQb3NpdGlvbi56LCAxLjApO1xcbiAgdmVjNCBuZXh0UHJvamVjdGVkID0gcHJvalZpZXdNb2RlbCAqIHZlYzQoYU5leHQueCwgYU5leHQueSwgYU5leHQueiwgMS4wKTtcXG5cXG4gIHZQb3NpdGlvbiA9IGN1cnJlbnRQcm9qZWN0ZWQueHl6O1xcbiAgdk5vcm1hbCA9IGFOb3JtYWw7XFxuICB2VVYgPSBhVGV4dHVyZUNvb3JkO1xcbiAgLy9nZXQgMkQgc2NyZWVuIHNwYWNlIHdpdGggVyBkaXZpZGUgYW5kIGFzcGVjdCBjb3JyZWN0aW9uXFxuICB2ZWMyIGN1cnJlbnRTY3JlZW4gPSBjdXJyZW50UHJvamVjdGVkLnh5IC8gY3VycmVudFByb2plY3RlZC53ICogYXNwZWN0VmVjO1xcbiAgdmVjMiBwcmV2aW91c1NjcmVlbiA9IHByZXZpb3VzUHJvamVjdGVkLnh5IC8gcHJldmlvdXNQcm9qZWN0ZWQudyAqIGFzcGVjdFZlYztcXG4gIHZlYzIgbmV4dFNjcmVlbiA9IG5leHRQcm9qZWN0ZWQueHkgLyBuZXh0UHJvamVjdGVkLncgKiBhc3BlY3RWZWM7XFxuXFxuICB2Q291bnRlcnMgPSBhQ291bnRlcnM7XFxuXFxuICBmbG9hdCBzY2FsZSA9IDEuMDtcXG4gIC8vIGZsb2F0IGxlbiA9IHRoaWNrbmVzcztcXG4gIGZsb2F0IGxlbiA9IHBvdygxLiAtIHZDb3VudGVycywgLjQpICogdGhpY2tuZXNzO1xcbiAgLy8gZmxvYXQgbGVuID0gdGhpY2tuZXNzICogdVRoaWNrbmVzc09mZnNldDtcXG5cXG4gIGZsb2F0IG9yaWVudGF0aW9uID0gYURpcmVjdGlvbjtcXG5cXG4gIHZDb2xvciA9IHZlYzMoMS4wLCAuMCwgMC4wKTtcXG4gIHZlYzIgZGlyID0gdmVjMigwLjApO1xcbiAgaWYgKGN1cnJlbnRTY3JlZW4gPT0gcHJldmlvdXNTY3JlZW4pIHtcXG4gICAgZGlyID0gbm9ybWFsaXplKG5leHRTY3JlZW4gLSBjdXJyZW50U2NyZWVuKTtcXG4gIH1cXG4gIGVsc2UgaWYgKGN1cnJlbnRTY3JlZW4gPT0gbmV4dFNjcmVlbikge1xcbiAgICBkaXIgPSBub3JtYWxpemUoY3VycmVudFNjcmVlbiAtIHByZXZpb3VzU2NyZWVuKTtcXG4gIH1cXG4gIGVsc2Uge1xcbiAgICAvL2dldCBhRGlyZWN0aW9ucyBmcm9tIChDIC0gQikgYW5kIChCIC0gQSlcXG5cXG4gICAgdmVjMiBkaXJBID0gbm9ybWFsaXplKChjdXJyZW50U2NyZWVuIC0gcHJldmlvdXNTY3JlZW4pKTtcXG4gICAgaWYgKG1pdGVyID09IDEpIHtcXG4gICAgICB2ZWMyIGRpckIgPSBub3JtYWxpemUoKG5leHRTY3JlZW4gLSBjdXJyZW50U2NyZWVuKSk7XFxuICAgICAgLy9ub3cgY29tcHV0ZSB0aGUgbWl0ZXIgam9pbiBub3JtYWwgYW5kIGxlbmd0aFxcbiAgICAgIHZlYzIgdGFuZ2VudCA9IG5vcm1hbGl6ZShkaXJBICsgZGlyQik7XFxuICAgICAgdmVjMiBwZXJwID0gdmVjMigtZGlyQS55LCBkaXJBLngpO1xcbiAgICAgIHZlYzIgbWl0ZXIgPSB2ZWMyKC10YW5nZW50LnksIHRhbmdlbnQueCk7XFxuICAgICAgZGlyID0gdGFuZ2VudDtcXG4gICAgICBsZW4gPSB0aGlja25lc3MgLyBkb3QobWl0ZXIsIHBlcnApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRpciA9IGRpckE7XFxuXFxuICAgIH1cXG4gIH1cXG4gIHZlYzIgbm9ybWFsID0gdmVjMigtZGlyLnksIGRpci54KTtcXG4gIHZDb2xvciA9IHZlYzMobm9ybWFsLCAxLjApO1xcbiAgbm9ybWFsLnggLz0gYXNwZWN0O1xcbiAgbm9ybWFsICo9IGxlbi8yLjA7XFxuXFxuICB2ZWM0IG9mZnNldCA9ICB2ZWM0KG5vcm1hbCAqIG9yaWVudGF0aW9uLCAwLjAsIDAuMCk7XFxuXFxuICBnbF9Qb3NpdGlvbiA9IGN1cnJlbnRQcm9qZWN0ZWQgKyBvZmZzZXQ7XFxufVxcblwiIiwiZXhwb3J0IGRlZmF1bHQgXCIvLyBiYXNpYy52ZXJ0XFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFQb3NPZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVTY2FsZTtcXG51bmlmb3JtIGZsb2F0IHVUaW1lO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzMgcG9zID0gYVZlcnRleFBvc2l0aW9uICogdVNjYWxlOy8vICogKDEuICsgY29zKCh1VGltZSArIGFFeHRyYSkgLyAyMC4pICogLjEpO1xcbiAgICBwb3MueHl6ICs9IGFQb3NPZmZzZXQ7XFxuXFxuICAgIHZlYzMgZGlyID0gYVBvc09mZnNldDtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChwb3MsIDEuMCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCIiLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgU0hBREVSX05BTUUgcGJyX2ZyYWdcXG5cXG4jZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2Q6IGVuYWJsZVxcbiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgXFx0dUJSREZNYXA7XFxudW5pZm9ybSBzYW1wbGVyQ3ViZSB1UmFkaWFuY2VNYXA7XFxudW5pZm9ybSBzYW1wbGVyQ3ViZSB1SXJyYWRpYW5jZU1hcDtcXG5cXG4jaWZkZWYgSEFTX0JBU0VDT0xPUk1BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVDb2xvck1hcDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX09DQ0xVU0lPTk1BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVBb01hcDtcXG51bmlmb3JtIGZsb2F0IHVPY2NsdXNpb25TdHJlbmd0aDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX05PUk1BTE1BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVOb3JtYWxNYXA7XFxudW5pZm9ybSBmbG9hdCB1Tm9ybWFsU2NhbGU7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19FTUlTU0lWRU1BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVFbWlzc2l2ZU1hcDtcXG51bmlmb3JtIHZlYzMgdUVtaXNzaXZlRmFjdG9yO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVSb3VnaG5lc3NNYXA7XFxuXFxudW5pZm9ybSB2ZWMzIHVMaWdodERpcmVjdGlvbjtcXG51bmlmb3JtIHZlYzMgdUxpZ2h0Q29sb3I7XFxudW5pZm9ybSB2ZWMzIHVDYW1lcmFQb3M7XFxuXFxudW5pZm9ybSB2ZWM0IHVTY2FsZURpZmZCYXNlTVI7XFxudW5pZm9ybSB2ZWM0IHVTY2FsZUZHRFNwZWM7XFxudW5pZm9ybSB2ZWM0IHVTY2FsZUlCTEFtYmllbnQ7XFxuXFxudW5pZm9ybSB2ZWMzIHVCYXNlQ29sb3I7XFxudW5pZm9ybSBmbG9hdCB1Um91Z2huZXNzO1xcbnVuaWZvcm0gZmxvYXQgdU1ldGFsbGljO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbnZhcnlpbmcgZmxvYXQgdkFscGhhQW5ub3RhdGlvbjtcXG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xcblxcbi8vXFx0RnJvbSBHTFRGIFdlYkdMIFBCUiA6XFxuLy9cXHRodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYtV2ViR0wtUEJSXFxuXFxuLy8gRW5jYXBzdWxhdGUgdGhlIHZhcmlvdXMgaW5wdXRzIHVzZWQgYnkgdGhlIHZhcmlvdXMgZnVuY3Rpb25zIGluIHRoZSBzaGFkaW5nIGVxdWF0aW9uXFxuLy8gV2Ugc3RvcmUgdmFsdWVzIGluIHRoaXMgc3RydWN0IHRvIHNpbXBsaWZ5IHRoZSBpbnRlZ3JhdGlvbiBvZiBhbHRlcm5hdGl2ZSBpbXBsZW1lbnRhdGlvbnNcXG4vLyBvZiB0aGUgc2hhZGluZyB0ZXJtcywgb3V0bGluZWQgaW4gdGhlIFJlYWRtZS5NRCBBcHBlbmRpeC5cXG5zdHJ1Y3QgUEJSSW5mb1xcbntcXG5cXHRmbG9hdCBOZG90TDsgICAgICAgICAgICAgICAgICAvLyBjb3MgYW5nbGUgYmV0d2VlbiBub3JtYWwgYW5kIGxpZ2h0IGRpcmVjdGlvblxcblxcdGZsb2F0IE5kb3RWOyAgICAgICAgICAgICAgICAgIC8vIGNvcyBhbmdsZSBiZXR3ZWVuIG5vcm1hbCBhbmQgdmlldyBkaXJlY3Rpb25cXG5cXHRmbG9hdCBOZG90SDsgICAgICAgICAgICAgICAgICAvLyBjb3MgYW5nbGUgYmV0d2VlbiBub3JtYWwgYW5kIGhhbGYgdmVjdG9yXFxuXFx0ZmxvYXQgTGRvdEg7ICAgICAgICAgICAgICAgICAgLy8gY29zIGFuZ2xlIGJldHdlZW4gbGlnaHQgZGlyZWN0aW9uIGFuZCBoYWxmIHZlY3RvclxcblxcdGZsb2F0IFZkb3RIOyAgICAgICAgICAgICAgICAgIC8vIGNvcyBhbmdsZSBiZXR3ZWVuIHZpZXcgZGlyZWN0aW9uIGFuZCBoYWxmIHZlY3RvclxcblxcdGZsb2F0IHBlcmNlcHR1YWxSb3VnaG5lc3M7ICAgIC8vIHJvdWdobmVzcyB2YWx1ZSwgYXMgYXV0aG9yZWQgYnkgdGhlIG1vZGVsIGNyZWF0b3IgKGlucHV0IHRvIHNoYWRlcilcXG5cXHRmbG9hdCBtZXRhbG5lc3M7ICAgICAgICAgICAgICAvLyBtZXRhbGxpYyB2YWx1ZSBhdCB0aGUgc3VyZmFjZVxcblxcdHZlYzMgcmVmbGVjdGFuY2UwOyAgICAgICAgICAgIC8vIGZ1bGwgcmVmbGVjdGFuY2UgY29sb3IgKG5vcm1hbCBpbmNpZGVuY2UgYW5nbGUpXFxuXFx0dmVjMyByZWZsZWN0YW5jZTkwOyAgICAgICAgICAgLy8gcmVmbGVjdGFuY2UgY29sb3IgYXQgZ3JhemluZyBhbmdsZVxcblxcdGZsb2F0IGFscGhhUm91Z2huZXNzOyAgICAgICAgIC8vIHJvdWdobmVzcyBtYXBwZWQgdG8gYSBtb3JlIGxpbmVhciBjaGFuZ2UgaW4gdGhlIHJvdWdobmVzcyAocHJvcG9zZWQgYnkgWzJdKVxcblxcdHZlYzMgZGlmZnVzZUNvbG9yOyAgICAgICAgICAgIC8vIGNvbG9yIGNvbnRyaWJ1dGlvbiBmcm9tIGRpZmZ1c2UgbGlnaHRpbmdcXG5cXHR2ZWMzIHNwZWN1bGFyQ29sb3I7ICAgICAgICAgICAvLyBjb2xvciBjb250cmlidXRpb24gZnJvbSBzcGVjdWxhciBsaWdodGluZ1xcbn07XFxuXFxuY29uc3QgZmxvYXQgTV9QSSA9IDMuMTQxNTkyNjUzNTg5NzkzO1xcbmNvbnN0IGZsb2F0IGNfTWluUm91Z2huZXNzID0gMC4wNDtcXG5cXG52ZWM0IFNSR0J0b0xJTkVBUih2ZWM0IHNyZ2JJbilcXG57XFxuXFx0I2lmZGVmIE1BTlVBTF9TUkdCXFxuXFx0I2lmZGVmIFNSR0JfRkFTVF9BUFBST1hJTUFUSU9OXFxuXFx0dmVjMyBsaW5PdXQgPSBwb3coc3JnYkluLnh5eix2ZWMzKDIuMikpO1xcblxcdCNlbHNlIC8vU1JHQl9GQVNUX0FQUFJPWElNQVRJT05cXG5cXHR2ZWMzIGJMZXNzID0gc3RlcCh2ZWMzKDAuMDQwNDUpLHNyZ2JJbi54eXopO1xcblxcdHZlYzMgbGluT3V0ID0gbWl4KCBzcmdiSW4ueHl6L3ZlYzMoMTIuOTIpLCBwb3coKHNyZ2JJbi54eXordmVjMygwLjA1NSkpL3ZlYzMoMS4wNTUpLHZlYzMoMi40KSksIGJMZXNzICk7XFxuXFx0I2VuZGlmIC8vU1JHQl9GQVNUX0FQUFJPWElNQVRJT05cXG5cXHRyZXR1cm4gdmVjNChsaW5PdXQsc3JnYkluLncpOztcXG5cXHQjZWxzZSAvL01BTlVBTF9TUkdCXFxuXFx0cmV0dXJuIHNyZ2JJbjtcXG5cXHQjZW5kaWYgLy9NQU5VQUxfU1JHQlxcbn1cXG5cXG52ZWMzIGdldE5vcm1hbCgpIHtcXG5cXHR2ZWMzIHBvc19keCA9IGRGZHgodlBvc2l0aW9uKTtcXG5cXHR2ZWMzIHBvc19keSA9IGRGZHkodlBvc2l0aW9uKTtcXG5cXHR2ZWMzIHRleF9keCA9IGRGZHgodmVjMyh2VGV4dHVyZUNvb3JkLCAwLjApKTtcXG5cXHR2ZWMzIHRleF9keSA9IGRGZHkodmVjMyh2VGV4dHVyZUNvb3JkLCAwLjApKTtcXG5cXHR2ZWMzIHQgPSAodGV4X2R5LnQgKiBwb3NfZHggLSB0ZXhfZHgudCAqIHBvc19keSkgLyAodGV4X2R4LnMgKiB0ZXhfZHkudCAtIHRleF9keS5zICogdGV4X2R4LnQpO1xcblxcblxcdHZlYzMgbmcgPSBub3JtYWxpemUodk5vcm1hbCk7XFxuXFxuXFx0dCA9IG5vcm1hbGl6ZSh0IC0gbmcgKiBkb3QobmcsIHQpKTtcXG5cXHR2ZWMzIGIgPSBub3JtYWxpemUoY3Jvc3MobmcsIHQpKTtcXG5cXHRtYXQzIHRibiA9IG1hdDModCwgYiwgbmcpO1xcblxcbiNpZmRlZiBIQVNfTk9STUFMTUFQXFxuXFx0dmVjMyBuID0gdGV4dHVyZTJEKHVOb3JtYWxNYXAsIHZUZXh0dXJlQ29vcmQpLnJnYjtcXG5cXHRuID0gbm9ybWFsaXplKHRibiAqICgoMi4wICogbiAtIDEuMCkgKiB2ZWMzKHVOb3JtYWxTY2FsZSwgdU5vcm1hbFNjYWxlLCAxLjApKSk7XFxuI2Vsc2VcXG5cXHQvLyBUaGUgdGJuIG1hdHJpeCBpcyBsaW5lYXJseSBpbnRlcnBvbGF0ZWQsIHNvIHdlIG5lZWQgdG8gcmUtbm9ybWFsaXplXFxuXFx0dmVjMyBuID0gbm9ybWFsaXplKHRiblsyXS54eXopO1xcbiNlbmRpZlxcblxcblxcdHJldHVybiBuO1xcbn1cXG5cXG52ZWMzIGdldElCTENvbnRyaWJ1dGlvbihQQlJJbmZvIHBicklucHV0cywgdmVjMyBuLCB2ZWMzIHJlZmxlY3Rpb24pXFxue1xcblxcdGZsb2F0IG1pcENvdW50ID0gNy4wOyAvLyByZXNvbHV0aW9uIG9mIDUxMng1MTJcXG5cXHRmbG9hdCBsb2QgPSAocGJySW5wdXRzLnBlcmNlcHR1YWxSb3VnaG5lc3MgKiBtaXBDb3VudCk7XFxuXFx0Ly8gcmV0cmlldmUgYSBzY2FsZSBhbmQgYmlhcyB0byBGMC4gU2VlIFsxXSwgRmlndXJlIDNcXG5cXHR2ZWMzIGJyZGYgPSBTUkdCdG9MSU5FQVIodGV4dHVyZTJEKHVCUkRGTWFwLCB2ZWMyKHBicklucHV0cy5OZG90ViwgMS4wIC0gcGJySW5wdXRzLnBlcmNlcHR1YWxSb3VnaG5lc3MpKSkucmdiO1xcblxcdHZlYzMgZGlmZnVzZUxpZ2h0ID0gU1JHQnRvTElORUFSKHRleHR1cmVDdWJlKHVJcnJhZGlhbmNlTWFwLCBuKSkucmdiO1xcblxcblxcdFxcblxcdCNpZmRlZiBVU0VfVEVYX0xPRFxcblxcdFxcdHZlYzMgc3BlY3VsYXJMaWdodCA9IFNSR0J0b0xJTkVBUih0ZXh0dXJlQ3ViZUxvZEVYVCh1UmFkaWFuY2VNYXAsIHJlZmxlY3Rpb24sIGxvZCkpLnJnYjtcXG5cXHQgICAgLy8gdmVjMyBzcGVjdWxhckxpZ2h0ID0gU1JHQnRvTElORUFSKHRleHR1cmVDdWJlTG9kRVhUKHVfU3BlY3VsYXJFbnZTYW1wbGVyLCByZWZsZWN0aW9uLCBsb2QpKS5yZ2I7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWMzIHNwZWN1bGFyTGlnaHQgPSBTUkdCdG9MSU5FQVIodGV4dHVyZUN1YmUodVJhZGlhbmNlTWFwLCByZWZsZWN0aW9uKSkucmdiO1xcblxcdCAgICAvLyB2ZWMzIHNwZWN1bGFyTGlnaHQgPSBTUkdCdG9MSU5FQVIodGV4dHVyZUN1YmUodV9TcGVjdWxhckVudlNhbXBsZXIsIHJlZmxlY3Rpb24pKS5yZ2I7XFxuXFx0I2VuZGlmXFxuXFxuXFx0dmVjMyBkaWZmdXNlID0gZGlmZnVzZUxpZ2h0ICogcGJySW5wdXRzLmRpZmZ1c2VDb2xvcjtcXG5cXHR2ZWMzIHNwZWN1bGFyID0gc3BlY3VsYXJMaWdodCAqIChwYnJJbnB1dHMuc3BlY3VsYXJDb2xvciAqIGJyZGYueCArIGJyZGYueSk7XFxuXFxuXFx0Ly8gRm9yIHByZXNlbnRhdGlvbiwgdGhpcyBhbGxvd3MgdXMgdG8gZGlzYWJsZSBJQkwgdGVybXNcXG5cXHRkaWZmdXNlICo9IHVTY2FsZUlCTEFtYmllbnQueDtcXG5cXHRzcGVjdWxhciAqPSB1U2NhbGVJQkxBbWJpZW50Lnk7XFxuXFxuXFx0cmV0dXJuIGRpZmZ1c2UgKyBzcGVjdWxhcjtcXG59XFxuXFxudmVjMyBkaWZmdXNlKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRyZXR1cm4gcGJySW5wdXRzLmRpZmZ1c2VDb2xvciAvIE1fUEk7XFxufVxcblxcbnZlYzMgc3BlY3VsYXJSZWZsZWN0aW9uKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRyZXR1cm4gcGJySW5wdXRzLnJlZmxlY3RhbmNlMCArIChwYnJJbnB1dHMucmVmbGVjdGFuY2U5MCAtIHBicklucHV0cy5yZWZsZWN0YW5jZTApICogcG93KGNsYW1wKDEuMCAtIHBicklucHV0cy5WZG90SCwgMC4wLCAxLjApLCA1LjApO1xcbn1cXG5cXG5mbG9hdCBnZW9tZXRyaWNPY2NsdXNpb24oUEJSSW5mbyBwYnJJbnB1dHMpXFxue1xcblxcdGZsb2F0IE5kb3RMID0gcGJySW5wdXRzLk5kb3RMO1xcblxcdGZsb2F0IE5kb3RWID0gcGJySW5wdXRzLk5kb3RWO1xcblxcdGZsb2F0IHIgPSBwYnJJbnB1dHMuYWxwaGFSb3VnaG5lc3M7XFxuXFxuXFx0ZmxvYXQgYXR0ZW51YXRpb25MID0gMi4wICogTmRvdEwgLyAoTmRvdEwgKyBzcXJ0KHIgKiByICsgKDEuMCAtIHIgKiByKSAqIChOZG90TCAqIE5kb3RMKSkpO1xcblxcdGZsb2F0IGF0dGVudWF0aW9uViA9IDIuMCAqIE5kb3RWIC8gKE5kb3RWICsgc3FydChyICogciArICgxLjAgLSByICogcikgKiAoTmRvdFYgKiBOZG90VikpKTtcXG5cXHRyZXR1cm4gYXR0ZW51YXRpb25MICogYXR0ZW51YXRpb25WO1xcbn1cXG5cXG5mbG9hdCBtaWNyb2ZhY2V0RGlzdHJpYnV0aW9uKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRmbG9hdCByb3VnaG5lc3NTcSA9IHBicklucHV0cy5hbHBoYVJvdWdobmVzcyAqIHBicklucHV0cy5hbHBoYVJvdWdobmVzcztcXG5cXHRmbG9hdCBmID0gKHBicklucHV0cy5OZG90SCAqIHJvdWdobmVzc1NxIC0gcGJySW5wdXRzLk5kb3RIKSAqIHBicklucHV0cy5OZG90SCArIDEuMDtcXG5cXHRyZXR1cm4gcm91Z2huZXNzU3EgLyAoTV9QSSAqIGYgKiBmKTtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcblxcdGZsb2F0IHBlcmNlcHR1YWxSb3VnaG5lc3MgICA9IDEuMC10ZXh0dXJlMkQodVJvdWdobmVzc01hcCwgdlRleHR1cmVDb29yZCkucjtcXG5cXHRmbG9hdCBtZXRhbGxpYyAgICAgICAgICAgICAgPSB1TWV0YWxsaWM7XFxuXFx0cGVyY2VwdHVhbFJvdWdobmVzcyAgICAgICAgID0gY2xhbXAocGVyY2VwdHVhbFJvdWdobmVzcywgY19NaW5Sb3VnaG5lc3MsIDEuMCk7XFxuXFx0bWV0YWxsaWMgICAgICAgICAgICAgICAgICAgID0gY2xhbXAobWV0YWxsaWMsIDAuMCwgMS4wKTtcXG5cXHRmbG9hdCBhbHBoYVJvdWdobmVzcyAgICAgICAgPSBwZXJjZXB0dWFsUm91Z2huZXNzICogcGVyY2VwdHVhbFJvdWdobmVzcztcXG5cXG4jaWZkZWYgSEFTX0JBU0VDT0xPUk1BUFxcdFxcblxcdHZlYzQgYmFzZUNvbG9yID0gU1JHQnRvTElORUFSKHRleHR1cmUyRCh1Q29sb3JNYXAsIHZUZXh0dXJlQ29vcmQpKTtcXG4jZWxzZVxcblxcdHZlYzQgYmFzZUNvbG9yICAgICAgICAgICAgICA9IHZlYzQodUJhc2VDb2xvciwgMS4wKTtcXG4jZW5kaWZcXHRcXG5cXHRcXG5cXHR2ZWMzIGYwICAgICAgICAgICAgICAgICAgICAgPSB2ZWMzKDAuMik7XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3IgICAgICAgICAgID0gYmFzZUNvbG9yLnJnYiAqICh2ZWMzKDEuMCkgLSBmMCk7XFxuXFx0ZGlmZnVzZUNvbG9yICAgICAgICAgICAgICAgICo9IDEuMCAtIG1ldGFsbGljO1xcblxcdHZlYzMgc3BlY3VsYXJDb2xvciAgICAgICAgICA9IG1peChmMCwgYmFzZUNvbG9yLnJnYiwgbWV0YWxsaWMpO1xcblxcdFxcblxcdC8vIENvbXB1dGUgcmVmbGVjdGFuY2UuXFxuXFx0ZmxvYXQgcmVmbGVjdGFuY2UgICAgICAgICAgID0gbWF4KG1heChzcGVjdWxhckNvbG9yLnIsIHNwZWN1bGFyQ29sb3IuZyksIHNwZWN1bGFyQ29sb3IuYik7XFxuXFx0XFxuXFx0Ly8gRm9yIHR5cGljYWwgaW5jaWRlbnQgcmVmbGVjdGFuY2UgcmFuZ2UgKGJldHdlZW4gNCUgdG8gMTAwJSkgc2V0IHRoZSBncmF6aW5nIHJlZmxlY3RhbmNlIHRvIDEwMCUgZm9yIHR5cGljYWwgZnJlc25lbCBlZmZlY3QuXFxuXFx0Ly8gRm9yIHZlcnkgbG93IHJlZmxlY3RhbmNlIHJhbmdlIG9uIGhpZ2hseSBkaWZmdXNlIG9iamVjdHMgKGJlbG93IDQlKSwgaW5jcmVtZW50YWxseSByZWR1Y2UgZ3JhemluZyByZWZsZWNhbmNlIHRvIDAlLlxcblxcdGZsb2F0IHJlZmxlY3RhbmNlOTAgICAgICAgICA9IGNsYW1wKHJlZmxlY3RhbmNlICogMjUuMCwgMC4wLCAxLjApO1xcblxcdHZlYzMgc3BlY3VsYXJFbnZpcm9ubWVudFIwICA9IHNwZWN1bGFyQ29sb3IucmdiO1xcblxcdHZlYzMgc3BlY3VsYXJFbnZpcm9ubWVudFI5MCA9IHZlYzMoMS4wLCAxLjAsIDEuMCkgKiByZWZsZWN0YW5jZTkwO1xcblxcdFxcblxcdHZlYzMgbiAgICAgICAgICAgICAgICAgICAgICA9IGdldE5vcm1hbCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsIGF0IHN1cmZhY2UgcG9pbnRcXG5cXHR2ZWMzIHYgICAgICAgICAgICAgICAgICAgICAgPSBub3JtYWxpemUodUNhbWVyYVBvcyAtIHZQb3NpdGlvbik7ICAgICAgICAvLyBWZWN0b3IgZnJvbSBzdXJmYWNlIHBvaW50IHRvIGNhbWVyYVxcblxcdHZlYzMgbCAgICAgICAgICAgICAgICAgICAgICA9IG5vcm1hbGl6ZSh1TGlnaHREaXJlY3Rpb24pOyAgICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBzdXJmYWNlIHBvaW50IHRvIGxpZ2h0XFxuXFx0dmVjMyBoICAgICAgICAgICAgICAgICAgICAgID0gbm9ybWFsaXplKGwrdik7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYWxmIHZlY3RvciBiZXR3ZWVuIGJvdGggbCBhbmQgdlxcblxcdHZlYzMgcmVmbGVjdGlvbiAgICAgICAgICAgICA9IC1ub3JtYWxpemUocmVmbGVjdCh2LCBuKSk7XFxuXFx0XFxuXFx0ZmxvYXQgTmRvdEwgICAgICAgICAgICAgICAgID0gY2xhbXAoZG90KG4sIGwpLCAwLjAwMSwgMS4wKTtcXG5cXHRmbG9hdCBOZG90ViAgICAgICAgICAgICAgICAgPSBhYnMoZG90KG4sIHYpKSArIDAuMDAxO1xcblxcdGZsb2F0IE5kb3RIICAgICAgICAgICAgICAgICA9IGNsYW1wKGRvdChuLCBoKSwgMC4wLCAxLjApO1xcblxcdGZsb2F0IExkb3RIICAgICAgICAgICAgICAgICA9IGNsYW1wKGRvdChsLCBoKSwgMC4wLCAxLjApO1xcblxcdGZsb2F0IFZkb3RIICAgICAgICAgICAgICAgICA9IGNsYW1wKGRvdCh2LCBoKSwgMC4wLCAxLjApO1xcblxcblxcdFBCUkluZm8gcGJySW5wdXRzID0gUEJSSW5mbyhcXG5cXHRcXHROZG90TCxcXG5cXHRcXHROZG90VixcXG5cXHRcXHROZG90SCxcXG5cXHRcXHRMZG90SCxcXG5cXHRcXHRWZG90SCxcXG5cXHRcXHRwZXJjZXB0dWFsUm91Z2huZXNzLFxcblxcdFxcdG1ldGFsbGljLFxcblxcdFxcdHNwZWN1bGFyRW52aXJvbm1lbnRSMCxcXG5cXHRcXHRzcGVjdWxhckVudmlyb25tZW50UjkwLFxcblxcdFxcdGFscGhhUm91Z2huZXNzLFxcblxcdFxcdGRpZmZ1c2VDb2xvcixcXG5cXHRcXHRzcGVjdWxhckNvbG9yXFxuXFx0KTtcXG5cXG5cXHQvLyBDYWxjdWxhdGUgdGhlIHNoYWRpbmcgdGVybXMgZm9yIHRoZSBtaWNyb2ZhY2V0IHNwZWN1bGFyIHNoYWRpbmcgbW9kZWxcXG5cXHR2ZWMzIEYgICAgICAgICAgICAgID0gc3BlY3VsYXJSZWZsZWN0aW9uKHBicklucHV0cyk7XFxuXFx0ZmxvYXQgRyAgICAgICAgICAgICA9IGdlb21ldHJpY09jY2x1c2lvbihwYnJJbnB1dHMpO1xcblxcdGZsb2F0IEQgICAgICAgICAgICAgPSBtaWNyb2ZhY2V0RGlzdHJpYnV0aW9uKHBicklucHV0cyk7XFxuXFx0XFxuXFx0Ly8gQ2FsY3VsYXRpb24gb2YgYW5hbHl0aWNhbCBsaWdodGluZyBjb250cmlidXRpb25cXG5cXHR2ZWMzIGRpZmZ1c2VDb250cmliID0gKDEuMCAtIEYpICogZGlmZnVzZShwYnJJbnB1dHMpO1xcblxcdHZlYzMgc3BlY0NvbnRyaWIgICAgPSBGICogRyAqIEQgLyAoNC4wICogTmRvdEwgKiBOZG90Vik7XFxuXFx0Ly8gT2J0YWluIGZpbmFsIGludGVuc2l0eSBhcyByZWZsZWN0YW5jZSAoQlJERikgc2NhbGVkIGJ5IHRoZSBlbmVyZ3kgb2YgdGhlIGxpZ2h0IChjb3NpbmUgbGF3KVxcblxcdHZlYzMgY29sb3IgICAgICAgICAgPSBOZG90TCAqIHVMaWdodENvbG9yICogKGRpZmZ1c2VDb250cmliICsgc3BlY0NvbnRyaWIpO1xcblxcdFxcbiNpZmRlZiBVU0VfSUJMXFxuXFx0Y29sb3IgKz0gZ2V0SUJMQ29udHJpYnV0aW9uKHBicklucHV0cywgbiwgcmVmbGVjdGlvbik7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19PQ0NMVVNJT05NQVBcXHRcXG5cXHRmbG9hdCBhbyAgICAgICAgICAgID0gdGV4dHVyZTJEKHVBb01hcCwgdlRleHR1cmVDb29yZCkucjtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCBjb2xvciAqIGFvLCB1T2NjbHVzaW9uU3RyZW5ndGgpO1xcbiNlbmRpZlxcdFxcblxcbiNpZmRlZiBIQVNfRU1JU1NJVkVNQVBcXG4gICAgdmVjMyBlbWlzc2l2ZSA9IFNSR0J0b0xJTkVBUih0ZXh0dXJlMkQodUVtaXNzaXZlTWFwLCB2VGV4dHVyZUNvb3JkKSkucmdiICogdUVtaXNzaXZlRmFjdG9yO1xcbiAgICBjb2xvciArPSBlbWlzc2l2ZTtcXG4jZW5kaWZcXG5cXHRcXG5cXHQvLyBUaGlzIHNlY3Rpb24gdXNlcyBtaXggdG8gb3ZlcnJpZGUgZmluYWwgY29sb3IgZm9yIHJlZmVyZW5jZSBhcHAgdmlzdWFsaXphdGlvblxcblxcdC8vIG9mIHZhcmlvdXMgcGFyYW1ldGVycyBpbiB0aGUgbGlnaHRpbmcgZXF1YXRpb24uXFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgRiwgdVNjYWxlRkdEU3BlYy54KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKEcpLCB1U2NhbGVGR0RTcGVjLnkpO1xcblxcdGNvbG9yICAgICAgICAgICAgICAgPSBtaXgoY29sb3IsIHZlYzMoRCksIHVTY2FsZUZHRFNwZWMueik7XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgc3BlY0NvbnRyaWIsIHVTY2FsZUZHRFNwZWMudyk7XFxuXFx0XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgZGlmZnVzZUNvbnRyaWIsIHVTY2FsZURpZmZCYXNlTVIueCk7XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgYmFzZUNvbG9yLnJnYiwgdVNjYWxlRGlmZkJhc2VNUi55KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKG1ldGFsbGljKSwgdVNjYWxlRGlmZkJhc2VNUi56KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKHBlcmNlcHR1YWxSb3VnaG5lc3MpLCB1U2NhbGVEaWZmQmFzZU1SLncpO1xcblxcdFxcblxcdC8vIG91dHB1dCB0aGUgZnJhZ21lbnQgY29sb3JcXG5cXHR2ZWMzIGNvbG9yU3BvdCA9IHZlYzMoMC4vMjU1LiwgMTU0Li8yNTUuLCAyMjEuLzI1NS4pO1xcblxcdHZlYzMgZkNvbG9yID0gbWl4KHBvdyhjb2xvcix2ZWMzKDEuMC8yLjIpKSwgY29sb3JTcG90LCB2QWxwaGFBbm5vdGF0aW9uICogMC41KTtcXG5cXHRnbF9GcmFnQ29sb3IgICAgICAgID0gdmVjNChmQ29sb3IsIGJhc2VDb2xvci5hKTtcXG5cXHQvLyBnbF9GcmFnQ29sb3IgICAgICAgID0gdmVjNCgsIGJhc2VDb2xvci5hKTtcXG5cXG59XCIiLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgU0hBREVSX05BTUUgcGJyX3ZlcnRcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdU1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdU5vcm1hbE1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdU1vZGVsVmlld01hdHJpeEludmVyc2U7XFxudW5pZm9ybSB2ZWMzIHVQb3NBbm5vdGF0aW9uO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbnZhcnlpbmcgdmVjMyB2UG9zaXRpb247XFxudmFyeWluZyBmbG9hdCB2QWxwaGFBbm5vdGF0aW9uO1xcblxcbmZsb2F0IGV4cG9uZW50aWFsSW4oZmxvYXQgdCkge1xcbiAgcmV0dXJuIHQgPT0gMC4wID8gdCA6IHBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdHZlYzQgcG9zaXRpb24gPSB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG5cXHR2UG9zaXRpb24gICAgID0gcG9zaXRpb24ueHl6IC8gcG9zaXRpb24udztcXG5cXHRcXG5cXHR2Tm9ybWFsICAgICAgID0gbm9ybWFsaXplKHZlYzModU1vZGVsTWF0cml4ICogdmVjNChhTm9ybWFsLCAwLjApKSk7XFxuXFx0dlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuXFxuXFx0ZmxvYXQgZGlzdCA9IGRpc3RhbmNlKHVQb3NBbm5vdGF0aW9uLCBwb3NpdGlvbi54eXopO1xcblxcdHZBbHBoYUFubm90YXRpb24gPSBzbW9vdGhzdGVwKDAuNSwgMC4sIGRpc3QpO1xcblxcdC8vIHZBbHBoYUFubm90YXRpb24gPSBzbW9vdGhzdGVwKCAwLjUtMC4wMSwgMC41LCBkaXN0KSAtIHNtb290aHN0ZXAoIDAuNSwgMC41KzAuMDEsIGRpc3QpO1xcblxcdFxcblxcdGdsX1Bvc2l0aW9uICAgPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogcG9zaXRpb247XFxufVxcblwiIl0sInNvdXJjZVJvb3QiOiIifQ==